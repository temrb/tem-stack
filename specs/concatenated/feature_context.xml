<directory_structure>
src/
  features/
    user-notes/
      api/
        services/
          user-notes.service.ts
        index.ts
        user-notes.ts
      components/
        user-notes-form.tsx
      lib/
        types/
          index.ts
        validation/
          user-notes.z.ts
      pages/
        index.tsx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/features/user-notes/components/user-notes-form.tsx">
'use client';
import { Button } from '@/components/ui/button';
import {
	Form,
	FormControl,
	FormField,
	FormItem,
	FormMessage,
} from '@/components/ui/form';
import { Textarea } from '@/components/ui/textarea';
import {
	UpdateNoteSchema,
	type UpdateNoteInput,
} from '@/features/user-notes/lib/validation/user-notes.z';
import { createFormErrorHandler } from '@/hooks/useHandleFormError';
import {
	handleTRPCError,
	handleTRPCSuccess,
} from '@/lib/core/errors/error-handler';
import { api } from '@/trpc/react';
import { zodResolver } from '@hookform/resolvers/zod';
import { useCallback, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import type { z } from 'zod';
interface UserNotesFormProps {
	initialNote: string;
}
const UserNotesForm = ({ initialNote }: UserNotesFormProps) => {
	const utils = api.useUtils();
	const form = useForm<z.infer<typeof UpdateNoteSchema>>({
		resolver: zodResolver(UpdateNoteSchema),
		defaultValues: {
			note: initialNote,
		},
		mode: 'onSubmit',
	});
	useEffect(() => {
		if (initialNote !== undefined) {
			form.reset({ note: initialNote });
		}
	}, [initialNote, form]);
	const updateNoteMutation = api.userNotes.main.updateNote.useMutation({
		onMutate: async (newNoteInput: UpdateNoteInput) => {
			await utils.userNotes.main.getNote.cancel();
			const previousNoteData = utils.userNotes.main.getNote.getData();
			utils.userNotes.main.getNote.setData(undefined, {
				success: true,
				note: newNoteInput.note,
			});
			return { previousNoteData };
		},
		onError: (error, _variables, context) => {
			if (context?.previousNoteData) {
				utils.userNotes.main.getNote.setData(
					undefined,
					context.previousNoteData,
				);
			}
			handleTRPCError(error, 'Failed to save note');
		},
		onSuccess: (data) => {
			handleTRPCSuccess('Note saved successfully!', data);
		},
		onSettled: () => {
			void utils.userNotes.main.getNote.invalidate();
		},
	});
	const onSubmit = useCallback(
		(values: z.infer<typeof UpdateNoteSchema>) => {
			updateNoteMutation.mutate(values);
		},
		[updateNoteMutation],
	);
	const formErrorHandler =
		createFormErrorHandler<z.infer<typeof UpdateNoteSchema>>();
	const handleSubmit = () => {
		void form.handleSubmit(onSubmit, formErrorHandler)();
	};
	const isLoading = updateNoteMutation.isPending;
	return (
		<Form {...form}>
			<form onSubmit={(e) => e.preventDefault()} className='space-y-4'>
				<FormField
					control={form.control}
					name='note'
					render={({ field }) => (
						<FormItem>
							<FormControl>
								<Textarea
									{...field}
									placeholder='Start writing your note here...'
									className='min-h-[400px] resize-y'
									disabled={isLoading}
									aria-label='Note content'
								/>
							</FormControl>
							<FormMessage />
						</FormItem>
					)}
				/>
				<div className='flex justify-end'>
					<Button
						type='button'
						onClick={handleSubmit}
						loading={isLoading}
						disabled={isLoading}
						aria-label='Save note'
					>
						Save Note
					</Button>
				</div>
			</form>
		</Form>
	);
};
export default UserNotesForm;
</file>

<file path="src/features/user-notes/api/services/user-notes.service.ts">
import tryCatch from '@/lib/core/utils/try-catch';
import { TRPCThrow } from '@/trpc/server/api/site/errors';
import { site } from '@/trpc/server/site';
import type { UpdateNoteInput } from '../../lib/validation/user-notes.z';
export const getNote = async (userId: string) => {
	const { data, error } = await tryCatch(
		site.user.findUnique({
			where: { id: userId },
			select: { note: true },
		})
	);
	if (error) {
		console.error(
			'getNote: An unexpected error occurred while fetching user note',
			error,
			{ userId }
		);
		TRPCThrow.internalError(
			'An unexpected error occurred while fetching your note. Please try again.'
		);
	}
	if (!data) {
		TRPCThrow.notFound('User not found.');
	}
	return {
		success: true,
		note: data!.note ?? '',
	};
};
/**
 * Updates the note for a specific user
 */
export const updateNote = async (userId: string, input: UpdateNoteInput) => {
	const { note } = input;
	const { data, error } = await tryCatch(
		site.user.update({
			where: { id: userId },
			data: { note },
			select: { note: true },
		})
	);
	if (error) {
		console.error(
			'updateNote: An unexpected error occurred while updating user note',
			error,
			{ userId }
		);
		TRPCThrow.internalError(
			'An unexpected error occurred while updating your note. Please try again.'
		);
	}
	if (!data) {
		TRPCThrow.notFound('User not found.');
	}
	return {
		success: true,
		message: 'Your note has been successfully saved.',
		note: data!.note,
	};
};
</file>

<file path="src/features/user-notes/api/index.ts">
import { createTRPCRouter } from '@/trpc/server/api/site/trpc';
import { userNotesRouter } from './user-notes';
export const userNotesFeatureRouter = createTRPCRouter({
	main: userNotesRouter,
});
</file>

<file path="src/features/user-notes/api/user-notes.ts">
import { createTRPCRouter, protectedProcedure } from '@/trpc/server/api/site/trpc';
import { UpdateNoteSchema } from '../lib/validation/user-notes.z';
import * as userNotesService from './services/user-notes.service';
export const userNotesRouter = createTRPCRouter({
	getNote: protectedProcedure.query(async ({ ctx }) => {
		const result = await userNotesService.getNote(ctx.session.user.id);
		return result;
	}),
	updateNote: protectedProcedure
		.input(UpdateNoteSchema)
		.mutation(async ({ input, ctx }) => {
			const result = await userNotesService.updateNote(
				ctx.session.user.id,
				input
			);
			return result;
		}),
});
</file>

<file path="src/features/user-notes/lib/types/index.ts">
export interface ExampleUserNotesType {
	id: string;
	name: string;
}
export type {};
</file>

<file path="src/features/user-notes/lib/validation/user-notes.z.ts">
import * as z from 'zod';
export const UpdateNoteSchema = z.object({
	note: z
		.string()
		.max(5000, 'Note must be less than 5000 characters')
		.trim(),
});
export type UpdateNoteInput = z.infer<typeof UpdateNoteSchema>;
</file>

<file path="src/features/user-notes/pages/index.tsx">
import { api } from '@/trpc/server';
import { getSession } from '@/lib/auth';
import UserNotesForm from '@/features/user-notes/components/user-notes-form';
import { TRPCError } from '@trpc/server';
const UserNotesPage = async () => {
	const session = await getSession();
	if (!session?.user) {
		return (
			<div className='mx-auto max-w-4xl space-y-6 p-6'>
				<div className='space-y-2'>
					<h1 className='text-3xl font-bold'>My Notes</h1>
					<p className='text-muted-foreground text-sm'>
						Write and save your private notes. Maximum 5000
						characters.
					</p>
				</div>
				<div className='flex items-center justify-center py-12'>
					<p className='text-muted-foreground'>
						Please sign in to view and manage your notes.
					</p>
				</div>
			</div>
		);
	}
	let initialNoteContent = '';
	let fetchError: string | null = null;
	try {
		// Directly call the tRPC query on the server for initial data fetching.
		// The `api` import from '@/trpc/server' ensures this runs in an RSC context
		const result = await api.userNotes.main.getNote();
		initialNoteContent = result.note;
	} catch (error) {
		if (error instanceof TRPCError) {
			fetchError = error.message;
		} else {
			console.error('Failed to fetch user note on server:', error);
			fetchError = 'Failed to load your note due to an unexpected error.';
		}
	}
	return (
		<div className='mx-auto max-w-4xl space-y-6 p-6'>
			<div className='space-y-2'>
				<h1 className='text-3xl font-bold'>My Notes</h1>
				<p className='text-muted-foreground text-sm'>
					Write and save your private notes. Maximum 5000 characters.
				</p>
			</div>
			{fetchError ? (
				<div className='flex items-center justify-center py-12'>
					<p className='text-destructive'>{fetchError}</p>
				</div>
			) : (
				<UserNotesForm initialNote={initialNoteContent} />
			)}
		</div>
	);
};
export default UserNotesPage;
</file>

</files>

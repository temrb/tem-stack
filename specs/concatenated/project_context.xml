<directory_structure>
.claude/
  CLAUDE.md
src/
  app/
    (site)/
      (home)/
        page.tsx
      (main)/
        feature-2/
          page.tsx
        notes/
          page.tsx
        settings/
          page.tsx
        track/
          page.tsx
      get-started/
        auth.tsx
        page.tsx
    api/
      auth/
        [...nextauth]/
          route.ts
      trpc/
        [trpc]/
          route.ts
    fonts/
      Hubot-Sans.woff2
      Mona-Sans.woff2
    icon.png/
      route.tsx
    icon.svg/
      route.ts
    apple-icon.tsx
    manifest.ts
    not-found.tsx
    opengraph-image.tsx
    robots.ts
    sitemap.ts
    twitter-image.tsx
  components/
    layouts/
      main/
        header/
          header-actions/
            action-layout.tsx
            registry.ts
          header-action.tsx
          index.tsx
        menubar/
          auth-action.tsx
          index.tsx
          menubar-item.tsx
          unauth-action.tsx
        content.tsx
        footer.tsx
        index.tsx
      profile-settings/
      general-layout.tsx
      layout-shell.tsx
      list-item.tsx
    ui/
      button/
        lib/
          types/
            base-props.d.ts
            button-props.d.ts
            index.ts
            link-props.d.ts
          utils/
            button-variants.ts
            get-spinner-size.ts
        index.tsx
        support-button.tsx
      loading/
        loading-spinner.tsx
        page-loading.tsx
      animated-tooltip.tsx
      avatar.tsx
      card.tsx
      form.tsx
      input.tsx
      label.tsx
      link.tsx
      logo.tsx
      nav-menu.tsx
      select.tsx
      sonner.tsx
      textarea.tsx
      tooltip.tsx
    suspense-wrapper.tsx
  features/
    settings/
      api/
        services/
          user.service.ts
        index.ts
        user.ts
      components/
        modals/
          delete-account-modal.tsx
        profile-settings-layout.tsx
        profile-settings-section.tsx
        settings-header-action.tsx
        settings-section.tsx
      lib/
        types/
          enums.ts
          index.ts
          settings.d.ts
        validation/
          index.ts
          user.z.ts
      pages/
        general/
          sections/
            delete-account.tsx
            theme.tsx
            update-alias.tsx
          index.tsx
      header-actions.ts
      modals.ts
    user-notes/
      api/
        services/
          user-notes.service.ts
        index.ts
        user-notes.ts
      lib/
        types/
          index.ts
        validation/
          user-notes.z.ts
      pages/
        index.tsx
  hooks/
    index.ts
    useHandleFormError.ts
    useKeyboardShortcut.ts
    useMediaQuery.ts
    useModals.ts
  lib/
    assets/
      svg/
        socials.tsx
    auth/
      client-session-handler.ts
      helpers.ts
      index.ts
      options.ts
      session-security.ts
    core/
      errors/
        error-handler.ts
        error-messages.ts
      types/
        aria-utils.ts
        routes.ts
        timer.ts
      utils/
        array.ts
        date.ts
        deep-equal.ts
        index.ts
        try-catch.ts
      index.ts
    infra/
      storage/
        zustand/
          examples.ts
          immer-config.ts
          index.ts
          types.ts
          versioning.ts
        index.ts
      index.ts
    metadata/
      config.ts
      data-fetching.ts
      icon-graphics.ts
      index.ts
      structured-data.ts
    proxy/
      helpers/
        app.helpers.ts
        index.ts
      utils/
        detect-bot.ts
        get-user-via-token.ts
        get-valid-subdomain.ts
        index.ts
        parse.ts
        route-matcher.ts
        session-handler.ts
      app.ts
      index.ts
    redis/
      client.ts
    ui/
      header-actions.ts
      index.ts
      modals.ts
  modals/
    modal-footer-actions.tsx
    modal-layout.tsx
    modal-provider.tsx
    registry.ts
    responsive-modal.tsx
  prisma/
    site/
      schema/
        schema.prisma
  providers/
    index.tsx
    session-provider.tsx
    theme-provider.tsx
  routes/
    account.ts
    admin.ts
    core.ts
    index.ts
    menubar.ts
  scripts/
    analytics.tsx
    index.ts
  styles/
    globals.css
  trpc/
    server/
      api/
        site/
          errors.ts
          helpers.ts
          logger.ts
          root.ts
          trpc.ts
      site.ts
    query-client.ts
    react.tsx
    server.ts
  zustand/
    ui/
      useLayoutStore.ts
      useModalStore.ts
    user/
      useOnboardingStore.ts
  env.js
  proxy.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/app/(site)/(home)/page.tsx">
import type { Metadata } from 'next';
export const metadata: Metadata = {
	title: 'Home',
	description: 'Home page of the site.',
	robots: {
		index: true,
		follow: true,
	},
};
const Page = () => {
	return <div>Page</div>;
};
export default Page;
</file>

<file path="src/app/(site)/(main)/feature-2/page.tsx">
const Page = () => {
	return <div>Page</div>;
};
export default Page;
</file>

<file path="src/app/(site)/(main)/notes/page.tsx">
import UserNotesPage from '@/features/user-notes/pages';
import type { Metadata } from 'next';
export const metadata: Metadata = {
	title: 'My Notes',
	description: 'Write and save your private notes.',
	robots: {
		index: false,
		follow: true,
	},
};
const Page = () => {
	return <UserNotesPage />;
};
export default Page;
</file>

<file path="src/app/(site)/(main)/settings/page.tsx">
import GeneralSettings from '@/features/settings/pages/general';
import type { Metadata } from 'next';
export const metadata: Metadata = {
	title: 'General Settings',
	description:
		'Manage your general settings, theme preferences, and account info.',
	robots: {
		index: false,
		follow: true,
	},
};
const Page = () => {
	return <GeneralSettings />;
};
export default Page;
</file>

<file path="src/app/(site)/(main)/track/page.tsx">
const Page = () => {
	return <div>Page</div>;
};
export default Page;
</file>

<file path="src/app/(site)/get-started/auth.tsx">
'use client';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Socials } from '@/lib/assets/svg/socials';
import { signIn } from 'next-auth/react';
import { useSearchParams } from 'next/navigation';
import { useState } from 'react';
const Auth = () => {
	const searchParams = useSearchParams();
	const redirectTo = searchParams.get('redirectTo');
	const [loading, setLoading] = useState(false);
	return (
		<div className='relative flex h-full w-full items-center justify-center p-2'>
			<Card className='border mx-auto w-full max-w-md shadow-lg'>
				<CardContent className='mx-auto max-w-sm space-y-3 py-6'>
					<Button
						disabled={loading}
						className='h-14 w-full'
						variant='secondary'
						onClick={() => {
							setLoading(true);
							signIn('google', {
								callbackUrl: redirectTo ? `${redirectTo}` : '/',
							}).then(() => setLoading(false));
						}}
						aria-label='Continue with Google'
					>
						<span className='flex w-full flex-row items-center justify-center space-x-2'>
							<Socials.Google className='size-6' />
							<p className='text-sm font-normal tracking-wide'>
								Continue with Google
							</p>
						</span>
					</Button>
				</CardContent>
			</Card>
		</div>
	);
};
export default Auth;
</file>

<file path="src/app/(site)/get-started/page.tsx">
import { cn } from '@/lib/core/utils';
import Auth from './auth';
const Landing = () => {
	return (
		<div className='relative flex h-full w-full items-center justify-center bg-background'>
			<div
				className={cn(
					'absolute inset-0',
					'[background-size:20px_20px]',
					'[background-image:radial-gradient(#d4d4d4_1px,transparent_1px)]',
					'dark:[background-image:radial-gradient(#404040_1px,transparent_1px)]',
				)}
			/>
			<div className='pointer-events-none absolute inset-0 flex items-center justify-center bg-background [mask-image:radial-gradient(ellipse_at_center,transparent_5%,black)]'></div>
			<div className='relative mx-auto flex h-full w-full max-w-lg flex-col items-center justify-start space-y-14 px-4 pt-4 sm:pt-16 lg:max-w-2xl'>
				<Auth />
				{}
			</div>
		</div>
	);
};
export default Landing;
</file>

<file path="src/app/api/auth/[...nextauth]/route.ts">
import { authOptions } from '@/lib/auth/options';
import NextAuth from 'next-auth';
const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };
</file>

<file path="src/app/api/trpc/[trpc]/route.ts">
import { appRouter } from '@/trpc/server/api/site/root';
import { createTRPCContext } from '@/trpc/server/api/site/trpc';
import { fetchRequestHandler } from '@trpc/server/adapters/fetch';
import type { NextRequest } from 'next/server';
const createContext = async (req: NextRequest) => {
	return createTRPCContext({
		headers: req.headers,
	});
};
const handler = (req: NextRequest) =>
	fetchRequestHandler({
		endpoint: '/api/trpc',
		req,
		router: appRouter,
		createContext: () => createContext(req),
		onError:
			process.env.NODE_ENV === 'development'
				? ({ path, error }) => {
						console.error(
							`‚ùå tRPC failed on ${path ?? '<no-path>'}: ${error.message}`,
						);
					}
				: undefined,
	});
export { handler as GET, handler as POST };
</file>

<file path="src/app/icon.png/route.tsx">
import { SOCIAL_IMAGE_SIZES } from '@/lib/metadata/config';
import { createGradientIconElement } from '@/lib/metadata/icon-graphics';
import { ImageResponse } from 'next/og';
export async function GET() {
	return new ImageResponse(
		createGradientIconElement({
			background: 'transparent',
			circleScale: 0.88,
		}),
		{
			...SOCIAL_IMAGE_SIZES.defaultIcon,
			headers: {
				'Cache-Control': 'public, max-age=31536000, immutable',
			},
		},
	);
}
</file>

<file path="src/app/icon.svg/route.ts">
export async function GET() {
	const svg = `
<svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="iconGradient" x1="0%" y1="100%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:hsl(0, 0%, 4%);stop-opacity:1" />
      <stop offset="100%" style="stop-color:hsl(0, 0%, 96%);stop-opacity:1" />
    </linearGradient>
  </defs>
  <circle cx="16" cy="16" r="14" fill="url(#iconGradient)" />
</svg>
	`.trim();
	return new Response(svg, {
		headers: {
			'Content-Type': 'image/svg+xml',
			'Cache-Control': 'public, max-age=31536000, immutable',
		},
	});
}
</file>

<file path="src/app/apple-icon.tsx">
import { SOCIAL_IMAGE_SIZES } from '@/lib/metadata/config';
import { createGradientIconElement } from '@/lib/metadata/icon-graphics';
import { ImageResponse } from 'next/og';
export const size = SOCIAL_IMAGE_SIZES.appleIcon;
export const contentType = 'image/png';
export default function AppleIcon() {
	return new ImageResponse(
		createGradientIconElement({
			background: 'transparent',
			circleScale: 0.92,
		}),
		{
			...size,
		},
	);
}
</file>

<file path="src/app/manifest.ts">
import env from '@/env';
import { DEFAULT_METADATA } from '@/lib/metadata/config';
import type { MetadataRoute } from 'next';
export default function manifest(): MetadataRoute.Manifest {
	return {
		name: env.NEXT_PUBLIC_APP_NAME,
		short_name: env.NEXT_PUBLIC_APP_NAME,
		description: DEFAULT_METADATA.defaultDescription,
		start_url: '/',
		display: 'standalone',
		background_color: '#ffffff',
		theme_color: '#3b82f6',
		icons: [
			{
				src: '/icon',
				sizes: '32x32',
				type: 'image/png',
			},
			{
				src: '/apple-icon',
				sizes: '180x180',
				type: 'image/png',
			},
		],
		categories: ['career', 'productivity', 'utilities'],
		lang: 'en',
		dir: 'ltr',
		orientation: 'portrait-primary',
	};
}
</file>

<file path="src/app/not-found.tsx">
const NotFound = () => {
	return (
		<span className='flex h-full w-full items-center justify-center text-pretty p-4 font-mono'>
			The page you are looking for does not exist.
		</span>
	);
};
export default NotFound;
</file>

<file path="src/app/opengraph-image.tsx">
import { SOCIAL_IMAGE_SIZES } from '@/lib/metadata/config';
import { ImageResponse } from 'next/og';
export const alt = 'Open Graph Image';
export const size = SOCIAL_IMAGE_SIZES.openGraph;
export const contentType = 'image/png';
export default function OpenGraphImage() {
	return new ImageResponse(
		(
			<div
				style={{
					height: '100%',
					width: '100%',
					display: 'flex',
					flexDirection: 'column',
					alignItems: 'center',
					justifyContent: 'center',
					backgroundColor: '#ffffff',
					position: 'relative',
					fontFamily: 'system-ui, sans-serif',
				}}
			>
				{}
				<div
					style={{
						position: 'absolute',
						bottom: '40px',
						right: '40px',
						width: '100px',
						height: '100px',
						borderRadius: '50%',
						background: 'hsl(20, 14.3%, 4.1%)',
					}}
				></div>
				{}
				{
}
			</div>
		),
		{
			...size,
		},
	);
}
</file>

<file path="src/app/robots.ts">
import env from '@/env';
import type { MetadataRoute } from 'next';
export default function robots(): MetadataRoute.Robots {
	return {
		rules: [
			{
				userAgent: '*',
				allow: '/',
			},
		],
		sitemap: `${env.NEXT_PUBLIC_APP_URL}/sitemap.xml`,
		host: env.NEXT_PUBLIC_APP_DOMAIN,
	};
}
</file>

<file path="src/app/sitemap.ts">
import env from '@/env';
import type { MetadataRoute } from 'next';
export default function sitemap(): MetadataRoute.Sitemap {
	const baseUrl = env.NEXT_PUBLIC_APP_URL;
	const currentDate = new Date();
	return [
		{
			url: baseUrl,
			lastModified: currentDate,
			changeFrequency: 'hourly',
			priority: 1.0,
		},
		{
			url: `${baseUrl}/job-search`,
			lastModified: currentDate,
			changeFrequency: 'daily',
			priority: 0.9,
		},
		{
			url: `${baseUrl}/get-started`,
			lastModified: currentDate,
			changeFrequency: 'weekly',
			priority: 0.8,
		},
		{
			url: `${baseUrl}/track`,
			lastModified: currentDate,
			changeFrequency: 'weekly',
			priority: 0.7,
		},
		{
			url: `${baseUrl}/settings`,
			lastModified: currentDate,
			changeFrequency: 'monthly',
			priority: 0.3,
		},
	];
}
</file>

<file path="src/app/twitter-image.tsx">
import { SOCIAL_IMAGE_SIZES } from '@/lib/metadata/config';
import { ImageResponse } from 'next/og';
export const alt = 'Attanble - The End To End Candidate Experience Platform';
export const size = SOCIAL_IMAGE_SIZES.twitter;
export const contentType = 'image/png';
export default function TwitterImage() {
	return new ImageResponse(
		(
			<div
				style={{
					height: '100%',
					width: '100%',
					display: 'flex',
					flexDirection: 'column',
					alignItems: 'center',
					justifyContent: 'center',
					backgroundColor: '#ffffff',
					position: 'relative',
					fontFamily: 'system-ui, sans-serif',
				}}
			>
				{}
				<div
					style={{
						position: 'absolute',
						bottom: '40px',
						right: '40px',
						width: '100px',
						height: '100px',
						borderRadius: '50%',
						background: 'hsl(20, 14.3%, 4.1%)',
					}}
				></div>
				{}
				{
}
			</div>
		),
		{
			...size,
		},
	);
}
</file>

<file path="src/components/layouts/main/header/header-actions/action-layout.tsx">
interface ActionLayoutProps {
	children: React.ReactNode;
}
const ActionLayout = ({ children }: Readonly<ActionLayoutProps>) => {
	return (
		<div className='flex flex-shrink-0 flex-row items-center justify-end space-x-3 md:space-x-4'>
			{children}
		</div>
	);
};
export default ActionLayout;
</file>

<file path="src/components/layouts/main/header/header-action.tsx">
'use client';
import SuspenseWrapper from '@/components/suspense-wrapper';
import Logo from '@/components/ui/logo';
import { normalizeRouteMatcher } from '@/lib/ui/header-actions';
import { useSession } from 'next-auth/react';
import { usePathname } from 'next/navigation';
import ActionLayout from './header-actions/action-layout';
import { headerActionRegistry } from './header-actions/registry';
const HeaderAction = () => {
	const session = useSession();
	const authenticated = session.status === 'authenticated';
	const pathname = usePathname();
	if (pathname.startsWith('/get-started')) {
		return <Logo textOnly style='solid' className='ml-auto' />;
	}
	if (authenticated) {
		for (const [key, definition] of Object.entries(headerActionRegistry)) {
			const routeMatcher = normalizeRouteMatcher(
				definition.config.routeMatcher,
			);
			if (routeMatcher(pathname)) {
				const { Component } = definition;
				return (
					<SuspenseWrapper>
						<ActionLayout>
							<Component />
						</ActionLayout>
					</SuspenseWrapper>
				);
			}
		}
	}
};
export default HeaderAction;
</file>

<file path="src/components/layouts/main/menubar/auth-action.tsx">
'use client';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import SupportButton from '@/components/ui/button/support-button';
import NavMenu from '@/components/ui/nav-menu';
import { signOut, useSession } from 'next-auth/react';
import { LuBolt, LuLogOut, LuShield } from 'react-icons/lu';
const AuthAction = () => {
	const session = useSession();
	const admin = session.data?.user?.role === 'ADMIN';
	const handleSignOut = () => {
		signOut({ callbackUrl: '/' });
	};
	if (session.status === 'authenticated') {
		return (
			<>
				<NavMenu
					trigger={
						<button
							className='cursor-pointer'
							aria-label='Open user menu'
						>
							<Avatar className='size-7'>
								<AvatarImage
									src={
										session?.data?.user?.image ??
										'/default-avatar.png'
									}
									referrerPolicy='no-referrer'
									className='pointer-events-none'
									alt={
										session?.data?.user?.name
											? `${session.data.user.name}'s avatar`
											: 'User avatar'
									}
								/>
								<AvatarFallback>
									{session?.data?.user?.name
										? session.data.user.name
												.slice(0, 2)
												.toUpperCase()
										: 'NA'}
								</AvatarFallback>
							</Avatar>
						</button>
					}
					items={[
						...(admin
							? [
									{
										id: 'admin',
										type: 'link' as const,
										text: 'Admin',
										href: '/admin',
										icon: (
											<LuShield className='size-5 md:size-[1.15rem]' />
										),
									},
								]
							: []),
						{
							id: 'settings',
							type: 'link',
							text: 'Account',
							href: '/settings',
							icon: (
								<LuBolt className='size-5 md:size-[1.15rem]' />
							),
						},
						{
							id: 'sign-out',
							type: 'button',
							text: 'Sign Out',
							onClick: handleSignOut,
							icon: (
								<LuLogOut className='size-5 md:size-[1.15rem]' />
							),
						},
					]}
				/>
				<SupportButton size='icon' variant='ghost' />
			</>
		);
	}
};
export default AuthAction;
</file>

<file path="src/components/layouts/main/menubar/index.tsx">
'use client';
import SuspenseWrapper from '@/components/suspense-wrapper';
import { Button } from '@/components/ui/button';
import type { Route } from '@/lib/core/types/routes';
import { cn } from '@/lib/core/utils';
import { routes } from '@/routes';
import { useLayoutStore } from '@/zustand/ui/useLayoutStore';
import { motion } from 'framer-motion';
import { useSession } from 'next-auth/react';
import { usePathname } from 'next/navigation';
import { lazy, useCallback } from 'react';
import { LuPanelLeftClose, LuX } from 'react-icons/lu';
import MenubarItem from './menubar-item';
const AuthAction = lazy(() => import('./auth-action'));
const UnAuthAction = lazy(() => import('./unauth-action'));
const menubarVariants = {
	hidden: {
		opacity: '0%',
		transition: {
			duration: 0.3,
		},
	},
	visible: {
		opacity: '100%',
		transition: {
			duration: 0.3,
			staggerChildren: 0.05,
			delayChildren: 0.1,
		},
	},
	exit: {
		opacity: '0%',
		transition: {
			duration: 0.3,
		},
	},
};
const menuItemContainerVariants = {
	hidden: { opacity: 0 },
	visible: {
		opacity: 1,
		transition: {
			staggerChildren: 0.03,
		},
	},
};
const menuItemVariants = {
	hidden: {
		opacity: 0,
	},
	visible: {
		opacity: 1,
	},
};
const Menubar = () => {
	const { menubar, setMenubar } = useLayoutStore();
	const currentPath = usePathname();
	const session = useSession();
	const features = routes.filter((route: Route) => {
		if (route.category !== 'feature') return false;
		return route.type !== 'admin';
	});
	const primaryNavRoutes = routes.filter((route: Route) => route.primaryNav);
	const renderAuthAction = useCallback(() => {
		return (
			<SuspenseWrapper>
				{session.status === 'authenticated' ? (
					<AuthAction />
				) : (
					<UnAuthAction />
				)}
			</SuspenseWrapper>
		);
	}, [session.status]);
	return (
		<motion.aside
			initial='hidden'
			animate='visible'
			exit='exit'
			variants={menubarVariants}
			className='flex h-full w-full flex-col-reverse md:border-r md:w-52 md:flex-col lg:w-64'
		>
			{}
			<div className='border-b z-30 flex h-16 w-full items-center justify-between border-border px-4'>
				<Button
					variant='ghost'
					size='icon'
					onClick={() => setMenubar(!menubar)}
					aria-label='Close menu'
				>
					<LuX className='flex size-4 md:hidden' />
					<LuPanelLeftClose className='hidden size-4 md:flex' />
				</Button>
				<div className='flex flex-row items-center space-x-1'>
					{primaryNavRoutes.map((route: Route) => {
						const isActive =
							currentPath === route.displayPath ||
							(route.displayPath !== '/' &&
								currentPath.startsWith(route.displayPath));
						const Icon = route.icon;
						return (
							<Button
								key={route.path}
								href={isActive ? undefined : route.displayPath}
								variant={isActive ? 'secondary' : 'ghost'}
								size='icon'
								className={cn(
									currentPath.startsWith(route.displayPath) &&
										route.displayPath !== '/' &&
										'hidden md:flex',
									isActive &&
										'pointer-events-none opacity-50',
								)}
								disabled={isActive}
								icon={
									Icon ? (
										<Icon
											className='size-4'
											aria-hidden='true'
										/>
									) : undefined
								}
								aria-label={route.displayName}
							/>
						);
					})}
				</div>
			</div>
			{}
			<div className='flex h-[calc(100dvh-8rem)] w-full flex-col overflow-y-auto overflow-x-hidden bg-background p-4 scrollbar-hide'>
				{
}
				<motion.div
					className='flex-1 space-y-2'
					variants={menuItemContainerVariants}
					initial='hidden'
					animate='visible'
				>
					{features.map((route: Route) => (
						<motion.div
							key={route.path}
							variants={menuItemVariants}
						>
							<MenubarItem {...route} />
						</motion.div>
					))}
				</motion.div>
			</div>
			{}
			<div className='border-b flex h-16 items-center justify-between px-4 md:border-t'>
				{renderAuthAction()}
			</div>
		</motion.aside>
	);
};
export default Menubar;
</file>

<file path="src/components/layouts/main/menubar/menubar-item.tsx">
'use client';
import { Button } from '@/components/ui/button';
import { useMediaQuery } from '@/hooks';
import type { Route } from '@/lib/core/types/routes';
import { cn } from '@/lib/core/utils';
import { useLayoutStore } from '@/zustand/ui/useLayoutStore';
import { usePathname } from 'next/navigation';
const MenubarItem = (props: Route) => {
	const {
		path,
		displayName,
		category,
		displayPath,
		type,
		status,
		onboardingCompleteRequired,
		icon: Icon,
	} = props;
	const currentPath = usePathname();
	const { setMenubar } = useLayoutStore();
	const { isMobile } = useMediaQuery();
	const navigationPath = displayPath || path;
	const isActive =
		currentPath === navigationPath ||
		(navigationPath !== '/' && currentPath.startsWith(navigationPath));
	const handleMenubarClose = () => {
		if (isMobile) {
			setMenubar(false);
		}
	};
	const defaultStyles =
		'flex w-full items-center justify-start md:px-3 md:py-1 p-4 text-sm font-medium text-muted-foreground md:rounded-sm';
	if (status) {
		return (
			<div
				className={cn(defaultStyles, 'cursor-default opacity-60')}
				aria-label={`${displayName} - ${status}`}
			>
				{Icon && (
					<Icon
						className='mr-2 h-4 w-4 flex-shrink-0'
						aria-hidden='true'
					/>
				)}
				<p className='text-overflow w-full truncate font-mono italic'>
					{status === 'soon' && 'Soon'}
					{status === 'next' && 'Next Update'}
				</p>
			</div>
		);
	}
	return (
		<Button
			variant='ghost'
			className={cn(
				defaultStyles,
				'gap-3',
				isActive &&
					'bg-foreground text-background md:pointer-events-none',
			)}
			onClick={handleMenubarClose}
			aria-label={displayName}
			href={navigationPath}
			icon={
				Icon && (
					<Icon
						className='h-4 w-4 flex-shrink-0'
						aria-hidden='true'
					/>
				)
			}
			iconPosition='left'
			disableWhilePending
		>
			{displayName}
		</Button>
	);
};
export default MenubarItem;
</file>

<file path="src/components/layouts/main/menubar/unauth-action.tsx">
'use client';
import { AnimatedTooltip } from '@/components/ui/animated-tooltip';
import { usePathname } from 'next/navigation';
import { Button } from '@/components/ui/button';
import SupportButton from '@/components/ui/button/support-button';
import Logo from '@/components/ui/logo';
import { useMediaQuery } from '@/hooks';
import { useLayoutStore } from '@/zustand/ui/useLayoutStore';
const people = [
	{
		id: 1,
		name: 'Aaron S.',
		designation: 'Perfect for my job search',
		image: 'https://images.unsplash.com/photo-1599566150163-29194dcaad36?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=3387&q=80',
	},
	{
		id: 2,
		name: 'Angela M.',
		designation: 'Took my job search to the next level',
		image: 'https://images.unsplash.com/photo-1620231145627-fd3a3b321d57?q=80&w=2670&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',
	},
	{
		id: 3,
		name: 'Josh R.',
		designation: 'Helped me land my dream job',
		image: 'https://images.unsplash.com/photo-1500648767791-00dcc994a43e?q=80&w=1287&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',
	},
	{
		id: 4,
		name: 'Jon W.',
		designation: 'A must-have for job seekers',
		image: 'https://images.unsplash.com/photo-1542909168-82c3e7fdca5c?q=80&w=1160&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',
	},
];
const UnAuthAction = () => {
	const pathname = usePathname();
	if (pathname === '/get-started') {
		return (
			<>
				<div className='hidden h-fit w-full items-center justify-start md:flex'>
					<AnimatedTooltip items={people} />
					<div className='ml-6 whitespace-nowrap text-xs'>
						1k+ others!
					</div>
				</div>
				<div className='h-full w-full md:hidden'>
					<SignInSection />
				</div>
			</>
		);
	}
	return <SignInSection />;
};
export default UnAuthAction;
const SignInSection = () => {
	const { setMenubar } = useLayoutStore();
	const { isMobile } = useMediaQuery();
	const handleClick = () => {
		if (isMobile) {
			setMenubar(false);
		}
	};
	return (
		<div className='flex h-full w-full flex-row items-center justify-between space-x-2'>
			<div className='flex items-center space-x-4'>
				<Button
					href='/get-started'
					text='Log In'
					aria-label='Sign In'
					size='sm'
					className='font-semibold'
					onClick={handleClick}
			/>
			<SupportButton variant='ghost' size='icon' />
			</div>
			<Logo style='gradient' />
		</div>
	);
};
</file>

<file path="src/components/layouts/main/content.tsx">
'use client';
import { cn } from '@/lib/core/utils';
import { useLayoutStore } from '@/zustand/ui/useLayoutStore';
import Header from './header';
export const getContentWidth = (menubar: boolean) =>
	menubar
		? 'hidden md:w-[calc(100%-13rem)] lg:w-[calc(100%-16rem)]'
		: 'flex w-full';
interface LayoutProps {
	children: React.ReactNode;
}
const Content = ({ children }: LayoutProps) => {
	const { menubar } = useLayoutStore();
	return (
		<div
			className={cn(
				'relative h-full flex-col bg-background md:flex',
				getContentWidth(menubar),
			)}
		>
			<Header />
			<section className='flex h-[calc(100dvh-4rem)] w-full overflow-y-auto overflow-x-hidden pt-16 scrollbar-hide md:h-full'>
				<div className='h-full w-full'>{children}</div>
			</section>
		</div>
	);
};
export default Content;
</file>

<file path="src/components/layouts/main/footer.tsx">
'use client';
import { Button } from '@/components/ui/button';
import type { Route } from '@/lib/core/types/routes';
import { cn } from '@/lib/core/utils';
import { routes } from '@/routes';
import { useLayoutStore } from '@/zustand/ui/useLayoutStore';
import { usePathname } from 'next/navigation';
import { LuMenu, LuX } from 'react-icons/lu';
const Footer = () => {
	const pathname = usePathname();
	const { menubar, setMenubar } = useLayoutStore();
	const primaryNavRoutes = routes.filter((route: Route) => route.primaryNav);
	const handleMenubarToggle = () => {
		setMenubar(!menubar);
	};
	const handleNavigation = () => {
		setMenubar(false);
	};
	return (
		<nav className='border-t fixed bottom-0 z-30 flex h-16 w-full flex-row items-center justify-around divide-x divide-muted bg-background md:hidden'>
			<Button
				onClick={handleMenubarToggle}
				variant='ghost'
				className={cn(
					'flex h-full w-full rounded-none',
					menubar && 'bg-foreground/10',
				)}
				aria-label={menubar ? 'Close menu' : 'Open menu'}
			>
				{menubar ? (
					<LuX
						className='size-7 opacity-50 transition-all duration-300'
						strokeWidth={1.5}
					/>
				) : (
					<LuMenu
						className='size-7 opacity-50 transition-all duration-300'
						strokeWidth={1.5}
					/>
				)}
			</Button>
			{primaryNavRoutes.map((route) => {
				const isCurrentRoute =
					pathname === route.displayPath ||
					(route.displayPath !== '/' &&
						pathname.startsWith(route.displayPath));
				const isActive = !menubar && isCurrentRoute;
				const Icon = route.icon;
				return (
					<Button
						key={route.path}
						href={route.displayPath}
						icon={
							Icon ? (
								<Icon
									className={cn(
										'size-7 transition-all duration-300',
										isActive ? 'opacity-100' : 'opacity-50',
									)}
									strokeWidth={1.5}
									aria-hidden='true'
								/>
							) : undefined
						}
						className={cn(
							'flex h-full w-full items-center justify-center rounded-none transition-colors duration-300',
							isActive && 'bg-foreground/10',
						)}
						onClick={(e: React.MouseEvent<HTMLButtonElement>) => {
							if (isCurrentRoute) {
								e.preventDefault();
								handleNavigation();
								return;
							}
							handleNavigation();
						}}
						aria-label={route.displayName}
						variant='ghost'
					/>
				);
			})}
		</nav>
	);
};
export default Footer;
</file>

<file path="src/components/layouts/main/index.tsx">
'use client';
import PageLoading from '@/components/ui/loading/page-loading';
import { useLayoutStore } from '@/zustand/ui/useLayoutStore';
import React from 'react';
import LayoutShell from '../layout-shell';
import Content from './content';
import Footer from './footer';
import Menubar from './menubar';
interface LayoutProps {
	children: React.ReactNode;
}
const MainLayout = ({ children }: LayoutProps) => {
	const { isLoading, menubar } = useLayoutStore();
	return (
		<LayoutShell>
			{isLoading ? (
				<PageLoading />
			) : (
				<>
					{menubar && <Menubar />}
					<Content>{children}</Content>
					<Footer />
				</>
			)}
		</LayoutShell>
	);
};
export default MainLayout;
</file>

<file path="src/components/layouts/general-layout.tsx">
export default function GeneralLayout({
	children,
	className,
}: {
	children: React.ReactNode;
	className?: string;
}) {
	return <div className={`h-full w-full p-4 ${className}`}>{children}</div>;
}
</file>

<file path="src/components/layouts/layout-shell.tsx">
interface LayoutProps {
	children: React.ReactNode;
}
const LayoutShell = ({ children }: LayoutProps) => {
	return (
		<main className='relative mx-auto flex h-full max-w-screen-2xl flex-1 flex-row overflow-hidden'>
			{children}
		</main>
	);
};
export default LayoutShell;
</file>

<file path="src/components/layouts/list-item.tsx">
import { cn } from '@/lib/core/utils';
export default function ListItem({
	children,
	className,
	role,
}: {
	children: React.ReactNode;
	className?: string;
	role?: string;
}) {
	return (
		<section
			className={cn(
				'border-t relative flex flex-col space-y-4 p-4 first:border-t-0',
				className,
			)}
			role={role}
		>
			{children}
		</section>
	);
}
</file>

<file path="src/components/ui/button/lib/types/base-props.d.ts">
import type { AriaProps } from '@/lib/core';
import type { VariantProps } from 'class-variance-authority';
import type { ReactNode } from 'react';
import type { buttonVariants } from '../utils/button-variants';
export type BaseProps = React.ButtonHTMLAttributes<HTMLButtonElement> &
	VariantProps<typeof buttonVariants> &
	AriaProps & {
		requireAuth?: boolean;
		loading?: boolean;
		icon?: ReactNode;
		iconPosition?: 'left' | 'right';
		shortcut?: string;
		disabledTooltip?: string | ReactNode;
		asChild?: boolean;
		text?: string;
		textWrapperClassName?: string;
		count?: number;
	};
</file>

<file path="src/components/ui/button/lib/types/button-props.d.ts">
type RegularProps = BaseProps & {
	href?: never;
	newTab?: never;
	pendingClassName?: never;
	disableWhilePending?: never;
	prefetch?: never;
	authRedirectFallback?: string;
};
</file>

<file path="src/components/ui/button/lib/types/index.ts">
import type { LinkProps } from './link-props';
export type ButtonProps = LinkProps | RegularProps;
</file>

<file path="src/components/ui/button/lib/types/link-props.d.ts">
import type { LinkProps as NextLinkProps } from 'next/link';
type LinkProps = BaseProps & {
	href: string;
	newTab?: boolean;
	pendingClassName?: string;
	disableWhilePending?: boolean;
	prefetch?: NextLinkProps['prefetch'];
	authRedirectFallback?: string;
};
</file>

<file path="src/components/ui/button/lib/utils/button-variants.ts">
import { cva } from 'class-variance-authority';
export const buttonVariants = cva(
	'inline-flex items-center justify-center rounded-md text-sm font-medium !ring-0 !outline-none transition-colors focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50',
	{
		variants: {
			variant: {
				default:
					'bg-primary text-primary-foreground hover:bg-primary/90',
				destructive:
					'bg-destructive text-destructive-foreground hover:bg-destructive/90',
				outline:
					'border border-border bg-background hover:bg-accent hover:text-accent-foreground',
				secondary:
					'bg-secondary text-secondary-foreground hover:bg-secondary/80',
				ghost: 'hover:bg-accent hover:text-accent-foreground',
				link: 'text-primary underline-offset-4 hover:underline',
				none: 'rounded-none !outline-none !ring-0',
			},
			size: {
				default: 'h-10 px-4 py-2',
				sm: 'h-9 rounded-md px-3',
				lg: 'h-11 rounded-md px-8',
				icon: 'size-8 p-2',
				none: 'rounded-none !outline-none !ring-0',
			},
		},
		defaultVariants: {
			variant: 'default',
			size: 'default',
		},
	},
);
</file>

<file path="src/components/ui/button/lib/utils/get-spinner-size.ts">
import type { VariantProps } from 'class-variance-authority';
import { isValidElement, type ReactNode } from 'react';
import type { buttonVariants } from '../..';
const getSpinnerSize = (
	size: VariantProps<typeof buttonVariants>['size'],
	icon: ReactNode,
): number => {
	if (size === 'icon') {
		return 16;
	}
	if (icon && isValidElement(icon) && icon.props) {
		const iconClassName = (icon.props as { className?: string }).className;
		if (iconClassName && typeof iconClassName === 'string') {
			const sizeMatch = iconClassName.match(/(?:h|w|size)-(\d+)/);
			if (sizeMatch?.[1]) {
				return Number.parseInt(sizeMatch[1], 10) * 4;
			}
		}
	}
	switch (size) {
		case 'sm':
			return 14;
		case 'lg':
			return 22;
		default:
			return 20;
	}
};
export default getSpinnerSize;
</file>

<file path="src/components/ui/button/index.tsx">
'use client';
import { useMediaQuery } from '@/hooks';
import {
	formatShortcut,
	useKeyboardShortcut,
} from '@/hooks/useKeyboardShortcut';
import { validateAriaProps } from '@/lib/core/types/aria-utils';
import { cn } from '@/lib/core/utils';
import { Slot } from '@radix-ui/react-slot';
import { useSession } from 'next-auth/react';
import { useLinkStatus } from 'next/link';
import { usePathname, useRouter } from 'next/navigation';
import type { ReactNode } from 'react';
import React, { useEffect } from 'react';
import Link from '../link';
import LoadingSpinner from '../loading/loading-spinner';
import type { ButtonProps } from './lib/types';
import { buttonVariants } from './lib/utils/button-variants';
import getSpinnerSize from './lib/utils/get-spinner-size';
interface LinkButtonContentProps {
	loading: boolean;
	disabled?: boolean;
	disableWhilePending?: boolean;
	isAuthRedirecting: boolean;
	asChild: boolean;
	className?: string;
	pendingClassName?: string;
	disabledTooltip?: React.ReactNode;
	renderContent: (isLoadingOverride?: boolean) => ReactNode;
	ref?: React.Ref<HTMLButtonElement>;
	restProps: Record<string, unknown>;
}
const LinkButtonContent = ({
	loading,
	disabled,
	disableWhilePending,
	isAuthRedirecting,
	asChild,
	className,
	pendingClassName,
	disabledTooltip,
	renderContent,
	ref,
	restProps,
}: LinkButtonContentProps) => {
	const { pending } = useLinkStatus();
	const combinedLoading = loading || pending;
	const combinedDisabled =
		disabled ||
		(disableWhilePending && pending) ||
		combinedLoading ||
		isAuthRedirecting;
	const Comp = asChild ? Slot : 'button';
	return (
		<Comp
			ref={ref}
			disabled={combinedDisabled}
			title={
				disabledTooltip && combinedDisabled
					? String(disabledTooltip)
					: undefined
			}
			className={cn(
				asChild ? className : '',
				pending && (pendingClassName || 'cursor-progress'),
			)}
			{...restProps}
		>
			{renderContent(combinedLoading)}
		</Comp>
	);
};
interface LinkButtonProps {
	href: string;
	newTab?: boolean;
	prefetch?: boolean | null;
	loading: boolean;
	disabled?: boolean;
	disableWhilePending?: boolean;
	isAuthRedirecting: boolean;
	asChild: boolean;
	handleAuthRedirect: (event: React.MouseEvent) => boolean;
	onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
	variant?: ButtonProps['variant'];
	size?: ButtonProps['size'];
	className?: string;
	pendingClassName?: string;
	disabledTooltip?: React.ReactNode;
	renderContent: (isLoadingOverride?: boolean) => ReactNode;
	ref?: React.Ref<HTMLButtonElement>;
	restProps: Record<string, unknown>;
}
const LinkButton = ({
	href,
	newTab,
	prefetch,
	loading,
	disabled,
	disableWhilePending,
	isAuthRedirecting,
	asChild,
	handleAuthRedirect,
	onClick,
	variant,
	size,
	className,
	pendingClassName,
	disabledTooltip,
	renderContent,
	ref,
	restProps,
}: LinkButtonProps) => {
	return (
		<Link
			href={href}
			newTab={newTab}
			prefetch={prefetch}
			aria-label={restProps['aria-label'] as string | undefined}
			onClick={(e: React.MouseEvent<HTMLAnchorElement>) => {
				if (handleAuthRedirect(e)) return;
				onClick?.(e as unknown as React.MouseEvent<HTMLButtonElement>);
			}}
			className={cn(buttonVariants({ variant, size }), className)}
		>
			<LinkButtonContent
				loading={loading}
				disabled={disabled}
				disableWhilePending={disableWhilePending}
				isAuthRedirecting={isAuthRedirecting}
				asChild={asChild}
				className={className}
				pendingClassName={pendingClassName}
				disabledTooltip={disabledTooltip}
				renderContent={renderContent}
				ref={ref}
				restProps={restProps}
			/>
		</Link>
	);
};
const Button = (
	props: ButtonProps & { ref?: React.Ref<HTMLButtonElement> },
) => {
	const {
		className,
		variant,
		size,
		requireAuth = false,
		loading = false,
		children,
		onClick,
		icon,
		iconPosition = 'left',
		shortcut,
		disabledTooltip,
		disabled,
		asChild = false,
		text,
		textWrapperClassName,
		count,
		href,
		newTab,
		pendingClassName,
		disableWhilePending,
		prefetch,
		authRedirectFallback,
		ref,
		...restProps
	} = props;
	validateAriaProps(restProps, 'Button');
	const { status } = useSession();
	const router = useRouter();
	const pathname = usePathname();
	const { isMobile } = useMediaQuery();
	const isAuthenticated = status === 'authenticated';
	const [isAuthRedirecting, setIsAuthRedirecting] = React.useState(false);
	const isDisabled = disabled || loading || isAuthRedirecting;
	const Comp = asChild ? Slot : 'button';
	useEffect(() => {
		if (
			process.env.NODE_ENV === 'development' &&
			size === 'icon' &&
			!restProps['aria-label'] &&
			!restProps['aria-labelledby']
		) {
			console.warn(
				`Accessibility Warning: An icon-only button should have an 'aria-label' or 'aria-labelledby' prop for screen readers.`,
			);
		}
	}, [size, restProps]);
	const getAuthRedirectUrl = React.useCallback(() => {
		const destination = authRedirectFallback || href || pathname;
		const url = new URL('/get-started', window.location.origin);
		url.searchParams.set('redirectTo', destination);
		return url.toString();
	}, [authRedirectFallback, href, pathname]);
	const handleAuthRedirect = React.useCallback(
		(event: React.MouseEvent) => {
			if (requireAuth && !isAuthenticated) {
				event.preventDefault();
				event.stopPropagation();
				setIsAuthRedirecting(true);
				router.push(getAuthRedirectUrl());
				return true;
			}
			return false;
		},
		[requireAuth, isAuthenticated, router, getAuthRedirectUrl],
	);
	const handleClick = React.useCallback(
		(event: React.MouseEvent<HTMLButtonElement>) => {
			if (handleAuthRedirect(event)) return;
			onClick?.(event);
		},
		[handleAuthRedirect, onClick],
	);
	useKeyboardShortcut(
		shortcut || '',
		() => {
			if (!isDisabled && onClick) {
				const syntheticEvent = new MouseEvent('click', {
					bubbles: true,
					cancelable: true,
				}) as unknown as React.MouseEvent<HTMLButtonElement>;
				handleClick(syntheticEvent);
			}
		},
		{
			enabled: !!shortcut && !isDisabled && !isMobile,
		},
	);
	const renderContent = (isLoadingOverride?: boolean): ReactNode => {
		const hasChildren = children !== undefined && children !== null;
		const content = hasChildren ? children : text;
		const hasContent = content !== undefined && content !== null;
		const isCurrentlyLoading = isLoadingOverride ?? loading;
		const iconSlot = isCurrentlyLoading ? (
			<LoadingSpinner
				size={getSpinnerSize(size, icon)}
				textNormal={true}
			/>
		) : (
			icon
		);
		if (iconSlot && !hasContent && !shortcut) {
			return iconSlot;
		}
		if (!iconSlot && !shortcut) {
			return hasContent ? (
				textWrapperClassName ? (
					<span className={textWrapperClassName}>{content}</span>
				) : (
					content
				)
			) : null;
		}
		return (
			<div className='flex items-center justify-between gap-2'>
				<div className='flex items-center gap-2'>
					{iconSlot && iconPosition === 'left' && (
						<span className='shrink-0'>{iconSlot}</span>
					)}
					{hasContent && (
						<span className={cn('truncate', textWrapperClassName)}>
							{content}
						</span>
					)}
					{iconSlot && iconPosition === 'right' && (
						<span className='shrink-0'>{iconSlot}</span>
					)}
					{count !== undefined && count > 0 && (
						<span className='ml-1 flex h-4 w-4 items-center justify-center rounded-full bg-primary-foreground text-[10px] text-primary'>
							{count}
						</span>
					)}
				</div>
				{shortcut && !isMobile && (
					<kbd className='border pointer-events-none hidden h-5 select-none items-center gap-1 rounded bg-muted px-1.5 font-mono text-xs text-muted-foreground opacity-100 md:inline-flex'>
						{formatShortcut(shortcut)}
					</kbd>
				)}
			</div>
		);
	};
	if (href) {
		return (
			<LinkButton
				href={href}
				newTab={newTab}
				prefetch={prefetch}
				loading={loading}
				disabled={disabled}
				disableWhilePending={disableWhilePending}
				isAuthRedirecting={isAuthRedirecting}
				asChild={asChild}
				handleAuthRedirect={handleAuthRedirect}
				onClick={onClick}
				variant={variant}
				size={size}
				className={className}
				pendingClassName={pendingClassName}
				disabledTooltip={disabledTooltip}
				renderContent={renderContent}
				ref={ref}
				restProps={restProps}
			/>
		);
	}
	return (
		<Comp
			className={cn(buttonVariants({ variant, size }), className)}
			ref={ref}
			disabled={isDisabled}
			onClick={handleClick}
			aria-busy={loading ? 'true' : undefined}
			title={
				disabledTooltip && isDisabled
					? String(disabledTooltip)
					: undefined
			}
			{...restProps}
		>
			{renderContent()}
		</Comp>
	);
};
Button.displayName = 'Button';
export { Button, buttonVariants };
</file>

<file path="src/components/ui/button/support-button.tsx">
import env from '@/env';
import { cn } from '@/lib/core/utils';
import type { ReactNode } from 'react';
import { LuLifeBuoy } from 'react-icons/lu';
import { Button } from '.';
import { Tooltip } from '../tooltip';
import type { ButtonProps } from './lib/types';
interface SupportButtonProps {
	variant?: ButtonProps['variant'];
	size?: ButtonProps['size'];
	text?: string;
	showIcon?: boolean;
	icon?: ReactNode;
	className?: string;
	disabled?: boolean;
}
const SupportButton = ({
	variant = 'ghost',
	size = 'default',
	text = 'Support',
	showIcon = true,
	icon,
	className,
	disabled = false,
}: SupportButtonProps) => {
	const shouldShowIcon = showIcon || size === 'icon';
	const displayIcon = icon ?? (
		<LuLifeBuoy
			className='size-4'
		/>
	);
	const buttonElement = (
		<Button
			href={env.NEXT_PUBLIC_FEATUREBASE_URL}
			newTab
			variant={variant}
			size={size}
			className={cn(className, size !== 'icon' && 'h-fit w-fit')}
			disabled={disabled}
			icon={shouldShowIcon ? displayIcon : undefined}
			iconPosition='left'
			aria-label={size === 'icon' ? 'Get Support' : text}
		>
			{size === 'icon' ? undefined : text}
		</Button>
	);
	if (size === 'icon') {
		return (
			<Tooltip
				trigger={buttonElement}
				content={
					<p className='text-sm'>Get support or request features!</p>
				}
				side='top'
			/>
		);
	}
	return buttonElement;
};
export default SupportButton;
</file>

<file path="src/components/ui/loading/loading-spinner.tsx">
import { cn } from '@/lib/core/utils';
interface Props {
	size: number;
	className?: string;
	textNormal?: boolean | false;
}
const LoadingSpinner = (props: Props) => {
	const { size, textNormal, className } = props;
	return (
		<svg
			className={cn(
				'animate-spin ease-in-out',
				!textNormal && 'text-foreground',
				className,
			)}
			xmlns='http://www.w3.org/2000/svg'
			fill='none'
			viewBox='0 0 350 350'
			height={size}
			width={size}
		>
			<circle
				className='opacity-55'
				r='130'
				stroke='currentColor'
				cx='175'
				cy='175'
				fill='none'
				strokeWidth='80'
				strokeDasharray='455'
				strokeLinecap='round'
				strokeDashoffset='-52'
			/>
		</svg>
	);
};
export default LoadingSpinner;
</file>

<file path="src/components/ui/loading/page-loading.tsx">
import LoadingSpinner from './loading-spinner';
const PageLoading = () => {
	return (
		<div className='flex h-full w-full items-center justify-center'>
			<LoadingSpinner size={26} />
		</div>
	);
};
export default PageLoading;
</file>

<file path="src/components/ui/animated-tooltip.tsx">
'use client';
import {
	AnimatePresence,
	motion,
	useMotionValue,
	useSpring,
	useTransform,
} from 'motion/react';
import Image from 'next/image';
import { useState } from 'react';
export const AnimatedTooltip = ({
	items,
}: {
	items: {
		id: number;
		name: string;
		designation: string;
		image: string;
	}[];
}) => {
	const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);
	const springConfig = { stiffness: 100, damping: 5 };
	const x = useMotionValue(0);
	const rotate = useSpring(
		useTransform(x, [-100, 100], [-45, 45]),
		springConfig,
	);
	const translateX = useSpring(
		useTransform(x, [-100, 100], [-50, 50]),
		springConfig,
	);
	const handleMouseMove = (event: React.MouseEvent<HTMLDivElement>) => {
		const target = event.target as HTMLDivElement;
		const halfWidth = target.offsetWidth / 2;
		x.set(event.nativeEvent.offsetX - halfWidth);
	};
	return (
		<>
			{items.map((item, idx) => (
				<div
					className='group relative -mr-4'
					key={item.name}
					onMouseEnter={() => setHoveredIndex(item.id)}
					onMouseLeave={() => setHoveredIndex(null)}
				>
					<AnimatePresence mode='popLayout'>
						{hoveredIndex === item.id && (
							<motion.div
								initial={{ opacity: 0, y: 20, scale: 0.6 }}
								animate={{
									opacity: 1,
									y: 0,
									scale: 1,
									transition: {
										type: 'spring',
										stiffness: 260,
										damping: 10,
									},
								}}
								exit={{ opacity: 0, y: 20, scale: 0.6 }}
								style={{
									translateX: translateX,
									rotate: rotate,
									whiteSpace: 'nowrap',
								}}
								className='absolute -left-1/2 -top-16 z-50 flex translate-x-1/2 flex-col items-center justify-center rounded-md bg-foreground px-4 py-2 text-xs shadow-xl dark:shadow-none'
							>
								<div className='absolute inset-x-10 -bottom-px z-30 h-px w-[20%]' />
								<div className='absolute -bottom-px left-10 z-30 h-px w-[40%]' />
								<div className='relative z-30 font-bold text-background'>
									{item.name}
								</div>
								<div className='text-xs text-background'>
									{item.designation}
								</div>
							</motion.div>
						)}
					</AnimatePresence>
					<Image
						onMouseMove={handleMouseMove}
						height={100}
						width={100}
						src={item.image}
						alt={item.name}
						className='relative !m-0 size-10 rounded-full border-2 border-background object-cover object-top !p-0 transition duration-500 group-hover:z-30 group-hover:scale-105'
					/>
				</div>
			))}
		</>
	);
};
</file>

<file path="src/components/ui/avatar.tsx">
'use client';
import * as AvatarPrimitive from '@radix-ui/react-avatar';
import * as React from 'react';
import { cn } from '@/lib/core/utils';
const Avatar = React.forwardRef<
	React.ComponentRef<typeof AvatarPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
	<AvatarPrimitive.Root
		ref={ref}
		className={cn(
			'relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full',
			className,
		)}
		{...props}
	/>
));
Avatar.displayName = AvatarPrimitive.Root.displayName;
const AvatarImage = React.forwardRef<
	React.ComponentRef<typeof AvatarPrimitive.Image>,
	React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
	<AvatarPrimitive.Image
		ref={ref}
		className={cn('aspect-square h-full w-full', className)}
		{...props}
	/>
));
AvatarImage.displayName = AvatarPrimitive.Image.displayName;
const AvatarFallback = React.forwardRef<
	React.ComponentRef<typeof AvatarPrimitive.Fallback>,
	React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
	<AvatarPrimitive.Fallback
		ref={ref}
		className={cn(
			'flex h-full w-full items-center justify-center rounded-full bg-stone-100 dark:bg-stone-800',
			className,
		)}
		{...props}
	/>
));
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName;
export { Avatar, AvatarFallback, AvatarImage };
</file>

<file path="src/components/ui/card.tsx">
import * as React from 'react';
import { cn } from '@/lib/core/utils';
const Card = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div
		ref={ref}
		className={cn(
			'border rounded-lg border-border bg-card text-foreground shadow-sm dark:shadow-none',
			className,
		)}
		{...props}
	/>
));
Card.displayName = 'Card';
const CardHeader = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div
		ref={ref}
		className={cn('flex flex-col space-y-1.5 p-6', className)}
		{...props}
	/>
));
CardHeader.displayName = 'CardHeader';
type CardTitleProps = React.HTMLAttributes<HTMLHeadingElement> & {
	as?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
};
const CardTitle = React.forwardRef<HTMLHeadingElement, CardTitleProps>(
	({ className, as: Comp = 'h3', ...props }, ref) => {
		const Component = Comp;
		return (
			<Component
				ref={ref}
				className={cn(
					'text-2xl font-semibold leading-none tracking-tight',
					className,
				)}
				{...props}
			/>
		);
	},
);
CardTitle.displayName = 'CardTitle';
const CardDescription = React.forwardRef<
	HTMLParagraphElement,
	React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
	<p
		ref={ref}
		className={cn('text-sm text-muted-foreground', className)}
		{...props}
	/>
));
CardDescription.displayName = 'CardDescription';
const CardContent = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
));
CardContent.displayName = 'CardContent';
const CardFooter = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div
		ref={ref}
		className={cn('flex items-center p-6 pt-0', className)}
		{...props}
	/>
));
CardFooter.displayName = 'CardFooter';
export {
	Card,
	CardContent,
	CardDescription,
	CardFooter,
	CardHeader,
	CardTitle,
};
</file>

<file path="src/components/ui/form.tsx">
import { Slot } from '@radix-ui/react-slot';
import * as React from 'react';
import {
	Controller,
	type ControllerProps,
	type FieldPath,
	type FieldValues,
	FormProvider,
	useFormContext,
} from 'react-hook-form';
import { Label } from '@/components/ui/label';
import { cn } from '@/lib/core/utils';
import type * as LabelPrimitive from '@radix-ui/react-label';
const Form = FormProvider;
type FormFieldContextValue<
	TFieldValues extends FieldValues = FieldValues,
	TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
	name: TName;
};
const FormFieldContext = React.createContext<FormFieldContextValue>(
	{} as FormFieldContextValue,
);
const FormField = <
	TFieldValues extends FieldValues = FieldValues,
	TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
	...props
}: ControllerProps<TFieldValues, TName>) => {
	return (
		<FormFieldContext.Provider value={{ name: props.name }}>
			<Controller {...props} />
		</FormFieldContext.Provider>
	);
};
const useFormField = () => {
	const fieldContext = React.useContext(FormFieldContext);
	const itemContext = React.useContext(FormItemContext);
	const { getFieldState, formState } = useFormContext();
	const fieldState = getFieldState(fieldContext.name, formState);
	if (!fieldContext) {
		throw new Error('useFormField should be used within <FormField>');
	}
	const { id } = itemContext;
	return {
		id,
		name: fieldContext.name,
		formItemId: `${id}-form-item`,
		formDescriptionId: `${id}-form-item-description`,
		formMessageId: `${id}-form-item-message`,
		...fieldState,
	};
};
type FormItemContextValue = {
	id: string;
};
const FormItemContext = React.createContext<FormItemContextValue>(
	{} as FormItemContextValue,
);
const FormItem = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
	const id = React.useId();
	return (
		<FormItemContext.Provider value={{ id }}>
			<div ref={ref} className={cn('space-y-2', className)} {...props} />
		</FormItemContext.Provider>
	);
});
FormItem.displayName = 'FormItem';
const FormLabel = React.forwardRef<
	React.ComponentRef<typeof LabelPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
	const { error, formItemId, id } = useFormField();
	return (
		<Label
			ref={ref}
			id={`${id}-label`}
			className={cn(error && 'text-red-500 dark:text-red-900', className)}
			htmlFor={formItemId}
			{...props}
		/>
	);
});
FormLabel.displayName = 'FormLabel';
const FormControl = React.forwardRef<
	React.ComponentRef<typeof Slot>,
	React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
	const { error, formItemId, formDescriptionId, formMessageId, id } =
		useFormField();
	return (
		<Slot
			ref={ref}
			id={formItemId}
			aria-labelledby={`${id}-label`}
			aria-describedby={
				!error
					? `${formDescriptionId}`
					: `${formDescriptionId} ${formMessageId}`
			}
			aria-invalid={!!error}
			{...props}
		/>
	);
});
FormControl.displayName = 'FormControl';
const FormDescription = React.forwardRef<
	HTMLParagraphElement,
	React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
	const { formDescriptionId } = useFormField();
	return (
		<div
			ref={ref}
			id={formDescriptionId}
			className={cn(
				'text-sm text-stone-500 dark:text-stone-400',
				className,
			)}
			{...props}
		/>
	);
});
FormDescription.displayName = 'FormDescription';
const FormMessage = React.forwardRef<
	HTMLParagraphElement,
	React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
	const { error, formMessageId } = useFormField();
	const body = error ? String(error?.message) : children;
	if (!body) {
		return null;
	}
	return (
		<p
			ref={ref}
			id={formMessageId}
			className={cn(
				'text-xs text-red-500 dark:text-red-900 md:text-sm',
				className,
			)}
			{...props}
		>
			{body}
		</p>
	);
});
FormMessage.displayName = 'FormMessage';
export {
	Form,
	FormControl,
	FormDescription,
	FormField,
	FormItem,
	FormLabel,
	FormMessage,
	useFormField,
};
</file>

<file path="src/components/ui/input.tsx">
import { type AriaProps, validateAriaProps } from '@/lib/core/types/aria-utils';
import { cn } from '@/lib/core/utils';
import * as React from 'react';
type InputProps = React.InputHTMLAttributes<HTMLInputElement> & AriaProps;
const Input = React.forwardRef<HTMLInputElement, InputProps>(
	({ className, type, ...props }, ref) => {
		validateAriaProps(props, 'Input');
		return (
			<input
				type={type}
				className={cn(
					'border flex h-10 w-full rounded-md border-stone-200 bg-white px-3 py-2 text-sm ring-offset-white file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-stone-500 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-stone-950 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 dark:border-stone-800 dark:bg-stone-950 dark:ring-offset-stone-950 dark:placeholder:text-stone-400 dark:focus-visible:ring-stone-300',
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Input.displayName = 'Input';
export { Input };
</file>

<file path="src/components/ui/label.tsx">
'use client';
import * as LabelPrimitive from '@radix-ui/react-label';
import { cva, type VariantProps } from 'class-variance-authority';
import * as React from 'react';
import { cn } from '@/lib/core/utils';
const labelVariants = cva(
	'text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70',
);
const Label = React.forwardRef<
	React.ComponentRef<typeof LabelPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
		VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
	<LabelPrimitive.Root
		ref={ref}
		className={cn(labelVariants(), className)}
		{...props}
	/>
));
Label.displayName = LabelPrimitive.Root.displayName;
export { Label };
</file>

<file path="src/components/ui/link.tsx">
'use client';
import { type AriaProps, validateAriaProps } from '@/lib/core/types/aria-utils';
import NextLink, { type LinkProps as NextLinkProps } from 'next/link';
import type { ReactNode } from 'react';
import React, { useMemo } from 'react';
export type CustomLinkProps = NextLinkProps &
	AriaProps & {
		className?: string;
		newTab?: boolean;
		children: ReactNode;
		ref?: React.Ref<HTMLAnchorElement>;
	};
const Link = (props: CustomLinkProps) => {
	const {
		children,
		newTab,
		className,
		prefetch = false,
		ref,
		...rest
	} = props;
	validateAriaProps(rest, 'Link');
	const newTabProps = useMemo(() => {
		return newTab
			? {
					target: '_blank',
					rel: 'noopener noreferrer',
				}
			: {};
	}, [newTab]);
	return (
		<NextLink
			{...rest}
			{...newTabProps}
			prefetch={prefetch}
			className={className}
			ref={ref}
		>
			{children}
		</NextLink>
	);
};
Link.displayName = 'Link';
export default Link;
</file>

<file path="src/components/ui/logo.tsx">
'use client';
import Link from '@/components/ui/link';
import env from '@/env';
import { cn } from '@/lib/core/utils';
import { Comfortaa } from 'next/font/google';
import { usePathname } from 'next/navigation';
const comfortaa = Comfortaa({
	subsets: ['latin'],
	display: 'swap',
	variable: '--font-comfortaa',
});
interface LogoProps {
	textOnly?: boolean;
	style: 'gradient' | 'solid' | 'fullText';
	size?: `size-${number}` | `size-${string}`;
	className?: string;
}
const Logo = ({ textOnly = false, style, size, className }: LogoProps) => {
	const pathname = usePathname();
	if (pathname === '/' || textOnly) {
		return <LogoItem style={style} size={size} />;
	}
	return (
		<Link
			href='/'
			className={cn('flex items-center', className)}
			aria-label={`${env.NEXT_PUBLIC_APP_NAME}`}
		>
			<LogoItem style={style} size={size} />
		</Link>
	);
};
export default Logo;
const LogoItem = ({ style, size }: LogoProps) => {
	const getTextSizeClass = (
		logoSize?: `size-${number}` | `size-${string}`,
	) => {
		if (!logoSize) {
			return 'text-xl';
		}
		const sizeValue = parseInt(logoSize.replace('size-', ''), 10);
		if (isNaN(sizeValue)) {
			return 'text-xl';
		}
		if (sizeValue <= 6) {
			return 'text-sm';
		} else if (sizeValue <= 8) {
			return 'text-xl';
		} else if (sizeValue <= 12) {
			return 'text-2xl';
		} else {
			return 'text-3xl';
		}
	};
	const textSizeClass = getTextSizeClass(size);
	return (
		<span
			className={cn(
				comfortaa.className,
				'animate flex transition-colors duration-300 ease-in-out',
				style === 'gradient' &&
					'bg-gradient-to-tr from-muted-foreground to-background shadow-sm dark:shadow-none',
				style === 'solid' && 'bg-foreground text-background',
				style !== 'fullText' &&
					'aspect-square items-center justify-center rounded-full',
				size ? size : 'size-8',
			)}
		>
			<p
				className={cn(
					'font-bold',
					textSizeClass,
					style === 'fullText' && 'whitespace-nowrap text-lg',
				)}
			>
				{style !== 'fullText'
					? env.NEXT_PUBLIC_APP_NAME?.slice(0, 1)
					: env.NEXT_PUBLIC_APP_NAME}
			</p>
		</span>
	);
};
</file>

<file path="src/components/ui/nav-menu.tsx">
'use client';
import * as DropdownMenu from '@radix-ui/react-dropdown-menu';
import { useRouter } from 'next/navigation';
import type { ReactNode } from 'react';
type MenuItem =
	| {
			id: string;
			type: 'link';
			text: string;
			href: string;
			icon?: ReactNode;
	  }
	| {
			id: string;
			type: 'button';
			text: string;
			onClick: () => void;
			icon?: ReactNode;
	  };
interface NavMenuProps {
	trigger: ReactNode;
	items: MenuItem[];
}
const NavMenu = ({ trigger, items }: NavMenuProps) => {
	const router = useRouter();
	const handleItemClick = (item: MenuItem) => {
		if (item.type === 'link') {
			router.push(item.href);
		} else if (item.type === 'button') {
			item.onClick();
		}
	};
	return (
		<DropdownMenu.Root>
			<DropdownMenu.Trigger asChild>{trigger}</DropdownMenu.Trigger>
			<DropdownMenu.Portal>
				<DropdownMenu.Content
					className='z-50 min-w-[12rem] overflow-hidden rounded-md border border-border bg-popover p-1 text-popover-foreground shadow-md'
					sideOffset={5}
					align='end'
				>
					{items.map((item, index) => (
						<DropdownMenu.Item
							key={item.id}
							className='relative flex cursor-pointer select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50'
							onSelect={() => handleItemClick(item)}
						>
							{item.icon && (
								<span className='flex-shrink-0'>{item.icon}</span>
							)}
							<span>{item.text}</span>
						</DropdownMenu.Item>
					))}
				</DropdownMenu.Content>
			</DropdownMenu.Portal>
		</DropdownMenu.Root>
	);
};
export default NavMenu;
</file>

<file path="src/components/ui/select.tsx">
'use client';
import { type AriaProps, validateAriaProps } from '@/lib/core/types/aria-utils';
import { cn } from '@/lib/core/utils';
import * as SelectPrimitive from '@radix-ui/react-select';
import * as React from 'react';
import { LuCheck, LuChevronDown, LuChevronUp } from 'react-icons/lu';
const Select = SelectPrimitive.Root;
const SelectGroup = SelectPrimitive.Group;
const SelectValue = SelectPrimitive.Value as React.FC<
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Value> & AriaProps
>;
const SelectTrigger = React.forwardRef<
	React.ComponentRef<typeof SelectPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger> & {
		hideIcon?: boolean;
		isLoading?: boolean;
		variant?: 'default' | 'none';
	} & AriaProps
>(
	(
		{
			className,
			children,
			hideIcon: icon,
			isLoading = false,
			variant = 'default',
			...props
		},
		ref,
	) => {
		validateAriaProps(props, 'SelectTrigger');
		return (
			<SelectPrimitive.Trigger
				ref={ref}
				className={cn(
					'flex h-10 items-center justify-between text-sm disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
					variant === 'default' &&
						'border w-full rounded-md border-stone-200 bg-white px-3 py-2 ring-offset-white placeholder:text-stone-500 focus:outline-none focus:ring-2 focus:ring-stone-950 focus:ring-offset-2 dark:border-stone-800 dark:bg-stone-950 dark:ring-offset-stone-950 dark:placeholder:text-stone-400 dark:focus:ring-stone-300',
					variant === 'none' &&
						'w-fit border-none p-0 ring-0 ring-offset-0 focus:outline-none',
					className,
				)}
				{...props}
			>
				{children}
				{!icon && (
					<SelectPrimitive.Icon asChild>
						<LuChevronDown className='h-4 w-4 opacity-50' />
					</SelectPrimitive.Icon>
				)}
			</SelectPrimitive.Trigger>
		);
	},
);
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;
const SelectScrollUpButton = React.forwardRef<
	React.ComponentRef<typeof SelectPrimitive.ScrollUpButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollUpButton
		ref={ref}
		className={cn(
			'flex cursor-default items-center justify-center py-1',
			className,
		)}
		{...props}
	>
		<LuChevronUp className='h-4 w-4' />
	</SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;
const SelectScrollDownButton = React.forwardRef<
	React.ComponentRef<typeof SelectPrimitive.ScrollDownButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollDownButton
		ref={ref}
		className={cn(
			'flex cursor-default items-center justify-center py-1',
			className,
		)}
		{...props}
	>
		<LuChevronDown className='h-4 w-4' />
	</SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
	SelectPrimitive.ScrollDownButton.displayName;
interface SelectContentProps {
	highZIndex?: boolean;
}
const SelectContent = React.forwardRef<
	React.ComponentRef<typeof SelectPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content> &
		SelectContentProps &
		AriaProps
>(({ className, children, position = 'popper', highZIndex, ...props }, ref) => {
	validateAriaProps(props, 'SelectContent');
	return (
		<SelectPrimitive.Portal>
			<SelectPrimitive.Content
				ref={ref}
				className={cn(
					'border relative z-10 max-h-96 min-w-[8rem] overflow-hidden rounded-md border-stone-200 bg-white text-stone-950 shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 dark:border-stone-800 dark:bg-stone-950 dark:text-stone-50 dark:shadow-none',
					highZIndex && 'z-[9999]',
					position === 'popper' &&
						'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
					className,
				)}
				position={position}
				{...props}
			>
				<SelectScrollUpButton />
				<SelectPrimitive.Viewport
					className={cn(
						'p-1',
						position === 'popper' &&
							'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]',
					)}
				>
					{children}
				</SelectPrimitive.Viewport>
				<SelectScrollDownButton />
			</SelectPrimitive.Content>
		</SelectPrimitive.Portal>
	);
});
SelectContent.displayName = SelectPrimitive.Content.displayName;
const SelectLabel = React.forwardRef<
	React.ComponentRef<typeof SelectPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Label
		ref={ref}
		className={cn('py-1.5 pl-8 pr-2 text-sm font-semibold', className)}
		{...props}
	/>
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;
const SelectItem = React.forwardRef<
	React.ComponentRef<typeof SelectPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item> & AriaProps
>(({ className, children, ...props }, ref) => {
	validateAriaProps(props, 'SelectItem');
	return (
		<SelectPrimitive.Item
			ref={ref}
			className={cn(
				'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-stone-100 focus:text-stone-900 data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-stone-800 dark:focus:text-stone-50',
				className,
			)}
			{...props}
		>
			<span className='absolute left-2 flex h-3.5 w-3.5 items-center justify-center'>
				<SelectPrimitive.ItemIndicator>
					<LuCheck className='h-4 w-4' />
				</SelectPrimitive.ItemIndicator>
			</span>
			<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
		</SelectPrimitive.Item>
	);
});
SelectItem.displayName = SelectPrimitive.Item.displayName;
const SelectSeparator = React.forwardRef<
	React.ComponentRef<typeof SelectPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Separator
		ref={ref}
		className={cn(
			'-mx-1 my-1 h-px bg-stone-100 dark:bg-stone-800',
			className,
		)}
		{...props}
	/>
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;
export {
	Select,
	SelectContent,
	SelectGroup,
	SelectItem,
	SelectLabel,
	SelectScrollDownButton,
	SelectScrollUpButton,
	SelectSeparator,
	SelectTrigger,
	SelectValue,
};
</file>

<file path="src/components/ui/sonner.tsx">
'use client';
import { useMediaQuery } from '@/hooks';
import { useTheme } from 'next-themes';
import { Toaster as Sonner } from 'sonner';
type ToasterProps = React.ComponentProps<typeof Sonner>;
const Toaster = ({ ...props }: ToasterProps) => {
	const { theme = 'system' } = useTheme();
	const { isMobile } = useMediaQuery();
	return (
		<Sonner
			theme={theme as ToasterProps['theme']}
			className='toaster group'
			toastOptions={{
				classNames: {
					toast: 'group toast group-[.toaster]:bg-white group-[.toaster]:text-stone-950 group-[.toaster]:border-stone-200 group-[.toaster]:shadow-lg dark:shadow-none dark:group-[.toaster]:bg-stone-950 dark:group-[.toaster]:text-stone-50 dark:group-[.toaster]:border-stone-800',
					description:
						'group-[.toast]:text-stone-500 dark:group-[.toast]:text-stone-400',
					actionButton:
						'group-[.toast]:bg-stone-900 group-[.toast]:text-stone-50 dark:group-[.toast]:bg-stone-50 dark:group-[.toast]:text-stone-900',
					cancelButton:
						'group-[.toast]:bg-stone-100 group-[.toast]:text-stone-500 dark:group-[.toast]:bg-stone-800 dark:group-[.toast]:text-stone-400',
				},
			}}
			{...props}
			position={isMobile ? 'top-right' : 'bottom-right'}
			richColors={true}
		/>
	);
};
export { Toaster };
</file>

<file path="src/components/ui/textarea.tsx">
import { type AriaProps, validateAriaProps } from '@/lib/core/types/aria-utils';
import { cn } from '@/lib/core/utils';
import * as React from 'react';
type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement> &
	AriaProps;
const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
	({ className, ...props }, ref) => {
		validateAriaProps(props, 'Textarea');
		return (
			<textarea
				className={cn(
					'border flex min-h-[80px] w-full rounded-md border-stone-200 bg-white px-3 py-2 text-sm ring-offset-white placeholder:text-stone-500 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-stone-950 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 dark:border-stone-800 dark:bg-stone-950 dark:ring-offset-stone-950 dark:placeholder:text-stone-400 dark:focus-visible:ring-stone-300',
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Textarea.displayName = 'Textarea';
export { Textarea };
</file>

<file path="src/components/ui/tooltip.tsx">
'use client';
import * as TooltipPrimitive from '@radix-ui/react-tooltip';
import * as React from 'react';
import { useMediaQuery } from '@/hooks';
import { cn } from '@/lib/core/utils';
const TooltipProvider = TooltipPrimitive.Provider;
const TooltipRoot = TooltipPrimitive.Root;
const TooltipTrigger = TooltipPrimitive.Trigger;
const TooltipContent = React.forwardRef<
	React.ComponentRef<typeof TooltipPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
	<TooltipPrimitive.Content
		ref={ref}
		sideOffset={sideOffset}
		className={cn(
			'border z-10 overflow-hidden rounded-md border-stone-200 bg-white px-3 py-1.5 text-sm text-stone-950 shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 dark:border-stone-800 dark:bg-stone-950 dark:text-stone-50 dark:shadow-none',
			className,
		)}
		{...props}
	/>
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;
interface TooltipProps {
	trigger: React.ReactNode;
	content: React.ReactNode;
	contentClassName?: string;
	side?: 'top' | 'right' | 'bottom' | 'left';
	sideOffset?: number;
}
const Tooltip = React.forwardRef<
	React.ComponentRef<typeof TooltipPrimitive.Content>,
	TooltipProps
>(({ trigger, content, contentClassName, side, sideOffset = 4 }, ref) => {
	const { isMobile } = useMediaQuery();
	if (isMobile) {
		return <>{trigger}</>;
	}
	return (
		<TooltipRoot>
			<TooltipTrigger asChild>{trigger}</TooltipTrigger>
			<TooltipContent
				ref={ref}
				className={contentClassName}
				side={side}
				sideOffset={sideOffset}
			>
				{content}
			</TooltipContent>
		</TooltipRoot>
	);
});
Tooltip.displayName = 'Tooltip';
export {
	Tooltip,
	TooltipContent,
	TooltipProvider,
	TooltipRoot,
	TooltipTrigger,
};
</file>

<file path="src/components/suspense-wrapper.tsx">
import { Suspense, type ReactNode } from 'react';
import LoadingSpinner from './ui/loading/loading-spinner';
import PageLoading from './ui/loading/page-loading';
interface SuspenseWrapperProps {
	type?: 'component' | 'page';
	children: ReactNode;
	loadingSize?: number;
	skeleton?: ReactNode;
}
const SuspenseWrapper = ({
	children,
	loadingSize = 16,
	type,
	skeleton,
}: Readonly<SuspenseWrapperProps>) => {
	return (
		<Suspense
			fallback={
				type === 'page' ? (
					<PageLoading />
				) : skeleton ? (
					skeleton
				) : (
					<LoadingSpinner size={loadingSize || 16} />
				)
			}
		>
			{children}
		</Suspense>
	);
};
export default SuspenseWrapper;
</file>

<file path="src/features/settings/api/services/user.service.ts">
import tryCatch from '@/lib/core/utils/try-catch';
import { TRPCThrow } from '@/trpc/server/api/site/errors';
import { site } from '@/trpc/server/site';
import type {
	DeleteAccountFormInput,
	UpdateAliasFormInput,
} from '../../lib/validation/user.z';
export const updateUserAlias = async (
	userId: string,
	input: UpdateAliasFormInput,
) => {
	const { alias } = input;
	const { data: existingUser, error: findError } = await tryCatch(
		site.user.findFirst({
			where: {
				alias,
				NOT: {
					id: userId,
				},
			},
		}),
	);
	if (findError) {
		console.error(
			'updateUserAlias: A non-TRPC, unexpected error occurred while checking for existing alias',
			findError,
			{ userId, alias },
		);
		TRPCThrow.internalError(
			'An unexpected error occurred. Please try again.',
		);
	}
	if (existingUser) {
		TRPCThrow.conflict(
			'This alias is already taken. Please choose another one.',
		);
	}
	const { data, error } = await tryCatch(
		site.user.update({
			where: { id: userId },
			data: { alias },
			select: { alias: true },
		}),
	);
	if (error) {
		console.error(
			'updateUserAlias: A non-TRPC, unexpected error occurred',
			error,
			{ userId, alias },
		);
		TRPCThrow.internalError(
			'An unexpected error occurred while updating your alias. Please try again.',
		);
	}
	return {
		success: true,
		message: 'Your alias has been successfully updated.',
		alias: data!.alias,
	};
};
export const checkAlias = async (alias: string, userId: string) => {
	if (alias.length < 5) {
		return { available: false, message: 'Alias is too short.' };
	}
	const { data: user, error } = await tryCatch(
		site.user.findFirst({
			where: {
				alias: alias,
				id: {
					not: userId,
				},
			},
		}),
	);
	if (error) {
		console.error(
			'checkAliasAvailability: A non-TRPC, unexpected error occurred',
			error,
			{ alias },
		);
		TRPCThrow.internalError(
			'An unexpected error occurred while checking alias availability.',
		);
	}
	if (user) {
		return { available: false, message: 'Alias is already taken.' };
	}
	return { available: true, message: 'Alias is available.' };
};
export const deleteUserAccount = async (
	userId: string,
	input: DeleteAccountFormInput,
) => {
	const { data: user, error: findError } = await tryCatch(
		site.user.findUnique({
			where: { id: userId },
			select: { email: true },
		}),
	);
	if (findError) {
		console.error(
			'deleteUserAccount: A non-TRPC, unexpected error occurred while finding user',
			findError,
			{ userId },
		);
		TRPCThrow.internalError(
			'An unexpected error occurred while deleting your account. Please try again or contact support if the issue persists.',
		);
	}
	if (!user) {
		TRPCThrow.notFound(
			'Cannot delete account: User account not found. Please log out and log back in.',
		);
	}
	if (user?.email?.toLowerCase() !== input.email.toLowerCase()) {
		TRPCThrow.badRequest(
			'The email you entered does not match your account email.',
		);
	}
	const { error } = await tryCatch(
		site.user.delete({
			where: { id: userId },
		}),
	);
	if (error) {
		console.error(
			'deleteUserAccount: A non-TRPC, unexpected error occurred',
			error,
			{ userId },
		);
		TRPCThrow.internalError(
			'An unexpected error occurred while deleting your account. Please try again or contact support if the issue persists.',
		);
	}
	return {
		success: true,
		message: 'Your account has been successfully deleted',
	};
};
export const checkUserOnboarding = async (userId: string) => {
	const { data, error } = await tryCatch(
		site.user.findUnique({
			where: {
				id: userId,
			},
			select: {
				onboardingCompleted: true,
			},
		}),
	);
	if (error) {
		console.error(
			'checkUserOnboarding: A non-TRPC, unexpected error occurred',
			error,
			{ userId },
		);
		TRPCThrow.internalError(
			'An unexpected error occurred while checking your onboarding status. Please refresh the page and try again.',
		);
	}
	if (!data) {
		return {
			success: true,
			isComplete: false,
		};
	}
	return {
		success: true,
		isComplete: data.onboardingCompleted ?? false,
	};
};
export const updateUserOnboarding = async (
	userId: string,
	complete: boolean,
) => {
	const { data, error } = await tryCatch(
		site.user.update({
			where: {
				id: userId,
			},
			data: {
				onboardingCompleted: complete,
				updatedAt: new Date(),
			},
			select: {
				onboardingCompleted: true,
			},
		}),
	);
	if (error) {
		console.error(
			'updateUserOnboarding: A non-TRPC, unexpected error occurred',
			error,
			{ userId, complete },
		);
		TRPCThrow.internalError(
			'An unexpected error occurred while updating your onboarding status. Please try again.',
		);
	}
	if (!data) {
		TRPCThrow.notFound(
			'Cannot update onboarding: User account not found. Please log out and log back in.',
		);
	}
	return {
		success: true,
		complete: data!.onboardingCompleted,
	};
};
</file>

<file path="src/features/settings/api/index.ts">
import { createTRPCRouter } from '@/trpc/server/api/site/trpc';
import { generalRouter } from './user';
export const settingsRouter = createTRPCRouter({
	general: generalRouter,
});
</file>

<file path="src/features/settings/api/user.ts">
import {
	createTRPCRouter,
	protectedProcedure,
} from '@/trpc/server/api/site/trpc';
import {
	CheckAliasSchema,
	DeleteAccountFormSchema,
	UpdateAliasFormSchema,
	UpdateOnboardingSchema,
} from '../lib/validation/user.z';
import {
	checkAlias as checkAliasAvailability,
	checkUserOnboarding,
	deleteUserAccount,
	updateUserAlias,
	updateUserOnboarding,
} from './services/user.service';
const updateAlias = protectedProcedure
	.input(UpdateAliasFormSchema)
	.mutation(async ({ ctx, input }) => {
		return updateUserAlias(ctx.session.user.id, input);
	});
const checkAlias = protectedProcedure
	.input(CheckAliasSchema)
	.query(async ({ ctx, input }) => {
		return checkAliasAvailability(input.alias, ctx.session.user.id);
	});
const deleteAccount = protectedProcedure
	.input(DeleteAccountFormSchema)
	.mutation(async ({ ctx, input }) => {
		return deleteUserAccount(ctx.session.user.id, input);
	});
const checkOnboarding = protectedProcedure.query(async ({ ctx }) => {
	return checkUserOnboarding(ctx.session.user.id);
});
const updateOnboarding = protectedProcedure
	.input(UpdateOnboardingSchema)
	.mutation(async ({ ctx, input }) => {
		return updateUserOnboarding(ctx.session.user.id, input.complete);
	});
export const generalRouter = createTRPCRouter({
	updateAlias,
	checkAlias,
	deleteAccount,
	checkOnboarding,
	updateOnboarding,
});
</file>

<file path="src/features/settings/components/modals/delete-account-modal.tsx">
'use client';
import {
	Form,
	FormControl,
	FormDescription,
	FormField,
	FormItem,
	FormMessage,
} from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { DeleteAccountFormSchema } from '@/features/settings/lib/validation/user.z';
import { createFormErrorHandler } from '@/hooks/useHandleFormError';
import {
	handleTRPCError,
	handleTRPCSuccess,
} from '@/lib/core/errors/error-handler';
import tryCatch from '@/lib/core/utils/try-catch';
import { ModalFooterActions } from '@/modals/modal-footer-actions';
import ModalLayout from '@/modals/modal-layout';
import { api } from '@/trpc/react';
import { useModalStore } from '@/zustand/ui/useModalStore';
import { zodResolver } from '@hookform/resolvers/zod';
import { signOut, useSession } from 'next-auth/react';
import React, { useCallback, useState } from 'react';
import { useForm } from 'react-hook-form';
import type { z } from 'zod';
const DeleteAccountModal: React.FC = () => {
	const { data: session } = useSession();
	const { hide } = useModalStore();
	const [isDeleting, setIsDeleting] = useState(false);
	const form = useForm<z.infer<typeof DeleteAccountFormSchema>>({
		resolver: zodResolver(DeleteAccountFormSchema),
		defaultValues: { delete: '', email: '' },
		mode: 'onSubmit',
	});
	const deleteAccountMutation =
		api.settings.general.deleteAccount.useMutation({
			onMutate: () => setIsDeleting(true),
			onSettled: () => setIsDeleting(false),
		});
	const handleSignOut = useCallback(async () => {
		const { error } = await tryCatch(signOut({ callbackUrl: '/' }));
		if (error) {
			console.error('Sign out failed', error);
			handleTRPCError(
				error,
				'Unable to sign out. Please close the browser.',
			);
		}
	}, []);
	const onSubmit = useCallback(
		async (values: z.infer<typeof DeleteAccountFormSchema>) => {
			if (isDeleting) return;
			if (
				values.email.toLowerCase() !==
				session?.user?.email?.toLowerCase()
			) {
				handleTRPCError(
					new Error('Email does not match your account email'),
				);
				return;
			}
			const { data: result, error } = await tryCatch(
				deleteAccountMutation.mutateAsync(values),
			);
			if (error) {
				handleTRPCError(error, 'Failed to delete account');
				return;
			}
			if (result) {
				handleTRPCSuccess('Account deleted successfully!', result);
				hide();
				await handleSignOut();
			}
		},
		[
			deleteAccountMutation,
			handleSignOut,
			isDeleting,
			session?.user?.email,
			hide,
		],
	);
	const formErrorHandler =
		createFormErrorHandler<z.infer<typeof DeleteAccountFormSchema>>();
	if (!session?.user) return null;
	const handleSubmit = () => {
		void form.handleSubmit(onSubmit, formErrorHandler)();
	};
	const footerActions = (
		<ModalFooterActions
			actions={[
				{
					label: 'Cancel',
					onClick: () => hide(),
					variant: 'none',
					disabled: isDeleting,
					'aria-label': 'Cancel and close modal',
					priority: 'secondary',
				},
				{
					label: 'Delete Account',
					onClick: handleSubmit,
					variant: 'destructive',
					disabled: isDeleting,
					loading: isDeleting,
					'aria-label': 'Delete account permanently',
					priority: 'primary',
				},
			]}
		/>
	);
	return (
		<ModalLayout
			title='Delete Account'
			description='This action is irreversible. Confirm your account deletion by typing "confirm delete account" and entering your account email.'
			displayImage={{
				type: 'image',
				src: session?.user?.image || '',
				alt:
					(session?.user?.name ?? 'Avatar').replaceAll(' ', '') ||
					'Avatar',
			}}
			footer={footerActions}
		>
			<Form {...form}>
				<form onSubmit={(e) => e.preventDefault()}>
					<div className='flex flex-col space-y-4 p-4 text-left sm:px-20 md:px-14'>
						<FormField
							control={form.control}
							name='delete'
							render={({ field }) => (
								<FormItem className='space-y-1'>
									<FormDescription className='text-pretty text-left text-xs tracking-normal sm:text-sm'>
										Please type{' '}
										<code className='text-normal py-.5 rounded-sm bg-muted px-1 font-semibold tracking-tighter'>
											confirm delete account
										</code>
									</FormDescription>
									<FormControl>
										<Input
											aria-label='Delete Account'
											type='text'
											{...field}
											autoComplete='off'
											autoFocus
											disabled={isDeleting}
											aria-describedby='delete-account-description'
											aria-invalid={
												!!form.formState.errors.delete
											}
										/>
									</FormControl>
									<FormMessage />
								</FormItem>
							)}
						/>
						<FormField
							control={form.control}
							name='email'
							render={({ field }) => (
								<FormItem className='space-y-1'>
									<FormDescription className='text-pretty text-left text-xs tracking-normal sm:text-sm'>
										Please enter your{' '}
										<code className='text-normal py-.5 rounded-sm bg-muted px-1 font-semibold tracking-tighter'>
											account email
										</code>
									</FormDescription>
									<FormControl>
										<Input
											aria-label='Email'
											type='email'
											{...field}
											autoComplete='email'
											disabled={isDeleting}
											aria-describedby='email-confirmation-description'
											aria-invalid={
												!!form.formState.errors.email
											}
										/>
									</FormControl>
									<FormMessage />
								</FormItem>
							)}
						/>
					</div>
				</form>
			</Form>
		</ModalLayout>
	);
};
export default React.memo(DeleteAccountModal);
</file>

<file path="src/features/settings/components/profile-settings-layout.tsx">
import React from 'react';
import ListItem from '../../../components/layouts/list-item';
interface ProfileSettingsLayoutProps {
	children: React.ReactNode;
}
const ProfileSettingsLayout = (props: ProfileSettingsLayoutProps) => {
	return <ListItem>{props.children}</ListItem>;
};
export default ProfileSettingsLayout;
</file>

<file path="src/features/settings/components/profile-settings-section.tsx">
import type { ProfileSettingsSectionProps } from '../lib/types';
const ProfileSettingsSection = (props: ProfileSettingsSectionProps) => {
	const { title, description, children } = props;
	return (
		<div className='flex flex-col space-y-4'>
			<div className='flex flex-col space-y-1'>
				<h1 className='overflow-hidden truncate font-medium'>
					{title}
				</h1>
				<p className='text-xs text-muted-foreground'>{description}</p>
			</div>
			{children}
		</div>
	);
};
export default ProfileSettingsSection;
</file>

<file path="src/features/settings/components/settings-header-action.tsx">
'use client';
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from '@/components/ui/select';
import { SettingsRoutes, type SettingsRoutesType } from '@/features/settings/lib/types';
import { formatEnumToTitleCase } from '@/lib/core/utils';
import { usePathname, useRouter } from 'next/navigation';
import { useTransition } from 'react';
const SettingsAction = () => {
	const pathname = usePathname();
	const router = useRouter();
	const [isPending, startTransition] = useTransition();
	const getCurrentRoute = (): SettingsRoutesType => {
		if (pathname === '/settings') return SettingsRoutes.General;
		const routeSegment = pathname.replace('/settings/', '');
		const matchedRoute = Object.values(SettingsRoutes).find(
			(route) => route === routeSegment,
		);
		return matchedRoute ?? SettingsRoutes.General;
	};
	const currentRoute = getCurrentRoute();
	const handleRouteChange = (value: string) => {
		startTransition(() => {
			const route = value as SettingsRoutesType;
			if (route === SettingsRoutes.General) {
				router.push('/settings');
			} else {
				router.push(`/settings/${route}`);
			}
		});
	};
	return (
		<>
			<Select
				value={currentRoute}
				onValueChange={handleRouteChange}
				disabled={isPending}
			>
				<SelectTrigger
					variant='none'
					aria-label='Select a category'
					disabled={isPending}
				>
					<SelectValue
						placeholder='Select a category'
						aria-label='Category Values'
					/>
				</SelectTrigger>
				<SelectContent highZIndex aria-label='Category Options'>
					{Object.values(SettingsRoutes).map((category) => (
						<SelectItem
							key={category}
							value={category}
							aria-label={category}
						>
							{formatEnumToTitleCase(category)}
						</SelectItem>
					))}
				</SelectContent>
			</Select>
		</>
	);
};
export default SettingsAction;
</file>

<file path="src/features/settings/components/settings-section.tsx">
import ListItem from '@/components/layouts/list-item';
import type { ProfileSettingsSectionProps } from '../lib/types';
const SettingsSection = ({
	title,
	description,
	children,
}: ProfileSettingsSectionProps) => {
	return (
		<ListItem>
			<div className='flex h-full w-full flex-col'>
				<h3 className='text-lg font-semibold'>{title}</h3>
				<p className='text-sm text-muted-foreground'>{description}</p>
			</div>
			<div className='w-full'>{children}</div>
		</ListItem>
	);
};
export default SettingsSection;
</file>

<file path="src/features/settings/lib/types/enums.ts">
export const SettingsRoutes = {
	General: 'GENERAL',
} as const;
export type SettingsRoutesType = typeof SettingsRoutes[keyof typeof SettingsRoutes];
</file>

<file path="src/features/settings/lib/types/index.ts">
export * from './enums';
export type * from './settings';
</file>

<file path="src/features/settings/lib/types/settings.d.ts">
export interface ProfileSettingsSectionProps {
	title: string;
	description: string;
	children: React.ReactNode;
}
</file>

<file path="src/features/settings/lib/validation/index.ts">
export * from './user.z';
</file>

<file path="src/features/settings/lib/validation/user.z.ts">
import * as z from 'zod';
export const DeleteAccountFormSchema = z.object({
	delete: z
		.string()
		.min(1, 'Confirmation text is required')
		.trim()
		.refine((value) => value.toLowerCase() === 'confirm delete account', {
			message: 'Please type exactly "confirm delete account"',
		}),
	email: z.preprocess(
		(val) => (typeof val === 'string' ? val.trim() : val),
		z.email(),
	),
});
export const UpdateProfileFormSchema = z.object({
	name: z
		.string()
		.max(100, 'Name must be less than 100 characters')
		.trim()
		.optional(),
});
export const UpdateAliasFormSchema = z.object({
	alias: z
		.string()
		.min(5, 'Alias must be at least 5 characters')
		.max(30, 'Alias cannot exceed 30 characters')
		.regex(
			/^[a-zA-Z0-9_.-]+$/,
			'Alias can only contain letters, numbers, underscores, periods, and hyphens',
		)
		.trim(),
});
export const CheckAliasSchema = z.object({
	alias: z.string(),
});
export const UpdateOnboardingSchema = z.object({
	complete: z.boolean(),
});
export type DeleteAccountFormInput = z.infer<typeof DeleteAccountFormSchema>;
export type UpdateProfileFormInput = z.infer<typeof UpdateProfileFormSchema>;
export type UpdateAliasFormInput = z.infer<typeof UpdateAliasFormSchema>;
export type CheckAliasInput = z.infer<typeof CheckAliasSchema>;
export type UpdateOnboardingInput = z.infer<typeof UpdateOnboardingSchema>;
</file>

<file path="src/features/settings/pages/general/sections/delete-account.tsx">
'use client';
import { Button } from '@/components/ui/button';
import { useModals } from '@/hooks/useModals';
const DeleteAccount = () => {
	const modals = useModals();
	return (
		<Button
			className='w-fit'
			onClick={() => modals.show.deleteAccount({})}
			variant='destructive'
			text='Confirm Delete Account'
			aria-label='Delete Account'
		/>
	);
};
export default DeleteAccount;
</file>

<file path="src/features/settings/pages/general/sections/theme.tsx">
'use client';
import { useTheme } from 'next-themes';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/core/utils';
export default function Theme() {
	const { setTheme, theme } = useTheme();
	return (
		<div className='flex flex-row'>
			<Button
				className={cn(
					'rounded-r-none border-r-0',
					theme === 'system' && 'pointer-events-none',
				)}
				variant={theme === 'system' ? 'default' : 'outline'}
				size='sm'
				onClick={() => setTheme('system')}
				text='System'
				aria-label='System Theme'
			/>
			<Button
				className={cn(
					'rounded-l-none rounded-r-none',
					theme === 'dark' && 'pointer-events-none',
				)}
				variant={theme === 'dark' ? 'default' : 'outline'}
				size='sm'
				onClick={() => setTheme('dark')}
				text='Dark'
				aria-label='Dark Theme'
			/>
			<Button
				className={cn(
					'rounded-l-none border-l-0',
					theme === 'light' && 'pointer-events-none',
				)}
				variant={theme === 'light' ? 'default' : 'outline'}
				size='sm'
				onClick={() => setTheme('light')}
				text='Light'
				aria-label='Light Theme'
			/>
		</div>
	);
}
</file>

<file path="src/features/settings/pages/general/sections/update-alias.tsx">
const UpdateAlias = () => {
	return <div>UpdateAlias</div>;
};
export default UpdateAlias;
</file>

<file path="src/features/settings/pages/general/index.tsx">
import SettingsSection from '@/features/settings/components/settings-section';
import DeleteAccount from './sections/delete-account';
import Theme from './sections/theme';
const GeneralSettings = () => {
	return (
		<>
			{
}
			<SettingsSection
				title='Dark Mode'
				description='Change your theme.'
				children={<Theme />}
			/>
			<SettingsSection
				title='Delete Account'
				description='Delete your account. This action is irreversible.'
				children={<DeleteAccount />}
			/>
		</>
	);
};
export default GeneralSettings;
</file>

<file path="src/features/settings/header-actions.ts">
import { lazy } from 'react';
import { createHeaderActionDefinition } from '@/lib/ui/header-actions';
export const settingsPage = createHeaderActionDefinition({
	Component: lazy(() => import('./components/settings-header-action')),
	config: {
		routeMatcher: '/settings',
	},
});
</file>

<file path="src/features/settings/modals.ts">
import { lazy } from 'react';
import { createModalDefinition } from '@/lib/ui/modals';
export const deleteAccount = createModalDefinition({
	Component: lazy(() => import('./components/modals/delete-account-modal')),
	defaultConfig: {
		size: 'md',
		preventEscapeClose: true,
		title: 'Delete Account',
		description: 'Confirm account deletion',
	},
});
</file>

<file path="src/features/user-notes/api/services/user-notes.service.ts">
import tryCatch from '@/lib/core/utils/try-catch';
import { TRPCThrow } from '@/trpc/server/api/site/errors';
import { site } from '@/trpc/server/site';
import type { UpdateNoteInput } from '../../lib/validation/user-notes.z';
export const getNote = async (userId: string) => {
	const { data, error } = await tryCatch(
		site.user.findUnique({
			where: { id: userId },
			select: { note: true },
		})
	);
	if (error) {
		console.error(
			'getNote: An unexpected error occurred while fetching user note',
			error,
			{ userId }
		);
		TRPCThrow.internalError(
			'An unexpected error occurred while fetching your note. Please try again.'
		);
	}
	if (!data) {
		TRPCThrow.notFound('User not found.');
	}
	return {
		success: true,
		note: data!.note ?? '',
	};
};
/**
 * Updates the note for a specific user
 */
export const updateNote = async (userId: string, input: UpdateNoteInput) => {
	const { note } = input;
	const { data, error } = await tryCatch(
		site.user.update({
			where: { id: userId },
			data: { note },
			select: { note: true },
		})
	);
	if (error) {
		console.error(
			'updateNote: An unexpected error occurred while updating user note',
			error,
			{ userId }
		);
		TRPCThrow.internalError(
			'An unexpected error occurred while updating your note. Please try again.'
		);
	}
	if (!data) {
		TRPCThrow.notFound('User not found.');
	}
	return {
		success: true,
		message: 'Your note has been successfully saved.',
		note: data!.note,
	};
};
</file>

<file path="src/features/user-notes/api/index.ts">
import { createTRPCRouter } from '@/trpc/server/api/site/trpc';
import { userNotesRouter } from './user-notes';
export const userNotesFeatureRouter = createTRPCRouter({
	main: userNotesRouter,
});
</file>

<file path="src/features/user-notes/api/user-notes.ts">
import { createTRPCRouter, protectedProcedure } from '@/trpc/server/api/site/trpc';
import { UpdateNoteSchema } from '../lib/validation/user-notes.z';
import * as userNotesService from './services/user-notes.service';
export const userNotesRouter = createTRPCRouter({
	getNote: protectedProcedure.query(async ({ ctx }) => {
		const result = await userNotesService.getNote(ctx.session.user.id);
		return result;
	}),
	updateNote: protectedProcedure
		.input(UpdateNoteSchema)
		.mutation(async ({ input, ctx }) => {
			const result = await userNotesService.updateNote(
				ctx.session.user.id,
				input
			);
			return result;
		}),
});
</file>

<file path="src/features/user-notes/lib/types/index.ts">
export interface ExampleUserNotesType {
	id: string;
	name: string;
}
export type {};
</file>

<file path="src/features/user-notes/lib/validation/user-notes.z.ts">
import * as z from 'zod';
export const UpdateNoteSchema = z.object({
	note: z
		.string()
		.max(5000, 'Note must be less than 5000 characters')
		.trim(),
});
export type UpdateNoteInput = z.infer<typeof UpdateNoteSchema>;
</file>

<file path="src/features/user-notes/pages/index.tsx">
'use client';
import { Button } from '@/components/ui/button';
import {
	Form,
	FormControl,
	FormField,
	FormItem,
	FormMessage,
} from '@/components/ui/form';
import { Textarea } from '@/components/ui/textarea';
import { UpdateNoteSchema } from '@/features/user-notes/lib/validation/user-notes.z';
import { createFormErrorHandler } from '@/hooks/useHandleFormError';
import {
	handleTRPCError,
	handleTRPCSuccess,
} from '@/lib/core/errors/error-handler';
import tryCatch from '@/lib/core/utils/try-catch';
import { api } from '@/trpc/react';
import { zodResolver } from '@hookform/resolvers/zod';
import { useCallback, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import type { z } from 'zod';
const UserNotesPage = () => {
	const { data: noteData, isLoading: isLoadingNote } =
		api.userNotes.main.getNote.useQuery(undefined, {
			refetchOnWindowFocus: false,
		});
	const form = useForm<z.infer<typeof UpdateNoteSchema>>({
		resolver: zodResolver(UpdateNoteSchema),
		defaultValues: {
			note: '',
		},
		mode: 'onSubmit',
	});
	useEffect(() => {
		if (noteData?.note !== undefined) {
			form.reset({ note: noteData.note });
		}
	}, [noteData, form]);
	const updateNoteMutation = api.userNotes.main.updateNote.useMutation();
	const onSubmit = useCallback(
		async (values: z.infer<typeof UpdateNoteSchema>) => {
			const { data: result, error } = await tryCatch(
				updateNoteMutation.mutateAsync(values),
			);
			if (error) {
				handleTRPCError(error, 'Failed to save note');
				return;
			}
			if (result) {
				handleTRPCSuccess('Note saved successfully!', result);
			}
		},
		[updateNoteMutation],
	);
	const formErrorHandler =
		createFormErrorHandler<z.infer<typeof UpdateNoteSchema>>();
	const handleSubmit = () => {
		void form.handleSubmit(onSubmit, formErrorHandler)();
	};
	const isLoading = updateNoteMutation.isPending;
	return (
		<div className='mx-auto max-w-4xl space-y-6 p-6'>
			<div className='space-y-2'>
				<h1 className='text-3xl font-bold'>My Notes</h1>
				<p className='text-sm text-muted-foreground'>
					Write and save your private notes. Maximum 5000 characters.
				</p>
			</div>
			{isLoadingNote ? (
				<div className='flex items-center justify-center py-12'>
					<p className='text-muted-foreground'>
						Loading your note...
					</p>
				</div>
			) : (
				<Form {...form}>
					<form
						onSubmit={(e) => e.preventDefault()}
						className='space-y-4'
					>
						<FormField
							control={form.control}
							name='note'
							render={({ field }) => (
								<FormItem>
									<FormControl>
										<Textarea
											{...field}
											placeholder='Start writing your note here...'
											className='min-h-[400px] resize-y'
											disabled={isLoading}
											aria-label='Note content'
										/>
									</FormControl>
									<FormMessage />
								</FormItem>
							)}
						/>
						<div className='flex justify-end'>
							<Button
								type='button'
								onClick={handleSubmit}
								loading={isLoading}
								disabled={isLoading}
								aria-label='Save note'
							>
								Save Note
							</Button>
						</div>
					</form>
				</Form>
			)}
		</div>
	);
};
export default UserNotesPage;
</file>

<file path="src/hooks/index.ts">
export * from './useHandleFormError';
export * from './useKeyboardShortcut';
export * from './useMediaQuery';
export * from './useModals';
</file>

<file path="src/hooks/useHandleFormError.ts">
import type { FieldErrors, FieldValues } from 'react-hook-form';
import { toast } from 'sonner';
export function createFormErrorHandler<T extends FieldValues>() {
	return (errors: FieldErrors<T>) => {
		const error = Object.values(errors).find((e) => e?.message);
		if (error && typeof error.message === 'string') {
			toast.error(error.message);
		} else {
			toast.error('An unexpected form error occurred. Please try again.');
		}
	};
}
</file>

<file path="src/hooks/useKeyboardShortcut.ts">
import { useEffect, useRef } from 'react';
interface UseKeyboardShortcutOptions {
	enabled?: boolean;
	preventDefault?: boolean;
	stopPropagation?: boolean;
}
export const useKeyboardShortcut = (
	key: string | string[],
	callback: (e: KeyboardEvent) => void,
	options: UseKeyboardShortcutOptions = {},
) => {
	const {
		enabled = true,
		preventDefault = true,
		stopPropagation = true,
	} = options;
	const callbackRef = useRef(callback);
	callbackRef.current = callback;
	useEffect(() => {
		if (!enabled) return;
		const handleKeyDown = (event: KeyboardEvent) => {
			const target = event.target as HTMLElement;
			const isTyping =
				target.tagName === 'INPUT' ||
				target.tagName === 'TEXTAREA' ||
				target.contentEditable === 'true' ||
				target.hasAttribute('data-cmdk-input');
			if (isTyping) return;
			const keys = Array.isArray(key) ? key : [key];
			if (keys.includes(event.key)) {
				if (preventDefault) event.preventDefault();
				if (stopPropagation) event.stopPropagation();
				callbackRef.current(event);
			}
		};
		document.addEventListener('keydown', handleKeyDown);
		return () => document.removeEventListener('keydown', handleKeyDown);
	}, [key, enabled, preventDefault, stopPropagation]);
};
export const formatShortcut = (key: string | string[]): string => {
	const firstKey = Array.isArray(key) ? key[0] : key;
	if (!firstKey) return '';
	if (firstKey === ' ') return 'Space';
	if (firstKey === 'Enter') return '‚èé';
	if (firstKey === 'Escape') return 'Esc';
	if (firstKey === 'ArrowUp') return '‚Üë';
	if (firstKey === 'ArrowDown') return '‚Üì';
	if (firstKey === 'ArrowLeft') return '‚Üê';
	if (firstKey === 'ArrowRight') return '‚Üí';
	if (firstKey.length === 1) {
		return firstKey.toUpperCase();
	}
	return firstKey;
};
</file>

<file path="src/hooks/useMediaQuery.ts">
import { useEffect, useState } from 'react';
const getDevice = (): 'mobile' | 'tablet' | 'desktop' | null => {
	if (typeof window === 'undefined') return null;
	return window.matchMedia('(min-width: 1024px)').matches
		? 'desktop'
		: window.matchMedia('(min-width: 769px)').matches
			? 'tablet'
			: 'mobile';
};
const getDimensions = () => {
	if (typeof window === 'undefined') return null;
	return { width: window.innerWidth, height: window.innerHeight };
};
export const useMediaQuery = () => {
	const [device, setDevice] = useState<
		'mobile' | 'tablet' | 'desktop' | null
	>(getDevice());
	const [dimensions, setDimensions] = useState<{
		width: number;
		height: number;
	} | null>(getDimensions());
	useEffect(() => {
		const checkDevice = () => {
			setDevice(getDevice());
			setDimensions(getDimensions());
		};
		checkDevice();
		window.addEventListener('resize', checkDevice);
		return () => {
			window.removeEventListener('resize', checkDevice);
		};
	}, []);
	return {
		device,
		width: dimensions?.width,
		height: dimensions?.height,
		isMobile: device === 'mobile',
		isTablet: device === 'tablet',
		isDesktop: device === 'desktop',
	};
};
</file>

<file path="src/hooks/useModals.ts">
import { useModalStore } from '@/zustand/ui/useModalStore';
import {
	modalRegistry,
	type ModalKey,
	type ModalPropsMap,
} from '@/modals/registry';
import type { ModalConfig } from '@/lib/ui/modals';
import { useMemo } from 'react';
type ModalOpeners = {
	[K in ModalKey]: (props: ModalPropsMap[K], config?: ModalConfig) => void;
};
export function useModals() {
	const { show, hide } = useModalStore();
	const showFns = useMemo(() => {
		const openers = {} as ModalOpeners;
		for (const key in modalRegistry) {
			const modalKey = key as ModalKey;
			openers[modalKey] = (props, config) => show(modalKey, props, config);
		}
		return openers;
	}, [show]);
	return {
		show: showFns,
		hide,
	};
}
</file>

<file path="src/lib/assets/svg/socials.tsx">
import type { SVGProps } from 'react';
const xmlns = 'http://www.w3.org/2000/svg';
export const Socials = {
	Google: (props: SVGProps<SVGSVGElement>) => (
		<svg
			{...props}
			fill='currentColor'
			xmlns={xmlns}
			viewBox='0 0 375 375'
			version='1.0'
		>
			<path
				fill='#FFF'
				d='M 375 187.5 C 375 190.570312 374.925781 193.636719 374.773438 196.699219 C 374.625 199.765625 374.398438 202.824219 374.097656 205.878906 C 373.796875 208.933594 373.421875 211.976562 372.96875 215.011719 C 372.519531 218.046875 371.996094 221.070312 371.398438 224.078125 C 370.796875 227.089844 370.125 230.082031 369.378906 233.058594 C 368.636719 236.035156 367.816406 238.992188 366.925781 241.929688 C 366.035156 244.863281 365.074219 247.777344 364.039062 250.667969 C 363.003906 253.554688 361.902344 256.417969 360.726562 259.253906 C 359.554688 262.089844 358.308594 264.890625 356.996094 267.667969 C 355.6875 270.441406 354.308594 273.179688 352.859375 275.886719 C 351.414062 278.59375 349.902344 281.261719 348.324219 283.894531 C 346.746094 286.527344 345.105469 289.117188 343.402344 291.667969 C 341.695312 294.222656 339.929688 296.730469 338.101562 299.195312 C 336.273438 301.660156 334.386719 304.078125 332.4375 306.449219 C 330.492188 308.820312 328.488281 311.144531 326.429688 313.417969 C 324.367188 315.691406 322.253906 317.914062 320.082031 320.082031 C 317.914062 322.253906 315.691406 324.367188 313.417969 326.429688 C 311.144531 328.488281 308.820312 330.492188 306.449219 332.4375 C 304.078125 334.386719 301.660156 336.273438 299.195312 338.101562 C 296.730469 339.929688 294.222656 341.695312 291.667969 343.402344 C 289.117188 345.105469 286.527344 346.746094 283.894531 348.324219 C 281.261719 349.902344 278.59375 351.414062 275.886719 352.859375 C 273.179688 354.304688 270.441406 355.6875 267.667969 356.996094 C 264.890625 358.308594 262.089844 359.554688 259.253906 360.726562 C 256.417969 361.902344 253.554688 363.003906 250.667969 364.039062 C 247.777344 365.074219 244.863281 366.035156 241.929688 366.925781 C 238.992188 367.816406 236.035156 368.636719 233.058594 369.378906 C 230.082031 370.125 227.089844 370.796875 224.078125 371.398438 C 221.070312 371.996094 218.046875 372.519531 215.011719 372.96875 C 211.976562 373.421875 208.933594 373.796875 205.878906 374.097656 C 202.824219 374.398438 199.765625 374.625 196.699219 374.773438 C 193.636719 374.925781 190.570312 375 187.5 375 C 184.429688 375 181.363281 374.925781 178.300781 374.773438 C 175.234375 374.625 172.175781 374.398438 169.121094 374.097656 C 166.066406 373.796875 163.023438 373.421875 159.988281 372.96875 C 156.953125 372.519531 153.929688 371.996094 150.921875 371.398438 C 147.910156 370.796875 144.917969 370.125 141.941406 369.378906 C 138.964844 368.636719 136.007812 367.816406 133.070312 366.925781 C 130.136719 366.035156 127.222656 365.074219 124.332031 364.039062 C 121.445312 363.003906 118.582031 361.902344 115.746094 360.726562 C 112.910156 359.554688 110.105469 358.308594 107.332031 356.996094 C 104.558594 355.6875 101.820312 354.308594 99.113281 352.859375 C 96.40625 351.414062 93.738281 349.902344 91.105469 348.324219 C 88.472656 346.746094 85.882812 345.105469 83.332031 343.402344 C 80.777344 341.695312 78.269531 339.929688 75.804688 338.101562 C 73.339844 336.273438 70.921875 334.386719 68.550781 332.4375 C 66.179688 330.492188 63.855469 328.488281 61.582031 326.429688 C 59.308594 324.367188 57.085938 322.253906 54.917969 320.082031 C 52.746094 317.914062 50.632812 315.691406 48.570312 313.417969 C 46.511719 311.144531 44.507812 308.820312 42.558594 306.449219 C 40.613281 304.078125 38.726562 301.660156 36.898438 299.195312 C 35.070312 296.730469 33.304688 294.222656 31.597656 291.667969 C 29.894531 289.117188 28.253906 286.527344 26.675781 283.894531 C 25.097656 281.261719 23.585938 278.59375 22.140625 275.886719 C 20.691406 273.179688 19.3125 270.441406 18.003906 267.667969 C 16.691406 264.890625 15.445312 262.089844 14.273438 259.253906 C 13.097656 256.417969 11.996094 253.554688 10.960938 250.667969 C 9.925781 247.777344 8.964844 244.863281 8.074219 241.929688 C 7.183594 238.992188 6.363281 236.035156 5.621094 233.058594 C 4.875 230.082031 4.203125 227.089844 3.601562 224.078125 C 3.003906 221.070312 2.480469 218.046875 2.03125 215.011719 C 1.578125 211.976562 1.203125 208.933594 0.902344 205.878906 C 0.601562 202.824219 0.375 199.765625 0.226562 196.699219 C 0.0742188 193.636719 0 190.570312 0 187.5 C 0 184.429688 0.0742188 181.363281 0.226562 178.300781 C 0.375 175.234375 0.601562 172.175781 0.902344 169.121094 C 1.203125 166.066406 1.578125 163.023438 2.03125 159.988281 C 2.480469 156.953125 3.003906 153.929688 3.601562 150.921875 C 4.203125 147.910156 4.875 144.917969 5.621094 141.941406 C 6.363281 138.964844 7.183594 136.007812 8.074219 133.070312 C 8.964844 130.136719 9.925781 127.222656 10.960938 124.332031 C 11.996094 121.445312 13.097656 118.582031 14.273438 115.746094 C 15.445312 112.910156 16.691406 110.105469 18.003906 107.332031 C 19.3125 104.558594 20.691406 101.820312 22.140625 99.113281 C 23.585938 96.40625 25.097656 93.738281 26.675781 91.105469 C 28.253906 88.472656 29.894531 85.882812 31.597656 83.332031 C 33.304688 80.777344 35.070312 78.269531 36.898438 75.804688 C 38.726562 73.339844 40.613281 70.921875 42.558594 68.550781 C 44.507812 66.179688 46.511719 63.855469 48.570312 61.582031 C 50.632812 59.308594 52.746094 57.085938 54.917969 54.917969 C 57.085938 52.746094 59.308594 50.632812 61.582031 48.570312 C 63.855469 46.511719 66.179688 44.507812 68.550781 42.558594 C 70.921875 40.613281 73.339844 38.726562 75.804688 36.898438 C 78.269531 35.070312 80.777344 33.304688 83.332031 31.597656 C 85.882812 29.894531 88.472656 28.253906 91.105469 26.675781 C 93.738281 25.097656 96.40625 23.585938 99.113281 22.140625 C 101.820312 20.691406 104.558594 19.3125 107.332031 18.003906 C 110.105469 16.691406 112.910156 15.445312 115.746094 14.273438 C 118.582031 13.097656 121.445312 11.996094 124.332031 10.960938 C 127.222656 9.925781 130.136719 8.964844 133.070312 8.074219 C 136.007812 7.183594 138.964844 6.363281 141.941406 5.617188 C 144.917969 4.875 147.910156 4.203125 150.921875 3.601562 C 153.929688 3.003906 156.953125 2.480469 159.988281 2.03125 C 163.023438 1.578125 166.066406 1.203125 169.121094 0.902344 C 172.175781 0.601562 175.234375 0.375 178.300781 0.226562 C 181.363281 0.0742188 184.429688 0 187.5 0 C 190.570312 0 193.636719 0.0742188 196.699219 0.226562 C 199.765625 0.375 202.824219 0.601562 205.878906 0.902344 C 208.933594 1.203125 211.976562 1.578125 215.011719 2.03125 C 218.046875 2.480469 221.070312 3.003906 224.078125 3.601562 C 227.089844 4.203125 230.082031 4.875 233.058594 5.617188 C 236.035156 6.363281 238.992188 7.183594 241.929688 8.074219 C 244.863281 8.964844 247.777344 9.925781 250.667969 10.960938 C 253.554688 11.996094 256.417969 13.097656 259.253906 14.273438 C 262.089844 15.445312 264.890625 16.691406 267.667969 18.003906 C 270.441406 19.3125 273.179688 20.691406 275.886719 22.140625 C 278.59375 23.585938 281.261719 25.097656 283.894531 26.675781 C 286.527344 28.253906 289.117188 29.894531 291.667969 31.597656 C 294.222656 33.304688 296.730469 35.070312 299.195312 36.898438 C 301.660156 38.726562 304.078125 40.613281 306.449219 42.558594 C 308.820312 44.507812 311.144531 46.511719 313.417969 48.570312 C 315.691406 50.632812 317.914062 52.746094 320.082031 54.917969 C 322.253906 57.085938 324.367188 59.308594 326.429688 61.582031 C 328.488281 63.855469 330.492188 66.179688 332.4375 68.550781 C 334.386719 70.921875 336.273438 73.339844 338.101562 75.804688 C 339.929688 78.269531 341.695312 80.777344 343.402344 83.332031 C 345.105469 85.882812 346.746094 88.472656 348.324219 91.105469 C 349.902344 93.738281 351.414062 96.40625 352.859375 99.113281 C 354.304688 101.820312 355.6875 104.558594 356.996094 107.332031 C 358.308594 110.105469 359.554688 112.910156 360.726562 115.746094 C 361.902344 118.582031 363.003906 121.445312 364.039062 124.332031 C 365.074219 127.222656 366.035156 130.136719 366.925781 133.070312 C 367.816406 136.007812 368.636719 138.964844 369.378906 141.941406 C 370.125 144.917969 370.796875 147.910156 371.398438 150.921875 C 371.996094 153.929688 372.519531 156.953125 372.96875 159.988281 C 373.421875 163.023438 373.796875 166.066406 374.097656 169.121094 C 374.398438 172.175781 374.625 175.234375 374.773438 178.300781 C 374.925781 181.363281 375 184.429688 375 187.5 Z M 375 187.5'
			/>
			<path
				fill='#FFF'
				d='M 154.5 81.25 C 127.25 90.75 103.75 111 90.75 137 C 86.25 146 83 155.25 81 165.25 C 76 189.75 79.5 215.75 90.75 238 C 98 252.5 108.5 265.5 121.25 275.5 C 133.25 285 147.25 292.25 162 296 C 180.75 301 200.75 300.75 219.5 296.5 C 236.5 292.5 252.75 284.5 265.75 272.5 C 279.5 260 289 243.5 294.25 225.75 C 299.75 206.5 300.5 185.75 297 166 C 261.75 166 226.5 166 191.25 166 C 191.25 180.75 191.25 195.25 191.25 210 C 211.75 210 232 210 252.5 210 C 250.25 224 241.75 237 230 244.75 C 222.5 249.75 214 253 205.25 254.5 C 196.5 256 187.25 256.25 178.25 254.5 C 169.25 252.75 160.75 249 153.25 243.5 C 141.25 235 132 222.75 127.5 209 C 122.75 195 122.75 179.25 127.5 165.25 C 131 155.5 136.5 146.25 143.75 138.75 C 152.75 129.5 164.5 122.75 177.5 120 C 188.5 117.75 199.75 118 210.5 121.25 C 219.5 124 227.75 129 234.75 135.5 C 241.75 128.5 248.5 121.75 255.5 114.75 C 259.25 111 263 107.5 266.5 103.75 C 256 94 243.75 86.25 230.25 81.25 C 206 73 179 72.75 154.5 81.25 Z M 154.5 81.25'
			/>
			<path
				fill='#EA4335'
				d='M 154.5 81.5 C 178.75 73.25 206 73.25 230.25 82.25 C 243.5 87.25 256 94.75 266.25 104.75 C 262.75 108.5 259 112 255.5 115.75 C 248.5 122.75 241.75 129.5 234.75 136.5 C 228 130 219.75 125 210.5 122.25 C 200 119 188.25 118.5 177.5 121 C 165 123.75 153 130.5 144 139.75 C 136.75 147.25 131 156.25 127.75 166.25 C 115.5 156.75 103.25 147.25 91 137.75 C 104 111.25 127.25 90.75 154.5 81.5 Z M 154.5 81.5'
			/>
			<path
				fill='#FBBC05'
				d='M 81.25 165.25 C 83.25 155.5 86.5 146 91 137 C 103.25 146.5 115.5 156 127.75 165.5 C 123 179.5 123 195.25 127.75 209.25 C 115.5 218.75 103.25 228.25 91 237.75 C 79.75 215.75 76.25 189.75 81.25 165.25 Z M 81.25 165.25'
			/>
			<path
				fill='#4285F4'
				d='M 191.25 166.5 C 226.5 166.5 261.75 166.5 297 166.5 C 300.5 186.25 299.75 206.75 294.25 226 C 289 243.75 279.5 260 265.75 272.75 C 253.75 263.5 242 254.25 230 245 C 241.75 237 250 224.25 252.5 210.25 C 232 210.25 211.75 210.25 191.25 210.25 C 191.25 195.75 191.25 181 191.25 166.5 Z M 191.25 166.5'
			/>
			<path
				fill='#34A853'
				d='M 91 238 C 103.25 228.5 115.5 219 127.75 209.5 C 132.5 223.25 141.5 235.5 153.5 244 C 161 249.25 169.5 253 178.5 254.75 C 187.25 256.5 196.5 256.25 205.25 254.75 C 214 253.25 222.5 250 230 245 C 242 254.25 253.75 263.5 265.75 272.75 C 252.75 284.75 236.75 292.75 219.75 296.75 C 201 301 181 301.25 162.25 296.25 C 147.5 292.25 133.5 285.25 121.5 275.75 C 108.75 265.5 98.25 252.25 91 238 Z M 91 238'
			/>
		</svg>
	),
	Github: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 256 250'>
			<path
				d='M128.001 0C57.317 0 0 57.307 0 128.001c0 56.554 36.676 104.535 87.535 121.46 6.397 1.185 8.746-2.777 8.746-6.158 0-3.052-.12-13.135-.174-23.83-35.61 7.742-43.124-15.103-43.124-15.103-5.823-14.795-14.213-18.73-14.213-18.73-11.613-7.944.876-7.78.876-7.78 12.853.902 19.621 13.19 19.621 13.19 11.417 19.568 29.945 13.911 37.249 10.64 1.149-8.272 4.466-13.92 8.127-17.116-28.431-3.236-58.318-14.212-58.318-63.258 0-13.975 5-25.394 13.188-34.358-1.329-3.224-5.71-16.242 1.24-33.874 0 0 10.749-3.44 35.21 13.121 10.21-2.836 21.16-4.258 32.038-4.307 10.878.049 21.837 1.47 32.066 4.307 24.431-16.56 35.165-13.12 35.165-13.12 6.967 17.63 2.584 30.65 1.255 33.873 8.207 8.964 13.173 20.383 13.173 34.358 0 49.163-29.944 59.988-58.447 63.157 4.591 3.972 8.682 11.762 8.682 23.704 0 17.126-.148 30.91-.148 35.126 0 3.407 2.304 7.398 8.792 6.14C219.37 232.5 256 184.537 256 128.002 256 57.307 198.691 0 128.001 0Zm-80.06 182.34c-.282.636-1.283.827-2.194.39-.929-.417-1.45-1.284-1.15-1.922.276-.655 1.279-.838 2.205-.399.93.418 1.46 1.293 1.139 1.931Zm6.296 5.618c-.61.566-1.804.303-2.614-.591-.837-.892-.994-2.086-.375-2.66.63-.566 1.787-.301 2.626.591.838.903 1 2.088.363 2.66Zm4.32 7.188c-.785.545-2.067.034-2.86-1.104-.784-1.138-.784-2.503.017-3.05.795-.547 2.058-.055 2.861 1.075.782 1.157.782 2.522-.019 3.08Zm7.304 8.325c-.701.774-2.196.566-3.29-.49-1.119-1.032-1.43-2.496-.726-3.27.71-.776 2.213-.558 3.315.49 1.11 1.03 1.45 2.505.701 3.27Zm9.442 2.81c-.31 1.003-1.75 1.459-3.199 1.033-1.448-.439-2.395-1.613-2.103-2.626.301-1.01 1.747-1.484 3.207-1.028 1.446.436 2.396 1.602 2.095 2.622Zm10.744 1.193c.036 1.055-1.193 1.93-2.715 1.95-1.53.034-2.769-.82-2.786-1.86 0-1.065 1.202-1.932 2.733-1.958 1.522-.03 2.768.818 2.768 1.868Zm10.555-.405c.182 1.03-.875 2.088-2.387 2.37-1.485.271-2.861-.365-3.05-1.386-.184-1.056.893-2.114 2.376-2.387 1.514-.263 2.868.356 3.061 1.403Z'
				fill='currentColor'
			/>
		</svg>
	),
	Indeed: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M14.822 10.308a3.018 3.018 0 111.32-4.038 3.006 3.006 0 01-1.32 4.044zM11.6.572c2.47-.901 5.294-.852 7.408.982a3.587 3.587 0 011.023 1.37c.213.69-.749-.07-.88-.168a9.407 9.407 0 00-2.15-1.095C12.837.386 8.897 2.707 6.463 6.316a19.505 19.505 0 00-2.248 5.126 2.918 2.918 0 01-.213.642c-.107.204-.049-.547-.049-.572a15.821 15.821 0 01.43-2.239C5.511 5.34 8.01 2.065 11.6.565zm.037 20.993v-8.763c.249.025.486.037.736.037a6.167 6.167 0 003.219-.895v9.62c0 .822-.15 1.43-.52 1.826A1.874 1.874 0 0113.62 24a1.825 1.825 0 01-1.427-.609c-.368-.404-.56-1.013-.56-1.825z' />
		</svg>
	),
	LinkedIn: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M20.5 2h-17A1.5 1.5 0 002 3.5v17A1.5 1.5 0 003.5 22h17a1.5 1.5 0 001.5-1.5v-17A1.5 1.5 0 0020.5 2zM8 19H5v-9h3zM6.5 8.25A1.75 1.75 0 118.3 6.5a1.78 1.78 0 01-1.8 1.75zM19 19h-3v-4.74c0-1.42-.6-1.93-1.38-1.93A1.74 1.74 0 0013 14.19a.66.66 0 000 .14V19h-3v-9h2.9v1.3a3.11 3.11 0 012.7-1.4c1.55 0 3.36.86 3.36 3.66z'></path>
		</svg>
	),
	Greenhouse: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	Lever: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	Workable: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	Ashby: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	Jobvite: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	SmartRecruiters: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	iCIMS: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	Pinpoint: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	Paylocity: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	BreezyHR: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	Oracle: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	Recruitee: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	Rippling: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	Teamtailor: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	JazzHR: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	Dover: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	BuiltIn: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	LevelsFyi: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	Glassdoor: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	YCombinator: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	Wellfound: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
	Generic: (props: SVGProps<SVGSVGElement>) => (
		<svg {...props} fill='currentColor' xmlns={xmlns} viewBox='0 0 24 24'>
			<path d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' />
		</svg>
	),
};
</file>

<file path="src/lib/auth/client-session-handler.ts">
import { TRPCClientError } from '@trpc/client';
import { signOut } from 'next-auth/react';
export function handleTRPCSessionError(error: unknown): void {
	if (!(error instanceof TRPCClientError)) {
		return;
	}
	if (
		error.data?.cause?.shouldInvalidateSession === true &&
		error.data.httpStatus === 401
	) {
		const redirectUrl = error.data.cause.redirectUrl || '/get-started';
		signOut({ redirect: false })
			.then(() => {
				if (typeof window !== 'undefined') {
					window.location.href = redirectUrl;
				}
			})
			.catch((signOutError) => {
				console.error('Error during sign out:', signOutError);
				if (typeof window !== 'undefined') {
					window.location.href = '/get-started';
				}
			});
	}
}
export function handleSessionErrorIfApplicable(error: unknown): boolean {
	if (
		error instanceof TRPCClientError &&
		error.data?.cause?.shouldInvalidateSession === true &&
		error.data.httpStatus === 401
	) {
		handleTRPCSessionError(error);
		return true;
	}
	return false;
}
export function isSessionInvalidationError(error: unknown): boolean {
	return (
		error instanceof TRPCClientError &&
		error.data?.cause?.shouldInvalidateSession === true &&
		error.data.httpStatus === 401
	);
}
</file>

<file path="src/lib/auth/helpers.ts">
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useCallback } from 'react';
export const useAuthCheck = () => {
	const { status } = useSession();
	const router = useRouter();
	return useCallback(
		(action: () => void) => {
			if (status !== 'authenticated') {
				const url = new URL('/get-started', window.location.origin);
				url.searchParams.set('redirectTo', window.location.pathname);
				router.push(url.toString());
				return;
			}
			action();
		},
		[status, router],
	);
};
</file>

<file path="src/lib/auth/index.ts">
import 'server-only';
import type { UserRole } from '@/prisma/site/.generated/enums';
import type { ISODateString } from 'next-auth';
import { getServerSession } from 'next-auth/next';
import { authOptions } from './options';
export interface Session {
	user: {
		id: string;
		email: string;
		name: string;
		image?: string;
		role?: UserRole;
		alias?: string;
		onboardingCompleted?: boolean;
	};
	expires: ISODateString;
}
export const getSession = async () => {
	return getServerSession(authOptions) as Promise<Session>;
};
</file>

<file path="src/lib/auth/options.ts">
import 'server-only';
import env from '@/env';
import type { UserRole } from '@/prisma/site/.generated/enums';
import { site } from '@/trpc/server/site';
import { PrismaAdapter } from '@auth/prisma-adapter';
import type { DefaultSession, NextAuthOptions } from 'next-auth';
import type { Adapter } from 'next-auth/adapters';
import type { DefaultJWT } from 'next-auth/jwt';
import GoogleProvider from 'next-auth/providers/google';
declare module 'next-auth' {
	interface Session extends DefaultSession {
		user: {
			id: string;
			email: string;
			name: string;
			image?: string;
			role?: UserRole;
			alias?: string;
			onboardingCompleted?: boolean;
		} & DefaultSession['user'];
	}
}
declare module 'next-auth/jwt' {
	interface JWT extends DefaultJWT {
		role?: UserRole;
		alias?: string;
		onboardingCompleted?: boolean;
	}
}
const VERCEL_DEPLOYMENT = !!process.env.VERCEL_URL;
export const authOptions: NextAuthOptions = {
	pages: {
		signIn: '/get-started',
		error: '/error',
	},
	callbacks: {
		async signIn({ user, account, profile }) {
			if (process.env.NODE_ENV === 'development') {
				console.log(
					'‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è AUTH DEBUG ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è',
					{ user, account, profile },
					'‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è',
				);
			}
			if (!user.email) {
				return false;
			}
			if (
				account?.provider === 'google' ||
				account?.provider === 'linkedin'
			) {
				const userExists = await site.user.findUnique({
					where: {
						email: user.email,
					},
					select: {
						id: true,
						name: true,
						image: true,
					},
				});
				if (userExists && profile) {
					await site.user.update({
						where: { email: user.email },
						data: {
							...(userExists.name ? {} : { name: profile.name }),
							...(userExists.image
								? {}
								: {
										image: profile.picture,
									}),
						},
					});
				}
			}
			return true;
		},
		async jwt({ token, account, user, trigger, session }) {
			if (!token.email) {
				return {};
			}
			if (user) {
				token.sub = user.id;
				token.email = user.email;
				token.name = user.name;
				token.picture = user.image;
				token.role = user.role;
				token.alias = user.alias;
				token.onboardingCompleted = user.onboardingCompleted ?? false;
			}
			if (trigger === 'update') {
				const refreshedUser = await site.user.findUnique({
					where: { id: token.sub },
					select: {
						onboardingCompleted: true,
						role: true,
						name: true,
						email: true,
						image: true,
						alias: true,
					},
				});
				if (refreshedUser) {
					token.name = refreshedUser.name;
					token.email = refreshedUser.email;
					token.picture = refreshedUser.image;
					token.role = refreshedUser.role;
					token.alias = refreshedUser.alias;
					token.onboardingCompleted =
						refreshedUser.onboardingCompleted;
				} else {
					return {};
				}
			}
			if (session?.role) {
				token.role = session.role;
				token.alias = session.alias;
			}
			return token;
		},
		async session({ session, token }) {
			session.user = {
				id: token.sub,
				email: token.email,
				name: token.name,
				image: token.picture,
				role: token.role,
				alias: token.alias,
				onboardingCompleted: token.onboardingCompleted ?? false,
				...(token || session).user,
			};
			return session;
		},
	},
	debug: process.env.NODE_ENV === 'development',
	adapter: PrismaAdapter(site) as Adapter,
	session: {
		strategy: 'jwt',
	},
	cookies: {
		sessionToken: {
			name: `${VERCEL_DEPLOYMENT ? '__Secure-' : ''}next-auth.session-token`,
			options: {
				httpOnly: true,
				sameSite: 'lax',
				path: '/',
				domain: VERCEL_DEPLOYMENT
					? `.${env.NEXT_PUBLIC_APP_DOMAIN}`
					: undefined,
				secure: VERCEL_DEPLOYMENT,
			},
		},
	},
	providers: [
		GoogleProvider({
			clientId: env.GOOGLE_CLIENT_ID as string,
			clientSecret: env.GOOGLE_CLIENT_SECRET as string,
			allowDangerousEmailAccountLinking: true,
			profile(profile) {
				return {
					id: profile.sub,
					name: profile.name,
					email: profile.email,
					image: profile.picture,
					role: profile.role ?? 'USER',
				};
			},
		}),
	],
};
</file>

<file path="src/lib/auth/session-security.ts">
import type { UserRole } from '@/prisma/site/.generated/enums';
import { TRPCError } from '@trpc/server';
import type { Session } from './index';
interface SessionContext {
	session: Session | null;
	headers?: Headers;
}
interface ValidatedUser {
	id: string;
	email: string;
	name: string;
	image?: string;
	role?: UserRole;
	alias?: string;
	onboardingCompleted?: boolean;
}
export function validateSessionSecurity(ctx: SessionContext): boolean {
	if (!ctx.session) {
		return false;
	}
	if (!ctx.session.user) {
		return false;
	}
	if (
		!ctx.session.user.id ||
		typeof ctx.session.user.id !== 'string' ||
		ctx.session.user.id.trim() === ''
	) {
		return false;
	}
	// Check if user has required email field
	if (
		!ctx.session.user.email ||
		typeof ctx.session.user.email !== 'string' ||
		ctx.session.user.email.trim() === ''
	) {
		return false;
	}
	// All validation checks passed
	return true;
}
/**
 * Type guard to ensure session context has a valid user
 */
const hasValidUser = (
	ctx: SessionContext,
): ctx is SessionContext & {
	session: NonNullable<SessionContext['session']> & {
		user: ValidatedUser;
	};
} => {
	return validateSessionSecurity(ctx);
};
export function enforceSessionSecurity(ctx: SessionContext): ValidatedUser {
	if (!hasValidUser(ctx)) {
		let redirectUrl = '/get-started';
		if (ctx.headers) {
			const referer = ctx.headers.get('referer');
			const host = ctx.headers.get('host');
			if (referer && host) {
				try {
					const refererUrl = new URL(referer);
					const currentPath = refererUrl.pathname + refererUrl.search;
					if (
						refererUrl.host === host &&
						currentPath !== '/get-started'
					) {
						redirectUrl = `/get-started?redirectTo=${encodeURIComponent(currentPath)}`;
					}
				} catch {
				}
			}
		}
		throw new TRPCError({
			code: 'UNAUTHORIZED',
			message: 'Invalid session. Please log in again.',
			cause: {
				shouldInvalidateSession: true,
				redirectUrl,
			},
		});
	}
	return ctx.session.user;
}
export function isSessionInvalidationError(error: any): boolean {
	return (
		error?.data?.cause?.shouldInvalidateSession === true &&
		error?.code === 'UNAUTHORIZED'
	);
}
</file>

<file path="src/lib/core/errors/error-handler.ts">
import { TRPCClientError } from '@trpc/client';
import { toast } from 'sonner';
import { ZodError } from 'zod';
import { TRPC_ERROR_MESSAGES } from './error-messages';
interface ErrorResponse {
	data?: {
		zodError?: {
			fieldErrors?: Record<string, string[]>;
			formErrors?: string[];
		};
		code?: string;
	};
	message?: string;
}
const formatErrors = (errors: string[]): string => errors.join(', ');
const formatFieldErrors = (fieldErrors: Record<string, string[]>): string =>
	Object.entries(fieldErrors)
		.map(
			([field, errors]) =>
				`${field}: ${Array.isArray(errors) ? formatErrors(errors) : String(errors)}`,
		)
		.join('; ');
const handleZodError = (
	zodError: NonNullable<ErrorResponse['data']>['zodError'],
): boolean => {
	if (!zodError) return false;
	if (zodError.fieldErrors && Object.keys(zodError.fieldErrors).length > 0) {
		toast.error(
			`Validation Error: ${formatFieldErrors(zodError.fieldErrors)}`,
		);
		return true;
	}
	if (zodError.formErrors && zodError.formErrors.length > 0) {
		toast.error(`Validation Error: ${formatErrors(zodError.formErrors)}`);
		return true;
	}
	return false;
};
const getTRPCErrorMessage = (
	code?: string,
	originalMessage?: string,
): string => {
	if (code && code in TRPC_ERROR_MESSAGES) {
		return (
			originalMessage ||
			TRPC_ERROR_MESSAGES[code as keyof typeof TRPC_ERROR_MESSAGES]
		);
	}
	return originalMessage || 'An unexpected error occurred';
};
const formatZodErrors = (issues: any[]): string =>
	issues.map((err) => `${err.path.join('.')}: ${err.message}`).join(', ');
const errorHandlers = {
	trpc: (error: TRPCClientError<any> & ErrorResponse) => {
		if (error.data?.zodError && handleZodError(error.data.zodError)) {
			return;
		}
		const message = getTRPCErrorMessage(error.data?.code, error.message);
		toast.error(message);
	},
	zod: (error: ZodError) => {
		const message = `Validation Error: ${formatZodErrors(error.issues)}`;
		toast.error(message);
	},
	generic: (error: Error, fallback: string) => {
		toast.error(error.message || fallback);
	},
	unknown: (fallback: string) => {
		toast.error(fallback);
	},
};
export function handleTRPCError(
	error: unknown,
	fallbackMessage = 'An error occurred',
): void {
	if (error instanceof TRPCClientError) {
		errorHandlers.trpc(error as TRPCClientError<any> & ErrorResponse);
	} else if (error instanceof ZodError) {
		errorHandlers.zod(error);
	} else if (error instanceof Error) {
		errorHandlers.generic(error, fallbackMessage);
	} else {
		errorHandlers.unknown(fallbackMessage);
	}
}
export function handleTRPCSuccess(
	message: string,
	result?: { message?: string },
): void {
	const successMessage = result?.message || message;
	toast.success(successMessage);
}
export async function executeTRPCMutation<T>(
	mutationFn: () => Promise<T>,
	successMessage: string,
	errorMessage?: string,
): Promise<{ data: T | null; error: unknown | null }> {
	try {
		const data = await mutationFn();
		handleTRPCSuccess(successMessage, data as any);
		return { data, error: null };
	} catch (error) {
		handleTRPCError(error, errorMessage);
		return { data: null, error };
	}
}
export function extractErrorMessage(
	error: unknown,
	fallback = 'An error occurred',
): string {
	if (error instanceof TRPCClientError) {
		return error.message || fallback;
	} else if (error instanceof Error) {
		return error.message || fallback;
	}
	return fallback;
}
</file>

<file path="src/lib/core/errors/error-messages.ts">
import type { TRPC_ERROR_CODE_KEY } from '@trpc/server/rpc';
export const TRPC_ERROR_MESSAGES = {
	PARSE_ERROR: 'Failed to parse the request',
	BAD_REQUEST: 'Invalid request. Please check your input',
	INTERNAL_SERVER_ERROR: 'An internal server error occurred',
	NOT_IMPLEMENTED: 'This feature is not yet implemented',
	BAD_GATEWAY: 'Bad gateway error occurred',
	SERVICE_UNAVAILABLE: 'Service is temporarily unavailable',
	GATEWAY_TIMEOUT: 'Gateway timeout occurred',
	UNAUTHORIZED: 'You must be logged in to access this resource',
	PAYMENT_REQUIRED: 'Payment is required to access this resource',
	FORBIDDEN: 'You do not have permission to perform this action',
	NOT_FOUND: 'The requested resource was not found',
	METHOD_NOT_SUPPORTED: 'This method is not supported',
	TIMEOUT: 'Request timed out. Please try again',
	CONFLICT: 'This action conflicts with existing data',
	PRECONDITION_FAILED: 'Precondition failed',
	PAYLOAD_TOO_LARGE: 'Request payload is too large',
	UNSUPPORTED_MEDIA_TYPE: 'Unsupported media type',
	UNPROCESSABLE_CONTENT: 'The request content could not be processed',
	PRECONDITION_REQUIRED: 'Required precondition header is missing',
	TOO_MANY_REQUESTS: 'Too many requests. Please try again later',
	CLIENT_CLOSED_REQUEST: 'Client closed the request',
} as const satisfies Record<TRPC_ERROR_CODE_KEY, string>;
export function getErrorMessage(code: TRPC_ERROR_CODE_KEY): string {
	return TRPC_ERROR_MESSAGES[code];
}
export type TRPCErrorCode = keyof typeof TRPC_ERROR_MESSAGES;
</file>

<file path="src/lib/core/types/aria-utils.ts">
export type RequireAtLeastOne<
	T,
	Keys extends keyof T = keyof T,
> = Keys extends keyof T
	? T &
			{
				[K in Keys]-?: Required<Pick<T, K>> &
					Partial<Pick<T, Exclude<Keys, K>>>;
			}[Keys]
	: never;
export type AriaProps = {
	'aria-label'?: string;
	'aria-labelledby'?: string;
};
export type RequiredAriaProps = RequireAtLeastOne<{
	'aria-label'?: string;
	'aria-labelledby'?: string;
}>;
export class MissingAriaAttributeError extends Error {
	constructor(props: Record<string, unknown>, componentName: string) {
		super(
			`${componentName} component is missing required accessibility attributes. Either 'aria-label' or 'aria-labelledby' must be provided.`,
		);
		this.name = 'MissingAriaAttributeError';
		Object.defineProperty(this, 'componentName', {
			enumerable: true,
			value: componentName,
		});
		Object.defineProperty(this, 'componentProps', {
			enumerable: true,
			value: props,
		});
		if (Error.captureStackTrace) {
			Error.captureStackTrace(this, MissingAriaAttributeError);
		}
	}
}
export function validateAriaProps(
	props: Record<string, unknown>,
	componentName: string,
	skipValidation = false,
): boolean {
	if (skipValidation) {
		return true;
	}
	const hasAriaLabel = props['aria-label'] !== undefined;
	const hasAriaLabelledBy = props['aria-labelledby'] !== undefined;
	if (!hasAriaLabel && !hasAriaLabelledBy) {
		const error = new MissingAriaAttributeError(props, componentName);
		console.error(
			`%cüî¥ Accessibility Error: ${error.message}`,
			'font-weight: bold; color: #f44336;',
			'\nComponent:',
			componentName,
			'\nProvided props:',
			props,
		);
		if (process.env.NODE_ENV !== 'production') {
			throw error;
		}
		return false;
	}
	return true;
}
export function hasValidAriaLabeling(props: Record<string, unknown>): boolean {
	return (
		props['aria-label'] !== undefined ||
		props['aria-labelledby'] !== undefined
	);
}
</file>

<file path="src/lib/core/types/routes.ts">
import type { IconType } from 'react-icons';
interface Route {
	path: string;
	displayPath: string;
	displayName: string;
	type: 'public' | 'private' | 'admin';
	category: 'ancillary' | 'feature' | 'admin';
	icon?: IconType;
	onboardingCompleteRequired?: boolean;
	status?: 'soon' | 'next' | 'new';
	primaryNav?: boolean;
}
export type { Route };
</file>

<file path="src/lib/core/types/timer.ts">
export type Timer = ReturnType<typeof setTimeout>;
</file>

<file path="src/lib/core/utils/array.ts">
interface Positionable {
	position?: number;
}
export const sortByPosition = <T extends Positionable>(items: T[]): T[] => {
	return [...items].sort((a, b) => (a.position ?? 0) - (b.position ?? 0));
};
export const hasContent = <T>(items?: T[]): items is T[] => {
	return Array.isArray(items) && items.length > 0;
};
</file>

<file path="src/lib/core/utils/date.ts">
export const formatDate = (
	date: Date,
	options: Intl.DateTimeFormatOptions = {
		month: 'short',
		year: 'numeric',
	},
): string => {
	return date.toLocaleDateString('en-US', options);
};
export const formatDateRange = (
	startDate: Date,
	endDate?: Date,
	presentLabel: string = 'Present',
): string => {
	const start = formatDate(startDate);
	const end = endDate ? formatDate(endDate) : presentLabel;
	return `${start} - ${end}`;
};
export const postedDateFormatDate = (date: Date): string => {
	const now = new Date();
	const timeDiff = now.getTime() - date.getTime();
	const oneDay = 24 * 60 * 60 * 1000;
	const oneYear = 365 * oneDay;
	if (timeDiff < oneDay) {
		const hoursAgo = Math.floor(timeDiff / (60 * 60 * 1000));
		const minutesAgo = Math.floor(timeDiff / (60 * 1000));
		const secondsAgo = Math.floor(timeDiff / 1000);
		if (hoursAgo > 0) return `${hoursAgo} hr${hoursAgo > 1 ? 's' : ''}`;
		if (minutesAgo > 0)
			return `${minutesAgo} min${minutesAgo > 1 ? 's' : ''}`;
		return `${secondsAgo} sec${secondsAgo > 1 ? 's' : ''}`;
	}
	const options: Intl.DateTimeFormatOptions = {
		month: 'numeric',
		day: 'numeric',
	};
	if (timeDiff >= oneYear) {
		options.year = 'numeric';
	}
	return date.toLocaleDateString('en-US', options);
};
export const getPreText = (date: Date): string => {
	const now = new Date();
	const timeDiff = now.getTime() - date.getTime();
	const oneDay = 24 * 60 * 60 * 1000;
	return timeDiff < oneDay ? '' : ' on';
};
export const formatNumber = (num: number): string => {
	if (num >= 1000000) {
		return `${(num / 1000000).toFixed(1).replace(/\.0$/, '')}mil`;
	}
	if (num >= 1000) {
		return `${(num / 1000).toFixed(1).replace(/\.0$/, '')}k`;
	}
	return num.toString();
};
</file>

<file path="src/lib/core/utils/deep-equal.ts">
export function isDeepStrictEqual(
	a: unknown,
	b: unknown,
	seen: WeakMap<object, object> = new WeakMap(),
): boolean {
	if (a === b) return true;
	if (Number.isNaN(a) && Number.isNaN(b)) return true;
	if (typeof a !== typeof b) return false;
	if (a === null || b === null || a === undefined || b === undefined) {
		return false;
	}
	if (typeof a !== 'object') return false;
	if (seen.has(a as object)) {
		return seen.get(a as object) === b;
	}
	seen.set(a as object, b as object);
	try {
		if (a instanceof Date && b instanceof Date) {
			return a.getTime() === b.getTime();
		}
		if (a instanceof RegExp && b instanceof RegExp) {
			return a.source === b.source && a.flags === b.flags;
		}
		if (Array.isArray(a) && Array.isArray(b)) {
			if (a.length !== b.length) return false;
			for (let i = 0; i < a.length; i++) {
				if (!isDeepStrictEqual(a[i], b[i], seen)) return false;
			}
			return true;
		}
		if (a instanceof Set && b instanceof Set) {
			if (a.size !== b.size) return false;
			for (const value of a) {
				let found = false;
				for (const bValue of b) {
					if (isDeepStrictEqual(value, bValue, seen)) {
						found = true;
						break;
					}
				}
				if (!found) return false;
			}
			return true;
		}
		if (a instanceof Map && b instanceof Map) {
			if (a.size !== b.size) return false;
			for (const [key, value] of a) {
				let found = false;
				for (const [bKey, bValue] of b) {
					if (
						isDeepStrictEqual(key, bKey, seen) &&
						isDeepStrictEqual(value, bValue, seen)
					) {
						found = true;
						break;
					}
				}
				if (!found) return false;
			}
			return true;
		}
		if (Array.isArray(a) || Array.isArray(b)) return false;
		if (a instanceof Set || b instanceof Set) return false;
		if (a instanceof Map || b instanceof Map) return false;
		if (a instanceof Date || b instanceof Date) return false;
		if (a instanceof RegExp || b instanceof RegExp) return false;
		const aObj = a as Record<string | symbol, unknown>;
		const bObj = b as Record<string | symbol, unknown>;
		const aKeys = [
			...Object.keys(aObj),
			...Object.getOwnPropertySymbols(aObj),
		];
		const bKeys = [
			...Object.keys(bObj),
			...Object.getOwnPropertySymbols(bObj),
		];
		if (aKeys.length !== bKeys.length) return false;
		const bKeysSet = new Set(bKeys);
		for (const key of aKeys) {
			if (!bKeysSet.has(key)) return false;
			if (!isDeepStrictEqual(aObj[key], bObj[key], seen)) {
				return false;
			}
		}
		return true;
	} catch (error) {
		return false;
	}
}
</file>

<file path="src/lib/core/utils/index.ts">
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';
export const cn = (...inputs: ClassValue[]) => {
	return twMerge(clsx(inputs));
};
export const formatEnumToTitleCase = (enumValue: string): string => {
	return enumValue
		.toLowerCase()
		.split('_')
		.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
		.join(' ');
};
const sortObjectKeys = (obj: any): any => {
	if (typeof obj !== 'object' || obj === null) return obj;
	if (Array.isArray(obj)) return obj.map(sortObjectKeys);
	return Object.keys(obj)
		.sort()
		.reduce((acc, key) => {
			acc[key] = sortObjectKeys(obj[key]);
			return acc;
		}, {} as any);
};
export { hasContent, sortByPosition } from './array';
export { formatDate, formatDateRange, postedDateFormatDate } from './date';
export { default as tryCatch } from './try-catch';
</file>

<file path="src/lib/core/utils/try-catch.ts">
import { TRPCError } from '@trpc/server';
type Success<T> = {
	data: T;
	error: null;
};
type Failure<E> = {
	data: null;
	error: E;
};
type Result<T, E = Error> = Success<T> | Failure<E>;
const tryCatch = async <T, E = Error>(
	promiseOrFunction: Promise<T> | (() => Promise<T>),
): Promise<Result<T, E>> => {
	try {
		const promise =
			typeof promiseOrFunction === 'function'
				? promiseOrFunction()
				: promiseOrFunction;
		const data = await promise;
		return { data, error: null };
	} catch (error) {
		if (error instanceof TRPCError) {
			throw error;
		}
		process.env.NODE_ENV === 'development' &&
			console.log('üöÄ ~ tryCatch ~ error:', error);
		return { data: null, error: error as E };
	}
};
export default tryCatch;
</file>

<file path="src/lib/core/index.ts">
export * from './errors/error-handler';
export * from './utils';
export * from './types/aria-utils';
export type * from './types/routes';
export type * from './types/timer';
</file>

<file path="src/lib/infra/storage/zustand/examples.ts">
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import {
	createVersionedPersistOptions,
	migrationUtils,
	type BaseVersionedState,
	type StoreVersionConfig,
} from './index';
interface SimpleExampleState extends BaseVersionedState {
	count: number;
	name: string;
	increment: () => void;
	setName: (name: string) => void;
}
const simpleVersionConfig: StoreVersionConfig<SimpleExampleState> = {
	currentVersion: 2,
	migrations: [
		{
			version: 1,
			description: 'Initial version with hydration tracking',
			migrate: (state) => {
				return migrationUtils.addDefaultFields(state, {
					_hasHydrated: false,
				});
			},
		},
		{
			version: 2,
			description: 'Add name field to state',
			migrate: (state) => {
				return migrationUtils.addDefaultFields(state, {
					name: 'Anonymous User',
				});
			},
		},
	],
};
export const useSimpleExampleStore = create<SimpleExampleState>()(
	persist(
		immer((set) => ({
			count: 0,
			name: 'Anonymous User',
			increment: () =>
				set((state) => {
					state.count += 1;
				}),
			setName: (name: string) =>
				set((state) => {
					state.name = name;
				}),
			_hasHydrated: false,
			_setHasHydrated: (hydrated: boolean) =>
				set((state) => {
					state._hasHydrated = hydrated;
				}),
		})),
		createVersionedPersistOptions('simple-example', simpleVersionConfig, {
			storage: createJSONStorage(() => localStorage),
			partialize: (state) => ({
				count: state.count,
				name: state.name,
				_hasHydrated: state._hasHydrated,
			}),
			onRehydrateStorage: () => {
				return (state, error) => {
					if (error) {
						console.error(
							'[SimpleExampleStore] Hydration error:',
							error,
						);
						return;
					}
					if (state) {
						state._setHasHydrated?.(true);
					}
				};
			},
		}),
	),
);
interface ComplexExampleState extends BaseVersionedState {
	userProfile: {
		fullName: string;
		email: string;
		preferences: {
			theme: 'light' | 'dark';
			notifications: boolean;
		};
	};
	settings: {
		language: string;
		timezone: string;
	};
	updateUserProfile: (
		profile: Partial<ComplexExampleState['userProfile']>,
	) => void;
	updateSettings: (
		settings: Partial<ComplexExampleState['settings']>,
	) => void;
}
const complexVersionConfig: StoreVersionConfig<ComplexExampleState> = {
	currentVersion: 3,
	migrations: [
		{
			version: 1,
			description: 'Initial version with hydration tracking',
			migrate: (state) => {
				return migrationUtils.addDefaultFields(state, {
					_hasHydrated: false,
				});
			},
		},
		{
			version: 2,
			description: 'Rename name to fullName and restructure',
			migrate: (state) => {
				if (state.userProfile?.name) {
					state.userProfile.fullName = state.userProfile.name;
					delete state.userProfile.name;
				}
				return migrationUtils.addDefaultFields(state, {
					userProfile: {
						fullName: '',
						email: '',
						preferences: {
							theme: 'light' as const,
							notifications: true,
						},
					},
				});
			},
		},
		{
			version: 3,
			description: 'Add settings configuration',
			migrate: (state) => {
				return migrationUtils.addDefaultFields(state, {
					settings: {
						language: 'en',
						timezone: 'UTC',
					},
				});
			},
		},
	],
	clearOnFailure: true,
	enableLogging: process.env.NODE_ENV === 'development',
};
export const useComplexExampleStore = create<ComplexExampleState>()(
	persist(
		immer((set) => ({
			userProfile: {
				fullName: '',
				email: '',
				preferences: {
					theme: 'light',
					notifications: true,
				},
			},
			settings: {
				language: 'en',
				timezone: 'UTC',
			},
			updateUserProfile: (profile) =>
				set((state) => {
					Object.assign(state.userProfile, profile);
				}),
			updateSettings: (settings) =>
				set((state) => {
					Object.assign(state.settings, settings);
				}),
			_hasHydrated: false,
			_setHasHydrated: (hydrated: boolean) =>
				set((state) => {
					state._hasHydrated = hydrated;
				}),
		})),
		createVersionedPersistOptions('complex-example', complexVersionConfig, {
			storage: createJSONStorage(() => localStorage),
			partialize: (state) => ({
				userProfile: state.userProfile,
				settings: state.settings,
				_hasHydrated: state._hasHydrated,
			}),
			onRehydrateStorage: () => {
				return (state, error) => {
					if (error) {
						console.error(
							'[ComplexExampleStore] Hydration error:',
							error,
						);
						return;
					}
					if (state) {
						const isValid = migrationUtils.validateState(state, [
							'userProfile.fullName',
							'userProfile.email',
							'settings.language',
						]);
						if (!isValid) {
							console.warn(
								'[ComplexExampleStore] Invalid state structure detected',
							);
						}
						state._setHasHydrated?.(true);
					}
				};
			},
		}),
	),
);
interface TemporaryState extends BaseVersionedState {
	tempData: string[];
	isProcessing: boolean;
	addTempData: (data: string) => void;
	clearTempData: () => void;
	setProcessing: (processing: boolean) => void;
}
export const useTemporaryStore = create<TemporaryState>()(
	immer((set) => ({
		tempData: [],
		isProcessing: false,
		addTempData: (data) =>
			set((state) => {
				state.tempData.push(data);
			}),
		clearTempData: () =>
			set((state) => {
				state.tempData = [];
			}),
		setProcessing: (processing) =>
			set((state) => {
				state.isProcessing = processing;
			}),
		_hasHydrated: true,
		_setHasHydrated: (hydrated: boolean) =>
			set((state) => {
				state._hasHydrated = hydrated;
			}),
	})),
);
interface AsyncMigrationState extends BaseVersionedState {
	apiData: Record<string, any>;
	lastSync: number;
	syncData: () => Promise<void>;
}
const asyncVersionConfig: StoreVersionConfig<AsyncMigrationState> = {
	currentVersion: 2,
	migrations: [
		{
			version: 1,
			description: 'Initial version with hydration tracking',
			migrate: (state) => {
				return migrationUtils.addDefaultFields(state, {
					_hasHydrated: false,
				});
			},
		},
		{
			version: 2,
			description: 'Clear old API data format (async)',
			migrate: async (state) => {
				if (state.apiData && typeof state.apiData === 'object') {
					const transformedData = Object.entries(
						state.apiData,
					).reduce(
						(acc, [key, value]) => {
							acc[`transformed_${key}`] = value;
							return acc;
						},
						{} as Record<string, any>,
					);
					state.apiData = transformedData;
				}
				return state;
			},
		},
	],
	clearOnFailure: true,
	enableLogging: process.env.NODE_ENV === 'development',
};
export const useAsyncMigrationStore = create<AsyncMigrationState>()(
	persist(
		immer((set, get) => ({
			apiData: {},
			lastSync: Date.now(),
			syncData: async () => {
				set((state) => {
					state.lastSync = Date.now();
				});
			},
			_hasHydrated: false,
			_setHasHydrated: (hydrated: boolean) =>
				set((state) => {
					state._hasHydrated = hydrated;
				}),
		})),
		createVersionedPersistOptions(
			'async-migration-example',
			asyncVersionConfig,
			{
				storage: createJSONStorage(() => localStorage),
				partialize: (state) => ({
					apiData: state.apiData,
					lastSync: state.lastSync,
					_hasHydrated: state._hasHydrated,
				}),
			},
		),
	),
);
</file>

<file path="src/lib/infra/storage/zustand/immer-config.ts">
import { enableMapSet } from 'immer';
enableMapSet();
</file>

<file path="src/lib/infra/storage/zustand/index.ts">
export type * from './types';
export * from './versioning';
export type {
	Mutate,
	StateCreator,
	StoreApi,
	StoreMutatorIdentifier,
} from 'zustand';
export type {
	PersistOptions,
	PersistStorage,
	StorageValue,
} from 'zustand/middleware';
</file>

<file path="src/lib/infra/storage/zustand/types.ts">
import type { StateCreator } from 'zustand';
import type { PersistOptions } from 'zustand/middleware';
export interface BaseVersionedState {
	_hasHydrated: boolean;
	_setHasHydrated: (hydrated: boolean) => void;
}
export type ImmerVersionedState<T> = T & {
	_hasHydrated: boolean;
	_setHasHydrated: (hydrated: boolean) => void;
};
export interface HydrationConfig<TState> {
	enableHydrationTracking?: boolean;
	onHydrationStart?: (state: TState) => void;
	onHydrationComplete?: (state: TState) => void;
	onHydrationError?: (error: Error, state?: TState) => void;
	defaultValues?: Partial<TState>;
	requiredFields?: string[];
}
export interface VersionedPersistOptions<TState, TPersistedState = TState>
	extends Omit<PersistOptions<TState, TPersistedState>, 'migrate'> {
	version: number;
	migrate?: (
		persistedState: any,
		version: number,
	) => TPersistedState | Promise<TPersistedState>;
	hydrationConfig?: HydrationConfig<TState>;
}
export interface StoreConfig<TState> {
	name: string;
	version: number;
	stateCreator: StateCreator<TState>;
	persistOptions?: Partial<VersionedPersistOptions<TState>>;
	hydrationConfig?: HydrationConfig<TState>;
}
export interface MigrationResult<TState> {
	success: boolean;
	state?: TState;
	error?: string;
	toVersion: number;
	fromVersion: number;
}
export interface MigrationContext {
	fromVersion: number;
	toVersion: number;
	storeName?: string;
	enableLogging?: boolean;
}
export type EnhancedVersionMigrationFn<TState = any> = (
	persistedState: any,
	context: MigrationContext,
) => TState | Promise<TState>;
export interface StoreMetadata {
	name: string;
	version: number;
	lastMigrationDate?: Date;
	migrationHistory?: Array<{
		fromVersion: number;
		toVersion: number;
		date: Date;
		success: boolean;
		error?: string;
	}>;
}
export type StoreState<T> = T extends (...args: any[]) => infer R ? R : never;
export type PersistableState<T> = {
	[K in keyof T]: T[K] extends Function
		? never
		: K extends `_${string}`
			? never
			: T[K];
};
export type PartializeFn<TState, TPersistedState = Partial<TState>> = (
	state: TState,
) => TPersistedState;
export interface StateValidationConfig<TState> {
	requiredFields: (keyof TState)[];
	validator?: (state: TState) => boolean;
	onValidationFailure?: 'reset' | 'merge-defaults' | 'throw';
	defaultValues?: Partial<TState>;
}
export interface AdvancedPersistConfig<TState> {
	persistOptions: VersionedPersistOptions<TState>;
	validation?: StateValidationConfig<TState>;
	hydration?: HydrationConfig<TState>;
	debug?: {
		enableLogging?: boolean;
		logMigrations?: boolean;
		logHydration?: boolean;
	};
}
</file>

<file path="src/lib/infra/storage/zustand/versioning.ts">
import type { PersistOptions } from 'zustand/middleware';
export type VersionMigrationFn<TState = any> = (
	persistedState: any,
	version: number,
) => TState | Promise<TState>;
export interface VersionMigration<TState = any> {
	version: number;
	migrate: VersionMigrationFn<TState>;
	description?: string;
}
export interface StoreVersionConfig<TState = any> {
	currentVersion: number;
	migrations: VersionMigration<TState>[];
	clearOnFailure?: boolean;
	enableLogging?: boolean;
}
export function createVersionedMigration<TState = any>(
	config: StoreVersionConfig<TState>,
): VersionMigrationFn<TState> {
	const { migrations, clearOnFailure = true, enableLogging = true } = config;
	return (persistedState: any, version: number): TState => {
		if (enableLogging && process.env.NODE_ENV === 'development') {
			console.log(
				`[Store Migration] Starting migration from version ${version} to ${config.currentVersion}`,
			);
		}
		try {
			const applicableMigrations = migrations
				.filter((migration) => migration.version > version)
				.sort((a, b) => a.version - b.version);
			let state = persistedState;
			for (const migration of applicableMigrations) {
				if (enableLogging && process.env.NODE_ENV === 'development') {
					console.log(
						`[Store Migration] Applying migration to version ${migration.version}${
							migration.description
								? `: ${migration.description}`
								: ''
						}`,
					);
				}
				state = migration.migrate(state, migration.version - 1);
			}
			if (enableLogging && process.env.NODE_ENV === 'development') {
				console.log(
					'[Store Migration] Migration completed successfully',
				);
			}
			return state;
		} catch (error) {
			if (enableLogging && process.env.NODE_ENV === 'development') {
				console.error('[Store Migration] Migration failed:', error);
			}
			if (clearOnFailure) {
				if (typeof window !== 'undefined') {
					console.warn(
						'[Store Migration] Clearing corrupted storage data due to migration failure',
					);
				}
				return undefined as any;
			}
			throw error;
		}
	};
}
export const migrationUtils = {
	renameField: <T = any>(state: any, oldKey: string, newKey: string): T => {
		if (state && typeof state === 'object' && oldKey in state) {
			state[newKey] = state[oldKey];
			delete state[oldKey];
		}
		return state;
	},
	removeFields: <T = any>(state: any, fieldsToRemove: string[]): T => {
		if (state && typeof state === 'object') {
			fieldsToRemove.forEach((field) => {
				if (field in state) {
					delete state[field];
				}
			});
		}
		return state;
	},
	addDefaultFields: <T = any>(
		state: any,
		defaults: Record<string, any>,
	): T => {
		if (!state || typeof state !== 'object') {
			return defaults as T;
		}
		const merged = { ...defaults, ...state };
		return merged as T;
	},
	transformNested: <T = any>(
		state: any,
		path: string,
		transformer: (value: any) => any,
	): T => {
		if (!state || typeof state !== 'object') {
			return state;
		}
		const keys = path.split('.');
		let current = state;
		for (let i = 0; i < keys.length - 1; i++) {
			const key = keys[i];
			if (!key || !current[key] || typeof current[key] !== 'object') {
				return state;
			}
			current = current[key];
		}
		const finalKey = keys[keys.length - 1];
		if (finalKey && finalKey in current) {
			current[finalKey] = transformer(current[finalKey]);
		}
		return state;
	},
	validateState: <T = any>(
		state: any,
		requiredFields: string[],
	): state is T => {
		if (!state || typeof state !== 'object') {
			return false;
		}
		return requiredFields.every((field) => {
			const keys = field.split('.');
			let current = state;
			for (const key of keys) {
				if (
					!current ||
					typeof current !== 'object' ||
					!(key in current)
				) {
					return false;
				}
				current = current[key];
			}
			return true;
		});
	},
	clearRelatedStorage: (patterns: string[]): void => {
		if (typeof window === 'undefined') return;
		patterns.forEach((pattern) => {
			Object.keys(localStorage).forEach((key) => {
				if (key.includes(pattern)) {
					localStorage.removeItem(key);
				}
			});
		});
	},
};
export function createVersionedPersistOptions<TState>(
	name: string,
	versionConfig: StoreVersionConfig<TState>,
	additionalOptions?: Partial<PersistOptions<TState, Partial<TState>>>,
): PersistOptions<TState, Partial<TState>> {
	return {
		name,
		version: versionConfig.currentVersion,
		migrate: createVersionedMigration(versionConfig),
		...additionalOptions,
	} as PersistOptions<TState, Partial<TState>>;
}
</file>

<file path="src/lib/infra/storage/index.ts">
export * from './zustand';
</file>

<file path="src/lib/infra/index.ts">
export * from './storage';
</file>

<file path="src/lib/metadata/config.ts">
import env from '@/env';
export const DEFAULT_METADATA = {
	siteName: env.NEXT_PUBLIC_APP_NAME,
	siteUrl: env.NEXT_PUBLIC_APP_URL,
	domain: env.NEXT_PUBLIC_APP_DOMAIN,
	defaultTitle: env.NEXT_PUBLIC_APP_NAME,
	defaultDescription: 'Site description goes here.',
	defaultKeywords: ['keyword1', 'keyword2'],
	author: env.NEXT_PUBLIC_APP_NAME,
	locale: 'en_US',
	type: 'website' as const,
	twitter: {
		site: `@${env.NEXT_PUBLIC_APP_NAME}`,
		creator: `@${env.NEXT_PUBLIC_APP_NAME}`,
		card: 'summary_large_image' as const,
	},
	verification: {
		google: env.NEXT_PUBLIC_GTAG_ID,
	},
	robots: {
		index: true,
		follow: true,
		googleBot: {
			index: true,
			follow: true,
			'max-video-preview': -1,
			'max-image-preview': 'large' as const,
			'max-snippet': -1,
		},
	},
	openGraph: {
		type: 'website' as const,
		siteName: env.NEXT_PUBLIC_APP_NAME,
		locale: 'en_US',
		images: {
			width: 1200,
			height: 630,
			alt: `${env.NEXT_PUBLIC_APP_NAME} - Open Graph Image`,
		},
	},
} as const;
export const SOCIAL_IMAGE_SIZES = {
	openGraph: {
		width: 1200,
		height: 630,
	},
	twitter: {
		width: 1200,
		height: 630,
	},
	defaultIcon: {
		width: 32,
		height: 32,
	},
	appleIcon: {
		width: 180,
		height: 180,
	},
} as const;
export const METADATA_PATHS = {
	openGraphImage: '/opengraph-image',
	twitterImage: '/twitter-image',
	favicon: '/favicon.ico',
	icon: '/icon',
	appleIcon: '/apple-icon',
	manifest: '/manifest.json',
	sitemap: '/sitemap.xml',
	robots: '/robots.txt',
} as const;
</file>

<file path="src/lib/metadata/data-fetching.ts">
export const metadataDataFetchingReady = true;
</file>

<file path="src/lib/metadata/icon-graphics.ts">
import type { CSSProperties, ReactElement } from 'react';
import { createElement } from 'react';
const DEFAULT_GRADIENT =
	'linear-gradient(to top right, hsl(0 0% 4%), hsl(0 0% 96%))';
interface GradientIconElementOptions {
	background?: string;
	circleScale?: number;
	borderColor?: string;
	borderWidth?: number;
}
export function createGradientIconElement({
	background = 'transparent',
	circleScale = 0.84,
	borderColor,
	borderWidth = 0,
}: GradientIconElementOptions = {}): ReactElement {
	const containerStyle: CSSProperties = {
		width: '100%',
		height: '100%',
		display: 'flex',
		alignItems: 'center',
		justifyContent: 'center',
		background,
	};
	const circleSize = `${Math.min(Math.max(circleScale, 0.1), 1) * 100}%`;
	const circleStyle: CSSProperties = {
		width: circleSize,
		height: circleSize,
		borderRadius: '50%',
		background: DEFAULT_GRADIENT,
	};
	if (borderColor && borderWidth > 0) {
		circleStyle.border = `${borderWidth}px solid ${borderColor}`;
	}
	return createElement(
		'div',
		{ style: containerStyle },
		createElement('div', { style: circleStyle }),
	);
}
</file>

<file path="src/lib/metadata/index.ts">
export { DEFAULT_METADATA, METADATA_PATHS, SOCIAL_IMAGE_SIZES } from './config';
export {
	createBreadcrumbStructuredData,
	createJobPostingStructuredData,
	createOrganizationStructuredData,
	createWebSiteStructuredData,
} from './structured-data';
</file>

<file path="src/lib/metadata/structured-data.ts">
import { DEFAULT_METADATA } from './config';
export interface OrganizationStructuredData {
	'@context': 'https://schema.org';
	'@type': 'Organization';
	name: string;
	url: string;
	description: string;
	logo?: string;
	sameAs?: string[];
}
export interface WebSiteStructuredData {
	'@context': 'https://schema.org';
	'@type': 'WebSite';
	name: string;
	url: string;
	description: string;
	potentialAction?: {
		'@type': 'SearchAction';
		target: string;
		'query-input': string;
	};
}
export interface JobPostingStructuredData {
	'@context': 'https://schema.org';
	'@type': 'JobPosting';
	title: string;
	description: string;
	hiringOrganization: {
		'@type': 'Organization';
		name: string;
	};
	jobLocation?: {
		'@type': 'Place';
		address?: string;
	};
	datePosted?: string;
	validThrough?: string;
	employmentType?: string;
	baseSalary?: {
		'@type': 'MonetaryAmount';
		currency: string;
		value: {
			'@type': 'QuantitativeValue';
			value: number | string;
		};
	};
}
export interface BreadcrumbStructuredData {
	'@context': 'https://schema.org';
	'@type': 'BreadcrumbList';
	itemListElement: Array<{
		'@type': 'ListItem';
		position: number;
		name: string;
		item: string;
	}>;
}
export function createOrganizationStructuredData(): OrganizationStructuredData {
	return {
		'@context': 'https://schema.org',
		'@type': 'Organization',
		name: DEFAULT_METADATA.siteName,
		url: DEFAULT_METADATA.siteUrl,
		description: DEFAULT_METADATA.defaultDescription,
		logo: `${DEFAULT_METADATA.siteUrl}/icon?size=512`,
		sameAs: [
		],
	};
}
export function createWebSiteStructuredData(): WebSiteStructuredData {
	return {
		'@context': 'https://schema.org',
		'@type': 'WebSite',
		name: DEFAULT_METADATA.siteName,
		url: DEFAULT_METADATA.siteUrl,
		description: DEFAULT_METADATA.defaultDescription,
		potentialAction: {
			'@type': 'SearchAction',
			target: `${DEFAULT_METADATA.siteUrl}/jobs?q={search_term_string}`,
			'query-input': 'required name=search_term_string',
		},
	};
}
export function createJobPostingStructuredData(jobData: {
	title: string;
	description: string;
	company: string;
	location?: string;
	datePosted?: string;
	validThrough?: string;
	employmentType?: string;
	salary?: {
		currency: string;
		value: number | string;
	};
}): JobPostingStructuredData {
	const structuredData: JobPostingStructuredData = {
		'@context': 'https://schema.org',
		'@type': 'JobPosting',
		title: jobData.title,
		description: jobData.description,
		hiringOrganization: {
			'@type': 'Organization',
			name: jobData.company,
		},
	};
	if (jobData.location) {
		structuredData.jobLocation = {
			'@type': 'Place',
			address: jobData.location,
		};
	}
	if (jobData.datePosted) {
		structuredData.datePosted = jobData.datePosted;
	}
	if (jobData.validThrough) {
		structuredData.validThrough = jobData.validThrough;
	}
	if (jobData.employmentType) {
		structuredData.employmentType = jobData.employmentType;
	}
	if (jobData.salary) {
		structuredData.baseSalary = {
			'@type': 'MonetaryAmount',
			currency: jobData.salary.currency,
			value: {
				'@type': 'QuantitativeValue',
				value: jobData.salary.value,
			},
		};
	}
	return structuredData;
}
export function createBreadcrumbStructuredData(
	breadcrumbs: Array<{ name: string; url: string }>,
): BreadcrumbStructuredData {
	return {
		'@context': 'https://schema.org',
		'@type': 'BreadcrumbList',
		itemListElement: breadcrumbs.map((breadcrumb, index) => ({
			'@type': 'ListItem',
			position: index + 1,
			name: breadcrumb.name,
			item: `${DEFAULT_METADATA.siteUrl}${breadcrumb.url}`,
		})),
	};
}
</file>

<file path="src/lib/proxy/helpers/app.helpers.ts">
import type { Route } from '@/lib/core/types/routes';
import { UserRole } from '@/prisma/site/.generated/enums';
import { routes } from '@/routes';
import type { NextRequest } from 'next/server';
import { NextResponse } from 'next/server';
import { createRouteMatcher } from '../utils/route-matcher';
const REDIRECT_PATHS = ['/get-started'];
function findRouteConfig(pathname: string): Route | undefined {
	return routes.find((route) => {
		const routeRegExp = createRouteMatcher(route.path);
		return routeRegExp.test(pathname);
	});
}
function requiresOnboarding(pathname: string): boolean {
	const routeConfig = findRouteConfig(pathname);
	return routeConfig?.onboardingCompleteRequired === true;
}
function isRouteAccessibleForRole(
	pathname: string,
	userRole: UserRole,
): boolean {
	if (userRole === UserRole.ADMIN) {
		if (pathname.startsWith('/admin')) {
			return true;
		}
	}
	const routeConfig = findRouteConfig(pathname);
	if (!routeConfig) {
		return true;
	}
	const roleToRouteType: Record<UserRole, Route['type'][]> = {
		[UserRole.USER]: ['public', 'private'],
		[UserRole.ADMIN]: ['public', 'private', 'admin'],
	};
	const allowedTypes = roleToRouteType[userRole] || ['public'];
	return allowedTypes.includes(routeConfig.type);
}
function handleSignedInRedirection(
	pathname: string,
	req: NextRequest,
): NextResponse | null {
	if (REDIRECT_PATHS.includes(pathname)) {
		return NextResponse.redirect(new URL('/', req.url));
	}
	return null;
}
export function handleSignedInUser(
	userRole: UserRole,
	pathname: string,
	req: NextRequest,
	isOnboardingComplete: boolean,
): NextResponse {
	const redirectResponse = handleSignedInRedirection(pathname, req);
	if (redirectResponse) return redirectResponse;
	if (!isOnboardingComplete && pathname !== '/onboarding') {
		if (requiresOnboarding(pathname)) {
			if (process.env.NODE_ENV === 'development') {
				console.log(
					`Redirecting to onboarding from ${pathname} - onboarding not complete`,
				);
			}
			return NextResponse.redirect(new URL('/onboarding', req.url));
		}
	}
	if (isOnboardingComplete && pathname === '/onboarding') {
		if (process.env.NODE_ENV === 'development') {
			console.log(
				'User has completed onboarding, redirecting from /onboarding to home',
			);
		}
		return NextResponse.redirect(new URL('/', req.url));
	}
	if (isRouteAccessibleForRole(pathname, userRole)) {
		return NextResponse.next();
	}
	return NextResponse.redirect(new URL('/not-found', req.url));
}
export function handleSignedOutUser(
	pathname: string,
	req: NextRequest,
): NextResponse {
	if (pathname === '/onboarding') {
		if (process.env.NODE_ENV === 'development') {
			console.log(
				'Unauthenticated user trying to access /onboarding, redirecting to /get-started',
			);
		}
		const redirectUrl = new URL('/get-started', req.url);
		redirectUrl.searchParams.set('redirectTo', pathname);
		return NextResponse.redirect(redirectUrl);
	}
	const routeConfig = findRouteConfig(pathname);
	if (!routeConfig) {
		return NextResponse.next();
	}
	if (routeConfig.type !== 'public') {
		const redirectUrl = new URL('/get-started', req.url);
		redirectUrl.searchParams.set('redirectTo', pathname);
		return NextResponse.redirect(redirectUrl);
	}
	return NextResponse.next();
}
</file>

<file path="src/lib/proxy/helpers/index.ts">
export * from './app.helpers';
</file>

<file path="src/lib/proxy/utils/detect-bot.ts">
import type { NextRequest } from 'next/server';
export const detectBot = (req: NextRequest): boolean => {
	const url = req.nextUrl;
	if (url.searchParams.get('bot')) return true;
	const ua = req.headers.get('User-Agent') || '';
	// List of bot identifiers
	const botPatterns = [
		'bot',
		'chatgpt',
		'facebookexternalhit',
		'whatsapp',
		'google',
		'baidu',
		'bing',
		'msn',
		'duckduckbot',
		'teoma',
		'slurp',
		'yandex',
		'metainspector',
		'go-http-client',
		'iframely',
	];
	return botPatterns.some((pattern) =>
		ua.toLowerCase().includes(pattern.toLowerCase()),
	);
};
</file>

<file path="src/lib/proxy/utils/get-user-via-token.ts">
import env from '@/env';
import type { JWT } from 'next-auth/jwt';
import { getToken } from 'next-auth/jwt';
import type { NextRequest } from 'next/server';
export async function getUserViaToken(req: NextRequest): Promise<JWT | null> {
	const session = await getToken({
		req,
		secret: env.NEXTAUTH_SECRET,
	});
	return session;
}
</file>

<file path="src/lib/proxy/utils/get-valid-subdomain.ts">
export const getValidSubdomain = (host?: string | null): string | null => {
	let subdomain: string | null = null;
	if (!host && typeof window !== 'undefined') {
		host = window.location.host;
	}
	if (host && host.includes('.')) {
		const candidate = host.split('.')[0];
		if (candidate && !candidate.includes('localhost')) {
			subdomain = candidate;
		}
	}
	return subdomain;
};
</file>

<file path="src/lib/proxy/utils/index.ts">
export * from './detect-bot';
export * from './get-user-via-token';
export * from './get-valid-subdomain';
export * from './parse';
export * from './route-matcher';
</file>

<file path="src/lib/proxy/utils/parse.ts">
import type { NextRequest } from 'next/server';
interface ParsedRequest {
	domain: string;
	path: string;
	fullPath: string;
	key: string;
	fullKey: string;
	searchParamsString: string;
}
export const parse = (req: NextRequest): ParsedRequest => {
	let domain = req.headers.get('host') as string;
	domain = domain.replace('www.', '').toLowerCase();
	let path = req.nextUrl.pathname;
	// fullPath is the full URL path (along with search params)
	const searchParams = req.nextUrl.searchParams.toString();
	const searchParamsString =
		searchParams.length > 0 ? `?${searchParams}` : '';
	const fullPath = `${path}${searchParamsString}`;
	// Here, we are using decodeURIComponent to handle foreign languages like Hebrew
	const key = decodeURIComponent(path.split('/')[1] || '');
	const fullKey = decodeURIComponent(path.slice(1));
	return { domain, path, fullPath, key, fullKey, searchParamsString };
};
</file>

<file path="src/lib/proxy/utils/route-matcher.ts">
export function createRouteMatcher(routePath: string): RegExp {
	const pattern = routePath
		.replace(/\/:\w+\*/g, '(?:/.*)?')
		.replace(/\/:\w+/g, '/[^/]+');
	return new RegExp(`^${pattern}$`);
}
</file>

<file path="src/lib/proxy/utils/session-handler.ts">
import tryCatch from '@/lib/core/utils/try-catch';
import type { NextRequest } from 'next/server';
import { NextResponse } from 'next/server';
import { getUserViaToken } from './get-user-via-token';
interface SessionValidationResult {
	isValid: boolean;
	shouldRedirect: boolean;
	redirectUrl?: string;
	user?: {
		id: string;
		email: string;
		name: string;
		role?: string;
		onboardingCompleted?: boolean;
	};
}
export async function validateProxySession(
	req: NextRequest,
): Promise<SessionValidationResult> {
	const { data: token, error } = await tryCatch(getUserViaToken(req));
	if (error) {
		const errorMessage =
			error instanceof Error ? error.message : 'Unknown error';
		console.error('Proxy session validation error:', errorMessage);
		return {
			isValid: false,
			shouldRedirect: true,
			redirectUrl: generateRedirectUrl(req, 'Session validation failed'),
		};
	}
	if (!token) {
		return {
			isValid: false,
			shouldRedirect: false,
		};
	}
	if (
		!token.sub ||
		typeof token.sub !== 'string' ||
		token.sub.trim() === ''
	) {
		return {
			isValid: false,
			shouldRedirect: true,
			redirectUrl: generateRedirectUrl(req, 'Invalid user ID'),
		};
	}
	if (
		!token.email ||
		typeof token.email !== 'string' ||
		token.email.trim() === ''
	) {
		return {
			isValid: false,
			shouldRedirect: true,
			redirectUrl: generateRedirectUrl(req, 'Invalid email'),
		};
	}
	return {
		isValid: true,
		shouldRedirect: false,
		user: {
			id: token.sub,
			email: token.email,
			name: token.name || '',
			role: token.role as string,
			onboardingCompleted: token.onboardingCompleted as boolean,
		},
	};
}
/**
 * Handles invalid session by clearing cookies and redirecting
 *
 * @param req - The Next.js request object
 * @param result - The session validation result
 * @returns NextResponse with redirect and cleared cookies
 */
export function handleInvalidSession(
	req: NextRequest,
	result: SessionValidationResult,
): NextResponse {
	if (!result.shouldRedirect || !result.redirectUrl) {
		// If no redirect needed, just continue with the request
		return NextResponse.next();
	}
	// Create redirect response
	const response = NextResponse.redirect(
		new URL(result.redirectUrl, req.url),
	);
	// Clear NextAuth session cookies
	const cookiesToClear = [
		'next-auth.session-token',
		'__Secure-next-auth.session-token',
		'next-auth.csrf-token',
		'__Host-next-auth.csrf-token',
		'next-auth.callback-url',
		'__Secure-next-auth.callback-url',
	];
	cookiesToClear.forEach((cookieName) => {
		response.cookies.set(cookieName, '', {
			expires: new Date(0),
			path: '/',
			domain: undefined,
			secure: process.env.NODE_ENV === 'production',
			httpOnly: true,
			sameSite: 'lax',
		});
	});
	return response;
}
function generateRedirectUrl(req: NextRequest, reason?: string): string {
	const currentPath = req.nextUrl.pathname + req.nextUrl.search;
	const authPages = ['/get-started', '/sign-in', '/sign-up', '/auth'];
	const isAuthPage = authPages.some((page) => currentPath.startsWith(page));
	const isApiRoute = currentPath.startsWith('/api');
	if (isAuthPage || isApiRoute || currentPath === '/') {
		return '/get-started';
	}
	const redirectUrl = `/get-started?redirectTo=${encodeURIComponent(currentPath)}`;
	if (reason && process.env.NODE_ENV === 'development') {
		console.log(
			`Session invalidation in proxy: ${reason} - redirecting to ${redirectUrl}`,
		);
	}
	return redirectUrl;
}
export function requiresAuthentication(pathname: string): boolean {
	const publicPaths = [
		'/get-started',
		'/sign-in',
		'/sign-up',
		'/auth',
		'/api/auth',
		'/_next',
		'/_static',
		'/_vercel',
		'/favicon.ico',
		'/robots.txt',
		'/sitemap.xml',
	];
	return !publicPaths.some((publicPath) => pathname.startsWith(publicPath));
}
</file>

<file path="src/lib/proxy/app.ts">
import { UserRole } from '@/prisma/site/.generated/enums';
import type { NextRequest } from 'next/server';
import { NextResponse } from 'next/server';
import { handleSignedInUser, handleSignedOutUser } from './helpers';
import { getUserViaToken } from './utils';
import {
	handleInvalidSession,
	requiresAuthentication,
	validateProxySession,
} from './utils/session-handler';
interface UserState {
	isAuthenticated: boolean;
	isOnboardingComplete: boolean;
	role?: UserRole;
}
async function getUserState(req: NextRequest): Promise<UserState> {
	const token = await getUserViaToken(req);
	return {
		isAuthenticated: !!token,
		isOnboardingComplete: token?.onboardingCompleted === true,
		role: token?.role as UserRole | undefined,
	};
}
export default async function proxy(req: NextRequest) {
	const { pathname } = req.nextUrl;
	const isDevelopment = process.env.NODE_ENV === 'development';
	if (pathname.startsWith('/admin')) {
		if (isDevelopment) {
			console.log(
				`Admin route detected: ${pathname}, env: ${process.env.NODE_ENV}`,
			);
		}
		if (!isDevelopment) {
			if (isDevelopment) {
				console.warn(
					'Admin routes are only available in development environments',
				);
			}
			return NextResponse.redirect(new URL('/not-found', req.url));
		}
		const sessionResult = await validateProxySession(req);
		if (!sessionResult.isValid) {
			if (isDevelopment) {
				console.warn(`Invalid session for admin route: ${pathname}`);
			}
			return handleInvalidSession(req, sessionResult);
		}
		if (sessionResult.user?.role !== UserRole.ADMIN) {
			if (isDevelopment) {
				console.warn(
					`Unauthorized access attempt to admin route by ${sessionResult.user?.role} user: ${pathname}`,
				);
			}
			return NextResponse.redirect(new URL('/not-found', req.url));
		}
		if (isDevelopment) {
			console.log(`Admin access granted to ${pathname}`);
		}
		return NextResponse.next();
	}
	if (requiresAuthentication(pathname)) {
		const sessionResult = await validateProxySession(req);
		if (!sessionResult.isValid && sessionResult.shouldRedirect) {
			if (isDevelopment) {
				console.warn(
					`Invalid session detected for protected route: ${pathname}`,
				);
			}
			return handleInvalidSession(req, sessionResult);
		}
	}
	const userState = await getUserState(req);
	if (userState.isAuthenticated && userState.role) {
		return handleSignedInUser(
			userState.role,
			pathname,
			req,
			userState.isOnboardingComplete,
		);
	}
	return handleSignedOutUser(pathname, req);
}
</file>

<file path="src/lib/proxy/index.ts">
export { default as AppProxy } from './app';
</file>

<file path="src/lib/redis/client.ts">
import env from '@/env';
import { Redis } from '@upstash/redis';
export const redis = new Redis({
	url: env.UPSTASH_REDIS_REST_URL,
	token: env.UPSTASH_REDIS_REST_TOKEN,
});
</file>

<file path="src/lib/ui/header-actions.ts">
import type { ComponentType, LazyExoticComponent } from 'react';
export type RouteMatcher = (pathname: string) => boolean;
export interface HeaderActionConfig {
	routeMatcher: RouteMatcher | string;
}
export interface HeaderActionDefinition<P = Record<string, never>> {
	Component: LazyExoticComponent<ComponentType<P>>;
	config: HeaderActionConfig;
}
export function createHeaderActionDefinition<P = Record<string, never>>(
	definition: HeaderActionDefinition<P>,
): HeaderActionDefinition<P> {
	return definition;
}
export function normalizeRouteMatcher(
	matcher: RouteMatcher | string,
): RouteMatcher {
	if (typeof matcher === 'string') {
		return (pathname: string) => pathname.startsWith(matcher);
	}
	return matcher;
}
</file>

<file path="src/lib/ui/index.ts">
export * from './modals';
</file>

<file path="src/lib/ui/modals.ts">
import type { ComponentType, LazyExoticComponent } from 'react';
export interface ModalConfig {
	size?: 'sm' | 'md' | 'lg' | 'full';
	preventEscapeClose?: boolean;
	preventClickOutsideClose?: boolean;
	desktopOnly?: boolean;
	className?: string;
	title?: string;
	description?: string;
}
export interface ModalDefinition<P = Record<string, never>> {
	Component: LazyExoticComponent<ComponentType<P>>;
	defaultConfig?: ModalConfig;
}
export function createModalDefinition<P = Record<string, never>>(
	definition: ModalDefinition<P>,
): ModalDefinition<P> {
	return definition;
}
</file>

<file path="src/modals/modal-footer-actions.tsx">
'use client';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/core/utils';
import React from 'react';
type ModalActionPriority = 'primary' | 'secondary' | 'tertiary';
interface ModalAction {
	label: string;
	onClick: () => void;
	variant?:
		| 'default'
		| 'destructive'
		| 'outline'
		| 'secondary'
		| 'ghost'
		| 'none'
		| 'link';
	disabled?: boolean;
	loading?: boolean;
	'aria-label'?: string;
	size?: 'default' | 'sm' | 'lg' | 'icon' | 'none';
	fullWidth?: boolean;
	priority?: ModalActionPriority;
}
interface ModalFooterActionsProps {
	actions: ModalAction[];
	layout?: 'default' | 'reverse' | 'center' | 'spread' | 'stack';
	className?: string;
	fullWidth?: boolean;
}
export const ModalFooterActions: React.FC<ModalFooterActionsProps> = ({
	actions,
	layout = 'default',
	className,
	fullWidth = false,
}) => {
	if (actions.length === 0) {
		return null;
	}
	const priorityOrder: Record<ModalActionPriority, number> = {
		tertiary: 0,
		secondary: 1,
		primary: 2,
	};
	const prioritizedActions = actions.slice().sort((actionA, actionB) => {
		const aPriority = priorityOrder[actionA.priority ?? 'secondary'];
		const bPriority = priorityOrder[actionB.priority ?? 'secondary'];
		return aPriority - bPriority;
	});
	const actionsToRender =
		layout === 'reverse'
			? [...prioritizedActions].reverse()
			: prioritizedActions;
	const getContainerClasses = () => {
		const baseClasses = 'flex items-center';
		switch (layout) {
			case 'stack':
				return cn(baseClasses, 'flex-col gap-2', className);
			case 'center':
				return cn(
					baseClasses,
					'justify-center gap-3 flex-wrap sm:flex-nowrap',
					className,
				);
			case 'spread':
				return cn(
					baseClasses,
					'justify-between gap-3 flex-wrap sm:flex-nowrap',
					className,
				);
			case 'reverse':
			case 'default':
			default:
				return cn(
					baseClasses,
					'justify-end gap-3 flex-wrap sm:flex-nowrap',
					className,
				);
		}
	};
	const getButtonClasses = (action: ModalAction) => {
		const classes = [];
		if (action.loading) {
			classes.push('opacity-50');
		}
		if (layout === 'stack' && (fullWidth || action.fullWidth)) {
			classes.push('w-full');
		}
		if (layout === 'spread' && fullWidth) {
			classes.push('flex-1');
		}
		if (layout !== 'stack') {
			classes.push('min-w-0 flex-shrink-0');
		}
		return cn(...classes);
	};
	const getButtonVariant = (action: ModalAction) => {
		if (action.variant) {
			return action.variant;
		}
		const priority = action.priority ?? 'secondary';
		if (priority === 'primary') {
			return 'default';
		}
		return 'outline';
	};
	return (
		<div className={getContainerClasses()}>
			{actionsToRender.map((action, index) => (
				<Button
					key={`${action.label}-${index}`}
					variant={getButtonVariant(action)}
					onClick={action.onClick}
					disabled={action.disabled || action.loading}
					loading={action.loading}
					aria-label={action['aria-label'] || action.label}
					size={action.size}
					className={getButtonClasses(action)}
				>
					{action.label}
				</Button>
			))}
		</div>
	);
};
export type { ModalAction, ModalActionPriority, ModalFooterActionsProps };
</file>

<file path="src/modals/modal-layout.tsx">
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { ModalBody, ModalFooter, ModalHeader } from '@/modals/responsive-modal';
import React from 'react';
interface ModalLayoutProps {
	children?: React.ReactNode;
	title: string;
	description: string;
	displayImage: {
		src?: string;
		alt?: string;
		type?: 'icon' | 'image';
		iconText?: string;
	};
	footer?: React.ReactNode;
	showCloseButton?: boolean;
}
const ModalLayout = (props: ModalLayoutProps) => {
	const {
		title,
		description,
		displayImage,
		children,
		footer,
		showCloseButton = true,
	} = props;
	return (
		<>
			<ModalBody className='space-y-6'>
				<ModalHeader showCloseButton={showCloseButton}>
					<div className='flex flex-col items-center justify-center space-y-1 py-1'>
						{displayImage.type === 'icon' ? (
							<span className='border flex size-10 items-center justify-center rounded-full bg-muted'>
								<h2 className='text-xl font-semibold capitalize'>
									{displayImage.iconText}
								</h2>
							</span>
						) : (
							<Avatar className='size-10'>
								<AvatarImage
									src={displayImage.src as string}
									referrerPolicy='no-referrer'
									className='pointer-events-none'
								/>
								<AvatarFallback>
									{displayImage.alt?.slice(0, 2)}
								</AvatarFallback>
							</Avatar>
						)}
						<h3 className='text-lg font-medium'>{title}</h3>
						<p className='text-center text-xs text-muted-foreground md:text-sm'>
							{description}
						</p>
					</div>
				</ModalHeader>
				{children}
			</ModalBody>
			{footer && <ModalFooter>{footer}</ModalFooter>}
		</>
	);
};
export default ModalLayout;
export type { ModalLayoutProps };
</file>

<file path="src/modals/modal-provider.tsx">
'use client';
import SuspenseWrapper from '@/components/suspense-wrapper';
import LoadingSpinner from '@/components/ui/loading/loading-spinner';
import { useModalStore } from '@/zustand/ui/useModalStore';
import { ResponsiveModal } from '@/modals/responsive-modal';
import { modalRegistry } from '@/modals/registry';
const ModalProvider = () => {
	const { activeModal, hide } = useModalStore();
	const renderActiveModal = () => {
		if (!activeModal) return null;
		const definition = modalRegistry[activeModal.key];
		if (!definition) {
			console.warn(
				`Modal with key "${activeModal.key}" not found in registry.`,
			);
			return null;
		}
		const { Component } = definition;
		return <Component {...(activeModal.props as any)} />;
	};
	const getModalConfig = () => {
		if (!activeModal) return {};
		const definition = modalRegistry[activeModal.key];
		const defaultConfig = definition?.defaultConfig || {};
		const runtimeConfig = activeModal.config || {};
		return {
			...defaultConfig,
			...runtimeConfig,
		};
	};
	const config = getModalConfig();
	return (
		<ResponsiveModal
			isOpen={!!activeModal}
			onClose={hide}
			size={config.size}
			preventEscapeClose={config.preventEscapeClose}
			preventClickOutsideClose={config.preventClickOutsideClose}
			desktopOnly={config.desktopOnly}
			className={config.className}
			title={config.title}
			description={config.description}
		>
			<SuspenseWrapper
				skeleton={
					<div className='flex items-center justify-center p-14'>
						<LoadingSpinner size={24} />
					</div>
				}
			>
				{renderActiveModal()}
			</SuspenseWrapper>
		</ResponsiveModal>
	);
};
export default ModalProvider;
</file>

<file path="src/modals/responsive-modal.tsx">
'use client';
import { Button } from '@/components/ui/button';
import { useMediaQuery } from '@/hooks';
import { cn } from '@/lib/core/utils';
import * as Dialog from '@radix-ui/react-dialog';
import { VisuallyHidden } from '@radix-ui/react-visually-hidden';
import React, {
	createContext,
	useCallback,
	useContext,
	useEffect,
	useState,
} from 'react';
import { LuX } from 'react-icons/lu';
import { Drawer } from 'vaul';
interface ModalContextType {
	isMobile: boolean;
	onClose: () => void;
}
const ModalContext = createContext<ModalContextType | undefined>(undefined);
const useModalContext = () => {
	const context = useContext(ModalContext);
	if (!context) {
		throw new Error('Modal components must be used within ResponsiveModal');
	}
	return context;
};
interface ResponsiveModalProps {
	children: React.ReactNode;
	className?: string;
	title?: string;
	description?: string;
	isOpen: boolean;
	onClose: () => void;
	preventEscapeClose?: boolean;
	preventClickOutsideClose?: boolean;
	desktopOnly?: boolean;
	size?: 'sm' | 'md' | 'lg' | 'full';
	footer?: React.ReactNode;
}
const sizeClasses = {
	sm: 'max-w-sm',
	md: 'max-w-lg',
	lg: 'max-w-2xl',
	full: 'max-w-full',
};
interface ModalHeaderProps {
	children: React.ReactNode;
	className?: string;
	showCloseButton?: boolean;
}
export const ModalHeader: React.FC<ModalHeaderProps> = ({
	children,
	className,
	showCloseButton = true,
}) => {
	const { isMobile, onClose } = useModalContext();
	return (
		<div
			className={cn(
				'border-b relative border-border bg-background',
				isMobile ? 'px-4 py-4' : 'px-6 py-6',
				className,
			)}
		>
			{}
			<div className='w-full'>{children}</div>
			{}
			{showCloseButton && !isMobile && (
				<Button
					className='absolute right-0 top-0'
					onClick={onClose}
					aria-label='Close modal'
					variant='ghost'
					size='icon'
					icon={<LuX className='size-4' />}
				/>
			)}
		</div>
	);
};
interface ModalBodyProps {
	children: React.ReactNode;
	className?: string;
	scrollable?: boolean;
}
export const ModalBody: React.FC<ModalBodyProps> = ({
	children,
	className,
	scrollable = true,
}) => {
	const { isMobile } = useModalContext();
	return (
		<div
			className={cn(
				'flex-1',
				scrollable && 'overflow-y-auto',
				isMobile ? 'px-4 py-4' : 'px-6 py-4',
				className,
			)}
		>
			{children}
		</div>
	);
};
interface ModalFooterProps {
	children: React.ReactNode;
	className?: string;
	borderTop?: boolean;
}
export const ModalFooter: React.FC<ModalFooterProps> = ({
	children,
	className,
	borderTop = true,
}) => {
	const { isMobile } = useModalContext();
	return (
		<div
			className={cn(
				'sticky bottom-0 z-20 bg-background',
				borderTop && 'border-t border-border',
				isMobile ? 'p-4' : 'p-6',
				className,
			)}
		>
			{children}
		</div>
	);
};
export const ResponsiveModal: React.FC<ResponsiveModalProps> = ({
	children,
	className,
	title = 'Modal',
	description,
	isOpen,
	onClose,
	preventEscapeClose = false,
	preventClickOutsideClose = false,
	desktopOnly = false,
	size = 'md',
	footer,
}) => {
	const { isMobile } = useMediaQuery();
	const [isMounted, setIsMounted] = useState(false);
	useEffect(() => {
		setIsMounted(true);
	}, []);
	const handleOpenChange = useCallback(
		(open: boolean) => {
			if (!open && !preventEscapeClose) {
				onClose();
			}
		},
		[onClose, preventEscapeClose],
	);
	const handleOverlayClick = useCallback(
		(e: React.MouseEvent) => {
			if (!preventClickOutsideClose && e.target === e.currentTarget) {
				onClose();
			}
		},
		[onClose, preventClickOutsideClose],
	);
	if (!isMounted) {
		return null;
	}
	const contextValue: ModalContextType = {
		isMobile,
		onClose,
	};
	if (isMobile && !desktopOnly) {
		return (
			<ModalContext.Provider value={contextValue}>
				<Drawer.Root open={isOpen} onOpenChange={handleOpenChange}>
					<Drawer.Portal>
						<Drawer.Overlay
							className='fixed inset-0 z-50 bg-black/60 backdrop-blur-md'
							onClick={handleOverlayClick}
						/>
						<Drawer.Content
							className={cn(
								'border fixed bottom-0 left-0 right-0 z-50 flex flex-col rounded-t-lg border-border bg-background',
								footer
									? 'mt-[5dvh] h-[95dvh]'
									: 'mt-[5dvh] h-auto max-h-[95dvh]',
								className,
							)}
							onOpenAutoFocus={(e) => e.preventDefault()}
							onCloseAutoFocus={(e) => e.preventDefault()}
						>
							{title && (
								<VisuallyHidden>
									<Dialog.Title>{title}</Dialog.Title>
								</VisuallyHidden>
							)}
							{description && (
								<VisuallyHidden>
									<Dialog.Description>
										{description}
									</Dialog.Description>
								</VisuallyHidden>
							)}
							{}
							<div className='sticky top-0 z-30 flex w-full items-center justify-center rounded-t-lg bg-background pb-2 pt-3'>
								<div className='h-1 w-12 rounded-full bg-muted-foreground/50' />
							</div>
							{}
							<div className='flex min-h-0 flex-1 flex-col'>
								{children}
							</div>
							{}
							{footer && (
								<div className='border-t sticky bottom-0 z-20 border-border bg-background px-4 py-4'>
									{footer}
								</div>
							)}
						</Drawer.Content>
					</Drawer.Portal>
				</Drawer.Root>
			</ModalContext.Provider>
		);
	}
	return (
		<ModalContext.Provider value={contextValue}>
			<Dialog.Root open={isOpen} onOpenChange={handleOpenChange}>
				<Dialog.Portal>
					<Dialog.Overlay
						className='fixed inset-0 z-50 bg-black/60 backdrop-blur-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0'
						onClick={handleOverlayClick}
					/>
					<Dialog.Content
						className={cn(
							'border fixed left-[50%] top-[50%] z-50 flex w-full translate-x-[-50%] translate-y-[-50%] flex-col overflow-hidden rounded-lg border-border bg-background shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%]',
							footer ? 'max-h-[85vh]' : 'max-h-[90vh]',
							sizeClasses[size],
							className,
						)}
						onOpenAutoFocus={(e) => e.preventDefault()}
						onCloseAutoFocus={(e) => e.preventDefault()}
					>
						{title && (
							<VisuallyHidden>
								<Dialog.Title>{title}</Dialog.Title>
							</VisuallyHidden>
						)}
						{description && (
							<VisuallyHidden>
								<Dialog.Description>
									{description}
								</Dialog.Description>
							</VisuallyHidden>
						)}
						{}
						<div className='flex min-h-0 flex-1 flex-col'>
							{children}
						</div>
						{}
						{footer && (
							<div className='border-t sticky bottom-0 z-20 border-border bg-background px-6 py-6'>
								{footer}
							</div>
						)}
					</Dialog.Content>
				</Dialog.Portal>
			</Dialog.Root>
		</ModalContext.Provider>
	);
};
export type {
	ModalBodyProps,
	ModalFooterProps,
	ModalHeaderProps,
	ResponsiveModalProps,
};
</file>

<file path="src/providers/index.tsx">
import { Toaster } from '@/components/ui/sonner';
import { TooltipProvider } from '@/components/ui/tooltip';
import { getSession } from '@/lib/auth';
import ModalProvider from '@/modals/modal-provider';
import { TRPCReactProvider } from '@/trpc/react';
import SessionProvider from './session-provider';
import { ThemeProvider } from './theme-provider';
export const Providers = async ({
	children,
}: Readonly<{ children: React.ReactNode }>) => {
	const session = await getSession();
	return (
		<ThemeProvider
			attribute='class'
			defaultTheme='light'
			enableSystem
			disableTransitionOnChange
		>
			<TRPCReactProvider>
				<SessionProvider session={session}>
					<TooltipProvider>{children}</TooltipProvider>
					<ModalProvider />
				</SessionProvider>
				<Toaster />
			</TRPCReactProvider>
		</ThemeProvider>
	);
};
export default Providers;
</file>

<file path="src/providers/session-provider.tsx">
'use client';
import { SessionProvider } from 'next-auth/react';
export default SessionProvider;
</file>

<file path="src/providers/theme-provider.tsx">
'use client';
import { ThemeProvider as NextThemesProvider } from 'next-themes';
type ThemeProviderProps = React.ComponentProps<typeof NextThemesProvider>;
export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
	return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}
</file>

<file path="src/routes/account.ts">
import type { Route } from '@/lib/core/types/routes';
import { LuLayoutTemplate } from 'react-icons/lu';
const accountRoutes: Route[] = [
	{
		path: '/settings/:path*',
		displayPath: '/settings',
		type: 'private',
		displayName: 'Settings',
		category: 'ancillary',
	},
	{
		path: '/get-started',
		displayPath: '/get-started',
		type: 'public',
		displayName: 'Get Started',
		category: 'ancillary',
	},
	{
		path: '/onboarding',
		displayPath: '/onboarding',
		type: 'private',
		displayName: 'Onboarding',
		category: 'ancillary',
		status: 'soon',
	},
	{
		path: '/profile/:path*',
		displayPath: '/profile',
		type: 'private',
		displayName: 'Profile',
		category: 'ancillary',
		icon: LuLayoutTemplate,
		status: 'soon',
	},
];
export { accountRoutes };
</file>

<file path="src/routes/admin.ts">
import type { Route } from '@/lib/core/types/routes';
import { LuShield } from 'react-icons/lu';
const adminRoutes: Route[] = [
	{
		path: '/admin/:path*',
		type: 'admin',
		displayName: 'Admin',
		displayPath: '/admin',
		category: 'admin',
		icon: LuShield,
	},
];
export { adminRoutes };
</file>

<file path="src/routes/index.ts">
import type { Route } from '@/lib/core/types/routes';
import { accountRoutes } from './account';
import { adminRoutes } from './admin';
import { coreRoutes } from './core';
import { menubarRoutes } from './menubar';
const routes: Route[] = [
	...coreRoutes,
	...menubarRoutes,
	...accountRoutes,
	...adminRoutes,
];
const getRoutesByCategory = (category: Route['category']) => {
	return routes.filter((route) => route.category === category);
};
const ancillaryRoutes = routes.reduce(
	(acc, route) => {
		if (route.category === 'feature') {
			acc[route.displayName] = route;
		}
		return acc;
	},
	{} as Record<string, Route>,
);
export {
	accountRoutes,
	adminRoutes,
	ancillaryRoutes,
	coreRoutes,
	getRoutesByCategory,
	menubarRoutes,
	routes,
};
</file>

<file path="src/scripts/analytics.tsx">
import env from '@/env';
import { GoogleTagManager } from '@next/third-parties/google';
import { Analytics as VercelAnalytics } from '@vercel/analytics/react';
import Script from 'next/script';
export const Analytics = () => {
	return (
		process.env.NODE_ENV === 'production' && (
			<>
				{}
				<Script
					type='text/javascript'
					id='ms_clarity'
					dangerouslySetInnerHTML={{
						__html: `
		(function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
	})(window, document, "clarity", "script", "${env.NEXT_PUBLIC_CLARITY_PROJECT_ID}");
					`,
					}}
				/>
				{}
				<GoogleTagManager gtmId={env.NEXT_PUBLIC_GTAG_ID} />
				{}
				<VercelAnalytics />
			</>
		)
	);
};
export default Analytics;
</file>

<file path="src/scripts/index.ts">
export { default as Analytics } from './analytics';
</file>

<file path="src/styles/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
@keyframes comment-highlight {
	0% {
		background-color: hsl(var(--primary) / 0.1);
	}
	100% {
		background-color: transparent;
	}
}
.comment-highlight {
	animation: comment-highlight 2s ease-out;
	border-radius: 0.75rem 0 0 0;
}
@layer base {
	:root {
		--background: 0 0% 100%;
		--foreground: 20 14.3% 4.1%;
		--card: 0 0% 100%;
		--card-foreground: 20 14.3% 4.1%;
		--popover: 0 0% 100%;
		--popover-foreground: 20 14.3% 4.1%;
		--primary: 24 9.8% 10%;
		--primary-foreground: 60 9.1% 97.8%;
		--secondary: 60 4.8% 95.9%;
		--secondary-foreground: 24 9.8% 10%;
		--muted: 60 4.8% 95.9%;
		--muted-foreground: 25 5.3% 44.7%;
		--accent: 60 4.8% 95.9%;
		--accent-foreground: 24 9.8% 10%;
		--destructive: 0 84.2% 60.2%;
		--destructive-foreground: 60 9.1% 97.8%;
		--border: 20 5.9% 90%;
		--input: 20 5.9% 90%;
		--ring: 20 14.3% 4.1%;
		--radius: 0.75rem;
		--sidebar-background: 0 0% 98%;
		--sidebar-foreground: 240 5.3% 26.1%;
		--sidebar-primary: 240 5.9% 10%;
		--sidebar-primary-foreground: 0 0% 98%;
		--sidebar-accent: 240 4.8% 95.9%;
		--sidebar-accent-foreground: 240 5.9% 10%;
		--sidebar-border: 220 13% 91%;
		--sidebar-ring: 217.2 91.2% 59.8%;
	}
	.dark {
		--background: 20 14.3% 4.1%;
		--foreground: 60 9.1% 97.8%;
		--card: 20 14.3% 4.1%;
		--card-foreground: 60 9.1% 97.8%;
		--popover: 20 14.3% 4.1%;
		--popover-foreground: 60 9.1% 97.8%;
		--primary: 60 9.1% 97.8%;
		--primary-foreground: 24 9.8% 10%;
		--secondary: 12 6.5% 15.1%;
		--secondary-foreground: 60 9.1% 97.8%;
		--muted: 12 6.5% 15.1%;
		--muted-foreground: 24 5.4% 63.9%;
		--accent: 12 6.5% 15.1%;
		--accent-foreground: 60 9.1% 97.8%;
		--destructive: 0 62.8% 30.6%;
		--destructive-foreground: 60 9.1% 97.8%;
		--border: 12 6.5% 15.1%;
		--input: 12 6.5% 15.1%;
		--ring: 24 5.7% 82.9%;
		--sidebar-background: 240 5.9% 10%;
		--sidebar-foreground: 240 4.8% 95.9%;
		--sidebar-primary: 224.3 76.3% 48%;
		--sidebar-primary-foreground: 0 0% 100%;
		--sidebar-accent: 240 3.7% 15.9%;
		--sidebar-accent-foreground: 240 4.8% 95.9%;
		--sidebar-border: 240 3.7% 15.9%;
		--sidebar-ring: 217.2 91.2% 59.8%;
	}
}
</file>

<file path="src/trpc/server/api/site/errors.ts">
import { TRPC_ERROR_MESSAGES } from '@/lib/core/errors/error-messages';
import type { TRPC_ERROR_CODE_KEY } from '@trpc/server/rpc';
import { errorCode } from './trpc';
const throwError = (code: TRPC_ERROR_CODE_KEY, message?: string): never => {
	throw new errorCode({
		code,
		message: message ?? TRPC_ERROR_MESSAGES[code],
	});
};
const createErrorThrower =
	(code: TRPC_ERROR_CODE_KEY) =>
	(message?: string): never =>
		throwError(code, message);
export class TRPCThrow {
	static parseError = createErrorThrower('PARSE_ERROR');
	static badRequest = createErrorThrower('BAD_REQUEST');
	static internalError = createErrorThrower('INTERNAL_SERVER_ERROR');
	static notImplemented = createErrorThrower('NOT_IMPLEMENTED');
	static badGateway = createErrorThrower('BAD_GATEWAY');
	static serviceUnavailable = createErrorThrower('SERVICE_UNAVAILABLE');
	static gatewayTimeout = createErrorThrower('GATEWAY_TIMEOUT');
	static unauthorized = createErrorThrower('UNAUTHORIZED');
	static paymentRequired = createErrorThrower('PAYMENT_REQUIRED');
	static forbidden = createErrorThrower('FORBIDDEN');
	static notFound = createErrorThrower('NOT_FOUND');
	static methodNotSupported = createErrorThrower('METHOD_NOT_SUPPORTED');
	static conflict = createErrorThrower('CONFLICT');
	static preconditionFailed = createErrorThrower('PRECONDITION_FAILED');
	static payloadTooLarge = createErrorThrower('PAYLOAD_TOO_LARGE');
	static unsupportedMediaType = createErrorThrower('UNSUPPORTED_MEDIA_TYPE');
	static unprocessableContent = createErrorThrower('UNPROCESSABLE_CONTENT');
	static preconditionRequired = createErrorThrower('PRECONDITION_REQUIRED');
	static tooManyRequests = createErrorThrower('TOO_MANY_REQUESTS');
	static timeout = createErrorThrower('TIMEOUT');
	static clientClosedRequest = createErrorThrower('CLIENT_CLOSED_REQUEST');
}
export { throwError };
export { TRPC_ERROR_MESSAGES as ERROR_MESSAGES };
</file>

<file path="src/trpc/server/api/site/helpers.ts">
import type { createTRPCContext } from './trpc';
export type Context = Awaited<ReturnType<typeof createTRPCContext>>;
export const getUserFromContext = (ctx: Context) => {
	return ctx.session?.user ?? null;
};
export const isAdmin = (user: Context['session']['user'] | null): boolean => {
	if (!user) return false;
	return user.role === 'ADMIN';
};
</file>

<file path="src/trpc/server/api/site/logger.ts">
const logError = (
	context: string,
	error: unknown,
	metadata: Record<string, unknown> = {},
) => {
	const errorMessage =
		error instanceof Error ? error.message : 'Unknown error';
	const stack = error instanceof Error ? error.stack : undefined;
	console.error(`Error in ${context}:`, {
		...metadata,
		message: errorMessage,
		...(process.env.NODE_ENV === 'development' && { stack }),
	});
};
export { logError };
</file>

<file path="src/trpc/server/api/site/trpc.ts">
import { initTRPC, TRPCError } from '@trpc/server';
import superjson from 'superjson';
import { ZodError } from 'zod';
import { getSession } from '@/lib/auth';
import { enforceSessionSecurity } from '@/lib/auth/session-security';
import { UserRole } from '@/prisma/site/.generated/enums';
import { site } from '../../site';
import { TRPCThrow } from './errors';
export const createTRPCContext = async (opts: { headers: Headers }) => {
	const session = await getSession();
	return {
		site,
		session,
		...opts,
	};
};
const t = initTRPC.context<typeof createTRPCContext>().create({
	transformer: superjson,
	errorFormatter({ shape, error }) {
		return {
			...shape,
			data: {
				...shape.data,
				zodError:
					error.cause instanceof ZodError
						? error.cause.flatten()
						: null,
			},
		};
	},
});
export const createCallerFactory = t.createCallerFactory;
export const createTRPCRouter = t.router;
const timingMiddleware = t.middleware(async ({ next, path }) => {
	const start = Date.now();
	if (t._config.isDev) {
		const waitMs = Math.floor(Math.random() * 400) + 100;
		await new Promise((resolve) => setTimeout(resolve, waitMs));
	}
	const result = await next();
	const end = Date.now();
	if (process.env.NODE_ENV === 'development') {
		console.log(`[TRPC] ${path} took ${end - start}ms to execute`);
	}
	return result;
});
export const publicProcedure = t.procedure.use(timingMiddleware);
export const protectedProcedure = t.procedure
	.use(timingMiddleware)
	.use(({ ctx, next }) => {
		const user = enforceSessionSecurity(ctx);
		return next({
			ctx: {
				session: { ...ctx.session!, user },
			},
		});
	});
export const adminProcedure = t.procedure
	.use(timingMiddleware)
	.use(({ ctx, next }) => {
		const user = enforceSessionSecurity(ctx);
		if (user.role !== UserRole.ADMIN) {
			TRPCThrow.forbidden('You must be an admin to access this resource');
		}
		return next({
			ctx: {
				session: { ...ctx.session!, user },
			},
		});
	});
export const errorCode = TRPCError;
</file>

<file path="src/trpc/server/site.ts">
import env from '@/env';
import { PrismaClient } from '@/prisma/site/.generated/client';
import { PrismaPg } from '@prisma/adapter-pg';
import { attachDatabasePool } from '@vercel/functions';
import { Pool } from 'pg';
const pool = new Pool({
	connectionString: env.SITE_DATABASE_URL,
	max: 20,
	connectionTimeoutMillis: 10000,
	idleTimeoutMillis: 30000,
});
attachDatabasePool(pool);
const createSitePrismaClient = () =>
	new PrismaClient({
		adapter: new PrismaPg(pool),
		log:
			env.NODE_ENV === 'development'
				? ['query', 'error', 'warn']
				: ['error'],
	});
const globalForSitePrisma = globalThis as unknown as {
	sitePrisma: ReturnType<typeof createSitePrismaClient> | undefined;
};
export const site = globalForSitePrisma.sitePrisma ?? createSitePrismaClient();
if (env.NODE_ENV !== 'production') globalForSitePrisma.sitePrisma = site;
</file>

<file path="src/trpc/query-client.ts">
import { handleTRPCSessionError } from '@/lib/auth/client-session-handler';
import {
	defaultShouldDehydrateQuery,
	QueryClient,
} from '@tanstack/react-query';
import SuperJSON from 'superjson';
export const createQueryClient = () => {
	const queryClient = new QueryClient({
		defaultOptions: {
			queries: {
				staleTime: 30 * 1000,
			},
			mutations: {
			},
			dehydrate: {
				serializeData: SuperJSON.serialize,
				shouldDehydrateQuery: (query) =>
					defaultShouldDehydrateQuery(query) ||
					query.state.status === 'pending',
			},
			hydrate: {
				deserializeData: SuperJSON.deserialize,
			},
		},
	});
	queryClient.getQueryCache().config.onError = (error) => {
		handleTRPCSessionError(error);
	};
	queryClient.getMutationCache().config.onError = (error) => {
		handleTRPCSessionError(error);
	};
	return queryClient;
};
</file>

<file path="src/trpc/react.tsx">
'use client';
import { QueryClientProvider, type QueryClient } from '@tanstack/react-query';
import { httpBatchStreamLink, loggerLink } from '@trpc/client';
import { createTRPCReact } from '@trpc/react-query';
import { useState } from 'react';
import SuperJSON from 'superjson';
import '@/lib/infra/storage/zustand/immer-config';
import type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import { createQueryClient } from './query-client';
import type { AppRouter } from './server/api/site/root';
let clientQueryClientSingleton: QueryClient | undefined = undefined;
const getQueryClient = () => {
	if (typeof window === 'undefined') {
		return createQueryClient();
	}
	return (clientQueryClientSingleton ??= createQueryClient());
};
export const api = createTRPCReact<AppRouter>();
export type RouterInputs = inferRouterInputs<AppRouter>;
export type RouterOutputs = inferRouterOutputs<AppRouter>;
export function TRPCReactProvider(props: { children: React.ReactNode }) {
	const queryClient = getQueryClient();
	const [trpcClient] = useState(() =>
		api.createClient({
			links: [
				loggerLink({
					enabled: (op) =>
						process.env.NODE_ENV === 'development' ||
						(op.direction === 'down' && op.result instanceof Error),
				}),
				httpBatchStreamLink({
					transformer: SuperJSON,
					url: getBaseUrl() + '/api/trpc',
					headers: () => {
						const headers = new Headers();
						headers.set('x-trpc-source', 'nextjs-react');
						return headers;
					},
				}),
			],
		}),
	);
	return (
		<QueryClientProvider client={queryClient}>
			<api.Provider client={trpcClient} queryClient={queryClient}>
				{props.children}
			</api.Provider>
		</QueryClientProvider>
	);
}
const getBaseUrl = () => {
	if (typeof window !== 'undefined') return window.location.origin;
	if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;
	return `http://localhost:${process.env.PORT ?? 4242}`;
};
</file>

<file path="src/trpc/server.ts">
import 'server-only';
import { createHydrationHelpers } from '@trpc/react-query/rsc';
import { headers } from 'next/headers';
import { cache } from 'react';
import { createQueryClient } from './query-client';
import { createCaller, type AppRouter } from './server/api/site/root';
import { createTRPCContext } from './server/api/site/trpc';
const createContext = cache(async () => {
	const heads = new Headers(await headers());
	heads.set('x-trpc-source', 'rsc');
	return createTRPCContext({
		headers: heads,
	});
});
const getQueryClient = cache(createQueryClient);
const caller = createCaller(createContext);
export const { trpc: api, HydrateClient } = createHydrationHelpers<AppRouter>(
	caller,
	getQueryClient,
);
</file>

<file path="src/zustand/ui/useLayoutStore.ts">
import {
	createVersionedPersistOptions,
	migrationUtils,
	type BaseVersionedState,
	type StoreVersionConfig,
} from '@/lib/infra/storage/zustand';
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
const isDesktop =
	typeof window !== 'undefined' &&
	window.matchMedia('(min-width: 1024px)').matches;
interface LayoutState extends BaseVersionedState {
	menubar: boolean;
	setMenubar: (menubar: boolean) => void;
	isLoading: boolean;
	setLoading: (loading: boolean) => void;
}
const versionConfig: StoreVersionConfig<LayoutState> = {
	currentVersion: 1,
	migrations: [
		{
			version: 1,
			description: 'Add hydration tracking and standardize versioning',
			migrate: (state) => {
				return migrationUtils.addDefaultFields(state, {
					_hasHydrated: false,
				});
			},
		},
	],
	clearOnFailure: true,
	enableLogging: process.env.NODE_ENV === 'development',
};
export const useLayoutStore = create<LayoutState>()(
	persist(
		immer((set) => ({
			menubar: isDesktop,
			setMenubar: (menubar: boolean) =>
				set((state) => {
					state.menubar = menubar;
				}),
			isLoading: true,
			setLoading: (loading) =>
				set((state) => {
					state.isLoading = loading;
				}),
			_hasHydrated: false,
			_setHasHydrated: (hydrated: boolean) =>
				set((state) => {
					state._hasHydrated = hydrated;
				}),
		})),
		createVersionedPersistOptions('layout', versionConfig, {
			storage: createJSONStorage(() => localStorage),
			partialize: (state) => ({
				menubar: state.menubar,
				_hasHydrated: state._hasHydrated,
			}),
			onRehydrateStorage: () => {
				return (state, error) => {
					if (error) {
						console.error('[LayoutStore] Hydration error:', error);
						return;
					}
					if (state) {
						state._setHasHydrated?.(true);
						state.setLoading(false);
					}
				};
			},
		}),
	),
);
</file>

<file path="src/zustand/ui/useModalStore.ts">
import type { ModalConfig } from '@/lib/ui/modals';
import type { ModalKey, ModalPropsMap } from '@/modals/registry';
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
export type ActiveModal<K extends ModalKey = ModalKey> = {
	key: K;
	props: ModalPropsMap[K];
	config?: ModalConfig;
};
interface ModalState {
	activeModal: ActiveModal | null;
	show: <K extends ModalKey>(
		key: K,
		props: ModalPropsMap[K],
		config?: ModalConfig,
	) => void;
	hide: () => void;
}
export const useModalStore = create<ModalState>()(
	immer((set) => ({
		activeModal: null,
		show: (key, props, config) =>
			set((state) => {
				state.activeModal = { key, props, config };
			}),
		hide: () =>
			set((state) => {
				state.activeModal = null;
			}),
	})),
);
</file>

<file path="src/zustand/user/useOnboardingStore.ts">
import {
	createVersionedPersistOptions,
	migrationUtils,
	type BaseVersionedState,
	type StoreVersionConfig,
} from '@/lib/infra/storage/zustand';
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
interface OnboardingState extends BaseVersionedState {
	completed: boolean;
	setCompleted: (complete: boolean) => void;
}
const versionConfig: StoreVersionConfig<OnboardingState> = {
	currentVersion: 1,
	migrations: [
		{
			version: 1,
			description: 'Add hydration tracking and standardize versioning',
			migrate: (state) => {
				return migrationUtils.addDefaultFields(state, {
					_hasHydrated: false,
				});
			},
		},
	],
	clearOnFailure: true,
	enableLogging: process.env.NODE_ENV === 'development',
};
export const useOnboardingStore = create<OnboardingState>()(
	persist(
		immer((set) => ({
			completed: false,
			setCompleted: (completed) =>
				set((state) => {
					state.completed = completed;
				}),
			_hasHydrated: false,
			_setHasHydrated: (hydrated: boolean) =>
				set((state) => {
					state._hasHydrated = hydrated;
				}),
		})),
		createVersionedPersistOptions('onboarding-status', versionConfig, {
			storage: createJSONStorage(() => localStorage),
			partialize: (state) => ({
				completed: state.completed,
				_hasHydrated: state._hasHydrated,
			}),
			onRehydrateStorage: () => {
				return (state, error) => {
					if (error) {
						console.error(
							'[OnboardingStore] Hydration error:',
							error,
						);
						return;
					}
					if (state) {
						state._setHasHydrated?.(true);
					}
				};
			},
		}),
	),
);
</file>

<file path="src/env.js">
import { createEnv } from '@t3-oss/env-nextjs';
import * as z from 'zod';
const env = createEnv({
	server: {
		ANALYZE: z.coerce.boolean().default(false),
		NODE_ENV: z
			.enum(['development', 'test', 'production'])
			.default('development'),
		NEXTAUTH_SECRET:
			process.env.NODE_ENV === 'production'
				? z.string()
				: z.string().optional(),
		NEXTAUTH_URL: z.preprocess(
			(str) => process.env.VERCEL_URL ?? str,
			process.env.VERCEL ? z.string() : z.url(),
		),
		UPSTASH_REDIS_REST_URL: z.url(),
		UPSTASH_REDIS_REST_TOKEN: z.string(),
		SITE_DATABASE_URL: z.url(),
		SITE_DIRECT_URL: z.url(),
		GOOGLE_CLIENT_ID: z.string(),
		GOOGLE_CLIENT_SECRET: z.string(),
	},
	client: {
		NEXT_PUBLIC_APP_NAME: z.string(),
		NEXT_PUBLIC_APP_URL: z.url(),
		NEXT_PUBLIC_APP_DOMAIN: z.string(),
		NEXT_PUBLIC_GTAG_ID: z.string(),
		NEXT_PUBLIC_CLARITY_PROJECT_ID: z.string(),
		NEXT_PUBLIC_FEATUREBASE_URL: z.string(),
	},
	runtimeEnv: {
		ANALYZE: process.env.ANALYZE,
		NODE_ENV: process.env.NODE_ENV,
		NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET,
		NEXTAUTH_URL: process.env.NEXTAUTH_URL,
		UPSTASH_REDIS_REST_URL: process.env.UPSTASH_REDIS_REST_URL,
		UPSTASH_REDIS_REST_TOKEN: process.env.UPSTASH_REDIS_REST_TOKEN,
		SITE_DATABASE_URL: process.env.SITE_DATABASE_URL,
		SITE_DIRECT_URL: process.env.SITE_DIRECT_URL,
		GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID,
		GOOGLE_CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET,
		NEXT_PUBLIC_APP_NAME: process.env.NEXT_PUBLIC_APP_NAME,
		NEXT_PUBLIC_APP_URL: process.env.NEXT_PUBLIC_APP_URL,
		NEXT_PUBLIC_APP_DOMAIN: process.env.NEXT_PUBLIC_APP_DOMAIN,
		NEXT_PUBLIC_GTAG_ID: process.env.NEXT_PUBLIC_GTAG_ID,
		NEXT_PUBLIC_CLARITY_PROJECT_ID:
			process.env.NEXT_PUBLIC_CLARITY_PROJECT_ID,
		NEXT_PUBLIC_FEATUREBASE_URL: process.env.NEXT_PUBLIC_FEATUREBASE_URL,
	},
	skipValidation: !!process.env.SKIP_ENV_VALIDATION,
	emptyStringAsUndefined: true,
});
export default env;
</file>

<file path="src/proxy.ts">
import { AppProxy } from '@/lib/proxy';
import type { NextFetchEvent, NextRequest } from 'next/server';
export const config = {
	matcher: [
		'/((?!api/|_next/|_proxy/|_static|_vercel|[\\w-]+\\.\\w+).*)',
	],
};
export default async function proxy(req: NextRequest, ev: NextFetchEvent) {
	return AppProxy(req);
}
</file>

<file path=".claude/CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Tech Stack Overview

This is a Next.js 16 application built with the T3 Stack architecture:

- **Framework**: Next.js 16 with App Router, React 19, TypeScript 5.8
- **Styling**: TailwindCSS with Radix UI components
- **State Management**: Zustand with Immer for client state
- **API Layer**: tRPC 11 for end-to-end type-safe APIs
- **Database**: PostgreSQL with Prisma 6.18 (using @prisma/adapter-pg for connection pooling)
- **Authentication**: NextAuth.js 4.24 with Google OAuth
- **Caching**: Upstash Redis for rate limiting and caching
- **Validation**: Zod 4 for runtime type validation
- **AI SDK**: Vercel AI SDK 5 (available but optional)

## Development Commands

### Core Development

```bash
npm run dev              # Start dev server on port 4242 with Prisma Studio
npm run build            # Production build with Prisma generation
npm run lint             # Run ESLint
npm run format           # Auto-fix with ESLint and Prettier
npm run format:check     # Check formatting without fixing
npm run analyze          # Analyze bundle size
```

### Database Operations

**Client Generation** (always run after schema changes):

```bash
npm run db:generate      # Generate Prisma client
```

**Development Migrations**:

```bash
npm run db:migrate:dev   # Create and apply new migration
npm run db:push          # Push schema changes without migration (dev only)
npm run db:studio        # Open Prisma Studio on port 5555
```

**Production Deployment**:

```bash
npm run db:migrate:deploy  # Apply migrations in production
```

**Migration Management**:

```bash
npm run db:status        # Check migration status
npm run db:reset         # Reset database (dev only - destroys data)
npm run db:pull          # Pull schema from database
```

**Migration Debugging**:

```bash
npm run db:site:diff                # Show diff between schema and datasource
npm run db:site:diff-from-prod      # Compare local schema to production DB
npm run db:site:resolve-applied -- MIGRATION_NAME     # Mark migration as applied
npm run db:site:resolve-rollback -- MIGRATION_NAME    # Mark migration as rolled back
```

## Feature Scaffolding

The repository includes a powerful CLI tool for creating new features with proper structure and automatic registry integration.

### Creating Features

```bash
npm run create                              # Interactive mode (recommended)
npm run create -- my-feature                # Quick create with positional argument
npm run create -- --name=my-feature         # Using --name flag
npm run create -- -n my-feature             # Using -n short flag
```

### Interactive Module Selection

When you run `npm run create`, you'll be prompted to select which modules to generate:

- **API** (tRPC routes and services) - Creates:
  - `api/index.ts` - Feature router that exports to root
  - `api/{feature-name}.ts` - tRPC procedures
  - `api/services/{feature-name}.service.ts` - Business logic layer
  - Auto-updates `src/trpc/server/api/site/root.ts`

- **Components** (React components) - Creates:
  - `components/{feature-name}-component.tsx` - Example component

- **Lib** (types and validation) - Creates:
  - `lib/types/index.ts` - TypeScript type definitions
  - `lib/validation/{feature-name}.z.ts` - Zod validation schemas

- **Pages** (reusable page sections) - Creates:
  - `pages/index.tsx` - Page component for composition

- **Header Actions** (dynamic header content) - Creates:
  - `header-actions.ts` - Header action definitions
  - `components/{feature-name}-header-action.tsx` - Header component
  - Auto-updates `src/components/layouts/main/header/header-actions/registry.ts`

- **Modals** (dialogs/drawers) - Creates:
  - `modals.ts` - Modal definitions
  - `components/modals/example-{feature-name}-modal.tsx` - Example modal
  - Auto-updates `src/modals/registry.ts`

### What Gets Auto-Generated

The scaffolding tool automatically:
1. Creates the feature directory at `src/features/{feature-name}/`
2. Generates boilerplate code with proper imports and type safety
3. Updates registry files (tRPC root, modals registry, header actions registry)
4. Uses proper naming conventions (kebab-case for files, PascalCase for components, camelCase for functions)
5. Includes example implementations you can customize

### Removing Features

```bash
npm run create -- --remove my-feature       # Remove feature and update registries
npm run create -- -r my-feature             # Short form
```

The removal process:
1. Removes imports and references from all registries
2. Prompts for confirmation before deleting the directory
3. Cleans up tRPC routes, modal definitions, and header actions

## Architecture

### Prisma Schema Organization

The database schema is located at `src/prisma/site/schema/schema.prisma`. The generated Prisma client outputs to `src/prisma/site/.generated/` with separate subdirectories for client and enums.

**Important**: Always use the generated types from `@/prisma/site/.generated/client` and `@/prisma/site/.generated/enums`.

### tRPC Architecture

The tRPC API follows a feature-based structure:

1. **Router Definition**: `src/trpc/server/api/site/root.ts` - Main app router that aggregates feature routers
2. **Feature Organization**: Each feature (e.g., settings) has:
    - `src/features/{feature}/api/index.ts` - Feature router that exports to root
    - `src/features/{feature}/api/{module}.ts` - Individual route modules (e.g., user.ts)
    - `src/features/{feature}/api/services/{module}.service.ts` - Business logic separated from routes
    - `src/features/{feature}/lib/validation/*.z.ts` - Zod validation schemas

3. **Server Setup**: `src/trpc/server/api/site/trpc.ts` contains the tRPC initialization and procedure builders
4. **Client Setup**: `src/trpc/react.tsx` provides the React Query integration

### Middleware (Next.js Proxy)

The application uses a custom middleware system in `src/lib/proxy/app.ts`:

- Handles authentication state and routing
- Validates JWT sessions for protected routes
- Manages admin route access (dev-only)
- Redirects based on user onboarding state
- Session validation via `validateProxySession()` for protected routes

### Authentication Flow

NextAuth.js configuration in `src/lib/auth/options.ts`:

- JWT strategy with custom session callbacks
- Google OAuth provider (extensible for more providers)
- Custom fields: `role`, `alias`, `onboardingCompleted`
- Session security handled in `src/lib/auth/session-security.ts`
- Client-side session handling in `src/lib/auth/client-session-handler.ts`

### Zustand State Management

Located in `src/zustand/`:

- Uses Immer middleware for immutable updates
- Configuration in `src/lib/infra/storage/zustand/immer-config.ts`
- Versioning support in `src/lib/infra/storage/zustand/versioning.ts`
- Example stores: `useLayoutStore`, `useModalStore`, `useOnboardingStore`

### Route Architecture

Routes are centrally managed in `src/routes/`:

- `src/routes/index.ts` - Main routes aggregator
- `src/routes/core.ts` - Core navigation routes
- `src/routes/menubar.ts` - Menubar/sidebar routes
- `src/routes/account.ts` - Account-related routes
- `src/routes/admin.ts` - Admin routes (dev-only)

Each route implements the `Route` interface from `src/lib/core/types/routes.ts`.

### Registry Pattern

The codebase uses a registry pattern for extensibility:

1. **Modal Registry** (`src/modals/registry.ts`):
    - Each feature exports modals from `{feature}/modals.ts`
    - Central registry aggregates all modals
    - Type-safe with auto-inferred props: `ModalPropsMap`
    - Usage: `const { openModal } = useModals(); openModal('modalKey', { props })`

2. **Header Action Registry** (`src/components/layouts/main/header/header-actions/registry.ts`):
    - Each feature exports header actions from `{feature}/header-actions.ts`
    - Automatically rendered based on current route
    - Type-safe with auto-inferred props: `HeaderActionPropsMap`

### Component Organization

- **UI Components**: `src/components/ui/` - Radix UI-based design system
- **Layout Components**: `src/components/layouts/` - Main layout, headers, footers
- **Feature Components**: `src/features/{feature}/components/` - Feature-specific components
- **Feature Pages**: `src/features/{feature}/pages/` - Reusable page sections

### Custom Hooks

Located in `src/hooks/`:

- `useModals` - Modal state management
- `useMediaQuery` - Responsive breakpoint detection
- `useKeyboardShortcut` - Keyboard shortcut handling
- `useHandleFormError` - Form error handling with toast notifications

### Environment Variables

Managed via `@t3-oss/env-nextjs` in `src/env.js`:

- Server-only variables (database URLs, API keys, OAuth secrets)
- Client-exposed variables (prefixed with `NEXT_PUBLIC_`)
- Automatic validation with Zod schemas
- Set `SKIP_ENV_VALIDATION=true` to skip validation (useful for Docker builds)

### Path Aliases

TypeScript path alias configured: `@/*` maps to `src/*`

## Feature Development Guidelines

When adding new features:

1. **Create Feature Directory**: `src/features/{feature-name}/`
2. **Add tRPC Router**:
    - Create `api/index.ts` with feature router
    - Add individual route files as needed (e.g., `api/user.ts`)
    - Separate business logic into `api/services/*.service.ts`
    - Add to `src/trpc/server/api/site/root.ts`
3. **Add Validation**: Create Zod schemas in `lib/validation/*.z.ts`
4. **Add UI Components**: Create in `components/`
5. **Add Routes**: Define routes in `src/routes/` if adding navigation
6. **Add Modals** (if needed):
    - Export modal definitions from `modals.ts`
    - Registry auto-includes them from `src/modals/registry.ts`
7. **Add Header Actions** (if needed):
    - Export from `header-actions.ts`
    - Registry auto-includes them from `src/components/layouts/main/header/header-actions/registry.ts`

## Database Schema Changes

1. Modify `src/prisma/site/schema/schema.prisma`
2. Run `npm run db:migrate:dev` to create and apply migration
3. Commit both the schema file and the migration files in `src/prisma/site/migrations/`
4. The Prisma client is automatically regenerated in `src/prisma/site/.generated/`

## Testing Database Connections

The application uses `@prisma/adapter-pg` with connection pooling:

- Pool configuration in `src/trpc/server/site.ts`
- Max connections: 20
- Connection timeout: 10s
- Idle timeout: 30s
- Vercel Functions integration via `attachDatabasePool()`

## Metadata and SEO

Metadata utilities in `src/lib/metadata/`:

- `config.ts` - Base metadata configuration
- `structured-data.ts` - JSON-LD schema generation
- `icon-graphics.ts` - Dynamic icon generation
- OpenGraph/Twitter images handled in `src/app/` route files

## Error Handling

- Custom error handler: `src/lib/core/errors/error-handler.ts`
- Error messages: `src/lib/core/errors/error-messages.ts`
- Form error handling: Use `useHandleFormError` hook
- tRPC error handling: Defined in `src/trpc/server/api/site/errors.ts`

## Analytics Integration

- Microsoft Clarity: `NEXT_PUBLIC_CLARITY_PROJECT_ID`
- Google Analytics: `NEXT_PUBLIC_GTAG_ID`
- Vercel Analytics: Automatically integrated
- Scripts in `src/scripts/analytics.tsx`

## Port Configuration

- **Dev Server**: <http://localhost:4242>
- **Prisma Studio**: <http://localhost:5555>

## Important Notes

- Admin routes (`/admin/*`) are only accessible in development mode
- The app uses standalone output mode for Docker deployments
- TailwindCSS uses the `tailwind-merge` utility for className composition
- Images use Next.js Image component with remote pattern allowlist
- Security headers configured in `next.config.js`
</file>

<file path="src/components/layouts/main/header/header-actions/registry.ts">
import type { ComponentType, LazyExoticComponent } from 'react';
import * as settingsHeaderActions from '@/features/settings/header-actions';
export const headerActionRegistry = {
    ...settingsHeaderActions,
} as const;
export type HeaderActionKey = keyof typeof headerActionRegistry;
export type HeaderActionPropsMap = {
    [K in HeaderActionKey]: (typeof headerActionRegistry)[K] extends {
        Component: LazyExoticComponent<ComponentType<infer P>>;
    }
    ? P extends Record<string, unknown>
    ? P
    : Record<string, never>
    : never;
};
</file>

<file path="src/components/layouts/main/header/index.tsx">
'use client';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/core/utils';
import { createRouteMatcher } from '@/lib/proxy/utils/route-matcher';
import { routes } from '@/routes';
import { useLayoutStore } from '@/zustand/ui/useLayoutStore';
import { usePathname } from 'next/navigation';
import { LuPanelLeftOpen } from 'react-icons/lu';
import HeaderAction from './header-action';
const Header = () => {
	const { menubar, setMenubar } = useLayoutStore();
	const currentPath = usePathname();
	const currentRoute = routes.find((route) => {
		if (route.path === '/') {
			return route.path === currentPath;
		}
		const routeRegExp = createRouteMatcher(route.path);
		return routeRegExp.test(currentPath);
	});
	const defaultStyles =
		'absolute top-0 z-20 flex h-16 w-full flex-row items-center justify-between bg-card p-4 bg-background border-b border-border';
	return (
		<header className={cn(defaultStyles)}>
			<div
				className={cn(
					'flex w-auto min-w-0 max-w-[60%] items-center sm:max-w-[50%]',
					!menubar && 'md:space-x-2',
				)}
			>
				<Button
					className={
						menubar ? 'hidden' : 'hidden flex-shrink-0 md:flex'
					}
					variant='ghost'
					size='icon'
					onClick={() => setMenubar(!menubar)}
					disabled={menubar}
					aria-label='Open menu'
					icon={<LuPanelLeftOpen className='size-4' />}
				/>
				{currentRoute && (
					<h1 className='truncate pr-2 text-lg font-medium md:text-xl'>
						{currentRoute.displayName}
					</h1>
				)}
			</div>
			<HeaderAction />
		</header>
	);
};
export default Header;
</file>

<file path="src/modals/registry.ts">
import type { ComponentType, LazyExoticComponent } from 'react';
import * as settingsModals from '@/features/settings/modals';
export const modalRegistry = {
    ...settingsModals,
} as const;
export type ModalKey = keyof typeof modalRegistry;
export type ModalPropsMap = {
    [K in ModalKey]: (typeof modalRegistry)[K] extends {
        Component: LazyExoticComponent<ComponentType<infer P>>;
    }
    ? P extends Record<string, unknown>
    ? P
    : Record<string, never>
    : never;
};
</file>

<file path="src/prisma/site/schema/schema.prisma">
generator client {
    provider        = "prisma-client"
    output          = "../.generated"
    previewFeatures = ["relationJoins"]
    runtime         = "nodejs"
    engineType      = "client"
}

datasource db {
    provider     = "postgresql"
    url          = env("SITE_DATABASE_URL")
    directUrl    = env("SITE_DIRECT_URL")
    relationMode = "foreignKeys"
}

model Account {
    id                String  @id @default(cuid(2))
    userId            String  @unique
    type              String
    provider          String
    providerAccountId String
    refresh_token     String?
    access_token      String?
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String?
    session_state     String?
    user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
    @@index([userId])
}

model Session {
    id           String   @id @default(cuid(2))
    sessionToken String   @unique
    userId       String   @unique
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
}

model VerificationToken {
    identifier String
    token      String
    expires    DateTime

    @@unique([identifier, token])
}

model Token {
    id         String    @id @default(cuid(2))
    name       String
    hashedKey  String    @unique
    partialKey String
    expires    DateTime?
    lastUsed   DateTime?
    createdAt  DateTime  @default(now())
    updatedAt  DateTime  @updatedAt
    userId     String
    user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
}

model User {
    id                  String    @id @default(cuid(2))
    createdAt           DateTime  @default(now())
    updatedAt           DateTime  @updatedAt
    alias               String    @unique @default(cuid(2))
    name                String?
    email               String?   @unique
    emailVerified       DateTime?
    image               String?
    onboardingCompleted Boolean   @default(false)
    role                UserRole  @default(USER)
    tier                UserTier  @default(FREE)
    banned              Boolean   @default(false)
    banReason           String?
    note                String?   @db.Text

    account Account?
    session Session?
    token   Token[]

    @@index([alias])
    @@index([email])
    @@index([role])
    @@index([tier])
}

enum UserRole {
    USER
    ADMIN
}

enum UserTier {
    FREE
    PRO
    MAX
}
</file>

<file path="src/routes/core.ts">
import type { Route } from '@/lib/core/types/routes';
import { LuNewspaper, LuTable2, LuFileText } from 'react-icons/lu';
const coreRoutes: Route[] = [
	{
		path: '/',
		displayPath: '/',
		displayName: 'Feed',
		type: 'public',
		category: 'ancillary',
		icon: LuNewspaper,
		primaryNav: true,
	},
	{
		path: '/thread/:slugId*',
		displayPath: '/thread',
		displayName: 'Thread',
		type: 'public',
		category: 'ancillary',
	},
	{
		path: '/posts',
		displayPath: '/posts',
		displayName: 'Your Posts',
		type: 'public',
		category: 'ancillary',
	},
	{
		path: '/track',
		displayPath: '/track',
		displayName: 'Track',
		type: 'private',
		category: 'ancillary',
		icon: LuTable2,
		primaryNav: true,
	},
	{
		path: '/track/visualize/:path*',
		displayPath: '/track/visualize',
		displayName: 'Visualize Tracking',
		type: 'private',
		category: 'ancillary',
	},
	{
		path: '/notes',
		displayPath: '/notes',
		displayName: 'Notes',
		type: 'private',
		category: 'ancillary',
		icon: LuFileText,
	},
];
export { coreRoutes };
</file>

<file path="src/routes/menubar.ts">
import type { Route } from '@/lib/core/types/routes';
import { LuNotebook, LuSearch } from 'react-icons/lu';
const menubarRoutes: Route[] = [
	{
		path: '/notes',
		displayPath: '/notes',
		displayName: 'Notes',
		type: 'public',
		category: 'feature',
		icon: LuNotebook,
	},
	{
		path: '/feature-2',
		displayPath: '/feature-2',
		displayName: 'Feature Two',
		type: 'public',
		category: 'feature',
		icon: LuSearch,
	},
];
export { menubarRoutes };
</file>

<file path="src/trpc/server/api/site/root.ts">
import { settingsRouter } from '@/features/settings/api';
import { createCallerFactory, createTRPCRouter } from './trpc';
import { userNotesFeatureRouter } from "@/features/user-notes/api";
export const appRouter = createTRPCRouter({
    settings: settingsRouter,
    userNotes: userNotesFeatureRouter
});
export type AppRouter = typeof appRouter;
export const createCaller = createCallerFactory(appRouter);
export default appRouter;
</file>

</files>

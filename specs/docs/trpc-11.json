[
	{
		"title": "tRPC Client | tRPC",
		"url": "https://trpc.io/docs/client/vanilla",
		"html": "Client Usage\nVanilla Client\nVersion: 11.x\ntRPC Client\n\nThe \"Vanilla\" tRPC client can be used to call your API procedures as if they are local functions, enabling a seamless development experience.\n\nimport type { AppRouter } from '../path/to/server/trpc';\nconst bilbo = await client.getUser.query('id_bilbo');\n// => { id: 'id_bilbo', name: 'Bilbo' };\nCopy\nWhen to use the Vanilla Client?‚Äã\n\nYou are likely to use this client in two scenarios:\n\nWith a frontend framework for which we don't have an official integration\nWith a separate backend service written in TypeScript.\nWhen NOT to use the Vanilla Client?‚Äã\nWhile you can use the client to call procedures from a React component, you should usually use our React Query Integration. It offers many additional features such as the ability to manage loading and error state, caching, and invalidation.\nWe recommend you do not use this client when calling procedures of the same API instance, this is because the invocation has to pass through the network layer. For complete recommendations on invoking a procedure in the current API, you can read more here.\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/vanilla#__docusaurus_skipToContent_fallback",
		"html": "Client Usage\nVanilla Client\nVersion: 11.x\ntRPC Client\n\nThe \"Vanilla\" tRPC client can be used to call your API procedures as if they are local functions, enabling a seamless development experience.\n\nimport type { AppRouter } from '../path/to/server/trpc';\nconst bilbo = await client.getUser.query('id_bilbo');\n// => { id: 'id_bilbo', name: 'Bilbo' };\nCopy\nWhen to use the Vanilla Client?‚Äã\n\nYou are likely to use this client in two scenarios:\n\nWith a frontend framework for which we don't have an official integration\nWith a separate backend service written in TypeScript.\nWhen NOT to use the Vanilla Client?‚Äã\nWhile you can use the client to call procedures from a React component, you should usually use our React Query Integration. It offers many additional features such as the ability to manage loading and error state, caching, and invalidation.\nWe recommend you do not use this client when calling procedures of the same API instance, this is because the invocation has to pass through the network layer. For complete recommendations on invoking a procedure in the current API, you can read more here.\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/nextjs",
		"html": "Client Usage\nNext.js Integration\nVersion: 11.x\nNext.js Integration\ntRPC ‚ù§Ô∏è Next.js‚Äã\n\nNext.js makes it easy to build a client and server together in one codebase. tRPC makes it easy to share types between them, ensuring typesafety for your application's data fetching.\n\nOur Next.js integration is built on top of our React Query Integration with some Next.js specific APIs, to handle both client and server side rendering.\n\nWhen using the Next.js integration, you'll get the following features:\n\nServer-side rendering - You can tell tRPC to render your pages on the server, and then hydrate them on the client. This way, you'll avoid an initial loading state, although time to first byte will be blocked by the server. Read more about Server-side rendering.\nStatic site generation - Prefetch queries on the server and generate static HTML files that are ready to be served. Read more about Static site generation.\nAutomatic Provider Wrapping - @trpc/next provides a higher-order component (HOC) that wraps your app with the necessary providers so you don't have to do it yourself.\nTIP\n\nIf you're using tRPC in a new project, consider using one of the example projects for reference: tRPC Example Projects\n\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/tanstack-react-query",
		"html": "üìÑÔ∏è Setup\n\nTanStack React Query setup\n\nüìÑÔ∏è Usage\n\nTanStack React Query usage\n\nüìÑÔ∏è Migrating\n\nMigrating from the classic React Client\n\nüìÑÔ∏è Server Components\n\nThis guide is an overview of how one may use tRPC with a React Server Components (RSC) framework such as Next.js App Router."
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/react",
		"html": "Client Usage\nReact Query Integration (Classic)\nVersion: 11.x\nReact Query Integration (Classic)\nTIP\n\nThese are the docs for our 'Classic' React Query integration, which (while still supported) is not the recommended way to start new tRPC projects with TanStack React Query. We recommend using the new TanStack React Query Integration instead.\n\ntRPC offers a first class integration with React. Under the hood this is simply a wrapper around the very popular @tanstack/react-query, so we recommend that you familiarise yourself with React Query, as their docs go in to much greater depth on its usage.\n\nIf you are using Next.js we recommend using our integration with that instead.\n\n‚ùì Do I have to use an integration?\nThe tRPC React Query Integration‚Äã\n\nThis library enables usage directly within React components\n\npages/IndexPage.tsx\nimport { trpc } from '../utils/trpc';\nexport default function IndexPage() {\n  const helloQuery = trpc.hello.useQuery({ name: 'Bob' });\n  const goodbyeMutation = trpc.goodbye.useMutation();\n  return (\n    <div>\n      <p>{helloQuery.data?.greeting}</p>\n      <button onClick={() => goodbyeMutation.mutate()}>Say Goodbye</button>\n    </div>\n  );\n}\nCopy\nDifferences to vanilla React Query‚Äã\n\nThe wrapper abstracts some aspects of React Query for you:\n\nQuery Keys - these are generated and managed by tRPC on your behalf, based on the procedure inputs you provide\nIf you need the query key which tRPC calculates, you can use getQueryKey\nType safe by default - the types you provide in your tRPC Backend also drive the types of your React Query client, providing safety throughout your React app\nEdit this page"
	},
	{
		"title": "Set up a tRPC Client | tRPC",
		"url": "https://trpc.io/docs/client/vanilla/setup",
		"html": "Client Usage\nVanilla Client\nSetup\nVersion: 11.x\nSet up a tRPC Client\n1. Install the tRPC Client library‚Äã\n\nUse your preferred package manager to install the @trpc/client library, and also install @trpc/server which contains some required types.\n\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install @trpc/server @trpc/client\n2. Import your App Router‚Äã\n\nImport your AppRouter type into the client application. This type holds the shape of your entire API.\n\nutils/trpc.ts\nimport type { AppRouter } from '../server/router';\nCopy\nTIP\n\nBy using import type you ensure that the reference will be stripped at compile-time, meaning you don't inadvertently import server-side code into your client. For more information, see the Typescript docs.\n\n3. Initialize the tRPC client‚Äã\n\nCreate a tRPC client with the createTRPCClient method, and add a links array with a terminating link pointing at your API. To learn more about tRPC links, click here.\n\nclient.ts\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from '../path/to/server/trpc';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/trpc',\n      // You can pass any HTTP headers you wish here\n      async headers() {\n        return {\n          authorization: getAuthCookie(),\n        };\n      },\n    }),\n  ],\n});\nCopy\n4. Use the tRPC Client‚Äã\n\nUnder the hood this creates a typed JavaScript Proxy which allows you to interact with your tRPC API in a fully type-safe way:\n\nclient.ts\nconst bilbo = await client.getUser.query('id_bilbo');\n// => { id: 'id_bilbo', name: 'Bilbo' };\nconst frodo = await client.createUser.mutate({ name: 'Frodo' });\n// => { id: 'id_frodo', name: 'Frodo' };\nCopy\n\nYou're all set!\n\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/vanilla/infer-types",
		"html": "Client Usage\nVanilla Client\nInferring Types\nVersion: 11.x\nInferring Types\n\nIt is often useful to access the types of your API within your clients. For this purpose, you are able to infer the types contained in your AppRouter.\n\n@trpc/server exports the following helper types to assist with inferring these types from the AppRouter exported by your @trpc/server router:\n\ninferRouterInputs<TRouter>\ninferRouterOutputs<TRouter>\nInferring Input & Output Types‚Äã\n\nLet's assume we have this example router:\n\nserver.ts\n// @filename: server.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from \"zod\";\n¬†\nconst t = initTRPC.create();\n¬†\nconst appRouter = t.router({\n  post: t.router({\n    list: t.procedure\n      .query(() => {\n        // imaginary db call\n        return [{ id: 1, title: 'tRPC is the best!' }];\n    }),\n    byId: t.procedure\n      .input(z.string())\n      .query((opts) => {\n        // imaginary db call\n        return { id: 1, title: 'tRPC is the best!' };\n    }),\n    create: t.procedure\n      .input(z.object({ title: z.string(), text: z.string(), }))\n      .mutation((opts) => {\n        // imaginary db call\n        return { id: 1, ...opts.input };\n    }),\n  }),\n});\n¬†\nexport type AppRouter = typeof appRouter;\nCopy\n\nUsing the helpers, we can infer the types of our router. The following example shows how to infer the types of the post.create procedure:\n\nclient.ts\n// @filename: client.ts\nimport type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';\nimport type { AppRouter } from './server';\n¬†\ntype RouterInput = inferRouterInputs<AppRouter>;\ntype RouterOutput = inferRouterOutputs<AppRouter>;\n¬†\ntype PostCreateInput = RouterInput['post']['create'];\n           \ntype PostCreateInput = {\n    title: string;\n    text: string;\n}\ntype PostCreateOutput = RouterOutput['post']['create'];\n            \ntype PostCreateOutput = {\n    title: string;\n    text: string;\n    id: number;\n}\nCopy\nInfer TRPCClientError types‚Äã\n\nIt's also useful to infer the error type for your AppRouter\n\nclient.ts\n// @filename: client.ts\nimport { TRPCClientError } from '@trpc/client';\nimport type { AppRouter } from './server';\nimport { trpc } from './trpc';\n¬†\nexport function isTRPCClientError(\n  cause: unknown,\n): cause is TRPCClientError<AppRouter> {\n  return cause instanceof TRPCClientError;\n}\n¬†\nasync function main() {\n  try {\n    await trpc.post.byId.query('1');\n  } catch (cause) {\n    if (isTRPCClientError(cause)) {\n      // `cause` is now typed as your router's `TRPCClientError`\n      console.log('data', cause.data);\n                                 \n(property) TRPCClientError<BuiltRouter<{ ctx: object; meta: object; errorShape: DefaultErrorShape; transformer: false; }, DecorateCreateRouterOptions<{ post: BuiltRouter<{ ctx: object; meta: object; errorShape: DefaultErrorShape; transformer: false; }, DecorateCreateRouterOptions<...>>; }>>>.data: Maybe<DefaultErrorData>\n    } else {\n      // [...]\n    }\n  }\n}\n¬†\nmain();\nCopy\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/vanilla/aborting-procedure-calls",
		"html": "Client Usage\nVanilla Client\nAborting Procedure Calls\nVersion: 11.x\nAborting Procedure Calls\n\ntRPC adheres to the industry standard when it comes to aborting procedures. All you have to do is pass an AbortSignal to the query or mutation options, and call the AbortController instance's abort method if you need to cancel the request.\n\nutils.ts\n// @filename: server.ts\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from './server.ts';\n¬†\nconst proxy = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/trpc',\n    }),\n  ],\n});\n¬†\n// 1. Create an AbortController instance - this is a standard javascript API\nconst ac = new AbortController();\n¬†\n// 2. Pass the signal to a query or mutation\nconst query = proxy.userById.query('id_bilbo', { signal: ac.signal });\n¬†\n// 3. Cancel the request if needed\nac.abort();\nCopy\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/links",
		"html": "Client Usage\nLinks\nVersion: 11.x\nLinks Overview\n\nLinks enable you to customize the flow of data between the tRPC Client and Server. A link should do only one thing, which can be either a self-contained modification to a tRPC operation (query, mutation, or subscription) or a side-effect based on the operation (such as logging).\n\nYou can compose links together into an array that you can provide to the tRPC client configuration via the links property, which represents a link chain. This means that the tRPC client will execute the links in the order they are added to the links array when doing a request and will execute them again in reverse when it's handling a response. Here's a visual representation of the link chain:\n\ntRPC Link Diagram. Based on Apollo's.\nNOTE\n\nThe below examples are assuming you use Next.js, but the same as below can be added if you use the vanilla tRPC client\n\nutils/trpc.ts\nimport { httpBatchLink, loggerLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nexport default createTRPCNext<AppRouter>({\n  config() {\n    const url = `http://localhost:3000`;\n    return {\n      links: [\n        loggerLink(),\n        httpBatchLink({\n          url,\n        }),\n      ],\n    };\n  },\n});\nCopy\nCreating a custom link‚Äã\n\nA link is a function that follows the TRPCLink type. Each link is composed of three parts:\n\nThe link returns a function that has a parameter with the TRPCClientRuntime type. This argument is passed by tRPC and it is used when creating a terminating link. If you're not creating a terminating link, you can just create a function that has no parameters. In such case, the link should be added to the links array without invoking (links: [..., myLink, httpBatchLink(...)]).\nThe function in step 1 returns another function that receives an object with two properties: op which is the Operation that is being executed by the client, and next which is the function we use to call the next link down the chain.\nThe function in step 2 returns a final function that returns the observable function provided by @trpc/server. The observable accepts a function that receives an observer which helps our link notify the next link up the chain how they should handle the operation result. In this function, we can just return next(op) and leave it as is, or we can subscribe to next, which enables our link to handle the operation result.\nExample‚Äã\nutils/customLink.ts\nimport { TRPCLink } from '@trpc/client';\nimport { observable } from '@trpc/server/observable';\nimport type { AppRouter } from '~/server/routers/_app';\nexport const customLink: TRPCLink<AppRouter> = () => {\n  // here we just got initialized in the app - this happens once per app\n  // useful for storing cache for instance\n  return ({ next, op }) => {\n    // this is when passing the result to the next link\n    // each link needs to return an observable which propagates results\n    return observable((observer) => {\n      console.log('performing operation:', op);\n      const unsubscribe = next(op).subscribe({\n        next(value) {\n          console.log('we received value', value);\n          observer.next(value);\n        },\n        error(err) {\n          console.log('we received error', err);\n          observer.error(err);\n        },\n        complete() {\n          observer.complete();\n        },\n      });\n      return unsubscribe;\n    });\n  };\n};\nCopy\nReferences‚Äã\n\nIf you need a more real reference for creating your custom link, you can check out some of the built-in links tRPC provides on GitHub.\n\nThe terminating link‚Äã\n\nThe terminating link is the last link in a link chain. Instead of calling the next function, the terminating link is responsible for sending your composed tRPC operation to the tRPC server and returning an OperationResultEnvelope.\n\nThe links array that you add to the tRPC client config should have at least one link, and that link should be a terminating link. If links don't have a terminating link at the end of them, the tRPC operation will not be sent to the tRPC server.\n\nhttpBatchLink is the recommended terminating link by tRPC.\n\nhttpLink, wsLink, and localLink are other examples of terminating links.\n\nManaging context‚Äã\n\nAs an operation moves along your link chain, it maintains a context that each link can read and modify. This allows links to pass metadata along the chain that other links use in their execution logic.\n\nObtain the current context object and modify it by accessing op.context.\n\nYou can set the context object's initial value for a particular operation by providing the context parameter to the query or useQuery hook (or mutation, subscription, etc.).\n\nFor an example use case, see Disable batching for certain requests.\n\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/headers",
		"html": "Client Usage\nCreate Custom Header\nVersion: 11.x\nCustom header\n\nThe headers option can be customized in the config when using the httpBatchLink or the httpLink.\n\nheaders can be both an object or a function. If it's a function it will get called dynamically for every HTTP request.\n\nutils/trpc.ts\n// Import the router type from your server file\nimport type { AppRouter } from '@/server/routers/app';\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nlet token: string;\nexport function setToken(newToken: string) {\n  /**\n   * You can also save the token to cookies, and initialize from\n   * cookies above.\n   */\n  token = newToken;\n}\nexport const trpc = createTRPCNext<AppRouter>({\n  config(config) {\n    return {\n      links: [\n        httpBatchLink({\n          url: 'http://localhost:3000/api/trpc',\n          /**\n           * Headers will be called on each request.\n           */\n          headers() {\n            return {\n              Authorization: token,\n            };\n          },\n        }),\n      ],\n    };\n  },\n});\nCopy\nExample with auth login‚Äã\npages/auth.tsx\nconst loginMut = trpc.auth.login.useMutation({\n  onSuccess(opts) {\n    token = opts.accessToken;\n  },\n});\nCopy\n\nThe token can be whatever you want it to be. It's entirely up to you whether that's just a client-side variable that you update the value of on success or whether you store the token and pull it from local storage.\n\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/cors",
		"html": "Client Usage\nCORS & Cookies\nVersion: 11.x\nSend cookies cross-origin\n\nIf your API resides on a different origin than your front-end and you wish to send cookies to it, you will need to enable CORS on your server and send cookies with your requests by providing the option {credentials: \"include\"} to fetch.\n\nThe arguments provided to the fetch function used by tRPC can be modified as follow.\n\napp.ts\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'YOUR_SERVER_URL',\n      fetch(url, options) {\n        return fetch(url, {\n          ...options,\n          credentials: 'include',\n        });\n      },\n    }),\n  ],\n});\nCopy\nINFO\n\nYou also need to enable CORS on your server by modifying your adapter, or the HTTP server which fronts your API. The best way to do this varies adapter-by-adapter and based on your hosting infrastructure, and individual adapters generally document this process where applicable.\n\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/nextjs/starter-projects",
		"html": "Client Usage\nNext.js Integration\nStarter Projects\nVersion: 11.x\nStarter Projects\n\nGet started quickly with one of the sample projects! Copy the snippet from Quick start with create-next-app in the below list to clone the project.\n\nDescription\tURL\tLinks\n\n\nNext.js starter with Prisma, E2E testing, & ESLint.\n\n\n\n\nQuick start with create-next-app\n\tnextjs.trpc.io\t\nCodeSandbox\nSource\n\n\n\nzART-stack example (zero-API, TypeScript, React).\n\n\n\n\nMonorepo setup with React Native, Next.js, & Prisma\n\n\n\n\nQuick start with git clone\n\tn/a\t\nSource\n\n\n\nNext.js TodoMVC-example with SSG & Prisma.\n\n\n\n\nQuick start with create-next-app\n\ttodomvc.trpc.io\t\nCodeSandbox\nSource\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/nextjs/setup",
		"html": "Client Usage\nNext.js Integration\nSetup\nVersion: 11.x\nSet up with Next.js Pages Router\nCAUTION\n\nThis guide is for Next.js Pages Router. If you are using Next.js App Router with React Server components, check out the RSC docs\n\nRecommended file structure‚Äã\n\nWe recommend a file structure like this one, although it is not enforced by tRPC. This is what you'll see in our examples. The rest of this page will take you through the process of adding tRPC in to this structure.\n\n.\n‚îú‚îÄ‚îÄ prisma  # <-- if prisma is added\n‚îÇ   ‚îî‚îÄ‚îÄ [..]\n‚îú‚îÄ‚îÄ src\n‚îÇ   ‚îú‚îÄ‚îÄ pages\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _app.tsx  # <-- add `withTRPC()`-HOC here\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ trpc\n‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ [trpc].ts  # <-- tRPC HTTP handler\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [..]\n‚îÇ   ‚îú‚îÄ‚îÄ server\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routers\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _app.ts  # <-- main app router\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ post.ts  # <-- sub routers\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [..]\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ context.ts   # <-- create app context\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ trpc.ts      # <-- procedure helpers\n‚îÇ   ‚îî‚îÄ‚îÄ utils\n‚îÇ       ‚îî‚îÄ‚îÄ trpc.ts  # <-- your typesafe tRPC hooks\n‚îî‚îÄ‚îÄ [..]\nCopy\nAdd tRPC to existing Next.js project‚Äã\n1. Install deps‚Äã\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install @trpc/server @trpc/client @trpc/react-query @trpc/next @tanstack/react-query@latest zod\n\nThe Next.js integration is actually a combination of our React Query Integration and some Next.js specific integrations.\n\n2. Enable strict mode‚Äã\n\nIf you want to use Zod for input validation, make sure you have enabled strict mode in your tsconfig.json:\n\ntsconfig.json\n\"compilerOptions\": {\n+   \"strict\": true\n}\nCopy\n\nIf strict mode is too harsh, you'll at least want to enable strictNullChecks:\n\ntsconfig.json\n\"compilerOptions\": {\n+   \"strictNullChecks\": true\n}\nCopy\n3. Create a tRPC router‚Äã\n\nInitialize your tRPC backend in src/server/trpc.ts using the initTRPC function, and create your first router. We're going to make a simple \"hello world\" router and procedure here - but for deeper information on creating your tRPC API you should refer to:\n\nthe Quickstart guide and Backend usage docs for tRPC information\nthe Next.js Adapter docs for mounting tRPC within your Next.js server.\nView sample backend\nNOTE\n\nThe backend above is using the recommended file structure, but you can keep it simple and put everything in an API handler directly if you prefer.\n\n4. Create tRPC hooks‚Äã\n\nuse the createTRPCNext function to create a set of strongly-typed hooks from your API's type signature.\n\nutils/trpc.ts\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport type { AppRouter } from '../server/routers/_app';\nfunction getBaseUrl() {\n  if (typeof window !== 'undefined')\n    // browser should use relative path\n    return '';\n  if (process.env.VERCEL_URL)\n    // reference for vercel.com\n    return `https://${process.env.VERCEL_URL}`;\n  if (process.env.RENDER_INTERNAL_HOSTNAME)\n    // reference for render.com\n    return `http://${process.env.RENDER_INTERNAL_HOSTNAME}:${process.env.PORT}`;\n  // assume localhost\n  return `http://localhost:${process.env.PORT ?? 3000}`;\n}\nexport const trpc = createTRPCNext<AppRouter>({\n  config(config) {\n    return {\n      links: [\n        httpBatchLink({\n          /**\n           * If you want to use SSR, you need to use the server's full URL\n           * @see https://trpc.io/docs/v11/ssr\n           **/\n          url: `${getBaseUrl()}/api/trpc`,\n          // You can pass any HTTP headers you wish here\n          async headers() {\n            return {\n              // authorization: getAuthCookie(),\n            };\n          },\n        }),\n      ],\n    };\n  },\n  /**\n   * @see https://trpc.io/docs/v11/ssr\n   **/\n  ssr: false,\n});\nCopy\nNOTE\n\ncreateTRPCNext does not work with the tRPC-v9 interop mode. If you are migrating from v9 using interop, you should continue using the old way of initializing tRPC.\n\n5. Configure _app.tsx‚Äã\n\nWrap your root app page in the trpc.withTRPC HOC, similar to this:\n\npages/_app.tsx\nimport type { AppType } from 'next/app';\nimport { trpc } from '../utils/trpc';\nconst MyApp: AppType = ({ Component, pageProps }) => {\n  return <Component {...pageProps} />;\n};\nexport default trpc.withTRPC(MyApp);\nCopy\n6. Make an API request‚Äã\n\nYou're all set!\n\nYou can now use the React hooks you have just created to invoke your API. For more detail see the React Query Integration\n\npages/index.tsx\nimport { trpc } from '../utils/trpc';\nexport default function IndexPage() {\n  const hello = trpc.hello.useQuery({ text: 'client' });\n  if (!hello.data) {\n    return <div>Loading...</div>;\n  }\n  return (\n    <div>\n      <p>{hello.data.greeting}</p>\n    </div>\n  );\n}\nCopy\ncreateTRPCNext() options‚Äã\nconfig-callback‚Äã\n\nThe config-argument is a function that returns an object that configures the tRPC and React Query clients. This function has a ctx input that gives you access to the Next.js req object, among other things. The returned value can contain the following properties:\n\nRequired:\nlinks to customize the flow of data between tRPC Client and the tRPC Server. Read more.\nOptional:\nqueryClientConfig: a configuration object for the React Query QueryClient used internally by the tRPC React hooks: QueryClient docs\nqueryClient: a React Query QueryClient instance\nNote: You can only provide either a queryClient or a queryClientConfig.\ntransformer: a transformer applied to outgoing payloads. Read more about Data Transformers\nabortOnUnmount: determines if in-flight requests will be cancelled on component unmount. This defaults to false.\noverrides: (default: undefined)‚Äã\n\nConfigure overrides for React Query's hooks.\n\nssr-boolean (default: false)‚Äã\n\nWhether tRPC should await queries when server-side rendering a page. Defaults to false.\n\nresponseMeta-callback‚Äã\n\nAbility to set request headers and HTTP status when server-side rendering.\n\nExample‚Äã\nutils/trpc.ts\nimport { createTRPCNext } from '@trpc/next';\nimport type { AppRouter } from '../pages/api/trpc/[trpc]';\nexport const trpc = createTRPCNext<AppRouter>({\n  config(config) {\n    /* [...] */\n  },\n});\nCopy\nNext steps‚Äã\n\nBrowse the rest of the docs to learn more about things like authorization, proxys, and error handling.\n\nYou can also find information about queries and mutations now that you're using @trpc/react-query.\n\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/nextjs/ssr",
		"html": "Client Usage\nNext.js Integration\nServer-Side Rendering (SSR)\nVersion: 11.x\nServer-Side Rendering\n\nTo enable SSR just set ssr: true in your createTRPCNext config callback.\n\nINFO\n\nWhen you enable SSR, tRPC will use getInitialProps to prefetch all queries on the server. This results in problems like this when you use getServerSideProps, and solving it is out of our hands.\n\n¬†\nAlternatively, you can leave SSR disabled (the default) and use Server-Side Helpers to prefetch queries in getStaticProps or getServerSideProps.\n\nIn order to execute queries properly during the server-side render step we need to add extra logic inside our config:\n\nAdditionally, consider Response Caching.\n\nutils/trpc.ts\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport { ssrPrepass } from '@trpc/next/ssrPrepass';\nimport superjson from 'superjson';\nimport type { AppRouter } from './api/trpc/[trpc]';\nexport const trpc = createTRPCNext<AppRouter>({\n  ssr: true,\n  ssrPrepass,\n  config(config) {\n    const { ctx } = opts;\n    if (typeof window !== 'undefined') {\n      // during client requests\n      return {\n        links: [\n          httpBatchLink({\n            url: '/api/trpc',\n          }),\n        ],\n      };\n    }\n    return {\n      links: [\n        httpBatchLink({\n          // The server needs to know your app's full url\n          url: `${getBaseUrl()}/api/trpc`,\n          /**\n           * Set custom request headers on every request from tRPC\n           * @see https://trpc.io/docs/v10/header\n           */\n          headers() {\n            if (!ctx?.req?.headers) {\n              return {};\n            }\n            // To use SSR properly, you need to forward client headers to the server\n            // This is so you can pass through things like cookies when we're server-side rendering\n            return {\n              cookie: ctx.req.headers.cookie,\n            };\n          },\n        }),\n      ],\n    };\n  },\n});\nCopy\n\nor, if you want to SSR conditional on a given request, you can pass a callback to ssr. This callback can return a boolean, or a Promise resolving to a boolean:\n\nutils/trpc.ts\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport superjson from 'superjson';\nimport type { AppRouter } from './api/trpc/[trpc]';\nexport const trpc = createTRPCNext<AppRouter>({\n  config(config) {\n    const { ctx } = opts;\n    if (typeof window !== 'undefined') {\n      // during client requests\n      return {\n        links: [\n          httpBatchLink({\n            url: '/api/trpc',\n          }),\n        ],\n      };\n    }\n    return {\n      links: [\n        httpBatchLink({\n          // The server needs to know your app's full url\n          url: `${getBaseUrl()}/api/trpc`,\n          /**\n           * Set custom request headers on every request from tRPC\n           * @see https://trpc.io/docs/v10/header\n           */\n          headers() {\n            if (!ctx?.req?.headers) {\n              return {};\n            }\n            // To use SSR properly, you need to forward client headers to the server\n            // This is so you can pass through things like cookies when we're server-side rendering\n            return {\n              cookie: ctx.req.headers.cookie,\n            };\n          },\n        }),\n      ],\n    };\n  },\n  ssr(opts) {\n    // only SSR if the request is coming from a bot\n    return opts.ctx?.req?.headers['user-agent']?.includes('bot');\n  },\n});\nCopy\npages/_app.tsx\nimport { trpc } from '~/utils/trpc';\nimport type { AppProps } from 'next/app';\nimport React from 'react';\nconst MyApp: AppType = ({ Component, pageProps }: AppProps) => {\n  return <Component {...pageProps} />;\n};\nexport default trpc.withTRPC(MyApp);\nCopy\nFAQ‚Äã\nQ: Why do I need to forward the client's headers to the server manually? Why doesn't tRPC automatically do that for me?‚Äã\n\nWhile it's rare that you wouldn't want to forward the client's headers to the server when doing SSR, you might want to add things dynamically in the headers. Therefore, tRPC doesn't want to take responsibility for header keys colliding, etc.\n\nQ: Why do I need to delete the connection header when using SSR on Node 18?‚Äã\n\nIf you don't remove the connection header, the data fetching will fail with TRPCClientError: fetch failed because connection is a forbidden header name.\n\nQ: Why do I still see network requests being made in the Network tab?‚Äã\n\nBy default, @tanstack/react-query (which we use for the data fetching hooks) refetches data on mount and window refocus, even if it's already got initial data via SSR. This ensures data is always up-to-date. See the page on SSG if you'd like to disable this behavior.\n\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/nextjs/ssg",
		"html": "Client Usage\nNext.js Integration\nStatic Site Generation (SSG)\nVersion: 11.x\nStatic Site Generation\nTIP\n\nReference project: https://github.com/trpc/examples-next-prisma-todomvc\n\nStatic site generation requires executing tRPC queries inside getStaticProps on each page.\n\nThis can be done using server-side helpers to prefetch the queries, dehydrate them, and pass it to the page. The queries will then automatically pick up the trpcState and use it as an initial value.\n\nFetch data in getStaticProps‚Äã\npages/posts/[id].tsx\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { prisma } from '~/server/context';\nimport { appRouter } from '~/server/routers/_app';\nimport { trpc } from '~/utils/trpc';\nimport {\n  GetStaticPaths,\n  GetStaticPropsContext,\n  InferGetStaticPropsType,\n} from 'next';\nimport superjson from 'superjson';\nexport async function getStaticProps(\n  context: GetStaticPropsContext<{ id: string }>,\n) {\n  const helpers = createServerSideHelpers({\n    router: appRouter,\n    ctx: {},\n    transformer: superjson, // optional - adds superjson serialization\n  });\n  const id = context.params?.id as string;\n  // prefetch `post.byId`\n  await helpers.post.byId.prefetch({ id });\n  return {\n    props: {\n      trpcState: helpers.dehydrate(),\n      id,\n    },\n    revalidate: 1,\n  };\n}\nexport const getStaticPaths: GetStaticPaths = async () => {\n  const posts = await prisma.post.findMany({\n    select: {\n      id: true,\n    },\n  });\n  return {\n    paths: posts.map((post) => ({\n      params: {\n        id: post.id,\n      },\n    })),\n    // https://nextjs.org/docs/pages/api-reference/functions/get-static-paths#fallback-blocking\n    fallback: 'blocking',\n  };\n};\nexport default function PostViewPage(\n  props: InferGetStaticPropsType<typeof getStaticProps>,\n) {\n  const { id } = props;\n  const postQuery = trpc.post.byId.useQuery({ id });\n  if (postQuery.status !== 'success') {\n    // won't happen since we're using `fallback: \"blocking\"`\n    return <>Loading...</>;\n  }\n  const { data } = postQuery;\n  return (\n    <>\n      <h1>{data.title}</h1>\n      <em>Created {data.createdAt.toLocaleDateString('en-us')}</em>\n      <p>{data.text}</p>\n      <h2>Raw data:</h2>\n      <pre>{JSON.stringify(data, null, 4)}</pre>\n    </>\n  );\n}\nCopy\n\nNote that the default behaviour of react-query is to refetch the data on the client-side when it mounts, so if you want to only fetch the data via getStaticProps, you need to set refetchOnMount and refetchOnWindowFocus to false in the query options.\n\nThis might be preferable if you want to minimize the number of requests to your API, which might be necessary if you're using a third-party rate-limited API for example.\n\nThis can be done per query:\n\nconst data = trpc.example.useQuery(\n  // if your query takes no input, make sure that you don't\n  // accidentally pass the query options as the first argument\n  undefined,\n  { refetchOnMount: false, refetchOnWindowFocus: false },\n);\nCopy\n\nOr globally, if every query across your app should behave the same way:\n\nutils/trpc.ts\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport superjson from 'superjson';\nimport type { AppRouter } from './api/trpc/[trpc]';\nexport const trpc = createTRPCNext<AppRouter>({\n  config(config) {\n    return {\n      links: [\n        httpBatchLink({\n          url: `${getBaseUrl()}/api/trpc`,\n        }),\n      ],\n      // Change options globally\n      queryClientConfig: {\n        defaultOptions: {\n          queries: {\n            refetchOnMount: false,\n            refetchOnWindowFocus: false,\n          },\n        },\n      },\n    },\n  },\n});\nCopy\n\nBe careful with this approach if your app has a mixture of static and dynamic queries.\n\nEdit this page"
	},
	{
		"title": "Server-Side Helpers | tRPC",
		"url": "https://trpc.io/docs/client/nextjs/server-side-helpers",
		"html": "Client Usage\nNext.js Integration\nServer-Side Helpers\nVersion: 11.x\nServer-Side Helpers\n\nThe server-side helpers provides you with a set of helper functions that you can use to prefetch queries on the server. This is useful for SSG, but also for SSR if you opt not to use ssr: true.\n\nPrefetching via the server-side helpers allows populating the query cache on the server, which means that these queries do not have to fetch on the client initially.\n\nThere are 2 ways to use the server-side helpers.‚Äã\n1. Internal router‚Äã\n\nThis method is used when you have direct access to your tRPC router. e.g. when developing a monolithic Next.js application.\n\nUsing the helpers makes tRPC call your procedures directly on the server, without an HTTP request, similar to server-side calls. That also means that you don't have the request and response at hand like you usually do. Make sure you're instantiating the server-side helpers with a context without req & res, which are typically filled via the context creation. We recommend the concept of \"inner\" and \"outer\" context in that scenario.\n\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { createContext } from '~/server/context';\nimport superjson from 'superjson';\nconst helpers = createServerSideHelpers({\n  router: appRouter,\n  ctx: await createContext(),\n  transformer: superjson, // optional - adds superjson serialization\n});\nCopy\n2. External router‚Äã\n\nThis method is used when you don't have direct access to your tRPC router. e.g. when developing a Next.js application and a standalone API hosted separately.\n\nimport { createTRPCClient } from '@trpc/client';\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport superjson from 'superjson';\nconst proxyClient = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/api/trpc',\n    }),\n  ],\n});\nconst helpers = createServerSideHelpers({\n  client: proxyClient,\n});\nCopy\nHelpers usage‚Äã\n\nThe server-side helpers methods return an object much like the tRPC client, with all of your routers as keys. However, rather than useQuery and useMutation, you get prefetch, fetch, prefetchInfinite, and fetchInfinite functions.\n\nThe primary difference between prefetch and fetch is that fetch acts much like a normal function call, returning the result of the query, whereas prefetch does not return the result and never throws - if you need that behavior, use fetch instead. Instead, prefetch will add the query to the cache, which you then dehydrate and send to the client.\n\nreturn {\n  props: {\n    // very important - use `trpcState` as the key\n    trpcState: helpers.dehydrate(),\n  },\n};\nCopy\n\nThe rule of thumb is prefetch for queries that you know you'll need on the client, and fetch for queries that you want to use the result of on the server.\n\nThe functions are all wrappers around react-query functions. Please check out their docs to learn more about them in detail.\n\nINFO\n\nFor a full example, see our E2E SSG test example\n\nNext.js Example‚Äã\npages/posts/[id].tsx\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { appRouter } from '~/server/routers/_app';\nimport { trpc } from '~/utils/trpc';\nimport { GetServerSidePropsContext, InferGetServerSidePropsType } from 'next';\nimport superjson from 'superjson';\nexport async function getServerSideProps(\n  context: GetServerSidePropsContext<{ id: string }>,\n) {\n  const helpers = createServerSideHelpers({\n    router: appRouter,\n    ctx: {},\n    transformer: superjson,\n  });\n  const id = context.params?.id as string;\n  /*\n   * Prefetching the `post.byId` query.\n   * `prefetch` does not return the result and never throws - if you need that behavior, use `fetch` instead.\n   */\n  await helpers.post.byId.prefetch({ id });\n  // Make sure to return { props: { trpcState: helpers.dehydrate() } }\n  return {\n    props: {\n      trpcState: helpers.dehydrate(),\n      id,\n    },\n  };\n}\nexport default function PostViewPage(\n  props: InferGetServerSidePropsType<typeof getServerSideProps>,\n) {\n  const { id } = props;\n  const postQuery = trpc.post.byId.useQuery({ id });\n  if (postQuery.status !== 'success') {\n    // won't happen since the query has been prefetched\n    return <>Loading...</>;\n  }\n  const { data } = postQuery;\n  return (\n    <>\n      <h1>{data.title}</h1>\n      <em>Created {data.createdAt.toLocaleDateString()}</em>\n      <p>{data.text}</p>\n      <h2>Raw data:</h2>\n      <pre>{JSON.stringify(data, null, 4)}</pre>\n    </>\n  );\n}\nCopy\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/nextjs/aborting-procedure-calls",
		"html": "Client Usage\nNext.js Integration\nAborting Procedure Calls\nVersion: 11.x\nAborting Procedure Calls\n\nBy default, tRPC does not cancel requests on unmount. If you want to opt into this behavior, you can provide abortOnUnmount in your configuration callback.\n\nGlobally‚Äã\nclient.ts\n// @filename: utils.ts\nimport { createTRPCNext } from '@trpc/next';\n¬†\nexport const trpc = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      // ...\n      abortOnUnmount: true,\n    };\n  },\n});\nCopy\nPer-request‚Äã\n\nYou may also override this behavior at the request level.\n\nclient.ts\n// @filename: pages/posts/[id].tsx\nimport { trpc } from '~/utils/trpc';\n¬†\nconst PostViewPage: NextPageWithLayout = () => {\n  const id = useRouter().query.id as string;\n  const postQuery = trpc.post.byId.useQuery({ id }, { trpc: { abortOnUnmount: true } });\n¬†\n  return (...)\n}\nCopy\nEdit this page"
	},
	{
		"title": "Disabling Queries | tRPC",
		"url": "https://trpc.io/docs/client/react/disabling-queries",
		"html": "Client Usage\nReact Query Integration (Classic)\nDisabling Queries\nVersion: 11.x\nDisabling Queries\n\nTo disable queries, you can pass skipToken as the first argument to useQuery or useInfiniteQuery. This will prevent the query from being executed.\n\nTypesafe conditional queries using skipToken‚Äã\nimport { skipToken } from '@tanstack/react-query';\nexport function MyComponent() {\nconst [name, setName] = useState<string | undefined>();\nconst result = trpc.getUserByName.useQuery(name ? { name: name } : skipToken);\n  return (\n    ...\n  )\n}\nCopy\nEdit this page"
	},
	{
		"title": "TanStack React Query | tRPC",
		"url": "https://trpc.io/docs/client/tanstack-react-query/setup",
		"html": "Client Usage\nTanStack React Query (‚≠êÔ∏è)\nSetup\nVersion: 11.x\nTanStack React Query\n\nCompared to our classic React Query Integration this client is simpler and more TanStack Query-native, providing factories for common TanStack React Query interfaces like QueryKeys, QueryOptions, and MutationOptions. We think it's the future and recommend using this over the classic client, read the announcement post for more information about this change.\n\nTIP\n\nYou can try this integration out on the homepage of tRPC.io: https://trpc.io/?try=minimal-react#try-it-out\n\n‚ùì Do I have to use an integration?\nSetup‚Äã\n1. Install dependencies‚Äã\n\nThe following dependencies should be installed\n\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install @trpc/server @trpc/client @trpc/tanstack-react-query @tanstack/react-query\n2. Import your AppRouter‚Äã\n\nImport your AppRouter type into the client application. This type holds the shape of your entire API.\n\nutils/trpc.ts\nimport type { AppRouter } from '../server/router';\nCopy\nTIP\n\nBy using import type you ensure that the reference will be stripped at compile-time, meaning you don't inadvertently import server-side code into your client. For more information, see the Typescript docs.\n\n3a. Setup the tRPC context provider‚Äã\n\nIn cases where you rely on React context, such as when using server-side rendering in full-stack frameworks like Next.js, it's important to create a new QueryClient for each request so that your users don't end up sharing the same cache, you can use the createTRPCContext to create a set of type-safe context providers and consumers from your AppRouter type signature.\n\nutils/trpc.ts\nimport { createTRPCContext } from '@trpc/tanstack-react-query';\nimport type { AppRouter } from '../server/router';\n¬†\nexport const { TRPCProvider, useTRPC, useTRPCClient } = createTRPCContext<AppRouter>();\nCopy\n\nThen, create a tRPC client, and wrap your application in the TRPCProvider, as below. You will also need to set up and connect React Query, which they document in more depth.\n\nTIP\n\nIf you already use React Query in your application, you should re-use the QueryClient and QueryClientProvider you already have. You can read more about the QueryClient initialization in the React Query docs.\n\ncomponents/App.tsx\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport { useState } from 'react';\nimport { TRPCProvider } from './utils/trpc';\nfunction makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        // With SSR, we usually want to set some default staleTime\n        // above 0 to avoid refetching immediately on the client\n        staleTime: 60 * 1000,\n      },\n    },\n  });\n}\nlet browserQueryClient: QueryClient | undefined = undefined;\nfunction getQueryClient() {\n  if (typeof window === 'undefined') {\n    // Server: always make a new query client\n    return makeQueryClient();\n  } else {\n    // Browser: make a new query client if we don't already have one\n    // This is very important, so we don't re-make a new client if React\n    // suspends during the initial render. This may not be needed if we\n    // have a suspense boundary BELOW the creation of the query client\n    if (!browserQueryClient) browserQueryClient = makeQueryClient();\n    return browserQueryClient;\n  }\n}\nexport function App() {\n  const queryClient = getQueryClient();\n  const [trpcClient] = useState(() =>\n    createTRPCClient<AppRouter>({\n      links: [\n        httpBatchLink({\n          url: 'http://localhost:2022',\n        }),\n      ],\n    }),\n  );\n  return (\n    <QueryClientProvider client={queryClient}>\n      <TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>\n        {/* Your app here */}\n      </TRPCProvider>\n    </QueryClientProvider>\n  );\n}\nCopy\n3b. Setup without React context‚Äã\n\nWhen building an SPA using only client-side rendering with something like Vite, you can create the QueryClient and tRPC client outside of React context as singletons.\n\nutils/trpc.ts\nimport { QueryClient } from '@tanstack/react-query';\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';\nimport type { AppRouter } from '../server/router';\nexport const queryClient = new QueryClient();\nconst trpcClient = createTRPCClient<AppRouter>({\n  links: [httpBatchLink({ url: 'http://localhost:2022' })],\n});\nexport const trpc = createTRPCOptionsProxy<AppRouter>({\n  client: trpcClient,\n  queryClient,\n});\nCopy\ncomponents/App.tsx\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport React from 'react';\nimport { queryClient } from './utils/trpc';\nexport function App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      {/* Your app here */}\n    </QueryClientProvider>\n  );\n}\nCopy\n4. Fetch data‚Äã\n\nYou can now use the tRPC React Query integration to call queries and mutations on your API.\n\ncomponents/user-list.tsx\nimport { useMutation, useQuery } from '@tanstack/react-query';\nimport { useTRPC } from '../utils/trpc';\nexport default function UserList() {\n  const trpc = useTRPC(); // use `import { trpc } from './utils/trpc'` if you're using the singleton pattern\n  const userQuery = useQuery(trpc.getUser.queryOptions({ id: 'id_bilbo' }));\n  const userCreator = useMutation(trpc.createUser.mutationOptions());\n  return (\n    <div>\n      <p>{userQuery.data?.name}</p>\n      <button onClick={() => userCreator.mutate({ name: 'Frodo' })}>\n        Create Frodo\n      </button>\n    </div>\n  );\n}\nCopy\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/tanstack-react-query/usage",
		"html": "Client Usage\nTanStack React Query (‚≠êÔ∏è)\nUsage\nVersion: 11.x\nTanStack React Query\n\nCompared to our classic React Query Integration this client is simpler and more TanStack Query-native, providing factories for common TanStack React Query interfaces like QueryKeys, QueryOptions, and MutationOptions. We think it's the future and recommend using this over the classic client, read the announcement post for more information about this change.\n\nQuick example query‚Äã\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from './trpc';\nfunction Users() {\n  const trpc = useTRPC();\n  const greetingQuery = useQuery(trpc.greeting.queryOptions({ name: 'Jerry' }));\n  // greetingQuery.data === 'Hello Jerry'\n}\nCopy\nUsage‚Äã\n\nThe philosophy of this client is to provide thin and type-safe factories which work natively and type-safely with Tanstack React Query. This means just by following the autocompletes the client gives you, you can focus on building just with the knowledge the TanStack React Query docs provide.\n\nexport default function Basics() {\n  const trpc = useTRPC();\n  const queryClient = useQueryClient();\n  // Create QueryOptions which can be passed to query hooks\n  const myQueryOptions = trpc.path.to.query.queryOptions({ /** inputs */ })\n  const myQuery = useQuery(myQueryOptions)\n  // or:\n  // useSuspenseQuery(myQueryOptions)\n  // useInfiniteQuery(myQueryOptions)\n  // Create MutationOptions which can be passed to useMutation\n  const myMutationOptions = trpc.path.to.mutation.mutationOptions()\n  const myMutation = useMutation(myMutationOptions)\n  // Create a QueryKey which can be used to manipulated many methods\n  // on TanStack's QueryClient in a type-safe manner\n  const myQueryKey = trpc.path.to.query.queryKey()\n  const invalidateMyQueryKey = () => {\n    queryClient.invalidateQueries({ queryKey: myQueryKey })\n  }\n  return (\n    // Your app here\n  )\n}\nCopy\n\nThe trpc object is fully type-safe and will provide autocompletes for all the procedures in your AppRouter. At the end of the proxy, the following methods are available:\n\nqueryOptions - querying data‚Äã\n\nAvailable for all query procedures. Provides a type-safe wrapper around Tanstack's queryOptions function. The first argument is the input for the procedure, and the second argument accepts any native Tanstack React Query options.\n\nconst queryOptions = trpc.path.to.query.queryOptions(\n  {\n    /** input */\n  },\n  {\n    // Any Tanstack React Query options\n    staleTime: 1000,\n  },\n);\nCopy\n\nYou can additionally provide a trpc object to the queryOptions function to provide tRPC request options to the client.\n\nconst queryOptions = trpc.path.to.query.queryOptions(\n  {\n    /** input */\n  },\n  {\n    trpc: {\n      // Provide tRPC request options to the client\n      context: {\n        // see https://trpc.io/docs/client/links#managing-context\n      },\n    },\n  },\n);\nCopy\n\nIf you want to disable a query in a type safe way, you can use skipToken:\n\nimport { skipToken } from '@tanstack/react-query';\nconst query = useQuery(\n  trpc.user.details.queryOptions(\n    user?.id && project?.id\n      ? {\n          userId: user.id,\n          projectId: project.id,\n        }\n      : skipToken,\n    {\n      staleTime: 1000,\n    },\n  ),\n);\nCopy\n\nThe result can be passed to useQuery or useSuspenseQuery hooks or query client methods like fetchQuery, prefetchQuery, prefetchInfiniteQuery, invalidateQueries, etc.\n\ninfiniteQueryOptions - querying infinite data‚Äã\n\nAvailable for all query procedures that takes a cursor input. Provides a type-safe wrapper around Tanstack's infiniteQueryOptions function. The first argument is the input for the procedure, and the second argument accepts any native Tanstack React Query options.\n\nconst infiniteQueryOptions = trpc.path.to.query.infiniteQueryOptions(\n  {\n    /** input */\n  },\n  {\n    // Any Tanstack React Query options\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  },\n);\nCopy\nqueryKey - getting the query key and performing operations on the query client‚Äã\n\nAvailable for all query procedures. Allows you to access the query key in a type-safe manner.\n\nconst queryKey = trpc.path.to.query.queryKey();\nCopy\n\nSince Tanstack React Query uses fuzzy matching for query keys, you can also create a partial query key for any sub-path to match all queries belonging to a router:\n\nconst queryKey = trpc.router.pathKey();\nCopy\n\nOr even the root path to match all tRPC queries:\n\nconst queryKey = trpc.pathKey();\nCopy\nqueryFilter - creating query filters‚Äã\n\nAvailable for all query procedures. Allows creating query filters in a type-safe manner.\n\nconst queryFilter = trpc.path.to.query.queryFilter(\n  {\n    /** input */\n  },\n  {\n    // Any Tanstack React Query filter\n    predicate: (query) => {\n      query.state.data;\n    },\n  },\n);\nCopy\n\nLike with query keys, if you want to run a filter across a whole router you can use pathFilter to target any sub-path.\n\nconst queryFilter = trpc.path.pathFilter({\n  // Any Tanstack React Query filter\n  predicate: (query) => {\n    query.state.data;\n  },\n});\nCopy\n\nUseful for creating filters that can be passed to client methods like queryClient.invalidateQueries etc.\n\nmutationOptions - creating mutation options‚Äã\n\nAvailable for all mutation procedures. Provides a type-safe identify function for constructing options that can be passed to useMutation.\n\nconst mutationOptions = trpc.path.to.mutation.mutationOptions({\n  // Any Tanstack React Query options\n  onSuccess: (data) => {\n    // do something with the data\n  },\n});\nCopy\nmutationKey - getting the mutation key‚Äã\n\nAvailable for all mutation procedures. Allows you to get the mutation key in a type-safe manner.\n\nconst mutationKey = trpc.path.to.mutation.mutationKey();\nCopy\nsubscriptionOptions - creating subscription options‚Äã\n\nTanStack does not provide a subscription hook, so we continue to expose our own abstraction here which works with a standard tRPC subscription setup. Available for all subscription procedures. Provides a type-safe identify function for constructing options that can be passed to useSubscription. Note that you need to have either the httpSubscriptionLink or wsLink configured in your tRPC client to use subscriptions.\n\nfunction SubscriptionExample() {\n  const trpc = useTRPC();\n  const subscription = useSubscription(\n    trpc.path.to.subscription.subscriptionOptions(\n      {\n        /** input */\n      },\n      {\n        enabled: true,\n        onStarted: () => {\n          // do something when the subscription is started\n        },\n        onData: (data) => {\n          // you can handle the data here\n        },\n        onError: (error) => {\n          // you can handle the error here\n        },\n        onConnectionStateChange: (state) => {\n          // you can handle the connection state here\n        },\n      },\n    ),\n  );\n  // Or you can handle the state here\n  subscription.data; // The lastly received data\n  subscription.error; // The lastly received error\n  /**\n   * The current status of the subscription.\n   * Will be one of: `'idle'`, `'connecting'`, `'pending'`, or `'error'`.\n   *\n   * - `idle`: subscription is disabled or ended\n   * - `connecting`: trying to establish a connection\n   * - `pending`: connected to the server, receiving data\n   * - `error`: an error occurred and the subscription is stopped\n   */\n  subscription.status;\n  // Reset the subscription (if you have an error etc)\n  subscription.reset();\n  return <>{/* ... */}</>;\n}\nCopy\nInferring Input and Output types‚Äã\n\nWhen you need to infer the input and output types for a procedure or router, there are 2 options available depending on the situation.\n\nInfer the input and output types of a full router\n\nimport type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';\nimport { AppRouter } from './path/to/server';\nexport type Inputs = inferRouterInputs<AppRouter>;\nexport type Outputs = inferRouterOutputs<AppRouter>;\nCopy\n\nInfer types for a single procedure\n\nimport type { inferInput, inferOutput } from '@trpc/tanstack-react-query';\nfunction Component() {\n  const trpc = useTRPC();\n  type Input = inferInput<typeof trpc.path.to.procedure>;\n  type Output = inferOutput<typeof trpc.path.to.procedure>;\n}\nCopy\nAccessing the tRPC client‚Äã\n\nIf you used the setup with React Context, you can access the tRPC client using the useTRPCClient hook.\n\nimport { useTRPCClient } from './trpc';\nfunction Component() {\n  const trpcClient = useTRPCClient();\n  const result = await trpcClient.path.to.procedure.query({\n    /** input */\n  });\n}\nCopy\n\nIf you setup without React Context, you can import the global client instance directly instead.\n\nimport { client } from './trpc';\nconst result = await client.path.to.procedure.query({\n  /** input */\n});\nCopy\nEdit this page"
	},
	{
		"title": "Migrating from the classic React Client | tRPC",
		"url": "https://trpc.io/docs/client/tanstack-react-query/migrating",
		"html": "Client Usage\nTanStack React Query (‚≠êÔ∏è)\nMigrating\nVersion: 11.x\nMigrating from the classic React Client\n\nThere are a few approaches to migrate over, and this library is a significant departure from the classic client, so we're not expecting anybody to do it in one shot. But you will probably want to try a combination of...\n\nCodemod migration‚Äã\nINFO\n\nThe codemod is a work in progress and we're looking for help to make it better. If you're interested in contributing to the codemod, please see Julius' comment here.\n\nWe're working on a codemod to help you migrate your existing codebase over to the new client. This is already available to try but we need your feedback and contributions to improve it. Codemods are very tricky to get right so we're looking for your help to make it as effective as possible.\n\nRun our upgrade CLI:\n\nnpx @trpc/upgrade\nCopy\n\nWhen prompted, select the transforms Migrate Hooks to xxxOptions API and Migrate context provider setup.\n\nGradual migration‚Äã\n\nThe new and classic clients are compatible with each other and can live together in the same application. This means you can start migrating by using the new client in new parts of your application, and gradually migrate over existing usage as you see fit. Most importantly, Query Keys are identical, which means you can use the new client and classic client together and still rely on TanStack Query's caching.\n\nMigrating Queries‚Äã\n\nA classic query would look like this\n\nimport { trpc } from './trpc';\nfunction Users() {\n  const greetingQuery = trpc.greeting.useQuery({ name: 'Jerry' });\n  // greetingQuery.data === 'Hello Jerry'\n}\nCopy\n\nand changes to\n\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from './trpc';\nfunction Users() {\n  const trpc = useTRPC();\n  const greetingQuery = useQuery(trpc.greeting.queryOptions({ name: 'Jerry' }));\n  // greetingQuery.data === 'Hello Jerry'\n}\nCopy\nMigrating Invalidations and other QueryClient usages‚Äã\n\nA classic query would look like this\n\nimport { trpc } from './trpc';\nfunction Users() {\n  const utils = trpc.useUtils();\n  async function invalidateGreeting() {\n    await utils.greeting.invalidate({ name: 'Jerry' });\n  }\n}\nCopy\n\nand changes to\n\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\nimport { useTRPC } from './trpc';\nfunction Users() {\n  const trpc = useTRPC();\n  const queryClient = useQueryClient();\n  async function invalidateGreeting() {\n    await queryClient.invalidateQueries(\n      trpc.greeting.queryFilter({ name: 'Jerry' }),\n    );\n  }\n}\nCopy\n\nThis is the same for any QueryClient usage, instead of using tRPC's useUtils you can now follow the TanStack documentation directly\n\nMigrating Mutations‚Äã\n\nA classic mutation might look like this\n\nimport { trpc } from './trpc';\nfunction Users() {\n  const createUserMutation = trpc.createUser.useMutation();\n  createUserMutation.mutate({ name: 'Jerry' });\n}\nCopy\n\nand changes to\n\nimport { useMutation } from '@tanstack/react-query';\nimport { useTRPC } from './trpc';\nfunction Users() {\n  const trpc = useTRPC();\n  const createUserMutation = useMutation(trpc.createUser.mutationOptions());\n  createUserMutation.mutate({ name: 'Jerry' });\n}\nCopy\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/tanstack-react-query/server-components",
		"html": "Client Usage\nTanStack React Query (‚≠êÔ∏è)\nServer Components\nVersion: 11.x\nSet up with React Server Components\n\nThis guide is an overview of how one may use tRPC with a React Server Components (RSC) framework such as Next.js App Router. Be aware that RSC on its own solves a lot of the same problems tRPC was designed to solve, so you may not need tRPC at all.\n\nThere are also not a one-size-fits-all way to integrate tRPC with RSCs, so see this guide as a starting point and adjust it to your needs and preferences.\n\nINFO\n\nIf you're looking for how to use tRPC with Server Actions, check out this blog post by Julius.\n\nCAUTION\n\nPlease read React Query's Advanced Server Rendering docs before proceeding to understand the different types of server rendering and what footguns to avoid.\n\nAdd tRPC to existing projects‚Äã\n1. Install deps‚Äã\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install @trpc/server @trpc/client @trpc/tanstack-react-query @tanstack/react-query@latest zod client-only server-only\n2. Create a tRPC router‚Äã\n\nInitialize your tRPC backend in trpc/init.ts using the initTRPC function, and create your first router. We're going to make a simple \"hello world\" router and procedure here - but for deeper information on creating your tRPC API you should refer to the Quickstart guide and Backend usage docs for tRPC information.\n\nINFO\n\nThe file names used here are not enforced by tRPC. You may use any file structure you wish.\n\nView sample backend\n3. Create a Query Client factory‚Äã\n\nCreate a shared file trpc/query-client.ts that exports a function that creates a QueryClient instance.\n\ntrpc/query-client.ts\nimport {\n  defaultShouldDehydrateQuery,\n  QueryClient,\n} from '@tanstack/react-query';\nimport superjson from 'superjson';\nexport function makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 30 * 1000,\n      },\n      dehydrate: {\n        // serializeData: superjson.serialize,\n        shouldDehydrateQuery: (query) =>\n          defaultShouldDehydrateQuery(query) ||\n          query.state.status === 'pending',\n      },\n      hydrate: {\n        // deserializeData: superjson.deserialize,\n      },\n    },\n  });\n}\nCopy\n\nWe're setting a few default options here:\n\nstaleTime: With SSR, we usually want to set some default staleTime above 0 to avoid refetching immediately on the client.\nshouldDehydrateQuery: This is a function that determines whether a query should be dehydrated or not. Since the RSC transport protocol supports hydrating promises over the network, we extend the defaultShouldDehydrateQuery function to also include queries that are still pending. This will allow us to start prefetching in a server component high up the tree, then consuming that promise in a client component further down.\nserializeData and deserializeData (optional): If you set up a data transformer in the previous step, set this option to make sure the data is serialized correctly when hydrating the query client over the server-client boundary.\n4. Create a tRPC client for Client Components‚Äã\n\nThe trpc/client.tsx is the entrypoint when consuming your tRPC API from client components. In here, import the type definition of your tRPC router and create typesafe hooks using createTRPCContext. We'll also export our context provider from this file.\n\ntrpc/client.tsx\n'use client';\n// ^-- to make sure we can mount the Provider from a server component\nimport type { QueryClient } from '@tanstack/react-query';\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport { createTRPCContext } from '@trpc/tanstack-react-query';\nimport { useState } from 'react';\nimport { makeQueryClient } from './query-client';\nimport type { AppRouter } from './routers/_app';\nexport const { TRPCProvider, useTRPC } = createTRPCContext<AppRouter>();\nlet browserQueryClient: QueryClient;\nfunction getQueryClient() {\n  if (typeof window === 'undefined') {\n    // Server: always make a new query client\n    return makeQueryClient();\n  }\n  // Browser: make a new query client if we don't already have one\n  // This is very important, so we don't re-make a new client if React\n  // suspends during the initial render. This may not be needed if we\n  // have a suspense boundary BELOW the creation of the query client\n  if (!browserQueryClient) browserQueryClient = makeQueryClient();\n  return browserQueryClient;\n}\nfunction getUrl() {\n  const base = (() => {\n    if (typeof window !== 'undefined') return '';\n    if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;\n    return 'http://localhost:3000';\n  })();\n  return `${base}/api/trpc`;\n}\nexport function TRPCReactProvider(\n  props: Readonly<{\n    children: React.ReactNode;\n  }>,\n) {\n  // NOTE: Avoid useState when initializing the query client if you don't\n  //       have a suspense boundary between this and the code that may\n  //       suspend because React will throw away the client on the initial\n  //       render if it suspends and there is no boundary\n  const queryClient = getQueryClient();\n  const [trpcClient] = useState(() =>\n    createTRPCClient<AppRouter>({\n      links: [\n        httpBatchLink({\n          // transformer: superjson, <-- if you use a data transformer\n          url: getUrl(),\n        }),\n      ],\n    }),\n  );\n  return (\n    <QueryClientProvider client={queryClient}>\n      <TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>\n        {props.children}\n      </TRPCProvider>\n    </QueryClientProvider>\n  );\n}\nCopy\n\nMount the provider in the root of your application (e.g. app/layout.tsx when using Next.js).\n\n5. Create a tRPC caller for Server Components‚Äã\n\nTo prefetch queries from server components, we create a proxy from our router. You can also pass in a client if your router is on a separate server.\n\ntrpc/server.tsx\nimport 'server-only'; // <-- ensure this file cannot be imported from the client\nimport { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';\nimport { cache } from 'react';\nimport { createTRPCContext } from './init';\nimport { makeQueryClient } from './query-client';\nimport { appRouter } from './routers/_app';\n// IMPORTANT: Create a stable getter for the query client that\n//            will return the same client during the same request.\nexport const getQueryClient = cache(makeQueryClient);\nexport const trpc = createTRPCOptionsProxy({\n  ctx: createTRPCContext,\n  router: appRouter,\n  queryClient: getQueryClient,\n});\n// If your router is on a separate server, pass a client:\ncreateTRPCOptionsProxy({\n  client: createTRPCClient({\n    links: [httpLink({ url: '...' })],\n  }),\n  queryClient: getQueryClient,\n});\nCopy\nUsing your API‚Äã\n\nNow you can use your tRPC API in your app. While you can use the React Query hooks in client components just like you would in any other React app, we can take advantage of the RSC capabilities by prefetching queries in a server component high up the tree. You may be familiar with this concept as \"render as you fetch\" commonly implemented as loaders. This means the request fires as soon as possible but without suspending until the data is needed by using the useQuery or useSuspenseQuery hooks.\n\nThis approach leverages Next.js App Router's streaming capabilities, initiating the query on the server and streaming data to the client as it becomes available. It optimizes both the time to first byte in the browser and the data fetch time, resulting in faster page loads. However, greeting.data may initially be undefined before the data streams in.\n\nIf you prefer to avoid this initial undefined state, you can await the prefetchQuery call. This ensures the query on the client always has data on first render, but it comes with a tradeoff - the page will load more slowly since the server must complete the query before sending HTML to the client.\n\napp/page.tsx\nimport { dehydrate, HydrationBoundary } from '@tanstack/react-query';\nimport { getQueryClient, trpc } from '~/trpc/server';\nimport { ClientGreeting } from './client-greeting';\nexport default async function Home() {\n  const queryClient = getQueryClient();\n  void queryClient.prefetchQuery(\n    trpc.hello.queryOptions({\n      /** input */\n    }),\n  );\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      <div>...</div>\n      {/** ... */}\n      <ClientGreeting />\n    </HydrationBoundary>\n  );\n}\nCopy\napp/client-greeting.tsx\n'use client';\n// <-- hooks can only be used in client components\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from '~/trpc/client';\nexport function ClientGreeting() {\n  const trpc = useTRPC();\n  const greeting = useQuery(trpc.hello.queryOptions({ text: 'world' }));\n  if (!greeting.data) return <div>Loading...</div>;\n  return <div>{greeting.data.greeting}</div>;\n}\nCopy\nTIP\n\nYou can also create a prefetch and HydrateClient helper functions to make it a bit more consice and reusable:\n\ntrpc/server.tsx\nexport function HydrateClient(props: { children: React.ReactNode }) {\n  const queryClient = getQueryClient();\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      {props.children}\n    </HydrationBoundary>\n  );\n}\nexport function prefetch<T extends ReturnType<TRPCQueryOptions<any>>>(\n  queryOptions: T,\n) {\n  const queryClient = getQueryClient();\n  if (queryOptions.queryKey[1]?.type === 'infinite') {\n    void queryClient.prefetchInfiniteQuery(queryOptions as any);\n  } else {\n    void queryClient.prefetchQuery(queryOptions);\n  }\n}\nCopy\n\nThen you can use it like this:\n\nimport { HydrateClient, prefetch, trpc } from '~/trpc/server';\nfunction Home() {\n  prefetch(\n    trpc.hello.queryOptions({\n      /** input */\n    }),\n  );\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ClientGreeting />\n    </HydrateClient>\n  );\n}\nCopy\nLeveraging Suspense‚Äã\n\nYou may prefer handling loading and error states using Suspense and Error Boundaries. You can do this by using the useSuspenseQuery hook.\n\napp/page.tsx\nimport { HydrateClient, prefetch, trpc } from '~/trpc/server';\nimport { Suspense } from 'react';\nimport { ErrorBoundary } from 'react-error-boundary';\nimport { ClientGreeting } from './client-greeting';\nexport default async function Home() {\n  prefetch(trpc.hello.queryOptions());\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ErrorBoundary fallback={<div>Something went wrong</div>}>\n        <Suspense fallback={<div>Loading...</div>}>\n          <ClientGreeting />\n        </Suspense>\n      </ErrorBoundary>\n    </HydrateClient>\n  );\n}\nCopy\napp/client-greeting.tsx\n'use client';\nimport { useSuspenseQuery } from '@tanstack/react-query';\nimport { trpc } from '~/trpc/client';\nexport function ClientGreeting() {\n  const trpc = useTRPC();\n  const { data } = useSuspenseQuery(trpc.hello.queryOptions());\n  return <div>{data.greeting}</div>;\n}\nCopy\nGetting data in a server component‚Äã\n\nIf you need access to the data in a server component, we recommend creating a server caller and using it directly. Please note that this method is detached from your query client and does not store the data in the cache. This means that you cannot use the data in a server component and expect it to be available in the client. This is intentional and explained in more detail in the Advanced Server Rendering guide.\n\ntrpc/server.tsx\n// ...\nexport const caller = appRouter.createCaller(createTRPCContext);\nCopy\napp/page.tsx\nimport { caller } from '~/trpc/server';\nexport default async function Home() {\n  const greeting = await caller.hello();\n  //    ^? { greeting: string }\n  return <div>{greeting.greeting}</div>;\n}\nCopy\n\nIf you really need to use the data both on the server as well as inside client components and understand the tradeoffs explained in the Advanced Server Rendering guide, you can use fetchQuery instead of prefetch to have the data both on the server as well as hydrating it down to the client:\n\napp/page.tsx\nimport { getQueryClient, HydrateClient, trpc } from '~/trpc/server';\nexport default async function Home() {\n  const queryClient = getQueryClient();\n  const greeting = await queryClient.fetchQuery(trpc.hello.queryOptions());\n  // Do something with greeting on the server\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ClientGreeting />\n    </HydrateClient>\n  );\n}\nCopy\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/react/setup",
		"html": "Client Usage\nReact Query Integration (Classic)\nSetup\nVersion: 11.x\nSet up the React Query Integration\n1. Install dependencies‚Äã\n\nThe following dependencies should be installed\n\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install @trpc/server @trpc/client @trpc/react-query @tanstack/react-query\n2. Import your AppRouter‚Äã\n\nImport your AppRouter type into the client application. This type holds the shape of your entire API.\n\nutils/trpc.ts\nimport type { AppRouter } from '../server/router';\nCopy\nTIP\n\nBy using import type you ensure that the reference will be stripped at compile-time, meaning you don't inadvertently import server-side code into your client. For more information, see the Typescript docs.\n\n3. Create tRPC hooks‚Äã\n\nCreate a set of strongly-typed React hooks from your AppRouter type signature with createTRPCReact.\n\nutils/trpc.ts\nimport { createTRPCReact } from '@trpc/react-query';\nimport type { AppRouter } from '../server/router';\n¬†\nexport const trpc = createTRPCReact<AppRouter>();\nCopy\n4. Add tRPC providers‚Äã\n\nCreate a tRPC client, and wrap your application in the tRPC Provider, as below. You will also need to set up and connect React Query, which they document in more depth.\n\nTIP\n\nIf you already use React Query in your application, you should re-use the QueryClient and QueryClientProvider you already have.\n\nApp.tsx\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { httpBatchLink } from '@trpc/client';\nimport React, { useState } from 'react';\nimport { trpc } from './utils/trpc';\nexport function App() {\n  const [queryClient] = useState(() => new QueryClient());\n  const [trpcClient] = useState(() =>\n    trpc.createClient({\n      links: [\n        httpBatchLink({\n          url: 'http://localhost:3000/trpc',\n          // You can pass any HTTP headers you wish here\n          async headers() {\n            return {\n              authorization: getAuthCookie(),\n            };\n          },\n        }),\n      ],\n    }),\n  );\n  return (\n    <trpc.Provider client={trpcClient} queryClient={queryClient}>\n      <QueryClientProvider client={queryClient}>\n        {/* Your app here */}\n      </QueryClientProvider>\n    </trpc.Provider>\n  );\n}\nCopy\nNOTE\n\nThe reason for using useState in the creation of the queryClient and the TRPCClient, as opposed to declaring them outside of the component, is to ensure that each request gets a unique client when using SSR. If you use client side rendering then you can move them if you wish.\n\n5. Fetch data‚Äã\n\nYou can now use the tRPC React Query integration to call queries and mutations on your API.\n\npages/IndexPage.tsx\nimport { trpc } from '../utils/trpc';\n¬†\nexport default function IndexPage() {\n  const userQuery = trpc.getUser.useQuery({ id: 'id_bilbo' });\n  const userCreator = trpc.createUser.useMutation();\n¬†\n  return (\n    <div>\n      <p>{userQuery.data?.name}</p>\n¬†\n      <button onClick={() => userCreator.mutate({ name: 'Frodo' })}>\n        Create Frodo\n      </button>\n    </div>\n  );\n}\nCopy\nEdit this page"
	},
	{
		"title": "Set up with React Server Components | tRPC",
		"url": "https://trpc.io/docs/client/react/server-components",
		"html": "Client Usage\nReact Query Integration (Classic)\nServer Components\nVersion: 11.x\nSet up with React Server Components\nTIP\n\nThese are the docs for our 'Classic' React Query integration, which (while still supported) is not the recommended way to start new tRPC projects with TanStack React Query. We recommend using the new TanStack React Query Integration instead.\n\nThis guide is an overview of how one may use tRPC with a React Server Components (RSC) framework such as Next.js App Router. Be aware that RSC on its own solves a lot of the same problems tRPC was designed to solve, so you may not need tRPC at all.\n\nThere are also not a one-size-fits-all way to integrate tRPC with RSCs, so see this guide as a starting point and adjust it to your needs and preferences.\n\nINFO\n\nIf you're looking for how to use tRPC with Server Actions, check out this blog post by Julius.\n\nCAUTION\n\nPlease read React Query's Advanced Server Rendering docs before proceeding to understand the different types of server rendering and what footguns to avoid.\n\nAdd tRPC to existing projects‚Äã\n1. Install deps‚Äã\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install @trpc/server @trpc/client @trpc/react-query @tanstack/react-query@latest zod client-only server-only\n2. Create a tRPC router‚Äã\n\nInitialize your tRPC backend in trpc/init.ts using the initTRPC function, and create your first router. We're going to make a simple \"hello world\" router and procedure here - but for deeper information on creating your tRPC API you should refer to the Quickstart guide and Backend usage docs for tRPC information.\n\nINFO\n\nThe file names used here are not enforced by tRPC. You may use any file structure you wish.\n\nView sample backend\n3. Create a Query Client factory‚Äã\n\nCreate a shared file trpc/query-client.ts that exports a function that creates a QueryClient instance.\n\ntrpc/query-client.ts\nimport {\n  defaultShouldDehydrateQuery,\n  QueryClient,\n} from '@tanstack/react-query';\nimport superjson from 'superjson';\nexport function makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 30 * 1000,\n      },\n      dehydrate: {\n        // serializeData: superjson.serialize,\n        shouldDehydrateQuery: (query) =>\n          defaultShouldDehydrateQuery(query) ||\n          query.state.status === 'pending',\n      },\n      hydrate: {\n        // deserializeData: superjson.deserialize,\n      },\n    },\n  });\n}\nCopy\n\nWe're setting a few default options here:\n\nstaleTime: With SSR, we usually want to set some default staleTime above 0 to avoid refetching immediately on the client.\nshouldDehydrateQuery: This is a function that determines whether a query should be dehydrated or not. Since the RSC transport protocol supports hydrating promises over the network, we extend the defaultShouldDehydrateQuery function to also include queries that are still pending. This will allow us to start prefetching in a server component high up the tree, then consuming that promise in a client component further down.\nserializeData and deserializeData (optional): If you set up a data transformer in the previous step, set this option to make sure the data is serialized correctly when hydrating the query client over the server-client boundary.\n4. Create a tRPC client for Client Components‚Äã\n\nThe trpc/client.tsx is the entrypoint when consuming your tRPC API from client components. In here, import the type definition of your tRPC router and create typesafe hooks using createTRPCReact. We'll also export our context provider from this file.\n\ntrpc/client.tsx\n'use client';\n// ^-- to make sure we can mount the Provider from a server component\nimport type { QueryClient } from '@tanstack/react-query';\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCReact } from '@trpc/react-query';\nimport { useState } from 'react';\nimport { makeQueryClient } from './query-client';\nimport type { AppRouter } from './routers/_app';\nexport const trpc = createTRPCReact<AppRouter>();\nlet clientQueryClientSingleton: QueryClient;\nfunction getQueryClient() {\n  if (typeof window === 'undefined') {\n    // Server: always make a new query client\n    return makeQueryClient();\n  }\n  // Browser: use singleton pattern to keep the same query client\n  return (clientQueryClientSingleton ??= makeQueryClient());\n}\nfunction getUrl() {\n  const base = (() => {\n    if (typeof window !== 'undefined') return '';\n    if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;\n    return 'http://localhost:3000';\n  })();\n  return `${base}/api/trpc`;\n}\nexport function TRPCProvider(\n  props: Readonly<{\n    children: React.ReactNode;\n  }>,\n) {\n  // NOTE: Avoid useState when initializing the query client if you don't\n  //       have a suspense boundary between this and the code that may\n  //       suspend because React will throw away the client on the initial\n  //       render if it suspends and there is no boundary\n  const queryClient = getQueryClient();\n  const [trpcClient] = useState(() =>\n    trpc.createClient({\n      links: [\n        httpBatchLink({\n          // transformer: superjson, <-- if you use a data transformer\n          url: getUrl(),\n        }),\n      ],\n    }),\n  );\n  return (\n    <trpc.Provider client={trpcClient} queryClient={queryClient}>\n      <QueryClientProvider client={queryClient}>\n        {props.children}\n      </QueryClientProvider>\n    </trpc.Provider>\n  );\n}\nCopy\n\nMount the provider in the root of your application (e.g. app/layout.tsx when using Next.js).\n\n5. Create a tRPC caller for Server Components‚Äã\n\nTo prefetch queries from server components, we use a tRPC caller. The @trpc/react-query/rsc module exports a thin wrapper around createCaller that integrates with your React Query client.\n\ntrpc/server.tsx\nimport 'server-only'; // <-- ensure this file cannot be imported from the client\nimport { createHydrationHelpers } from '@trpc/react-query/rsc';\nimport { cache } from 'react';\nimport { createCallerFactory, createTRPCContext } from './init';\nimport { makeQueryClient } from './query-client';\nimport { appRouter } from './routers/_app';\n// IMPORTANT: Create a stable getter for the query client that\n//            will return the same client during the same request.\nexport const getQueryClient = cache(makeQueryClient);\nconst caller = createCallerFactory(appRouter)(createTRPCContext);\nexport const { trpc, HydrateClient } = createHydrationHelpers<typeof appRouter>(\n  caller,\n  getQueryClient,\n);\nCopy\nUsing your API‚Äã\n\nNow you can use your tRPC API in your app. While you can use the React Query hooks in client components just like you would in any other React app, we can take advantage of the RSC capabilities by prefetching queries in a server component high up the tree. You may be familiar with this concept as \"render as you fetch\" commonly implemented as loaders. This means the request fires as soon as possible but without suspending until the data is needed by using the useQuery or useSuspenseQuery hooks.\n\napp/page.tsx\nimport { trpc } from '~/trpc/server';\nimport { ClientGreeting } from './client-greeting';\nexport default async function Home() {\n  void trpc.hello.prefetch();\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ClientGreeting />\n    </HydrateClient>\n  );\n}\nCopy\napp/client-greeting.tsx\n'use client';\n// <-- hooks can only be used in client components\nimport { trpc } from '~/trpc/client';\nexport function ClientGreeting() {\n  const greeting = trpc.hello.useQuery();\n  if (!greeting.data) return <div>Loading...</div>;\n  return <div>{greeting.data.greeting}</div>;\n}\nCopy\nLeveraging Suspense‚Äã\n\nYou may prefer handling loading and error states using Suspense and Error Boundaries. You can do this by using the useSuspenseQuery hook.\n\napp/page.tsx\nimport { trpc } from '~/trpc/server';\nimport { Suspense } from 'react';\nimport { ErrorBoundary } from 'react-error-boundary';\nimport { ClientGreeting } from './client-greeting';\nexport default async function Home() {\n  void trpc.hello.prefetch();\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ErrorBoundary fallback={<div>Something went wrong</div>}>\n        <Suspense fallback={<div>Loading...</div>}>\n          <ClientGreeting />\n        </Suspense>\n      </ErrorBoundary>\n    </HydrateClient>\n  );\n}\nCopy\napp/client-greeting.tsx\n'use client';\nimport { trpc } from '~/trpc/client';\nexport function ClientGreeting() {\n  const [data] = trpc.hello.useSuspenseQuery();\n  return <div>{data.greeting}</div>;\n}\nCopy\nGetting data in a server component‚Äã\n\nIf you need access to the data in a server component, you can invoke the procedure directly instead of using .prefetch(), just like you use the normal server caller. Please note that this method is de-attached from your query client and does not store the data in the cache. This means that you cannot use the data in a server component and expect it to be available in the client. This is intentional and explained in more detail in the Advanced Server Rendering guide.\n\napp/page.tsx\nimport { trpc } from '~/trpc/server';\nexport default async function Home() {\n  // Use the caller directly without using `.prefetch()`\n  const greeting = await trpc.hello();\n  //    ^? { greeting: string }\n  return <div>{greeting.greeting}</div>;\n}\nCopy\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/react/infer-types",
		"html": "Client Usage\nReact Query Integration (Classic)\nInferring Types\nVersion: 11.x\nInferring Types\n\nIn addition to the type inference made available by @trpc/server (see here) this integration also provides some inference helpers for usage purely in React.\n\nInfer React Query options based on your router‚Äã\n\nWhen creating custom hooks around tRPC procedures, it's sometimes necessary to have the types of the options inferred from the router. You can do so via the inferReactQueryProcedureOptions helper exported from @trpc/react-query.\n\ntrpc.ts\nimport {\n  createTRPCReact,\n  type inferReactQueryProcedureOptions,\n} from '@trpc/react-query';\nimport type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';\nimport type { AppRouter } from './server';\n¬†\n// infer the types for your router\nexport type ReactQueryOptions = inferReactQueryProcedureOptions<AppRouter>;\nexport type RouterInputs = inferRouterInputs<AppRouter>;\nexport type RouterOutputs = inferRouterOutputs<AppRouter>;\n¬†\nexport const trpc = createTRPCReact<AppRouter>();\nCopy\nusePostCreate.ts\nimport {\n  trpc,\n  type ReactQueryOptions,\n  type RouterInputs,\n  type RouterOutputs,\n} from './trpc';\n¬†\ntype PostCreateOptions = ReactQueryOptions['post']['create'];\n¬†\nfunction usePostCreate(options?: PostCreateOptions) {\n  const utils = trpc.useUtils();\n¬†\n  return trpc.post.create.useMutation({\n    ...options,\n    onSuccess(post) {\n      // invalidate all queries on the post router\n      // when a new post is created\n      utils.post.invalidate();\n      options?.onSuccess?.(post);\n    },\n  });\n}\nCopy\nusePostById.ts\nimport { ReactQueryOptions, RouterInputs, trpc } from './trpc';\n¬†\ntype PostByIdOptions = ReactQueryOptions['post']['byId'];\ntype PostByIdInput = RouterInputs['post']['byId'];\n¬†\nfunction usePostById(input: PostByIdInput, options?: PostByIdOptions) {\n  return trpc.post.byId.useQuery(input, options);\n}\nCopy\nInfer abstract types from a \"Router Factory\"‚Äã\n\nIf you write a factory which creates a similar router interface several times in your application, you may wish to share client code between usages of the factory. @trpc/react-query/shared exports several types which can be used to generate abstract types for a router factory, and build common React components which are passed the router as a prop.\n\napi/factory.ts\nimport { t, publicProcedure } from './trpc';\n¬†\n// @trpc/react-query/shared exports several **Like types which can be used to generate abstract types\nimport { RouterLike, UtilsLike } from '@trpc/react-query/shared';\n¬†\n// Factory function written by you, however you need,\n// so long as you can infer the resulting type of t.router() later\nexport function createMyRouter() {\n  return t.router({\n    createThing: publicProcedure\n      .input(ThingRequest)\n      .output(Thing)\n      .mutation(/* do work */),\n    listThings: publicProcedure\n      .input(ThingQuery)\n      .output(ThingArray)\n      .query(/* do work */),\n  })\n}\n¬†\n// Infer the type of your router, and then generate the abstract types for use in the client\ntype MyRouterType = ReturnType<typeof createMyRouter>\nexport MyRouterLike = RouterLike<MyRouterType>\nexport MyRouterUtilsLike = UtilsLike<MyRouterType>\nCopy\napi/server.ts\nexport type AppRouter = typeof appRouter;\n¬†\n// Export your MyRouter types to the client\nexport type { MyRouterLike, MyRouterUtilsLike } from './factory';\nCopy\nfrontend/usePostCreate.ts\nimport type { MyRouterLike, MyRouterUtilsLike, trpc, useUtils } from './trpc';\n¬†\ntype MyGenericComponentProps = {\n  route: MyRouterLike;\n  utils: MyRouterUtilsLike;\n};\n¬†\nfunction MyGenericComponent(props: MyGenericComponentProps) {\n  const { route } = props;\n  const thing = route.listThings.useQuery({\n    filter: 'qwerty',\n  });\n¬†\n  const mutation = route.doThing.useMutation({\n    onSuccess() {\n      props.utils.listThings.invalidate();\n    },\n  });\n¬†\n  function handleClick() {\n    mutation.mutate({\n      name: 'Thing 1',\n    });\n  }\n¬†\n  return; /* ui */\n}\n¬†\nfunction MyPageComponent() {\n  const utils = useUtils();\n¬†\n  return (\n    <MyGenericComponent\n      route={trpc.deep.route.things}\n      utils={utils.deep.route.things}\n    />\n  );\n}\n¬†\nfunction MyOtherPageComponent() {\n  const utils = useUtils();\n¬†\n  return (\n    <MyGenericComponent\n      route={trpc.different.things}\n      utils={utils.different.things}\n    />\n  );\n}\nCopy\n\nA more complete working example can be found here\n\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/react/useQuery",
		"html": "Client Usage\nReact Query Integration (Classic)\nuseQuery()\nVersion: 11.x\nuseQuery()\n\nuseQuery is the primary hook for data fetching, it works similarly to @tanstack/react-query's useQuery, but with some trpc specific options and additional features like streaming.\n\nNOTE\n\nFor in-depth information about options and usage patterns, refer to the TanStack Query docs on queries.\n\nSignature‚Äã\nfunction useQuery(\n  input: TInput | SkipToken,\n  opts?: UseTRPCQueryOptions;\n)\ninterface UseTRPCQueryOptions\n  extends UseQueryOptions {\n  trpc: {\n    ssr?: boolean;\n    abortOnUnmount?: boolean;\n    context?: Record<string, unknown>;\n  }\n}\nCopy\n\nSince UseTRPCQueryOptions extends @tanstack/react-query's UseQueryOptions, you can use any of their options here such as enabled, refetchOnWindowFocus, etc. We also have some trpc specific options that let you opt in or out of certain behaviors on a per-procedure level:\n\ntrpc.ssr: If you have ssr: true in your global config, you can set this to false to disable ssr for this particular query. Note that this does not work the other way around, i.e., you can not enable ssr on a procedure if your global config is set to false.\ntrpc.abortOnUnmount: Override the global config and opt in or out of aborting queries on unmount.\ntrpc.context: Add extra meta data that could be used in Links.\nTIP\n\nIf you need to set any options but don't want to pass any input, you can pass undefined instead.\n\nYou'll notice that you get autocompletion on the input based on what you have set in your input schema on your backend.\n\nExample usage‚Äã\nBackend code\ncomponents/MyComponent.tsx\nimport { trpc } from '../utils/trpc';\nexport function MyComponent() {\n  // input is optional, so we don't have to pass second argument\n  const helloNoArgs = trpc.hello.useQuery();\n  const helloWithArgs = trpc.hello.useQuery({ text: 'client' });\n  return (\n    <div>\n      <h1>Hello World Example</h1>\n      <ul>\n        <li>\n          helloNoArgs ({helloNoArgs.status}):{' '}\n          <pre>{JSON.stringify(helloNoArgs.data, null, 2)}</pre>\n        </li>\n        <li>\n          helloWithArgs ({helloWithArgs.status}):{' '}\n          <pre>{JSON.stringify(helloWithArgs.data, null, 2)}</pre>\n        </li>\n      </ul>\n    </div>\n  );\n}\nCopy\nStreaming responses using async generators‚Äã\nINFO\n\nSince v11 we now support streaming queries when using the httpBatchStreamLink.\n\nWhen returning an async generators in a query, you will:\n\nGet the results of the iterator in the data-property as an array which updates as the response comes in\nThe status will be success as soon as the first chunk is received.\nThe fetchStatus property which will be fetching until the last chunk is received.\nExample‚Äã\nserver/routers/_app.ts\nimport { publicProcedure, router } from './trpc';\nconst appRouter = router({\n  iterable: publicProcedure.query(async function* () {\n    for (let i = 0; i < 3; i++) {\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      yield i;\n    }\n  }),\n});\nexport type AppRouter = typeof appRouter;\nCopy\ncomponents/MyComponent.tsx\nimport { trpc } from '~/utils';\nexport function MyComponent() {\n  const result = trpc.iterable.useQuery();\n  return (\n    <div>\n      {result.data?.map((chunk, index) => (\n        <Fragment key={index}>{chunk}</Fragment>\n      ))}\n    </div>\n  );\n}\nCopy\n\nresult properties while streaming:\n\nstatus\tfetchStatus\tdata\n'pending'\t'fetching'\tundefined\n'success'\t'fetching'\t[]\n'success'\t'fetching'\t[1]\n'success'\t'fetching'\t[1, 2]\n'success'\t'fetching'\t[1, 2, 3]\n'success'\t'idle'\t[1, 2, 3]\nEdit this page"
	},
	{
		"title": "useMutation() | tRPC",
		"url": "https://trpc.io/docs/client/react/useMutation",
		"html": "Client Usage\nReact Query Integration (Classic)\nuseMutation()\nVersion: 11.x\nuseMutation()\nNOTE\n\nThe hooks provided by @trpc/react-query are a thin wrapper around @tanstack/react-query. For in-depth information about options and usage patterns, refer to their docs on mutations.\n\nWorks like react-query's mutations - see their docs.\n\nExample‚Äã\nBackend code\nimport { trpc } from '../utils/trpc';\nexport function MyComponent() {\n  const mutation = trpc.login.useMutation();\n  const handleLogin = () => {\n    const name = 'John Doe';\n    mutation.mutate({ name });\n  };\n  return (\n    <div>\n      <h1>Login Form</h1>\n      <button onClick={handleLogin} disabled={mutation.isPending}>\n        Login\n      </button>\n      {mutation.error && <p>Something went wrong! {mutation.error.message}</p>}\n    </div>\n  );\n}\nCopy\nEdit this page"
	},
	{
		"title": "useInfiniteQuery | tRPC",
		"url": "https://trpc.io/docs/client/react/useInfiniteQuery",
		"html": "Client Usage\nReact Query Integration (Classic)\nuseInfiniteQuery()\nVersion: 11.x\nuseInfiniteQuery\nINFO\nYour procedure needs to accept a cursor input of any type (string, number, etc) to expose this hook.\nFor more details on infinite queries read the react-query docs\nIn this example we're using Prisma - see their docs on cursor-based pagination\nExample Procedure‚Äã\nserver/routers/_app.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\nimport { Context } from './[trpc]';\nexport const t = initTRPC.create();\nexport const appRouter = t.router({\n  infinitePosts: t.procedure\n    .input(\n      z.object({\n        limit: z.number().min(1).max(100).nullish(),\n        cursor: z.number().nullish(), // <-- \"cursor\" needs to exist, but can be any type\n        direction: z.enum(['forward', 'backward']), // optional, useful for bi-directional query\n      }),\n    )\n    .query(async (opts) => {\n      const { input } = opts;\n      const limit = input.limit ?? 50;\n      const { cursor } = input;\n      const items = await prisma.post.findMany({\n        take: limit + 1, // get an extra item at the end which we'll use as next cursor\n        where: {\n          title: {\n            contains: 'Prisma' /* Optional filter */,\n          },\n        },\n        cursor: cursor ? { myCursor: cursor } : undefined,\n        orderBy: {\n          myCursor: 'asc',\n        },\n      });\n      let nextCursor: typeof cursor | undefined = undefined;\n      if (items.length > limit) {\n        const nextItem = items.pop();\n        nextCursor = nextItem!.myCursor;\n      }\n      return {\n        items,\n        nextCursor,\n      };\n    }),\n});\nCopy\nExample React Component‚Äã\ncomponents/MyComponent.tsx\nimport { trpc } from '../utils/trpc';\nexport function MyComponent() {\n  const myQuery = trpc.infinitePosts.useInfiniteQuery(\n    {\n      limit: 10,\n    },\n    {\n      getNextPageParam: (lastPage) => lastPage.nextCursor,\n      // initialCursor: 1, // <-- optional you can pass an initialCursor\n    },\n  );\n  // [...]\n}\nCopy\nHelpers‚Äã\ngetInfiniteData()‚Äã\n\nThis helper gets the currently cached data from an existing infinite query\n\ncomponents/MyComponent.tsx\nimport { trpc } from '../utils/trpc';\nexport function MyComponent() {\n  const utils = trpc.useUtils();\n  const myMutation = trpc.infinitePosts.add.useMutation({\n    async onMutate(opts) {\n      await utils.infinitePosts.cancel();\n      const allPosts = utils.infinitePosts.getInfiniteData({ limit: 10 });\n      // [...]\n    },\n  });\n}\nCopy\nsetInfiniteData()‚Äã\n\nThis helper allows you to update a query's cached data\n\ncomponents/MyComponent.tsx\nimport { trpc } from '../utils/trpc';\nexport function MyComponent() {\n  const utils = trpc.useUtils();\n  const myMutation = trpc.infinitePosts.delete.useMutation({\n    async onMutate(opts) {\n      await utils.infinitePosts.cancel();\n      utils.infinitePosts.setInfiniteData({ limit: 10 }, (data) => {\n        if (!data) {\n          return {\n            pages: [],\n            pageParams: [],\n          };\n        }\n        return {\n          ...data,\n          pages: data.pages.map((page) => ({\n            ...page,\n            items: page.items.filter((item) => item.status === 'published'),\n          })),\n        };\n      });\n    },\n  });\n  // [...]\n}\nCopy\nEdit this page"
	},
	{
		"title": "useSubscription() | tRPC",
		"url": "https://trpc.io/docs/client/react/useSubscription",
		"html": "Client Usage\nReact Query Integration (Classic)\nuseSubscription()\nVersion: 11.x\nuseSubscription()\n\nThe useSubscription hook can be used to subscribe to a subscription procedure on the server.\n\nSignature‚Äã\nOptions‚Äã\nTIP\nIf you need to set any options but don't want to pass any input, you can pass undefined instead.\nIf you pass skipToken from @tanstack/react-query, the subscription will be paused.\nHave a look at our SSE example for a complete example of how to use subscriptions\nfunction useSubscription<TOutput, TError>(\n  input: TInput | SkipToken,\n  opts?: UseTRPCSubscriptionOptions<TOutput, TError>,\n): TRPCSubscriptionResult<TOutput, TError>;\ninterface UseTRPCSubscriptionOptions<TOutput, TError> {\n  /**\n   * Callback invoked when the subscription starts.\n   */\n  onStarted?: () => void;\n  /**\n   * Callback invoked when new data is received from the subscription.\n   * @param data - The data received.\n   */\n  onData?: (data: TOutput) => void;\n  /**\n   * Callback invoked when an **unrecoverable error** occurs and the subscription is stopped.\n   */\n  onError?: (error: TError) => void;\n  /**\n   * Callback invoked when the subscription is completed.\n   */\n  onComplete?: () => void;\n  /**\n   * @deprecated Use a `skipToken` from `@tanstack/react-query` instead.\n   * This will be removed in a future version.\n   */\n  enabled?: boolean;\n}\nCopy\nReturn type‚Äã\ntype TRPCSubscriptionResult<TOutput, TError> = {\n  /**\n   * The current status of the subscription.\n   * Will be one of: `'idle'`, `'connecting'`, `'pending'`, or `'error'`.\n   *\n   * - `idle`: subscription is disabled or ended\n   * - `connecting`: trying to establish a connection\n   * - `pending`: connected to the server, receiving data\n   * - `error`: an error occurred and the subscription is stopped\n   */\n  status: 'idle' | 'connecting' | 'pending' | 'error';\n  /**\n   * The last data received from the subscription.\n   */\n  data: TOutput | undefined;\n  /**\n   * The last error received - will be `null` whenever the status is `'pending'` or `'idle'`\n   * - has a value only when the status is `'error'`\n   * - *may* have a value when the status is `'connecting'`\n   */\n  error: TRPCClientError | null;\n  /**\n   * Function to reset the subscription.\n   */\n  reset: () => void;\n};\nCopy\nExample‚Äã\ncomponents/MyComponent.tsx\nimport { trpc } from '../utils/trpc';\nexport function MyComponent() {\n  const [numbers, setNumbers] = React.useState<number[]>([]);\n  const result = trpc.onNumber.useSubscription(undefined, {\n    onData: (num) => {\n      setNumbers((prev) => [...prev, num]);\n    },\n  });\n  return (\n    <div>\n      <h1>Subscription Example</h1>\n      <p>\n        {result.status}: <pre>{JSON.stringify(result.data, null, 2)}</pre>\n      </p>\n      <h2>Previous numbers:</h2>\n      <ul>\n        {numbers.map((num, i) => (\n          <li key={i}>{num}</li>\n        ))}\n      </ul>\n      {result.status === 'error' && (\n        <button onClick={() => result.reset()}>\n          Something went wrong - restart the subscription\n        </button>\n      )}\n    </div>\n  );\n}\nCopy\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/react/useUtils",
		"html": "Client Usage\nReact Query Integration (Classic)\nuseUtils()\nVersion: 11.x\nuseUtils\n\nuseUtils is a hook that gives you access to helpers that let you manage the cached data of the queries you execute via @trpc/react-query. These helpers are actually thin wrappers around @tanstack/react-query's queryClient methods. If you want more in-depth information about options and usage patterns for useContext helpers than what we provide here, we will link to their respective @tanstack/react-query docs so you can refer to them accordingly.\n\nNOTE\n\nThis hook was called useContext() until 10.41.0 (and is still aliased for the foreseeable future)\n\nUsage‚Äã\n\nuseUtils returns an object with all the available queries you have in your routers. You use it the same way as your trpc client object. Once you reach a query, you'll have access to the query helpers. For example, let's say you have a post router with an all query:\n\nserver.ts\n// @filename: server.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n¬†\nconst t = initTRPC.create();\n¬†\nconst appRouter = t.router({\n  post: t.router({\n    all: t.procedure.query(() => {\n      return {\n        posts: [\n          { id: 1, title: 'everlong' },\n          { id: 2, title: 'After Dark' },\n        ],\n      };\n    }),\n  }),\n});\n¬†\nexport type AppRouter = typeof appRouter;\nCopy\n\nNow in our component, when we navigate the object useUtils gives us and reach the post.all query, we'll get access to our query helpers!\n\nMyComponent.tsx\nfunction MyComponent() {\n  const utils = trpc.useUtils();\n  utils.post.all.f;\n¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†\nfetch\nfetchInfinite\n  // [...]\n}\nCopy\nHelpers‚Äã\n\nThese are the helpers you'll get access to via useUtils. The table below will help you know which tRPC helper wraps which @tanstack/react-query helper method. Each react-query method will link to its respective docs/guide:\n\ntRPC helper wrapper\t@tanstack/react-query helper method\nfetch\tqueryClient.fetchQuery\nprefetch\tqueryClient.prefetchQuery\nfetchInfinite\tqueryClient.fetchInfiniteQuery\nprefetchInfinite\tqueryClient.prefetchInfiniteQuery\nensureData\tqueryClient.ensureData\ninvalidate\tqueryClient.invalidateQueries\nrefetch\tqueryClient.refetchQueries\ncancel\tqueryClient.cancelQueries\nsetData\tqueryClient.setQueryData\nsetQueriesData\tqueryClient.setQueriesData\ngetData\tqueryClient.getQueryData\nsetInfiniteData\tqueryClient.setInfiniteQueryData\ngetInfiniteData\tqueryClient.getInfiniteData\nsetMutationDefaults\tqueryClient.setMutationDefaults\ngetMutationDefaults\tqueryClient.getMutationDefaults\nisMutating\tqueryClient.isMutating\n‚ùì The function I want isn't here!‚Äã\n\n@tanstack/react-query has a lot of functions that we haven't put in the tRPC context yet. If you need a function that isn't here, feel free to open a feature request requesting it.\n\nIn the meantime, you can import and use the function directly from @tanstack/react-query. We also provide a getQueryKey which you can use to get the correct queryKey on the filters when using these functions.\n\nProxy client‚Äã\n\nIn addition to the above react-query helpers, the context also exposes your tRPC proxy client. This lets you call your procedures with async/await without needing to create an additional vanilla client.\n\nimport { trpc } from '../utils/trpc';\nfunction MyComponent() {\n  const [apiKey, setApiKey] = useState();\n  const utils = trpc.useUtils();\n  return (\n    <Form\n      handleSubmit={async (event) => {\n        const apiKey = await utils.client.apiKey.create.mutate(event);\n        setApiKey(apiKey);\n      }}\n    >\n      ...\n    </Form>\n  );\n}\nCopy\nQuery Invalidation‚Äã\n\nYou invalidate queries via the invalidate helper. invalidate is actually a special helper given that, unlike the other helpers, it's available at every level of the router map. This means you can either run invalidate on a single query, a whole router, or every router if you want. We get more in detail in the sections below.\n\nInvalidating a single query‚Äã\n\nYou can invalidate a query relating to a single procedure and even filter based on the input passed to it to prevent unnecessary calls to the back end.\n\nExample code‚Äã\nimport { trpc } from '../utils/trpc';\nfunction MyComponent() {\n  const utils = trpc.useUtils();\n  const mutation = trpc.post.edit.useMutation({\n    onSuccess(input) {\n      utils.post.all.invalidate();\n      utils.post.byId.invalidate({ id: input.id }); // Will not invalidate queries for other id's üëç\n    },\n  });\n  // [...]\n}\nCopy\nInvalidating across whole routers‚Äã\n\nIt is also possible to invalidate queries across an entire router rather then just one query.\n\nExample code‚Äã\nBackend code\nimport { trpc } from '../utils/trpc';\nfunction MyComponent() {\n  const utils = trpc.useUtils();\n  const invalidateAllQueriesAcrossAllRouters = () => {\n    // 1Ô∏è‚É£\n    // All queries on all routers will be invalidated üî•\n    utils.invalidate();\n  };\n  const invalidateAllPostQueries = () => {\n    // 2Ô∏è‚É£\n    // All post queries will be invalidated üì≠\n    utils.post.invalidate();\n  };\n  const invalidatePostById = () => {\n    // 3Ô∏è‚É£\n    // All queries in the post router with input {id:1} invalidated üì≠\n    utils.post.byId.invalidate({ id: 1 });\n  };\n  // Example queries\n  trpc.user.all.useQuery(); // Would only be validated by 1Ô∏è‚É£ only.\n  trpc.post.all.useQuery(); // Would be invalidated by 1Ô∏è‚É£ & 2Ô∏è‚É£\n  trpc.post.byId.useQuery({ id: 1 }); // Would be invalidated by 1Ô∏è‚É£, 2Ô∏è‚É£ and 3Ô∏è‚É£\n  trpc.post.byId.useQuery({ id: 2 }); // would be invalidated by 1Ô∏è‚É£ and 2Ô∏è‚É£ but NOT 3Ô∏è‚É£!\n  // [...]\n}\nCopy\nInvalidate full cache on every mutation‚Äã\n\nKeeping track of exactly what queries a mutation should invalidate is hard, therefore, it can be a pragmatic solution to invalidate the full cache as a side-effect on any mutation. Since we have request batching, this invalidation will simply refetch all queries on the page you're looking at in one single request.\n\nWe have added a feature to help with this:\n\nexport const trpc = createTRPCReact<AppRouter, SSRContext>({\n  overrides: {\n    useMutation: {\n      /**\n       * This function is called whenever a `.useMutation` succeeds\n       **/\n      async onSuccess(opts) {\n        /**\n         * @note that order here matters:\n         * The order here allows route changes in `onSuccess` without\n         * having a flash of content change whilst redirecting.\n         **/\n        // Calls the `onSuccess` defined in the `useQuery()`-options:\n        await opts.originalFn();\n        // Invalidate all queries in the react-query cache:\n        await opts.queryClient.invalidateQueries();\n      },\n    },\n  },\n});\nCopy\nAdditional Options‚Äã\n\nAside from the query helpers, the object useUtils returns also contains the following properties:\n\ninterface ProxyTRPCContextProps<TRouter extends AnyRouter, TSSRContext> {\n  /**\n   * The `TRPCClient`\n   */\n  client: TRPCClient<TRouter>;\n  /**\n   * The SSR context when server-side rendering\n   * @default null\n   */\n  ssrContext?: TSSRContext | null;\n  /**\n   * State of SSR hydration.\n   * - `false` if not using SSR.\n   * - `prepass` when doing a prepass to fetch queries' data\n   * - `mounting` before TRPCProvider has been rendered on the client\n   * - `mounted` when the TRPCProvider has been rendered on the client\n   * @default false\n   */\n  ssrState?: SSRState;\n  /**\n   * Abort loading query calls when unmounting a component - usually when navigating to a new page\n   * @default false\n   */\n  abortOnUnmount?: boolean;\n}\nCopy\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/react/createTRPCQueryUtils",
		"html": "Client Usage\nReact Query Integration (Classic)\ncreateTRPCQueryUtils()\nVersion: 11.x\ncreateTRPCQueryUtils\n\nThe use case for createTRPCQueryUtils is when you need to use the helpers outside of a React Component, for example in react-routers loaders.\n\nSimilar to useUtils, createTRPCQueryUtils is a function that gives you access to helpers that let you manage the cached data of the queries you execute via @trpc/react-query. These helpers are actually thin wrappers around @tanstack/react-query's queryClient methods. If you want more in-depth information about options and usage patterns for useUtils helpers than what we provide here, we will link to their respective @tanstack/react-query docs so you can refer to them accordingly.\n\nThe difference between useUtils and createTRPCQueryUtils is that useUtils is a react hook that uses useQueryClient under the hood. This means that it is able to work better within React Components.\n\nIf you need access to the client directly, you can use the client object that you passed to createTRPCQueryUtils during creation.\n\nCAUTION\n\nYou should avoid using createTRPCQueryUtils in React Components. Instead, use useUtils which is a React hook that implements useCallback and useQueryClient under the hood.\n\nUsage‚Äã\n\ncreateTRPCQueryUtils returns an object with all the available queries you have in your routers. You use it the same way as your trpc client object. Once you reach a query, you'll have access to the query helpers. For example, let's say you have a post router with an all query:\n\nNow in our component, when we navigate the object createTRPCQueryUtils gives us and reach the post.all query, we'll get access to our query helpers!\n\nMyPage.tsx\nimport { QueryClient } from '@tanstack/react-query';\nimport { createTRPCQueryUtils, createTRPCReact } from '@trpc/react-query';\nimport { useLoaderData } from 'react-router-dom';\nimport type { AppRouter } from './server';\nconst trpc = createTRPCReact<AppRouter>();\nconst trpcClient = trpc.createClient({ links: [] });\nconst queryClient = new QueryClient();\nconst clientUtils = createTRPCQueryUtils({ queryClient, client: trpcClient });\n// This is a react-router loader\nexport async function loader() {\n  const allPostsData = await clientUtils.post.all.ensureData(); // Fetches data if it doesn't exist in the cache\n  return {\n    allPostsData,\n  };\n}\n// This is a react component\nexport function Component() {\n  const loaderData = useLoaderData() as Awaited<ReturnType<typeof loader>>;\n  const allPostQuery = trpc.post.all.useQuery({\n    initialData: loaderData.allPostsData, // Uses the data from the loader\n  });\n  return (\n    <div>\n      {allPostQuery.data.posts.map((post) => (\n        <div key={post.id}>{post.title}</div>\n      ))}\n    </div>\n  );\n}\nCopy\nNOTE\n\nIf you were using Remix Run or SSR you wouldn't re-use the same queryClient for every request. Instead, you would create a new queryClient for every request so that there's no cross-request data leakage.\n\nHelpers‚Äã\n\nMuch like useUtils, createTRPCQueryUtils gives you access to same set of helpers. The only difference is that you need to pass in the queryClient and client objects.\n\nYou can see them on the useUtils-page.\n\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/react/useQueries",
		"html": "Client Usage\nReact Query Integration (Classic)\nuseQueries()\nVersion: 11.x\nuseQueries()\n\nThe useQueries hook can be used to fetch a variable number of queries at the same time using only one hook call.\n\nThe main use case for such a hook is to be able to fetch a number of queries, usually of the same type. For example if you fetch a list of todo ids, you can then map over them in a useQueries hook calling a byId endpoint that would fetch the details of each todo.\n\nNOTE\n\nWhile fetching multiple types in a useQueries hook is possible, there is not much of an advantage compared to using multiple useQuery calls unless you use the suspense option as that useQueries can trigger suspense in parallel while multiple useQuery calls would waterfall.\n\nUsage‚Äã\n\nThe useQueries hook is the same as that of @tanstack/query useQueries. The only difference is that you pass in a function that returns an array of queries instead of an array of queries inside an object parameter.\n\nTIP\n\nWhen you're using the httpBatchLink or wsLink, the below will end up being only 1 HTTP call to your server. Additionally, if the underlying procedure is using something like Prisma's findUnique() it will automatically batch & do exactly 1 database query as a well.\n\nconst Component = (props: { postIds: string[] }) => {\n  const postQueries = trpc.useQueries((t) =>\n    props.postIds.map((id) => t.post.byId({ id })),\n  );\n  return <>{/* [...] */}</>;\n};\nCopy\nProviding options to individual queries‚Äã\n\nYou can also pass in any normal query options to the second parameter of any of the query calls in the array such as enabled, suspense, refetchOnWindowFocus...etc. For a complete overview of all the available options, see the tanstack useQuery documentation.\n\nconst Component = () => {\n  const [post, greeting] = trpc.useQueries((t) => [\n    t.post.byId({ id: '1' }, { enabled: false }),\n    t.greeting({ text: 'world' }),\n  ]);\n  const onButtonClick = () => {\n    post.refetch();\n  };\n  return (\n    <div>\n      <h1>{post.data && post.data.title}</h1>\n      <p>{greeting.data.message}</p>\n      <button onClick={onButtonClick}>Click to fetch</button>\n    </div>\n  );\n};\nCopy\nContext‚Äã\n\nYou can also pass in an optional React Query context to override the default.\n\nconst [post, greeting] = trpc.useQueries(\n  (t) => [t.post.byId({ id: '1' }), t.greeting({ text: 'world' })],\n  myCustomContext,\n);\nCopy\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/react/suspense",
		"html": "Client Usage\nReact Query Integration (Classic)\nSuspense\nVersion: 11.x\nSuspense\nINFO\nEnsure you're on the latest version of React\nIf you use suspense with tRPC's automatic SSR in Next.js, the full page will crash on the server if a query fails, even if you have an <ErrorBoundary />\nUsage‚Äã\nTIP\n\nuseSuspenseQuery & useSuspenseInfiniteQuery both return a [data, query]-tuple, to make it easy to directly use your data and renaming the variable to something descriptive\n\nuseSuspenseQuery()‚Äã\n// @filename: pages/index.tsx\nimport React from 'react';\nimport { trpc } from '../utils/trpc';\n¬†\nfunction PostView() {\n  const [post, postQuery] = trpc.post.byId.useSuspenseQuery({ id: '1' });\n          \nconst post: {\n    id: string;\n    title: string;\n}\n¬†\n  return <>{/* ... */}</>;\n}\nCopy\nuseSuspenseInfiniteQuery()‚Äã\n// @filename: pages/index.tsx\nimport React from 'react';\nimport { trpc } from '../utils/trpc';\nfunction PostView() {\n  const [{ pages }, allPostsQuery] = trpc.post.all.useSuspenseInfiniteQuery(\n    {},\n    {\n      getNextPageParam(lastPage) {\n        return lastPage.nextCursor;\n      },\n    },\n  );\n  const { isFetching, isFetchingNextPage, fetchNextPage, hasNextPage } =\n    allPostsQuery;\n  return <>{/* ... */}</>;\n}\nCopy\nuseSuspenseQueries()‚Äã\n\nSuspense equivalent of useQueries().\n\nconst Component = (props: { postIds: string[] }) => {\n  const [posts, postQueries] = trpc.useSuspenseQueries((t) =>\n    props.postIds.map((id) => t.post.byId({ id })),\n  );\n  return <>{/* [...] */}</>;\n};\nCopy\nPrefetching‚Äã\n\nThe performance of suspense queries can be improved by prefetching the query data before the Suspense component is rendered (this is sometimes called \"render-as-you-fetch\").\n\nNOTE\nPrefetching and the render-as-you-fetch model are very dependent on the framework and router you are using. We recommend reading your frameworks router docs along with the @tanstack/react-query docs to understand how to implement these patterns.\nIf you are using Next.js please look at the docs on Server-Side Helpers to implement server-side prefetching.\nRoute-level prefetching‚Äã\nconst utils = createTRPCQueryUtils({ queryClient, client: trpcClient });\n// tanstack router/ react router loader\nconst loader = async (params: { id: string }) =>\n  utils.post.byId.ensureQueryData({ id: params.id });\nCopy\nComponent-level prefetching with usePrefetchQuery‚Äã\nimport { trpc } from '../utils/trpc';\nfunction PostViewPage(props: { postId: string }) {\n  trpc.post.byId.usePrefetchQuery({ id: props.postId });\n  return (\n    <Suspense>\n      <PostView postId={props.postId} />\n    </Suspense>\n  );\n}\nCopy\nComponent-level prefetching with usePrefetchInfiniteQuery‚Äã\nimport { trpc } from '../utils/trpc';\n// will have to be passed to the child PostView `useSuspenseInfiniteQuery`\nexport const getNextPageParam = (lastPage) => lastPage.nextCursor;\nfunction PostViewPage(props: { postId: string }) {\n  trpc.post.all.usePrefetchInfiniteQuery({}, { getNextPageParam });\n  return (\n    <Suspense>\n      <PostView postId={props.postId} />\n    </Suspense>\n  );\n}\nCopy\nEdit this page"
	},
	{
		"title": "getQueryKey | tRPC",
		"url": "https://trpc.io/docs/client/react/getQueryKey",
		"html": "Client Usage\nReact Query Integration (Classic)\ngetQueryKey()\nVersion: 11.x\ngetQueryKey\n\nWe provide a getQueryKey helper that accepts a router or procedure so that you can easily provide the native function the correct query key.\n\n// Queries\nfunction getQueryKey(\n  procedure: AnyQueryProcedure,\n  input?: DeepPartial<TInput>,\n  type?: QueryType; /** @default 'any' */\n): TRPCQueryKey;\n// Routers\nfunction getQueryKey(\n  router: AnyRouter,\n): TRPCQueryKey;\ntype QueryType = \"query\" | \"infinite\" | \"any\";\n// for useQuery ‚îÄ‚îÄ‚îò         ‚îÇ            ‚îÇ\n// for useInfiniteQuery ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ\n// will match all ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\nCopy\nNOTE\n\nThe query type any will match all queries in the cache only if the react query method where it's used uses fuzzy matching. See TanStack/query#5111 (comment) for more context.\n\nimport { useIsFetching, useQueryClient } from '@tanstack/react-query';\nimport { getQueryKey } from '@trpc/react-query';\nimport { trpc } from '~/utils/trpc';\nfunction MyComponent() {\n  const queryClient = useQueryClient();\n  const posts = trpc.post.list.useQuery();\n  // See if a query is fetching\n  const postListKey = getQueryKey(trpc.post.list, undefined, 'query');\n  const isFetching = useIsFetching(postListKey);\n  // Set some query defaults for an entire router\n  const postKey = getQueryKey(trpc.post);\n  queryClient.setQueryDefaults(postKey, { staleTime: 30 * 60 * 1000 });\n  // ...\n}\nCopy\nMutations‚Äã\n\nSimilarly to queries, we provide a getMutationKey for mutations. The underlying function is the same as getQueryKey (in fact, you could technically use getQueryKey for mutations as well), the only difference is in semantics.\n\nfunction getMutationKey(procedure: AnyMutationProcedure): TRPCMutationKey;\nCopy\nEdit this page"
	},
	{
		"title": "Aborting Procedure Calls | tRPC",
		"url": "https://trpc.io/docs/client/react/aborting-procedure-calls",
		"html": "Client Usage\nReact Query Integration (Classic)\nAborting Procedure Calls\nVersion: 11.x\nAborting Procedure Calls\n\nBy default, tRPC does not cancel requests via React Query. If you want to opt into this behaviour, you can provide abortOnUnmount in your configuration.\n\nNOTE\n\n@tanstack/react-query only supports aborting queries.\n\nGlobally‚Äã\nclient.ts\n// @filename: utils.ts\nimport { createTRPCReact } from '@trpc/react-query';\n¬†\nexport const trpc = createTRPCReact<AppRouter>({\n  abortOnUnmount: true,\n});\n¬†\ntrpc.createClient({\n  // ...\n});\nCopy\nPer-request‚Äã\n\nYou may also override this behaviour at the query level.\n\npages/post/[id].tsx\nimport { trpc } from '../utils/trpc';\n¬†\nfunction PostViewPage() {\n  const { query } = useRouter();\n  const postQuery = trpc.post.byId.useQuery(\n    { id: query.id },\n    { trpc: { abortOnUnmount: true } }\n  );\n¬†\n  // ...\n}\nCopy\nEdit this page"
	},
	{
		"title": "HTTP Link | tRPC",
		"url": "https://trpc.io/docs/client/links/httpLink",
		"html": "Client Usage\nLinks\nHTTP Link\nVersion: 11.x\nHTTP Link\n\nhttpLink is a terminating link that sends a tRPC operation to a tRPC procedure over HTTP.\n\nhttpLink supports both POST and GET requests.\n\nUsage‚Äã\n\nYou can import and add the httpLink to the links array as such:\n\nclient/index.ts\nimport { createTRPCClient, httpLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpLink({\n      url: 'http://localhost:3000',\n      // transformer,\n    }),\n  ],\n});\nCopy\nhttpLink Options‚Äã\n\nThe httpLink function takes an options object that has the HTTPLinkOptions shape.\n\nexport interface HTTPLinkOptions {\n  url: string;\n  /**\n   * Add ponyfill for fetch\n   */\n  fetch?: typeof fetch;\n  /**\n   * Add ponyfill for AbortController\n   */\n  AbortController?: typeof AbortController | null;\n  /**\n   * Data transformer\n   * @see https://trpc.io/docs/v11/data-transformers\n   **/\n  transformer?: DataTransformerOptions;\n  /**\n   * Headers to be set on outgoing requests or a callback that of said headers\n   * @see http://trpc.io/docs/v10/header\n   */\n  headers?:\n    | HTTPHeaders\n    | ((opts: { op: Operation }) => HTTPHeaders | Promise<HTTPHeaders>);\n  /**\n   * Send all requests as POSTS requests regardless of the procedure type\n   * The server must separately allow overriding the method. See:\n   * @see https://trpc.io/docs/rpc\n   */\n  methodOverride?: 'POST';\n}\nCopy\nReference‚Äã\n\nYou can check out the source code for this link on GitHub.\n\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/links/httpBatchLink",
		"html": "Client Usage\nLinks\nHTTP Batch Link\nVersion: 11.x\nHTTP Batch Link\n\nhttpBatchLink is a terminating link that batches an array of individual tRPC operations into a single HTTP request that's sent to a single tRPC procedure.\n\nUsage‚Äã\n\nYou can import and add the httpBatchLink to the links array as such:\n\nclient/index.ts\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n    // transformer,\n  ],\n});\nCopy\n\nAfter that, you can make use of batching by setting all your procedures in a Promise.all. The code below will produce exactly one HTTP request and on the server exactly one database query:\n\nconst somePosts = await Promise.all([\n  trpc.post.byId.query(1),\n  trpc.post.byId.query(2),\n  trpc.post.byId.query(3),\n]);\nCopy\nhttpBatchLink Options‚Äã\n\nThe httpBatchLink function takes an options object that has the HTTPBatchLinkOptions shape.\n\nexport interface HTTPBatchLinkOptions extends HTTPLinkOptions {\n  /**\n   * Maximum length of HTTP URL allowed before operations are split into multiple requests\n   * @default Infinity\n   */\n  maxURLLength?: number;\n  /**\n   * Maximum number of operations allowed in a single batch request\n   * @default Infinity\n   */\n  maxItems?: number;\n}\nexport interface HTTPLinkOptions {\n  url: string;\n  /**\n   * Add ponyfill for fetch\n   */\n  fetch?: typeof fetch;\n  /**\n   * Add ponyfill for AbortController\n   */\n  AbortController?: typeof AbortController | null;\n  /**\n   * Data transformer\n   * @see https://trpc.io/docs/data-transformers\n   **/\n  transformer?: DataTransformerOptions;\n  /**\n   * Headers to be set on outgoing requests or a callback that of said headers\n   * @see http://trpc.io/docs/header\n   */\n  headers?:\n    | HTTPHeaders\n    | ((opts: { opList: Operation[] }) => HTTPHeaders | Promise<HTTPHeaders>);\n}\nCopy\nSetting a maximum URL length‚Äã\n\nWhen sending batch requests, sometimes the URL can become too large causing HTTP errors like 413 Payload Too Large, 414 URI Too Long, and 404 Not Found. The maxURLLength option will limit the number of requests that can be sent together in a batch.\n\nAn alternative way of doing this is to\n\nclient/index.ts\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000',\n      maxURLLength: 2083, // a suitable size\n      // alternatively, you can make all RPC-calls to be called with POST\n      // methodOverride: 'POST',\n    }),\n  ],\n});\nCopy\nDisabling request batching‚Äã\n1. Disable batching on your server:‚Äã\nserver.ts\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\ncreateHTTPServer({\n  // [...]\n  // üëá disable batching\n  allowBatching: false,\n});\nCopy\n\nor, if you're using Next.js:\n\npages/api/trpc/[trpc].ts\nexport default trpcNext.createNextApiHandler({\n  // [...]\n  // üëá disable batching\n  allowBatching: false,\n});\nCopy\n2. Replace httpBatchLink with httpLink in your tRPC Client‚Äã\nclient/index.ts\nimport { createTRPCClient, httpLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\nCopy\n\nor, if you're using Next.js:\n\nutils/trpc.ts\nimport type { AppRouter } from '@/server/routers/app';\nimport { httpLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nexport const trpc = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      links: [\n        httpLink({\n          url: '/api/trpc',\n        }),\n      ],\n    };\n  },\n});\nCopy\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/links/httpBatchStreamLink",
		"html": "Client Usage\nLinks\nHTTP Batch Stream Link\nVersion: 11.x\nHTTP Batch Stream Link\n\nhttpBatchStreamLink is a terminating link that batches an array of individual tRPC operations into a single HTTP request that's sent to a single tRPC procedure (equivalent to httpBatchLink), but doesn't wait for all the responses of the batch to be ready and streams the responses as soon as any data is available.\n\nOptions‚Äã\n\nOptions are identical to httpBatchLink options.\n\nUsage‚Äã\n\nAll usage and options are identical to httpBatchLink.\n\nNOTE\n\nIf you require the ability to change/set response headers (which includes cookies) from within your procedures, make sure to use httpBatchLink instead! This is due to the fact that httpBatchStreamLink does not support setting headers once the stream has begun. Read more.\n\nYou can import and add the httpBatchStreamLink to the links array as such:\n\nclient/index.ts\nimport { createTRPCClient, httpBatchStreamLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchStreamLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\nCopy\n\nAfter that, you can make use of batching by setting all your procedures in a Promise.all. The code below will produce exactly one HTTP request and on the server exactly one database query:\n\nconst somePosts = await Promise.all([\n  trpc.post.byId.query(1),\n  trpc.post.byId.query(2),\n  trpc.post.byId.query(3),\n]);\nCopy\nStreaming mode‚Äã\n\nWhen batching requests together, the behavior of a regular httpBatchLink is to wait for all requests to finish before sending the response. If you want to send responses as soon as they are ready, you can use httpBatchStreamLink instead. This is useful for long-running requests.\n\nclient/index.ts\nimport { createTRPCClient, httpBatchStreamLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchStreamLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\nCopy\n\nCompared to a regular httpBatchLink, a httpBatchStreamLink will:\n\nCause the requests to be sent with a trpc-accept: application/jsonl header\nCause the response to be sent with a transfer-encoding: chunked and content-type: application/jsonl\nRemove the data key from the argument object passed to responseMeta (because with a streamed response, the headers are sent before the data is available)\nAsync generators and deferred promises‚Äã\n\nYou can try this out on the homepage of tRPC.io: https://trpc.io/?try=minimal#try-it-out\n\n// @filename: server.ts\nimport { publicProcedure, router } from './trpc';\n¬†\nconst appRouter = router({\n  examples: {\n    iterable: publicProcedure.query(async function* () {\n      for (let i = 0; i < 3; i++) {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        yield i;\n      }\n    }),\n  },\n});\n¬†\nexport type AppRouter = typeof appRouter;\n¬†\n¬†\n// @filename: client.ts\nimport { createTRPCClient, httpBatchStreamLink } from '@trpc/client';\nimport type { AppRouter } from './server';\n¬†\nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchStreamLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\nconst iterable = await trpc.examples.iterable.query();\n         \nconst iterable: AsyncIterable<number, never, unknown>\n¬†\nfor await (const value of iterable) {\n  console.log('Iterable:', value);\n                            \nconst value: number\n}\nCopy\nCompatibility (client-side)‚Äã\nBrowsers‚Äã\n\nBrowser support should be identical to fetch support.\n\nNode.js / Deno‚Äã\n\nFor runtimes other than the browser ones, the fetch implementation should support streaming, meaning that the response obtained by await fetch(...) should have a body property of type ReadableStream<Uint8Array> | NodeJS.ReadableStream, meaning that:\n\neither response.body.getReader is a function that returns a ReadableStreamDefaultReader<Uint8Array> object\nor response.body is a Uint8Array Buffer\n\nThis includes support for undici, node-fetch, native Node.js fetch implementation, and WebAPI fetch implementation (browsers).\n\nReact Native‚Äã\n\nReceiving the stream relies on the TextDecoder and TextDecoderStream APIs, which is not available in React Native. It's important to note that if your TextDecoderStream polyfill does not automatically polyfill ReadableStream and WritableStream those will also need to be polyfilled. If you still want to enable streaming, you need to polyfill those.\n\nYou will also need to overide the default fetch in the httpBatchStreamLink configuration options. In the below example we will be using the Expo fetch package for the fetch implementation.\n\nhttpBatchStreamLink({\n  fetch: (url, opts) =>\n    fetch(url, {\n      ...opts,\n      reactNative: { textStreaming: true },\n    }),\n  ...restOfConfig,\n});\nCopy\nCompatibility (server-side)‚Äã\n\n‚ö†Ô∏è for aws lambda, httpBatchStreamLink is not supported (will simply behave like a regular httpBatchLink). It should not break anything if enabled, but will not have any effect.\n\n‚ö†Ô∏è for cloudflare workers, you need to enable the ReadableStream API through a feature flag: streams_enable_constructors\n\nReference‚Äã\n\nYou can check out the source code for this link on GitHub.\n\nConfigure a ping option to keep the connection alive‚Äã\n\nWhen setting up your root config, you can pass in a jsonl option to configure a ping option to keep the connection alive.\n\nimport { initTRPC } from '@trpc/server';\nconst t = initTRPC.create({\n  jsonl: {\n    pingMs: 1000,\n  },\n});\nCopy\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/links/httpSubscriptionLink",
		"html": "Client Usage\nLinks\nHTTP Subscription Link\nVersion: 11.x\nHTTP Subscription Link\n\nhttpSubscriptionLink is a terminating link that's uses Server-sent Events (SSE) for subscriptions.\n\nSSE is a good option for real-time as it's a bit easier than setting up a WebSockets-server.\n\nSetup‚Äã\nINFO\n\nIf your client's environment doesn't support EventSource, you need an EventSource polyfill. For React Native specific instructions please defer to the compatibility section.\n\nTo use httpSubscriptionLink, you need to use a splitLink to make it explicit that we want to use SSE for subscriptions.\n\nclient/index.ts\nimport type { TRPCLink } from '@trpc/client';\nimport {\n  httpBatchLink,\n  httpSubscriptionLink,\n  loggerLink,\n  splitLink,\n} from '@trpc/client';\nconst trpcClient = createTRPCClient<AppRouter>({\n  /**\n   * @see https://trpc.io/docs/v11/client/links\n   */\n  links: [\n    // adds pretty logs to your console in development and logs errors in production\n    loggerLink(),\n    splitLink({\n      // uses the httpSubscriptionLink for subscriptions\n      condition: (op) => op.type === 'subscription',\n      true: httpSubscriptionLink({\n        url: `/api/trpc`,\n      }),\n      false: httpBatchLink({\n        url: `/api/trpc`,\n      }),\n    }),\n  ],\n});\nCopy\nTIP\n\nThe document here outlines the specific details of using httpSubscriptionLink. For general usage of subscriptions, see our subscriptions guide.\n\nHeaders and authorization / authentication‚Äã\nWeb apps‚Äã\nSame domain‚Äã\n\nIf you're doing a web application, cookies are sent as part of the request as long as your client is on the same domain as the server.\n\nCross-domain‚Äã\n\nIf the client and server are not on the same domain, you can use withCredentials: true (read more on MDN here).\n\nExample:\n\n// [...]\nhttpSubscriptionLink({\n  url: 'https://example.com/api/trpc',\n  eventSourceOptions() {\n    return {\n      withCredentials: true, // <---\n    };\n  },\n});\nCopy\nCustom headers through ponyfill‚Äã\n\nRecommended for non-web environments\n\nYou can ponyfill EventSource and use the eventSourceOptions -callback to populate headers.\n\nimport {\n  createTRPCClient,\n  httpBatchLink,\n  httpSubscriptionLink,\n  splitLink,\n} from '@trpc/client';\nimport { EventSourcePolyfill } from 'event-source-polyfill';\nimport type { AppRouter } from '../server/index.js';\n// Initialize the tRPC client\nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    splitLink({\n      condition: (op) => op.type === 'subscription',\n      true: httpSubscriptionLink({\n        url: 'http://localhost:3000',\n        // ponyfill EventSource\n        EventSource: EventSourcePolyfill,\n        // options to pass to the EventSourcePolyfill constructor\n        eventSourceOptions: async ({ op }) => {\n          //                          ^ Includes the operation that's being executed\n          // you can use this to generate a signature for the operation\n          const signature = await getSignature(op);\n          return {\n            headers: {\n              authorization: 'Bearer supersecret',\n              'x-signature': signature,\n            },\n          };\n        },\n      }),\n      false: httpBatchLink({\n        url: 'http://localhost:3000',\n      }),\n    }),\n  ],\n});\nCopy\nUpdating configuration on an active connection‚Äã\n\nhttpSubscriptionLink leverages SSE through EventSource, ensuring that connections encountering errors like network failures or bad response codes are automatically retried. However, EventSource does not allow re-execution of the eventSourceOptions() or url() options to update its configuration, which is particularly important in scenarios where authentication has expired since the last connection.\n\nTo address this limitation, you can use a retryLink in conjunction with httpSubscriptionLink. This approach ensures that the connection is re-established with the latest configuration, including any updated authentication details.\n\nCAUTION\n\nPlease note that restarting the connection will result in the EventSource being recreated from scratch, which means any previously tracked events will be lost.\n\nimport {\n  createTRPCClient,\n  httpBatchLink,\n  httpSubscriptionLink,\n  retryLink,\n  splitLink,\n} from '@trpc/client';\nimport {\n  EventSourcePolyfill,\n  EventSourcePolyfillInit,\n} from 'event-source-polyfill';\nimport type { AppRouter } from '../server/index.js';\n// Initialize the tRPC client\nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    splitLink({\n      condition: (op) => op.type === 'subscription',\n      false: httpBatchLink({\n        url: 'http://localhost:3000',\n      }),\n      true: [\n        retryLink({\n          retry: (opts) => {\n            opts.op.type;\n            //       ^? will always be 'subscription' since we're in a splitLink\n            const code = opts.error.data?.code;\n            if (!code) {\n              // This shouldn't happen as our httpSubscriptionLink will automatically retry within when there's a non-parsable response\n              console.error('No error code found, retrying', opts);\n              return true;\n            }\n            if (code === 'UNAUTHORIZED' || code === 'FORBIDDEN') {\n              console.log('Retrying due to 401/403 error');\n              return true;\n            }\n            return false;\n          },\n        }),\n        httpSubscriptionLink({\n          url: async () => {\n            // calculate the latest URL if needed...\n            return getAuthenticatedUri();\n          },\n          // ponyfill EventSource\n          EventSource: EventSourcePolyfill,\n          eventSourceOptions: async () => {\n            // ...or maybe renew an access token\n            const token = await auth.getOrRenewToken();\n            return {\n              headers: {\n                authorization: `Bearer ${token}`,\n              },\n            };\n          },\n        }),\n      ],\n    }),\n  ],\n});\nCopy\nConnection params‚Äã\n\nIn order to authenticate with EventSource, you can define connectionParams in httpSubscriptionLink. This will be sent as part of the URL, which is why other methods are preferred).\n\nserver/context.ts\nimport type { CreateHTTPContextOptions } from '@trpc/server/adapters/standalone';\n¬†\nexport const createContext = async (opts: CreateHTTPContextOptions) => {\n  const token = opts.info.connectionParams?.token;\n         \nconst token: string | undefined\n¬†\n  // [... authenticate]\n¬†\n  return {};\n};\n¬†\nexport type Context = Awaited<ReturnType<typeof createContext>>;\nCopy\nclient/trpc.ts\nimport {\n  createTRPCClient,\n  httpBatchLink,\n  httpSubscriptionLink,\n  splitLink,\n} from '@trpc/client';\nimport type { AppRouter } from '../server/index.js';\n// Initialize the tRPC client\nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    splitLink({\n      condition: (op) => op.type === 'subscription',\n      true: httpSubscriptionLink({\n        url: 'http://localhost:3000',\n        connectionParams: async () => {\n          // Will be serialized as part of the URL\n          return {\n            token: 'supersecret',\n          };\n        },\n      }),\n      false: httpBatchLink({\n        url: 'http://localhost:3000',\n      }),\n    }),\n  ],\n});\nCopy\nTimeout Configuration‚Äã\n\nThe httpSubscriptionLink supports configuring a timeout for inactivity through the reconnectAfterInactivityMs option. If no messages (including ping messages) are received within the specified timeout period, the connection will be marked as \"connecting\" and automatically attempt to reconnect.\n\nThe timeout configuration is set on the server side when initializing tRPC:\n\nserver/trpc.ts\nimport { initTRPC } from '@trpc/server';\nexport const t = initTRPC.create({\n  sse: {\n    client: {\n      reconnectAfterInactivityMs: 3_000,\n    },\n  },\n});\nCopy\nServer Ping Configuration‚Äã\n\nThe server can be configured to send periodic ping messages to keep the connection alive and prevent timeout disconnections. This is particularly useful when combined with the reconnectAfterInactivityMs-option.\n\nserver/trpc.ts\nimport { initTRPC } from '@trpc/server';\nexport const t = initTRPC.create({\n  sse: {\n    // Maximum duration of a single SSE connection in milliseconds\n    // maxDurationMs: 60_00,\n    ping: {\n      // Enable periodic ping messages to keep connection alive\n      enabled: true,\n      // Send ping message every 2s\n      intervalMs: 2_000,\n    },\n    // client: {\n    //   reconnectAfterInactivityMs: 3_000\n    // }\n  },\n});\nCopy\nCompatibility (React Native)‚Äã\n\nThe httpSubscriptionLink makes use of the EventSource API, Streams API, and AsyncIterators, these are not natively supported by React Native and will have to be ponyfilled.\n\nTo ponyfill EventSource we recommend to use a polyfill that utilizes the networking library exposed by React Native, over using a polyfill that using the XMLHttpRequest API. Libraries that polyfill EventSource using XMLHttpRequest fail to reconnect after the app has been in the background. Consider using the rn-eventsource-reborn package.\n\nThe Streams API can be ponyfilled using the web-streams-polyfill package.\n\nAsyncIterators can be polyfilled using the @azure/core-asynciterator-polyfill package.\n\nInstallation‚Äã\n\nInstall the required polyfills:\n\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install rn-eventsource-reborn web-streams-polyfill @azure/core-asynciterator-polyfill\n\nAdd the polyfills to your project before the link is used (e.g. where you add your TRPCReact.Provider):\n\nutils/api.tsx\nimport '@azure/core-asynciterator-polyfill';\nimport { RNEventSource } from 'rn-eventsource-reborn';\nimport { ReadableStream, TransformStream } from 'web-streams-polyfill';\nglobalThis.ReadableStream = globalThis.ReadableStream || ReadableStream;\nglobalThis.TransformStream = globalThis.TransformStream || TransformStream;\nCopy\n\nOnce the ponyfills are added, you can continue setting up the httpSubscriptionLink as described in the setup section.\n\nhttpSubscriptionLink Options‚Äã\ntype HTTPSubscriptionLinkOptions<\n  TRoot extends AnyClientTypes,\n  TEventSource extends EventSourceLike.AnyConstructor = typeof EventSource,\n> = {\n  /**\n   * EventSource ponyfill\n   */\n  EventSource?: TEventSource;\n  /**\n   * EventSource options or a callback that returns them\n   */\n  eventSourceOptions?:\n    | EventSourceLike.InitDictOf<TEventSource>\n    | ((opts: {\n        op: Operation;\n      }) =>\n        | EventSourceLike.InitDictOf<TEventSource>\n        | Promise<EventSourceLike.InitDictOf<TEventSource>>);\n};\nCopy\nSSE Options on the server‚Äã\nexport interface SSEStreamProducerOptions<TValue = unknown> {\n  ping?: {\n    /**\n     * Enable ping comments sent from the server\n     * @default false\n     */\n    enabled: boolean;\n    /**\n     * Interval in milliseconds\n     * @default 1000\n     */\n    intervalMs?: number;\n  };\n  /**\n   * Maximum duration in milliseconds for the request before ending the stream\n   * @default undefined\n   */\n  maxDurationMs?: number;\n  /**\n   * End the request immediately after data is sent\n   * Only useful for serverless runtimes that do not support streaming responses\n   * @default false\n   */\n  emitAndEndImmediately?: boolean;\n  /**\n   * Client-specific options - these will be sent to the client as part of the first message\n   * @default {}\n   */\n  client?: {\n    /**\n     * Timeout and reconnect after inactivity in milliseconds\n     * @default undefined\n     */\n    reconnectAfterInactivityMs?: number;\n  };\n}\nCopy\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/links/localLink",
		"html": "Client Usage\nLinks\nLocal Link\nVersion: 11.x\nLocal Link\n\nlocalLink is a terminating link that allows you to make tRPC procedure calls directly in your application without going through HTTP.\n\nINFO\n\nWe have prefixed this as unstable_ as it's a new API, but you're safe to use it! Read more.\n\nUsage‚Äã\nimport { createTRPCClient, unstable_localLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    unstable_localLink({\n      router: appRouter,\n      createContext: async () => {\n        // Create your context here\n        return {};\n      },\n      onError: (opts) => {\n        // Log errors here, similarly to how you would in an API route\n        console.error('Error:', opts.error);\n      },\n    }),\n  ],\n});\nCopy\nFeatures‚Äã\nDirect procedure calls without HTTP overhead\nFull support for queries, mutations, and subscriptions\nAutomatic error handling and transformation\nSupport for abort signals\nType-safe context creation\nOptions‚Äã\n\nThe localLink accepts the following options:\n\ntype LocalLinkOptions<TRouter extends AnyRouter> = {\n  router: TRouter;\n  createContext: () => Promise<inferRouterContext<TRouter>>;\n  onError?: (opts: ErrorHandlerOptions<inferRouterContext<TRouter>>) => void;\n} & TransformerOptions<inferClientTypes<TRouter>>;\nCopy\nrouter‚Äã\n\nThe tRPC router instance to use for procedure calls.\n\ncreateContext‚Äã\n\nA function that creates the context for each procedure call. This is called for each request and should return a promise that resolves to the context object.\n\nonError‚Äã\n\nAn optional error handler that is called when an error occurs during a procedure call. It receives the error, operation type, path, input, and context.\n\ntransformer‚Äã\n\nOptional input/output transformers for serialization/deserialization of data.\n\nNotes‚Äã\nIt's recommended to use this link in scenarios where you need direct procedure calls without HTTP\nFor most client-side applications, you should use the httpLink or other HTTP-based links instead\nThe link supports all tRPC features including queries, mutations, and subscriptions\nError handling and transformation are handled automatically, just like with HTTP-based links\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/links/wsLink",
		"html": "Client Usage\nLinks\nWebSocket Link\nVersion: 11.x\nWebSocket Link\n\nwsLink is a terminating link that's used when using tRPC's WebSockets Client and Subscriptions, which you can learn more about here).\n\nUsage‚Äã\n\nTo use wsLink, you need to pass it a TRPCWebSocketClient, which you can create with createWSClient:\n\nclient/index.ts\nimport { createTRPCClient, createWSClient, wsLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst wsClient = createWSClient({\n  url: 'ws://localhost:3000',\n});\nconst trpcClient = createTRPCClient<AppRouter>({\n  links: [wsLink<AppRouter>({ client: wsClient })],\n});\nCopy\nAuthentication / Connection params‚Äã\n\nSee more here\n\nwsLink / createWSClient Options‚Äã\n\nThe wsLink function requires a TRPCWebSocketClient to be passed, which can be configured with the fields defined in WebSocketClientOptions:\n\nexport interface WebSocketLinkOptions {\n  client: TRPCWebSocketClient;\n  /**\n   * Data transformer\n   * @see https://trpc.io/docs/v11/data-transformers\n   **/\n  transformer?: DataTransformerOptions;\n}\nfunction createWSClient(opts: WebSocketClientOptions) => TRPCWebSocketClient\nexport interface WebSocketClientOptions {\n  /**\n   * The URL to connect to (can be a function that returns a URL)\n   */\n  url: string | (() => MaybePromise<string>);\n  /**\n   * Connection params that are available in `createContext()`\n   * These are sent as the first message\n   */\n  connectionParams: string | (() => MaybePromise<string>);\n  /**\n   * Ponyfill which WebSocket implementation to use\n   */\n  WebSocket?: typeof WebSocket;\n  /**\n   * The number of milliseconds before a reconnect is attempted.\n   * @default {@link exponentialBackoff}\n   */\n  retryDelayMs?: typeof exponentialBackoff;\n  /**\n   * Triggered when a WebSocket connection is established\n   */\n  onOpen?: () => void;\n  /**\n   * Triggered when a WebSocket connection encounters an error\n   */\n  onError?: (evt?: Event) => void;\n  /**\n   * Triggered when a WebSocket connection is closed\n   */\n  onClose?: (cause?: { code?: number }) => void;\n  /**\n   * Lazy mode will close the WebSocket automatically after a period of inactivity (no messages sent or received and no pending requests)\n   */\n  lazy?: {\n    /**\n     * Enable lazy mode\n     * @default false\n     */\n    enabled: boolean;\n    /**\n     * Close the WebSocket after this many milliseconds\n     * @default 0\n     */\n    closeMs: number;\n  };\n  /**\n   * Send ping messages to the server and kill the connection if no pong message is returned\n   */\n  keepAlive?: {\n    /**\n     * @default false\n     */\n    enabled: boolean;\n    /**\n     * Send a ping message every this many milliseconds\n     * @default 5_000\n     */\n    intervalMs?: number;\n    /**\n     * Close the WebSocket after this many milliseconds if the server does not respond\n     * @default 1_000\n     */\n    pongTimeoutMs?: number;\n  };\n}\nCopy\nReference‚Äã\n\nYou can check out the source code for this link on GitHub.\n\nEdit this page"
	},
	{
		"title": "Split Link | tRPC",
		"url": "https://trpc.io/docs/client/links/splitLink",
		"html": "Client Usage\nLinks\nSplit Link\nVersion: 11.x\nSplit Link\n\nsplitLink is a link that allows you to branch your link chain's execution depending on a given condition. Both the true and false branches are required. You can provide just one link, or multiple links per branch via an array.\n\nIt's important to note that when you provide links for splitLink to execute, splitLink will create an entirely new link chain based on the links you passed. Therefore, you need to use a terminating link if you only provide one link or add the terminating link at the end of the array if you provide multiple links to be executed on a branch. Here's a visual representation of how splitLink works:\n\ntRPC Client\nOperation\nLink\nLink\nsplitLink\nInitiated\nCompleted\ndown\ndown\nup\nup\nTerminating Link\nRequest\nResponse\nRequest\ntRPC Server\npasses \ncondition?\nLink\nTerminating Link\nLink\ntrue\nBranch\nfalse\nBranch\ndown\nup\nResponse\nYES\nNO\ndown\nup\ndown\nup\nUsage Example‚Äã\nDisable batching for certain requests‚Äã\n\nLet's say you're using httpBatchLink as the terminating link in your tRPC client config. This means request batching is enabled in every request. However, if you need to disable batching only for certain requests, you would need to change the terminating link in your tRPC client config dynamically between httpLink and httpBatchLink. This is a perfect opportunity for splitLink to be used:\n\n1. Configure client / utils/trpc.ts‚Äã\nclient/index.ts\nimport {\n  createTRPCClient,\n  httpBatchLink,\n  httpLink,\n  splitLink,\n} from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst url = `http://localhost:3000`;\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    splitLink({\n      condition(op) {\n        // check for context property `skipBatch`\n        return Boolean(op.context.skipBatch);\n      },\n      // when condition is true, use normal request\n      true: httpLink({\n        url,\n      }),\n      // when condition is false, use batching\n      false: httpBatchLink({\n        url,\n      }),\n    }),\n  ],\n});\nCopy\n2. Perform request without batching‚Äã\nclient.ts\nconst postResult = proxy.posts.query(null, {\n  context: {\n    skipBatch: true,\n  },\n});\nCopy\n\nor:\n\nMyComponent.tsx\nexport function MyComponent() {\n  const postsQuery = proxy.posts.useQuery(undefined, {\n    trpc: {\n      context: {\n        skipBatch: true,\n      },\n    }\n  });\n  return (\n    <pre>{JSON.stringify(postsQuery.data ?? null, null, 4)}</pre>\n  )\n})\nCopy\nsplitLink Options‚Äã\n\nThe splitLink function takes an options object that has three fields: condition, true, and false.\n\nfunction splitLink<TRouter extends AnyRouter = AnyRouter>(opts: {\n  condition: (op: Operation) => boolean;\n  /**\n   * The link to execute next if the test function returns `true`.\n   */\n  true: TRPCLink<TRouter> | TRPCLink<TRouter>[];\n  /**\n   * The link to execute next if the test function returns `false`.\n   */\n  false: TRPCLink<TRouter> | TRPCLink<TRouter>[];\n}) => TRPCLink<TRouter>\nCopy\nReference‚Äã\n\nYou can check out the source code for this link on GitHub.\n\nEdit this page"
	},
	{
		"title": "tRPC",
		"url": "https://trpc.io/docs/client/links/loggerLink",
		"html": "Client Usage\nLinks\nLogger Link\nVersion: 11.x\nLogger Link\n\nloggerLink is a link that lets you implement a logger for your tRPC client. It allows you to see more clearly what operations are queries, mutations, or subscriptions, their requests, and responses. The link, by default, prints a prettified log to the browser's console. However, you can customize the logging behavior and the way it prints to the console with your own implementations.\n\nUsage‚Äã\n\nYou can import and add the loggerLink to the links array as such:\n\nclient/index.ts\nimport { createTRPCClient, httpBatchLink, loggerLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    /**\n     * The function passed to enabled is an example in case you want to the link to\n     * log to your console in development and only log errors in production\n     */\n    loggerLink({\n      enabled: (opts) =>\n        (process.env.NODE_ENV === 'development' &&\n          typeof window !== 'undefined') ||\n        (opts.direction === 'down' && opts.result instanceof Error),\n    }),\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\nCopy\nloggerLink Options‚Äã\n\nThe loggerLink function takes an options object that has the LoggerLinkOptions shape:\n\ntype LoggerLinkOptions<TRouter extends AnyRouter> = {\n  logger?: LogFn<TRouter>;\n  /**\n   * It is a function that returns a condition that determines whether to enable the logger.\n   * It is true by default.\n   */\n  enabled?: EnabledFn<TRouter>;\n  /**\n   * Used in the built-in defaultLogger\n   */\n  console?: ConsoleEsque;\n  /**\n   * Color mode used in the default logger.\n   * @default typeof window === 'undefined' ? 'ansi' : 'css'\n   */\n  colorMode?: 'ansi' | 'css';\n};\nCopy\nReference‚Äã\n\nYou can check out the source code for this link on GitHub.\n\nEdit this page"
	},
	{
		"title": "Retry Link | tRPC",
		"url": "https://trpc.io/docs/client/links/retryLink",
		"html": "Client Usage\nLinks\nRetry Link\nVersion: 11.x\nRetry Link\n\nretryLink is a link that allows you to retry failed operations in your tRPC client. It provides a customizable way to handle transient errors, such as network failures or server errors, by automatically retrying the failed requests based on specified conditions.\n\nTIP\n\nIf you use @trpc/react-query you will generally not need this link as it's built into the useQuery() and the useMutation() hooks from @tanstack/react-query.\n\nUsage‚Äã\n\nYou can import and add the retryLink to the links array when creating your tRPC client. This link can be placed before or after other links in your setup, depending on your requirements.\n\nimport { createTRPCClient, retryLink } from '@trpc/client';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    retryLink({\n      retry(opts) {\n        if (\n          opts.error.data &&\n          opts.error.data.code !== 'INTERNAL_SERVER_ERROR'\n        ) {\n          // Don't retry on non-500s\n          return false;\n        }\n        if (opts.op.type !== 'query') {\n          // Only retry queries\n          return false;\n        }\n        // Retry up to 3 times\n        return opts.attempts <= 3;\n      },\n      // Double every attempt, with max of 30 seconds (starting at 1 second)\n      retryDelayMs: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n    }),\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\nCopy\n\nIn the example above, we add the retryLink before the httpBatchLink. By default, retryLink will:\n\nRetry the request if the error is a TRPCClientError with a status code of 500 or if we couldn't get a valid TRPC error.\nRetry the request up to 3 times.\n\nYou can customize the retry logic by providing a custom retry function.\n\nOptions‚Äã\ninterface RetryLinkOptions<TInferrable extends InferrableClientTypes> {\n  /**\n   * The retry function\n   */\n  retry: (opts: RetryFnOptions<TInferrable>) => boolean;\n  /**\n   * The delay between retries in ms (defaults to 0)\n   */\n  retryDelayMs?: (attempt: number) => number;\n}\ninterface RetryFnOptions<TInferrable extends InferrableClientTypes> {\n  /**\n   * The operation that failed\n   */\n  op: Operation;\n  /**\n   * The error that occurred\n   */\n  error: TRPCClientError<TInferrable>;\n  /**\n   * The number of attempts that have been made (including the first call)\n   */\n  attempts: number;\n}\nCopy\nHandling tracked() events‚Äã\n\nWhen using retryLink with subscriptions that use tracked(), the link will automatically include the last known event ID when retrying. This ensures that when a subscription reconnects, it can resume from where it left off without missing any events.\n\nFor example, if you're using Server-sent Events (SSE) with httpSubscriptionLink, the retryLink will automatically handle reconnecting with the last event ID when errors like 401 Unauthorized occur.\n\nEdit this page"
	}
]

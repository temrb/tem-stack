[
  {
    "title": "Comparison | Better Auth",
    "url": "https://www.better-auth.com/docs/comparison",
    "html": "Comparison\n\nComparison is the thief of joy.\n\nHere are non detailed reasons why you may want to use Better Auth over other auth libraries and services.\n\nvs Other Auth Libraries\nFramework agnostic - Works with any framework, not just specific ones\nAdvanced features built-in - 2FA, multi-tenancy, multi-session, rate limiting, and many more\nPlugin system - Extend functionality without forking or complex workarounds\nFull control - Customize auth flows exactly how you want\nvs Self-Hosted Auth Servers\nNo separate infrastructure - Runs in your app, users stay in your database\nZero server maintenance - No auth servers to deploy, monitor, or update\nComplete feature set - Everything you need without the operational overhead\nvs Managed Auth Services\nKeep your data - Users stay in your database, not a third-party service\nNo per-user costs - Scale without worrying about auth billing\nSingle source of truth - All user data in one place\nvs Rolling Your Own\nSecurity handled - Battle-tested auth flows and security practices\nFocus on your product - Spend time on features that matter to your business\nPlugin extensibility - Add custom features without starting from scratch\nEdit on GitHub\n\nPrevious Page\n\nIntroduction\n\nNext Page\n\nInstallation"
  },
  {
    "title": "Introduction | Better Auth",
    "url": "https://www.better-auth.com/docs/introduction",
    "html": "Introduction\n\nBetter Auth is a framework-agnostic, universal authentication and authorization framework for TypeScript. It provides a comprehensive set of features out of the box and includes a plugin ecosystem that simplifies adding advanced functionalities. Whether you need 2FA, passkey, multi-tenancy, multi-session support, or even enterprise features like SSO, creating your own IDP, it lets you focus on building your application instead of reinventing the wheel.\n\nFeatures\n\nBetter Auth aims to be the most comprehensive auth library. It provides a wide range of features out of the box and allows you to extend it with plugins. Here are some of the features:\n\nFramework Agnostic\n\nSupport for most popular frameworks\n\nEmail & Password\n\nBuilt-in support for secure email and password authentication\n\nAccount & Session Management\n\nManage user accounts and sessions with ease\n\nBuilt-In Rate Limiter\n\nBuilt-in rate limiter with custom rules\n\nAutomatic Database Management\n\nAutomatic database management and migrations\n\nSocial Sign-on\n\nMultiple social sign-on providers\n\nOrganization & Access Control\n\nManage organizations and access control\n\nTwo Factor Authentication\n\nSecure your users with two factor authentication\n\nPlugin Ecosystem\n\nEven more capabilities with plugins\n\n...and much more!\n\nAI tooling\nLLMs.txt\n\nBetter Auth exposes an LLMs.txt that helps AI models understand how to integrate and interact with your authentication system. See it at https://better-auth.com/llms.txt.\n\nMCP\n\nBetter Auth provides an MCP server so you can use it with any AI model that supports the Model Context Protocol (MCP).\n\nCLI Options\n\nUse the Better Auth CLI to easily add the MCP server to your preferred client:\n\nCursor\nClaude Code\nOpen Code\nManual\nterminal\npnpm @better-auth/cli mcp --cursor\nManual Configuration\n\nAlternatively, you can manually configure the MCP server for each client:\n\nClaude Code\nOpen Code\nManual\nterminal\nclaude mcp add --transport http better-auth https://mcp.chonkie.ai/better-auth/better-auth-builder/mcp\n\nWe provide a firstâ€‘party MCP, powered by Chonkie. You can alternatively use context7 and other MCP providers.\n\nEdit on GitHub\n\nNext Page\n\nComparison"
  },
  {
    "title": "Installation | Better Auth",
    "url": "https://www.better-auth.com/docs/installation",
    "html": "Installation\nCopy Markdown\nOpen in\nInstall the Package\n\nLet's start by adding Better Auth to your project:\n\nnpm\npnpm\nyarn\nbun\nnpm install better-auth\n\nIf you're using a separate client and server setup, make sure to install Better Auth in both parts of your project.\n\nSet Environment Variables\n\nCreate a .env file in the root of your project and add the following environment variables:\n\nSecret Key\n\nRandom value used by the library for encryption and generating hashes. You can generate one using the button below or you can use something like openssl.\n\n.env\nBETTER_AUTH_SECRET=\nGenerate Secret\nSet Base URL\n.env\nBETTER_AUTH_URL=http://localhost:3000 # Base URL of your app\nCreate A Better Auth Instance\n\nCreate a file named auth.ts in one of these locations:\n\nProject root\nlib/ folder\nutils/ folder\n\nYou can also nest any of these folders under src/, app/ or server/ folder. (e.g. src/lib/auth.ts, app/lib/auth.ts).\n\nAnd in this file, import Better Auth and create your auth instance. Make sure to export the auth instance with the variable name auth or as a default export.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  //...\n});\nConfigure Database\n\nBetter Auth requires a database to store user data. You can easily configure Better Auth to use SQLite, PostgreSQL, or MySQL, and more!\n\nsqlite\npostgres\nmysql\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport Database from \"better-sqlite3\";\nexport const auth = betterAuth({\n    database: new Database(\"./sqlite.db\"),\n})\n\nAlternatively, if you prefer to use an ORM, you can use one of the built-in adapters.\n\ndrizzle\nprisma\nmongodb\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { drizzleAdapter } from \"better-auth/adapters/drizzle\";\nimport { db } from \"@/db\"; // your drizzle instance\nexport const auth = betterAuth({\n    database: drizzleAdapter(db, {\n        provider: \"pg\", // or \"mysql\", \"sqlite\"\n    }),\n});\n\nIf your database is not listed above, check out our other supported databases for more information, or use one of the supported ORMs.\n\nCreate Database Tables\n\nBetter Auth includes a CLI tool to help manage the schema required by the library.\n\nGenerate: This command generates an ORM schema or SQL migration file.\n\nIf you're using Kysely, you can apply the migration directly with migrate command below. Use generate only if you plan to apply the migration manually.\n\nTerminal\nnpx @better-auth/cli generate\nMigrate: This command creates the required tables directly in the database. (Available only for the built-in Kysely adapter)\nTerminal\nnpx @better-auth/cli migrate\n\nsee the CLI documentation for more information.\n\nIf you instead want to create the schema manually, you can find the core schema required in the database section.\n\nAuthentication Methods\n\nConfigure the authentication methods you want to use. Better Auth comes with built-in support for email/password, and social sign-on providers.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  //...other options\n  emailAndPassword: { \n    enabled: true, \n  }, \n  socialProviders: { \n    github: { \n      clientId: process.env.GITHUB_CLIENT_ID as string, \n      clientSecret: process.env.GITHUB_CLIENT_SECRET as string, \n    }, \n  }, \n});\n\nYou can use even more authentication methods like passkey, username, magic link and more through plugins.\n\nMount Handler\n\nTo handle API requests, you need to set up a route handler on your server.\n\nCreate a new file or route in your framework's designated catch-all route handler. This route should handle requests for the path /api/auth/* (unless you've configured a different base path).\n\nBetter Auth supports any backend framework with standard Request and Response objects and offers helper functions for popular frameworks.\n\nnext-js\nnuxt\nsvelte-kit\nremix\nsolid-start\nhono\nexpress\nelysia\ntanstack-start\nexpo\nCreate Client Instance\n\nThe client-side library helps you interact with the auth server. Better Auth comes with a client for all the popular web frameworks, including vanilla JavaScript.\n\nImport createAuthClient from the package for your framework (e.g., \"better-auth/react\" for React).\nCall the function to create your client.\nPass the base URL of your auth server. (If the auth server is running on the same domain as your client, you can skip this step.)\n\nIf you're using a different base path other than /api/auth make sure to pass the whole URL including the path. (e.g. http://localhost:3000/custom-path/auth)\n\nreact\nvue\nsvelte\nsolid\nvanilla\nlib/auth-client.ts\nimport { createAuthClient } from \"better-auth/react\"\nexport const authClient = createAuthClient({\n    /** The base URL of the server (optional if you're using the same domain) */\n    baseURL: \"http://localhost:3000\"\n})\n\nTip: You can also export specific methods if you prefer:\n\nexport const { signIn, signUp, useSession } = createAuthClient()\nðŸŽ‰ That's it!\n\nThat's it! You're now ready to use better-auth in your application. Continue to basic usage to learn how to use the auth instance to sign in users.\n\nEdit on GitHub\n\nPrevious Page\n\nComparison\n\nNext Page\n\nBasic Usage"
  },
  {
    "title": "Basic Usage | Better Auth",
    "url": "https://www.better-auth.com/docs/basic-usage",
    "html": "Basic Usage\nCopy Markdown\nOpen in\n\nBetter Auth provides built-in authentication support for:\n\nEmail and password\nSocial provider (Google, GitHub, Apple, and more)\n\nBut also can easily be extended using plugins, such as: username, magic link, passkey, email-otp, and more.\n\nEmail & Password\n\nTo enable email and password authentication:\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    emailAndPassword: {    \n        enabled: true\n    } \n})\nSign Up\n\nTo sign up a user you need to call the client method signUp.email with the user's information.\n\nsign-up.ts\nimport { authClient } from \"@/lib/auth-client\"; //import the auth client\nconst { data, error } = await authClient.signUp.email({\n        email, // user email address\n        password, // user password -> min 8 characters by default\n        name, // user display name\n        image, // User image URL (optional)\n        callbackURL: \"/dashboard\" // A URL to redirect to after the user verifies their email (optional)\n    }, {\n        onRequest: (ctx) => {\n            //show loading\n        },\n        onSuccess: (ctx) => {\n            //redirect to the dashboard or sign in page\n        },\n        onError: (ctx) => {\n            // display the error message\n            alert(ctx.error.message);\n        },\n});\n\nBy default, the users are automatically signed in after they successfully sign up. To disable this behavior you can set autoSignIn to false.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    emailAndPassword: {\n    \tenabled: true,\n    \tautoSignIn: false //defaults to true\n  },\n})\nSign In\n\nTo sign a user in, you can use the signIn.email function provided by the client.\n\nsign-in\nconst { data, error } = await authClient.signIn.email({\n        /**\n         * The user email\n         */\n        email,\n        /**\n         * The user password\n         */\n        password,\n        /**\n         * A URL to redirect to after the user verifies their email (optional)\n         */\n        callbackURL: \"/dashboard\",\n        /**\n         * remember the user session after the browser is closed. \n         * @default true\n         */\n        rememberMe: false\n}, {\n    //callbacks\n})\n\nAlways invoke client methods from the client side. Don't call them from the server.\n\nServer-Side Authentication\n\nTo authenticate a user on the server, you can use the auth.api methods.\n\nserver.ts\nimport { auth } from \"./auth\"; // path to your Better Auth server instance\nconst response = await auth.api.signInEmail({\n    body: {\n        email,\n        password\n    },\n    asResponse: true // returns a response object instead of data\n});\n\nIf the server cannot return a response object, you'll need to manually parse and set cookies. But for frameworks like Next.js we provide a plugin to handle this automatically\n\nSocial Sign-On\n\nBetter Auth supports multiple social providers, including Google, GitHub, Apple, Discord, and more. To use a social provider, you need to configure the ones you need in the socialProviders option on your auth object.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    socialProviders: { \n        github: { \n            clientId: process.env.GITHUB_CLIENT_ID!, \n            clientSecret: process.env.GITHUB_CLIENT_SECRET!, \n        } \n    }, \n})\nSign in with social providers\n\nTo sign in using a social provider you need to call signIn.social. It takes an object with the following properties:\n\nsign-in.ts\nimport { authClient } from \"@/lib/auth-client\"; //import the auth client\nawait authClient.signIn.social({\n    /**\n     * The social provider ID\n     * @example \"github\", \"google\", \"apple\"\n     */\n    provider: \"github\",\n    /**\n     * A URL to redirect after the user authenticates with the provider\n     * @default \"/\"\n     */\n    callbackURL: \"/dashboard\", \n    /**\n     * A URL to redirect if an error occurs during the sign in process\n     */\n    errorCallbackURL: \"/error\",\n    /**\n     * A URL to redirect if the user is newly registered\n     */\n    newUserCallbackURL: \"/welcome\",\n    /**\n     * disable the automatic redirect to the provider. \n     * @default false\n     */\n    disableRedirect: true,\n});\n\nYou can also authenticate using idToken or accessToken from the social provider instead of redirecting the user to the provider's site. See social providers documentation for more details.\n\nSignout\n\nTo signout a user, you can use the signOut function provided by the client.\n\nuser-card.tsx\nawait authClient.signOut();\n\nyou can pass fetchOptions to redirect onSuccess\n\nuser-card.tsx\nawait authClient.signOut({\n  fetchOptions: {\n    onSuccess: () => {\n      router.push(\"/login\"); // redirect to login page\n    },\n  },\n});\nSession\n\nOnce a user is signed in, you'll want to access the user session. Better Auth allows you to easily access the session data from both the server and client sides.\n\nClient Side\nUse Session\n\nBetter Auth provides a useSession hook to easily access session data on the client side. This hook is implemented using nanostore and has support for each supported framework and vanilla client, ensuring that any changes to the session (such as signing out) are immediately reflected in your UI.\n\nReact\nVue\nSvelte\nSolid\nVanilla\nuser.tsx\nimport { authClient } from \"@/lib/auth-client\" // import the auth client\nexport function User(){\n    const { \n        data: session, \n        isPending, //loading state\n        error, //error object\n        refetch //refetch the session\n    } = authClient.useSession() \n    return (\n        //...\n    )\n}\nGet Session\n\nIf you prefer not to use the hook, you can use the getSession method provided by the client.\n\nuser.tsx\nimport { authClient } from \"@/lib/auth-client\" // import the auth client\nconst { data: session, error } = await authClient.getSession()\n\nYou can also use it with client-side data-fetching libraries like TanStack Query.\n\nServer Side\n\nThe server provides a session object that you can use to access the session data. It requires request headers object to be passed to the getSession method.\n\nExample: Using some popular frameworks\n\nNext.js\nNuxt\nSvelte\nAstro\nHono\nTanStack\nserver.ts\nimport { auth } from \"./auth\"; // path to your Better Auth server instance\nimport { headers } from \"next/headers\";\nconst session = await auth.api.getSession({\n    headers: await headers() // you need to pass the headers object.\n})\n\nFor more details check session-management documentation.\n\nUsing Plugins\n\nOne of the unique features of Better Auth is a plugins ecosystem. It allows you to add complex auth related functionality with small lines of code.\n\nBelow is an example of how to add two factor authentication using two factor plugin.\n\nServer Configuration\n\nTo add a plugin, you need to import the plugin and pass it to the plugins option of the auth instance. For example, to add two factor authentication, you can use the following code:\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { twoFactor } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    //...rest of the options\n    plugins: [ \n        twoFactor() \n    ] \n})\n\nnow two factor related routes and method will be available on the server.\n\nMigrate Database\n\nAfter adding the plugin, you'll need to add the required tables to your database. You can do this by running the migrate command, or by using the generate command to create the schema and handle the migration manually.\n\ngenerating the schema:\n\nterminal\nnpx @better-auth/cli generate\n\nusing the migrate command:\n\nterminal\nnpx @better-auth/cli migrate\n\nIf you prefer adding the schema manually, you can check the schema required on the two factor plugin documentation.\n\nClient Configuration\n\nOnce we're done with the server, we need to add the plugin to the client. To do this, you need to import the plugin and pass it to the plugins option of the auth client. For example, to add two factor authentication, you can use the following code:\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nimport { twoFactorClient } from \"better-auth/client/plugins\"; \nconst authClient = createAuthClient({\n    plugins: [ \n        twoFactorClient({ \n            twoFactorPage: \"/two-factor\" // the page to redirect if a user needs to verify 2nd factor\n        }) \n    ] \n})\n\nnow two factor related methods will be available on the client.\n\nprofile.ts\nimport { authClient } from \"./auth-client\"\nconst enableTwoFactor = async() => {\n    const data = await authClient.twoFactor.enable({\n        password // the user password is required\n    }) // this will enable two factor\n}\nconst disableTwoFactor = async() => {\n    const data = await authClient.twoFactor.disable({\n        password // the user password is required\n    }) // this will disable two factor\n}\nconst signInWith2Factor = async() => {\n    const data = await authClient.signIn.email({\n        //...\n    })\n    //if the user has two factor enabled, it will redirect to the two factor page\n}\nconst verifyTOTP = async() => {\n    const data = await authClient.twoFactor.verifyTOTP({\n        code: \"123456\", // the code entered by the user \n        /**\n         * If the device is trusted, the user won't\n         * need to pass 2FA again on the same device\n         */\n        trustDevice: true\n    })\n}\n\nNext step: See the two factor plugin documentation.\n\nEdit on GitHub\n\nPrevious Page\n\nInstallation\n\nNext Page\n\nAPI"
  },
  {
    "title": "Other Relational Databases | Better Auth",
    "url": "https://www.better-auth.com/docs/adapters/other-relational-databases",
    "html": "Other Relational Databases\nCopy Markdown\nOpen in\n\nBetter Auth supports a wide range of database dialects out of the box thanks to Kysely.\n\nAny dialect supported by Kysely can be utilized with Better Auth, including capabilities for generating and migrating database schemas through the CLI.\n\nCore Dialects\nMySQL\nSQLite\nPostgreSQL\nMS SQL\nKysely Organization Dialects\nPostgres.js\nSingleStore Data API\nSupabase\nKysely Community dialects\nPlanetScale Serverless Driver\nCloudflare D1\nAWS RDS Data API\nPrisma Postgres\nSurrealDB\nNeon\nXata\nAWS S3 Select\nlibSQL/sqld\nFetch driver\nSQLite WASM\nDeno SQLite\nTiDB Cloud Serverless Driver\nCapacitor SQLite Kysely\nBigQuery\nClickhouse\nPGLite\n\nYou can see the full list of supported Kysely dialects here.\n\nEdit on GitHub\n\nPrevious Page\n\nMS SQL\n\nNext Page\n\nAdapters"
  },
  {
    "title": "CLI | Better Auth",
    "url": "https://www.better-auth.com/docs/concepts/cli",
    "html": "CLI\nCopy Markdown\nOpen in\n\nBetter Auth comes with a built-in CLI to help you manage the database schemas, initialize your project, generate a secret key for your application, and gather diagnostic information about your setup.\n\nGenerate\n\nThe generate command creates the schema required by Better Auth. If you're using a database adapter like Prisma or Drizzle, this command will generate the right schema for your ORM. If you're using the built-in Kysely adapter, it will generate an SQL file you can run directly on your database.\n\nTerminal\nnpx @better-auth/cli@latest generate\nOptions\n--output - Where to save the generated schema. For Prisma, it will be saved in prisma/schema.prisma. For Drizzle, it goes to schema.ts in your project root. For Kysely, it's an SQL file saved as schema.sql in your project root.\n--config - The path to your Better Auth config file. By default, the CLI will search for an auth.ts file in ./, ./utils, ./lib, or any of these directories under the src directory.\n--yes - Skip the confirmation prompt and generate the schema directly.\nMigrate\n\nThe migrate command applies the Better Auth schema directly to your database. This is available if you're using the built-in Kysely adapter. For other adapters, you'll need to apply the schema using your ORM's migration tool.\n\nTerminal\nnpx @better-auth/cli@latest migrate\nOptions\n--config - The path to your Better Auth config file. By default, the CLI will search for an auth.ts file in ./, ./utils, ./lib, or any of these directories under the src directory.\n--yes - Skip the confirmation prompt and apply the schema directly.\n\nUsing PostgreSQL with a non-default schema?\n\nThe migrate command automatically detects your configured search_path and creates tables in the correct schema. See the PostgreSQL adapter documentation for configuration details.\n\nInit\n\nThe init command allows you to initialize Better Auth in your project.\n\nTerminal\nnpx @better-auth/cli@latest init\nOptions\n--name - The name of your application. (defaults to the name property in your package.json).\n--framework - The framework your codebase is using. Currently, the only supported framework is Next.js.\n--plugins - The plugins you want to use. You can specify multiple plugins by separating them with a comma.\n--database - The database you want to use. Currently, the only supported database is SQLite.\n--package-manager - The package manager you want to use. Currently, the only supported package managers are npm, pnpm, yarn, bun (defaults to the manager you used to initialize the CLI).\nInfo\n\nThe info command provides diagnostic information about your Better Auth setup and environment. Useful for debugging and sharing when seeking support.\n\nTerminal\nnpx @better-auth/cli@latest info\nOutput\n\nThe command displays:\n\nSystem: OS, CPU, memory, Node.js version\nPackage Manager: Detected manager and version\nBetter Auth: Version and configuration (sensitive data auto-redacted)\nFrameworks: Detected frameworks (Next.js, React, Vue, etc.)\nDatabases: Database clients and ORMs (Prisma, Drizzle, etc.)\nOptions\n--config - Path to your Better Auth config file\n--json - Output as JSON for sharing or programmatic use\nExamples\n# Basic usage\nnpx @better-auth/cli@latest info\n# Custom config path\nnpx @better-auth/cli@latest info --config ./config/auth.ts\n# JSON output\nnpx @better-auth/cli@latest info --json > auth-info.json\n\nSensitive data like secrets, API keys, and database URLs are automatically replaced with [REDACTED] for safe sharing.\n\nSecret\n\nThe CLI also provides a way to generate a secret key for your Better Auth instance.\n\nTerminal\nnpx @better-auth/cli@latest secret\nCommon Issues\n\nError: Cannot find module X\n\nIf you see this error, it means the CLI can't resolve imported modules in your Better Auth config file. We are working on a fix for many of these issues, but in the meantime, you can try the following:\n\nRemove any import aliases in your config file and use relative paths instead. After running the CLI, you can revert to using aliases.\nEdit on GitHub\n\nPrevious Page\n\nAPI\n\nNext Page\n\nClient"
  },
  {
    "title": "Database | Better Auth",
    "url": "https://www.better-auth.com/docs/concepts/database#core-schema",
    "html": "Database\nCopy Markdown\nOpen in\nAdapters\n\nBetter Auth requires a database connection to store data. The database will be used to store data such as users, sessions, and more. Plugins can also define their own database tables to store data.\n\nYou can pass a database connection to Better Auth by passing a supported database instance in the database options. You can learn more about supported database adapters in the Other relational databases documentation.\n\nCLI\n\nBetter Auth comes with a CLI tool to manage database migrations and generate schema.\n\nRunning Migrations\n\nThe cli checks your database and prompts you to add missing tables or update existing ones with new columns. This is only supported for the built-in Kysely adapter. For other adapters, you can use the generate command to create the schema and handle the migration through your ORM.\n\nnpx @better-auth/cli migrate\n\nFor PostgreSQL users: The migrate command supports non-default schemas. It automatically detects your search_path configuration and creates tables in the correct schema. See PostgreSQL adapter for details.\n\nGenerating Schema\n\nBetter Auth also provides a generate command to generate the schema required by Better Auth. The generate command creates the schema required by Better Auth. If you're using a database adapter like Prisma or Drizzle, this command will generate the right schema for your ORM. If you're using the built-in Kysely adapter, it will generate an SQL file you can run directly on your database.\n\nnpx @better-auth/cli generate\n\nSee the CLI documentation for more information on the CLI.\n\nIf you prefer adding tables manually, you can do that as well. The core schema required by Better Auth is described below and you can find additional schema required by plugins in the plugin documentation.\n\nSecondary Storage\n\nSecondary storage in Better Auth allows you to use key-value stores for managing session data, rate limiting counters, etc. This can be useful when you want to offload the storage of this intensive records to a high performance storage or even RAM.\n\nImplementation\n\nTo use secondary storage, implement the SecondaryStorage interface:\n\ninterface SecondaryStorage {\n  get: (key: string) => Promise<unknown>; \n  set: (key: string, value: string, ttl?: number) => Promise<void>;\n  delete: (key: string) => Promise<void>;\n}\n\nThen, provide your implementation to the betterAuth function:\n\nbetterAuth({\n  // ... other options\n  secondaryStorage: {\n    // Your implementation here\n  },\n});\n\nBetter Auth uses seconds for the TTL value in set(). If your storage expects milliseconds, multiply by 1000 when passing the TTL (ttl * 1000).\n\nExample: Redis Implementation\n\nHere's a basic example using Redis:\n\nimport { createClient } from \"redis\";\nimport { betterAuth } from \"better-auth\";\nconst redis = createClient();\nawait redis.connect();\nexport const auth = betterAuth({\n\t// ... other options\n\tsecondaryStorage: {\n\t\tget: async (key) => {\n\t\t\treturn await redis.get(key);\n\t\t},\n\t\tset: async (key, value, ttl) => {\n\t\t\t// TTL in seconds â€” convert ms with ttl * 1000.\n\t\t\tif (ttl) await redis.set(key, value, { EX: ttl });\n\t\t\t// or for ioredis:\n\t\t\t// if (ttl) await redis.set(key, value, 'EX', ttl)\n\t\t\telse await redis.set(key, value);\n\t\t},\n\t\tdelete: async (key) => {\n\t\t\tawait redis.del(key);\n\t\t}\n\t}\n});\n\nThis implementation allows Better Auth to use Redis for storing session data and rate limiting counters. You can also add prefixes to the keys names.\n\nCore Schema\n\nBetter Auth requires the following tables to be present in the database. The types are in typescript format. You can use corresponding types in your database.\n\nUser\n\nTable Name: user\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for each user\nname\tstring\t-\tUser's chosen display name\nemail\tstring\t-\tUser's email address for communication and login\nemailVerified\tboolean\t-\tWhether the user's email is verified\nimage\tstring\t?\tUser's image url\ncreatedAt\tDate\t-\tTimestamp of when the user account was created\nupdatedAt\tDate\t-\tTimestamp of the last update to the user's information\nSession\n\nTable Name: session\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for each session\nuserId\tstring\t\nFK\tThe ID of the user\ntoken\tstring\t-\tThe unique session token\nexpiresAt\tDate\t-\tThe time when the session expires\nipAddress\tstring\t?\tThe IP address of the device\nuserAgent\tstring\t?\tThe user agent information of the device\ncreatedAt\tDate\t-\tTimestamp of when the session was created\nupdatedAt\tDate\t-\tTimestamp of when the session was updated\nAccount\n\nTable Name: account\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for each account\nuserId\tstring\t\nFK\tThe ID of the user\naccountId\tstring\t-\tThe ID of the account as provided by the SSO or equal to userId for credential accounts\nproviderId\tstring\t-\tThe ID of the provider\naccessToken\tstring\t?\tThe access token of the account. Returned by the provider\nrefreshToken\tstring\t?\tThe refresh token of the account. Returned by the provider\naccessTokenExpiresAt\tDate\t?\tThe time when the access token expires\nrefreshTokenExpiresAt\tDate\t?\tThe time when the refresh token expires\nscope\tstring\t?\tThe scope of the account. Returned by the provider\nidToken\tstring\t?\tThe ID token returned from the provider\npassword\tstring\t?\tThe password of the account. Mainly used for email and password authentication\ncreatedAt\tDate\t-\tTimestamp of when the account was created\nupdatedAt\tDate\t-\tTimestamp of when the account was updated\nVerification\n\nTable Name: verification\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for each verification\nidentifier\tstring\t-\tThe identifier for the verification request\nvalue\tstring\t-\tThe value to be verified\nexpiresAt\tDate\t-\tThe time when the verification request expires\ncreatedAt\tDate\t-\tTimestamp of when the verification request was created\nupdatedAt\tDate\t-\tTimestamp of when the verification request was updated\nCustom Tables\n\nBetter Auth allows you to customize the table names and column names for the core schema. You can also extend the core schema by adding additional fields to the user and session tables.\n\nCustom Table Names\n\nYou can customize the table names and column names for the core schema by using the modelName and fields properties in your auth config:\n\nauth.ts\nexport const auth = betterAuth({\n  user: {\n    modelName: \"users\",\n    fields: {\n      name: \"full_name\",\n      email: \"email_address\",\n    },\n  },\n  session: {\n    modelName: \"user_sessions\",\n    fields: {\n      userId: \"user_id\",\n    },\n  },\n});\n\nType inference in your code will still use the original field names (e.g., user.name, not user.full_name).\n\nTo customize table names and column name for plugins, you can use the schema property in the plugin config:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { twoFactor } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n  plugins: [\n    twoFactor({\n      schema: {\n        user: {\n          fields: {\n            twoFactorEnabled: \"two_factor_enabled\",\n            secret: \"two_factor_secret\",\n          },\n        },\n      },\n    }),\n  ],\n});\nExtending Core Schema\n\nBetter Auth provides a type-safe way to extend the user and session schemas. You can add custom fields to your auth config, and the CLI will automatically update the database schema. These additional fields will be properly inferred in functions like useSession, signUp.email, and other endpoints that work with user or session objects.\n\nTo add custom fields, use the additionalFields property in the user or session object of your auth config. The additionalFields object uses field names as keys, with each value being a FieldAttributes object containing:\n\ntype: The data type of the field (e.g., \"string\", \"number\", \"boolean\").\nrequired: A boolean indicating if the field is mandatory.\ndefaultValue: The default value for the field (note: this only applies in the JavaScript layer; in the database, the field will be optional).\ninput: This determines whether a value can be provided when creating a new record (default: true). If there are additional fields, like role, that should not be provided by the user during signup, you can set this to false.\n\nHere's an example of how to extend the user schema with additional fields:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  user: {\n    additionalFields: {\n      role: {\n        type: \"string\",\n        required: false,\n        defaultValue: \"user\",\n        input: false, // don't allow user to set role\n      },\n      lang: {\n        type: \"string\",\n        required: false,\n        defaultValue: \"en\",\n      },\n    },\n  },\n});\n\nNow you can access the additional fields in your application logic.\n\n//on signup\nconst res = await auth.api.signUpEmail({\n  email: \"test@example.com\",\n  password: \"password\",\n  name: \"John Doe\",\n  lang: \"fr\",\n});\n//user object\nres.user.role; // > \"admin\"\nres.user.lang; // > \"fr\"\n\nSee the TypeScript documentation for more information on how to infer additional fields on the client side.\n\nIf you're using social / OAuth providers, you may want to provide mapProfileToUser to map the profile data to the user object. So, you can populate additional fields from the provider's profile.\n\nExample: Mapping Profile to User For firstName and lastName\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  socialProviders: {\n    github: {\n      clientId: \"YOUR_GITHUB_CLIENT_ID\",\n      clientSecret: \"YOUR_GITHUB_CLIENT_SECRET\",\n      mapProfileToUser: (profile) => {\n        return {\n          firstName: profile.name.split(\" \")[0],\n          lastName: profile.name.split(\" \")[1],\n        };\n      },\n    },\n    google: {\n      clientId: \"YOUR_GOOGLE_CLIENT_ID\",\n      clientSecret: \"YOUR_GOOGLE_CLIENT_SECRET\",\n      mapProfileToUser: (profile) => {\n        return {\n          firstName: profile.given_name,\n          lastName: profile.family_name,\n        };\n      },\n    },\n  },\n});\nID Generation\n\nBetter Auth by default will generate unique IDs for users, sessions, and other entities. If you want to customize how IDs are generated, you can configure this in the advanced.database.generateId option in your auth config.\n\nYou can also disable ID generation by setting the advanced.database.generateId option to false. This will assume your database will generate the ID automatically.\n\nExample: Automatic Database IDs\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { db } from \"./db\";\nexport const auth = betterAuth({\n  database: db,\n  advanced: {\n    database: {\n      generateId: false,\n    },\n  },\n});\n\nExample: Using a Custom ID Generator\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { db } from \"./db\";\nexport const auth = betterAuth({\n  database: db,\n  advanced: {\n    database: {\n      generateId: () => crypto.randomUUID(),\n    },\n  },\n});\nNumeric IDs\n\nIf you prefer auto-incrementing numeric IDs, you can set the advanced.database.useNumberId option to true. Doing this will disable Better-Auth from generating IDs for any table, and will assume your database will generate the numeric ID automatically.\n\nWhen enabled, the Better-Auth CLI will generate or migrate the schema with the id field as a numeric type for your database with auto-incrementing attributes associated with it.\n\nimport { betterAuth } from \"better-auth\";\nimport { db } from \"./db\";\nexport const auth = betterAuth({\n  database: db,\n  advanced: {\n    database: {\n      useNumberId: true,\n    },\n  },\n});\n\nBetter-Auth will continue to infer the type of the id field as a string for the database, but will automatically convert it to a numeric type when fetching or inserting data from the database.\n\nIt's likely when grabbing id values returned from Better-Auth that you'll receive a string version of a number, this is normal. It's also expected that all id values passed to Better-Auth (eg via an endpoint body) is expected to be a string.\n\nDatabase Hooks\n\nDatabase hooks allow you to define custom logic that can be executed during the lifecycle of core database operations in Better Auth. You can create hooks for the following models: user, session, and account.\n\nAdditional fields are supported, however full type inference for these fields isn't yet supported. Improved type support is planned.\n\nThere are two types of hooks you can define:\n\n1. Before Hook\nPurpose: This hook is called before the respective entity (user, session, or account) is created or updated.\nBehavior: If the hook returns false, the operation will be aborted. And If it returns a data object, it'll replace the original payload.\n2. After Hook\nPurpose: This hook is called after the respective entity is created or updated.\nBehavior: You can perform additional actions or modifications after the entity has been successfully created or updated.\n\nExample Usage\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  databaseHooks: {\n    user: {\n      create: {\n        before: async (user, ctx) => {\n          // Modify the user object before it is created\n          return {\n            data: {\n              // Ensure to return Better-Auth named fields, not the original field names in your database.\n              ...user,\n              firstName: user.name.split(\" \")[0],\n              lastName: user.name.split(\" \")[1],\n            },\n          };\n        },\n        after: async (user) => {\n          //perform additional actions, like creating a stripe customer\n        },\n      },\n    },\n  },\n});\nThrowing Errors\n\nIf you want to stop the database hook from proceeding, you can throw errors using the APIError class imported from better-auth/api.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { APIError } from \"better-auth/api\";\nexport const auth = betterAuth({\n  databaseHooks: {\n    user: {\n      create: {\n        before: async (user, ctx) => {\n          if (user.isAgreedToTerms === false) {\n            // Your special condition.\n            // Send the API error.\n            throw new APIError(\"BAD_REQUEST\", {\n              message: \"User must agree to the TOS before signing up.\",\n            });\n          }\n          return {\n            data: user,\n          };\n        },\n      },\n    },\n  },\n});\nUsing the Context Object\n\nThe context object (ctx), passed as the second argument to the hook, contains useful information. For update hooks, this includes the current session, which you can use to access the logged-in user's details.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  databaseHooks: {\n    user: {\n      update: {\n        before: async (data, ctx) => {\n          // You can access the session from the context object.\n          if (ctx.context.session) {\n            console.log(\"User update initiated by:\", ctx.context.session.userId);\n          }\n          return { data };\n        },\n      },\n    },\n  },\n});\n\nMuch like standard hooks, database hooks also provide a ctx object that offers a variety of useful properties. Learn more in the Hooks Documentation.\n\nPlugins Schema\n\nPlugins can define their own tables in the database to store additional data. They can also add columns to the core tables to store additional data. For example, the two factor authentication plugin adds the following columns to the user table:\n\ntwoFactorEnabled: Whether two factor authentication is enabled for the user.\ntwoFactorSecret: The secret key used to generate TOTP codes.\ntwoFactorBackupCodes: Encrypted backup codes for account recovery.\n\nTo add new tables and columns to your database, you have two options:\n\nCLI: Use the migrate or generate command. These commands will scan your database and guide you through adding any missing tables or columns. Manual Method: Follow the instructions in the plugin documentation to manually add tables and columns.\n\nBoth methods ensure your database schema stays up to date with your plugins' requirements.\n\nEdit on GitHub\n\nPrevious Page\n\nCookies\n\nNext Page\n\nEmail"
  },
  {
    "title": "Next.js Example | Better Auth",
    "url": "https://www.better-auth.com/docs/examples/next-js",
    "html": "Next.js Example\nCopy Markdown\nOpen in\n\nThis is an example of how to use Better Auth with Next.\n\nImplements the following features: Email & Password . Social Sign-in . Passkeys . Email Verification . Password Reset . Two Factor Authentication . Profile Update . Session Management . Organization, Members and Roles\n\nSee Demo\n\nOpen in Stackblitz\nView on GitHub\nHow to run\nClone the code sandbox (or the repo) and open it in your code editor\nMove .env.example to .env and provide necessary variables\nRun the following commands\npnpm install\npnpm dev\nOpen the browser and navigate to http://localhost:3000\nSSO Login Example\n\nFor this example, we utilize DummyIDP. Initiate the login from the DummyIDP login, click \"Proceed\", and from here it will direct you to user's dashboard.\n\nEdit on GitHub\n\nPrevious Page\n\nRemix\n\nNext Page\n\nNuxt"
  },
  {
    "title": "Passkey | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/passkey",
    "html": "Passkey\nCopy Markdown\nOpen in\n\nPasskeys are a secure, passwordless authentication method using cryptographic key pairs, supported by WebAuthn and FIDO2 standards in web browsers. They replace passwords with unique key pairs: a private key stored on the user's device and a public key shared with the website. Users can log in using biometrics, PINs, or security keys, providing strong, phishing-resistant authentication without traditional passwords.\n\nThe passkey plugin implementation is powered by SimpleWebAuthn behind the scenes.\n\nInstallation\nAdd the plugin to your auth config\n\nTo add the passkey plugin to your auth config, you need to import the plugin and pass it to the plugins option of the auth instance.\n\nOptions\n\nrpID: A unique identifier for your website. 'localhost' is okay for local dev\n\nrpName: Human-readable title for your website\n\norigin: The URL at which registrations and authentications should occur. http://localhost and http://localhost:PORT are also valid. Do NOT include any trailing /\n\nauthenticatorSelection: Allows customization of WebAuthn authenticator selection criteria. Leave unspecified for default settings.\n\nauthenticatorAttachment: Specifies the type of authenticator\nplatform: Authenticator is attached to the platform (e.g., fingerprint reader)\ncross-platform: Authenticator is not attached to the platform (e.g., security key)\nDefault: not set (both platform and cross-platform allowed, with platform preferred)\nresidentKey: Determines credential storage behavior.\nrequired: User MUST store credentials on the authenticator (highest security)\npreferred: Encourages credential storage but not mandatory\ndiscouraged: No credential storage required (fastest experience)\nDefault: preferred\nuserVerification: Controls biometric/PIN verification during authentication:\nrequired: User MUST verify identity (highest security)\npreferred: Verification encouraged but not mandatory\ndiscouraged: No verification required (fastest experience)\nDefault: preferred\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { passkey } from \"better-auth/plugins/passkey\"\nexport const auth = betterAuth({\n    plugins: [ \n        passkey(), \n    ], \n})\nMigrate the database\n\nRun the migration or generate the schema to add the necessary fields and tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nSee the Schema section to add the fields manually.\n\nAdd the client plugin\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { passkeyClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n    plugins: [ \n        passkeyClient() \n    ] \n})\nUsage\nAdd/Register a passkey\n\nTo add or register a passkey make sure a user is authenticated and then call the passkey.addPasskey function provided by the client.\n\nClient\nServer\nPOST\n/passkey/add-passkey\nconst { data, error } = await authClient.passkey.addPasskey({\n    name: \"example-passkey-name\",\n    authenticatorAttachment: \"cross-platform\",\n});\nProp\tDescription\tType\nname?\t\nAn optional name to label the authenticator account being registered. If not provided, it will default to the user's email address or user ID\n\tstring\nauthenticatorAttachment?\t\nYou can also specify the type of authenticator you want to register. Default behavior allows both platform and cross-platform passkeys\n\t\"platform\" | \"cross-platform\"\n\nSetting throw: true in the fetch options has no effect for the register and sign-in passkey responses â€” they will always return a data object containing the error object.\n\nSign in with a passkey\n\nTo sign in with a passkey you can use the signIn.passkey method. This will prompt the user to sign in with their passkey.\n\nClient\nServer\nPOST\n/sign-in/passkey\nconst { data, error } = await authClient.signIn.passkey({\n    autoFill: true,\n});\nProp\tDescription\tType\nautoFill?\t\nBrowser autofill, a.k.a. Conditional UI. Read more: https://simplewebauthn.dev/docs/packages/browser#browser-autofill-aka-conditional-ui\n\tboolean\nExample Usage\n// With post authentication redirect\nawait authClient.signIn.passkey({\n    autoFill: true,\n    fetchOptions: {\n        onSuccess(context) {\n            // Redirect to dashboard after successful authentication\n            window.location.href = \"/dashboard\";\n        },\n        onError(context) {\n            // Handle authentication errors\n            console.error(\"Authentication failed:\", context.error.message);\n        }\n    }\n});\nList passkeys\n\nYou can list all of the passkeys for the authenticated user by calling passkey.listUserPasskeys:\n\nClient\nServer\nGET\n/passkey/list-user-passkeys\nconst { data: passkeys, error } = await authClient.passkey.listUserPasskeys();\nDeleting passkeys\n\nYou can delete a passkey by calling passkey.delete and providing the passkey ID.\n\nClient\nServer\nPOST\n/passkey/delete-passkey\nconst { data, error } = await authClient.passkey.deletePasskey({\n    id: \"some-passkey-id\", // required\n});\nProp\tDescription\tType\nid\t\nThe ID of the passkey to delete.\n\tstring\nUpdating passkey names\nClient\nServer\nPOST\n/passkey/update-passkey\nconst { data, error } = await authClient.passkey.updatePasskey({\n    id: \"id of passkey\", // required\n    name: \"my-new-passkey-name\", // required\n});\nProp\tDescription\tType\nid\t\nThe ID of the passkey which you want to update.\n\tstring\nname\t\nThe new name which the passkey will be updated to.\n\tstring\nConditional UI\n\nThe plugin supports conditional UI, which allows the browser to autofill the passkey if the user has already registered a passkey.\n\nThere are two requirements for conditional UI to work:\n\nUpdate input fields\n\nAdd the autocomplete attribute with the value webauthn to your input fields. You can add this attribute to multiple input fields, but at least one is required for conditional UI to work.\n\nThe webauthn value should also be the last entry of the autocomplete attribute.\n\n<label for=\"name\">Username:</label>\n<input type=\"text\" name=\"name\" autocomplete=\"username webauthn\">\n<label for=\"password\">Password:</label>\n<input type=\"password\" name=\"password\" autocomplete=\"current-password webauthn\">\nPreload the passkeys\n\nWhen your component mounts, you can preload the user's passkeys by calling the authClient.signIn.passkey method with the autoFill option set to true.\n\nTo prevent unnecessary calls, we will also add a check to see if the browser supports conditional UI.\n\nReact\nuseEffect(() => {\n   if (!PublicKeyCredential.isConditionalMediationAvailable ||\n       !PublicKeyCredential.isConditionalMediationAvailable()) {\n     return;\n   }\n  void authClient.signIn.passkey({ autoFill: true })\n}, [])\n\nDepending on the browser, a prompt will appear to autofill the passkey. If the user has multiple passkeys, they can select the one they want to use.\n\nSome browsers also require the user to first interact with the input field before the autofill prompt appears.\n\nDebugging\n\nTo test your passkey implementation you can use emulated authenticators. This way you can test the registration and sign-in process without even owning a physical device.\n\nSchema\n\nThe plugin require a new table in the database to store passkey data.\n\nTable Name: passkey\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for each passkey\nname\tstring\t?\tThe name of the passkey\npublicKey\tstring\t-\tThe public key of the passkey\nuserId\tstring\t\nFK\tThe ID of the user\ncredentialID\tstring\t-\tThe unique identifier of the registered credential\ncounter\tnumber\t-\tThe counter of the passkey\ndeviceType\tstring\t-\tThe type of device used to register the passkey\nbackedUp\tboolean\t-\tWhether the passkey is backed up\ntransports\tstring\t-\tThe transports used to register the passkey\ncreatedAt\tDate\t-\tThe time when the passkey was created\naaguid\tstring\t?\tAuthenticator's Attestation GUID indicating the type of the authenticator\nOptions\n\nrpID: A unique identifier for your website. 'localhost' is okay for local dev.\n\nrpName: Human-readable title for your website.\n\norigin: The URL at which registrations and authentications should occur. http://localhost and http://localhost:PORT are also valid. Do NOT include any trailing /.\n\nauthenticatorSelection: Allows customization of WebAuthn authenticator selection criteria. When unspecified, both platform and cross-platform authenticators are allowed with preferred settings for residentKey and userVerification.\n\naaguid: (optional) Authenticator Attestation GUID. This is a unique identifier for the passkey provider (device or authenticator type) and can be used to identify the type of passkey device used during registration or authentication.\n\nEdit on GitHub\n\nPrevious Page\n\nEmail OTP\n\nNext Page\n\nGeneric OAuth"
  },
  {
    "title": "Magic link | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/magic-link",
    "html": "Magic link\nCopy Markdown\nOpen in\n\nMagic link or email link is a way to authenticate users without a password. When a user enters their email, a link is sent to their email. When the user clicks on the link, they are authenticated.\n\nInstallation\nAdd the server Plugin\n\nAdd the magic link plugin to your server:\n\nserver.ts\nimport { betterAuth } from \"better-auth\";\nimport { magicLink } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n    plugins: [\n        magicLink({\n            sendMagicLink: async ({ email, token, url }, request) => {\n                // send email to user\n            }\n        })\n    ]\n})\nAdd the client Plugin\n\nAdd the magic link plugin to your client:\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nimport { magicLinkClient } from \"better-auth/client/plugins\";\nexport const authClient = createAuthClient({\n    plugins: [\n        magicLinkClient()\n    ]\n});\nUsage\nSign In with Magic Link\n\nTo sign in with a magic link, you need to call signIn.magicLink with the user's email address. The sendMagicLink function is called to send the magic link to the user's email.\n\nClient\nServer\nPOST\n/sign-in/magic-link\nconst { data, error } = await authClient.signIn.magicLink({\n    email: \"user@email.com\", // required\n    name: \"my-name\",\n    callbackURL: \"/dashboard\",\n    newUserCallbackURL: \"/welcome\",\n    errorCallbackURL: \"/error\",\n});\nProp\tDescription\tType\nemail\t\nEmail address to send the magic link.\n\tstring\nname?\t\nUser display name. Only used if the user is registering for the first time.\n\tstring\ncallbackURL?\t\nURL to redirect after magic link verification.\n\tstring\nnewUserCallbackURL?\t\nURL to redirect after new user signup\n\tstring\nerrorCallbackURL?\t\nURL to redirect if an error happen on verification If only callbackURL is provided but without an errorCallbackURL then they will be redirected to the callbackURL with an error query parameter.\n\tstring\n\nIf the user has not signed up, unless disableSignUp is set to true, the user will be signed up automatically.\n\nVerify Magic Link\n\nWhen you send the URL generated by the sendMagicLink function to a user, clicking the link will authenticate them and redirect them to the callbackURL specified in the signIn.magicLink function. If an error occurs, the user will be redirected to the callbackURL with an error query parameter.\n\nIf no callbackURL is provided, the user will be redirected to the root URL.\n\nIf you want to handle the verification manually, (e.g, if you send the user a different URL), you can use the verify function.\n\nClient\nServer\nGET\n/magic-link/verify\nconst { data, error } = await authClient.magicLink.verify({\n    query: {\n        token: \"123456\", // required\n        callbackURL: \"/dashboard\",\n    },\n});\nProp\tDescription\tType\ntoken\t\nVerification token.\n\tstring\ncallbackURL?\t\nURL to redirect after magic link verification, if not provided will return the session.\n\tstring\nConfiguration Options\n\nsendMagicLink: The sendMagicLink function is called when a user requests a magic link. It takes an object with the following properties:\n\nemail: The email address of the user.\nurl: The URL to be sent to the user. This URL contains the token.\ntoken: The token if you want to send the token with custom URL.\n\nand a request object as the second parameter.\n\nexpiresIn: specifies the time in seconds after which the magic link will expire. The default value is 300 seconds (5 minutes).\n\ndisableSignUp: If set to true, the user will not be able to sign up using the magic link. The default value is false.\n\ngenerateToken: The generateToken function is called to generate a token which is used to uniquely identify the user. The default value is a random string. There is one parameter:\n\nemail: The email address of the user.\n\nWhen using generateToken, ensure that the returned string is hard to guess because it is used to verify who someone actually is in a confidential way. By default, we return a long and cryptographically secure string.\n\nstoreToken: The storeToken function is called to store the magic link token in the database. The default value is \"plain\".\n\nThe storeToken function can be one of the following:\n\n\"plain\": The token is stored in plain text.\n\"hashed\": The token is hashed using the default hasher.\n{ type: \"custom-hasher\", hash: (token: string) => Promise<string> }: The token is hashed using a custom hasher.\nEdit on GitHub\n\nPrevious Page\n\nPhone Number\n\nNext Page\n\nEmail OTP"
  },
  {
    "title": "Username | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/username",
    "html": "Username\nCopy Markdown\nOpen in\n\nThe username plugin is a lightweight plugin that adds username support to the email and password authenticator. This allows users to sign in and sign up with their username instead of their email.\n\nInstallation\nAdd Plugin to the server\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { username } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    plugins: [ \n        username() \n    ] \n})\nMigrate the database\n\nRun the migration or generate the schema to add the necessary fields and tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nSee the Schema section to add the fields manually.\n\nAdd the client plugin\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { usernameClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n    plugins: [ \n        usernameClient() \n    ] \n})\nUsage\nSign up\n\nTo sign up a user with username, you can use the existing signUp.email function provided by the client. The signUp function should take a new username property in the object.\n\nClient\nServer\nPOST\n/sign-up/email\nconst { data, error } = await authClient.signUp.email({\n    email: \"email@domain.com\", // required\n    name: \"Test User\", // required\n    password: \"password1234\", // required\n    username: \"test\", // required\n    displayUsername: \"Test User123\",\n});\nProp\tDescription\tType\nemail\t\nThe email of the user.\n\tstring\nname\t\nThe name of the user.\n\tstring\npassword\t\nThe password of the user.\n\tstring\nusername\t\nThe username of the user.\n\tstring\ndisplayUsername?\t\nAn optional display username of the user.\n\tstring\n\nIf only username is provided, the displayUsername will be set to the pre normalized version of the username. You can see the Username Normalization and Display Username Normalization sections for more details.\n\nSign in\n\nTo sign in a user with username, you can use the signIn.username function provided by the client.\n\nClient\nServer\nPOST\n/sign-in/username\nconst { data, error } = await authClient.signIn.username({\n    username: \"test\", // required\n    password: \"password1234\", // required\n});\nProp\tDescription\tType\nusername\t\nThe username of the user.\n\tstring\npassword\t\nThe password of the user.\n\tstring\nUpdate username\n\nTo update the username of a user, you can use the updateUser function provided by the client.\n\nClient\nServer\nPOST\n/update-user\nconst { data, error } = await authClient.updateUser({\n    username: \"new-username\",\n});\nProp\tDescription\tType\nusername?\t\nThe username to update.\n\tstring\nCheck if username is available\n\nTo check if a username is available, you can use the isUsernameAvailable function provided by the client.\n\nClient\nServer\nPOST\n/is-username-available\nconst { data: response, error } = await authClient.isUsernameAvailable({\n    username: \"new-username\", // required\n});\nif(response?.available) {\n    console.log(\"Username is available\");\n} else {\n    console.log(\"Username is not available\");\n}\nProp\tDescription\tType\nusername\t\nThe username to check.\n\tstring\nOptions\nMin Username Length\n\nThe minimum length of the username. Default is 3.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { username } from \"better-auth/plugins\"\nconst auth = betterAuth({\n    plugins: [\n        username({\n            minUsernameLength: 5\n        })\n    ]\n})\nMax Username Length\n\nThe maximum length of the username. Default is 30.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { username } from \"better-auth/plugins\"\nconst auth = betterAuth({\n    plugins: [\n        username({\n            maxUsernameLength: 100\n        })\n    ]\n})\nUsername Validator\n\nA function that validates the username. The function should return false if the username is invalid. By default, the username should only contain alphanumeric characters, underscores, and dots.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { username } from \"better-auth/plugins\"\nconst auth = betterAuth({\n    plugins: [\n        username({\n            usernameValidator: (username) => {\n                if (username === \"admin\") {\n                    return false\n                }\n                return true\n            }\n        })\n    ]\n})\nDisplay Username Validator\n\nA function that validates the display username. The function should return false if the display username is invalid. By default, no validation is applied to display username.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { username } from \"better-auth/plugins\"\nconst auth = betterAuth({\n    plugins: [\n        username({\n            displayUsernameValidator: (displayUsername) => {\n                // Allow only alphanumeric characters, underscores, and hyphens\n                return /^[a-zA-Z0-9_-]+$/.test(displayUsername)\n            }\n        })\n    ]\n})\nUsername Normalization\n\nA function that normalizes the username, or false if you want to disable normalization.\n\nBy default, usernames are normalized to lowercase, so \"TestUser\" and \"testuser\", for example, are considered the same username. The username field will contain the normalized (lower case) username, while displayUsername will contain the original username.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { username } from \"better-auth/plugins\"\nconst auth = betterAuth({\n    plugins: [\n        username({\n            usernameNormalization: (username) => {\n                return username.toLowerCase()\n                    .replaceAll(\"0\", \"o\")\n                    .replaceAll(\"3\", \"e\")\n                    .replaceAll(\"4\", \"a\");\n            }\n        })\n    ]\n})\nDisplay Username Normalization\n\nA function that normalizes the display username, or false to disable normalization.\n\nBy default, display usernames are not normalized. When only username is provided during signup or update, the displayUsername will be set to match the original username value (before normalization). You can also explicitly set a displayUsername which will be preserved as-is. For custom normalization, provide a function that takes the display username as input and returns the normalized version.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { username } from \"better-auth/plugins\"\nconst auth = betterAuth({\n    plugins: [\n        username({\n            displayUsernameNormalization: (displayUsername) => displayUsername.toLowerCase(),\n        })\n    ]   \n})\nValidation Order\n\nBy default, username and display username are validated before normalization. You can change this behavior by setting validationOrder to post-normalization.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { username } from \"better-auth/plugins\"\nconst auth = betterAuth({\n    plugins: [\n        username({\n            validationOrder: {\n                username: \"post-normalization\",\n                displayUsername: \"post-normalization\",\n            }\n        })\n    ]\n})\nSchema\n\nThe plugin requires 2 fields to be added to the user table:\n\nField Name\tType\tKey\tDescription\nusername\tstring\t-\tThe username of the user\ndisplayUsername\tstring\t-\tNon normalized username of the user\nEdit on GitHub\n\nPrevious Page\n\nTwo Factor\n\nNext Page\n\nAnonymous"
  },
  {
    "title": "Better Auth Fastify Integration Guide | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/fastify",
    "html": "Better Auth Fastify Integration Guide\nCopy Markdown\nOpen in\n\nThis guide provides step-by-step instructions for configuring both essential handlers and CORS settings.\n\nA configured Better Auth instance is required before proceeding. If you haven't set this up yet, please consult our Installation Guide.\n\nPrerequisites\n\nVerify the following requirements before integration:\n\nNode.js Environment: v16 or later installed\nES Module Support: Enable ES modules in either:\npackage.json: { \"type\": \"module\" }\nTypeScript tsconfig.json: { \"module\": \"ESNext\" }\nFastify Dependencies:\nnpm\npnpm\nyarn\nbun\nnpm install fastify @fastify/cors\nFor TypeScript: Ensure your tsconfig.json includes \"esModuleInterop\": true for optimal compatibility.\nAuthentication Handler Setup\n\nConfigure Better Auth to process authentication requests by creating a catch-all route:\n\nserver.ts\nimport Fastify from \"fastify\";\nimport { auth } from \"./auth\"; // Your configured Better Auth instance\nconst fastify = Fastify({ logger: true });\n// Register authentication endpoint\nfastify.route({\n  method: [\"GET\", \"POST\"],\n  url: \"/api/auth/*\",\n  async handler(request, reply) {\n    try {\n      // Construct request URL\n      const url = new URL(request.url, `http://${request.headers.host}`);\n      \n      // Convert Fastify headers to standard Headers object\n      const headers = new Headers();\n      Object.entries(request.headers).forEach(([key, value]) => {\n        if (value) headers.append(key, value.toString());\n      });\n      // Create Fetch API-compatible request\n      const req = new Request(url.toString(), {\n        method: request.method,\n        headers,\n        body: request.body ? JSON.stringify(request.body) : undefined,\n      });\n      // Process authentication request\n      const response = await auth.handler(req);\n      // Forward response to client\n      reply.status(response.status);\n      response.headers.forEach((value, key) => reply.header(key, value));\n      reply.send(response.body ? await response.text() : null);\n    } catch (error) {\n      fastify.log.error(\"Authentication Error:\", error);\n      reply.status(500).send({ \n        error: \"Internal authentication error\",\n        code: \"AUTH_FAILURE\"\n      });\n    }\n  }\n});\n// Initialize server\nfastify.listen({ port: 4000 }, (err) => {\n  if (err) {\n    fastify.log.error(err);\n    process.exit(1);\n  }\n  console.log(\"Server running on port 4000\");\n});\nTrusted origins\n\nWhen a request is made from a different origin, the request will be blocked by default. You can add trusted origins to the auth instance.\n\nexport const auth = betterAuth({\n  trustedOrigins: [\"http://localhost:3000\", \"https://example.com\"],\n});\nConfiguring CORS\n\nSecure your API endpoints with proper CORS configuration:\n\nimport fastifyCors from \"@fastify/cors\";\n// Configure CORS policies\nfastify.register(fastifyCors, {\n  origin: process.env.CLIENT_ORIGIN || \"http://localhost:3000\",\n  methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"],\n  allowedHeaders: [\n    \"Content-Type\",\n    \"Authorization\",\n    \"X-Requested-With\"\n  ],\n  credentials: true,\n  maxAge: 86400\n});\n// Mount authentication handler after CORS registration\n// (Use previous handler configuration here)\nAlways restrict CORS origins in production environments. Use environment variables for dynamic configuration.\nEdit on GitHub\n\nPrevious Page\n\nHono\n\nNext Page\n\nExpress"
  },
  {
    "title": "Email OTP | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/email-otp",
    "html": "Email OTP\nCopy Markdown\nOpen in\n\nThe Email OTP plugin allows user to sign in, verify their email, or reset their password using a one-time password (OTP) sent to their email address.\n\nInstallation\nAdd the plugin to your auth config\n\nAdd the emailOTP plugin to your auth config and implement the sendVerificationOTP() method.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { emailOTP } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    // ... other config options\n    plugins: [\n        emailOTP({ \n            async sendVerificationOTP({ email, otp, type }) { \n                if (type === \"sign-in\") { \n                    // Send the OTP for sign in\n                } else if (type === \"email-verification\") { \n                    // Send the OTP for email verification\n                } else { \n                    // Send the OTP for password reset\n                } \n            }, \n        }) \n    ]\n})\nAdd the client plugin\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { emailOTPClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n    plugins: [\n        emailOTPClient()\n    ]\n})\nUsage\nSend an OTP\n\nUse the sendVerificationOtp() method to send an OTP to the user's email address.\n\nClient\nServer\nPOST\n/email-otp/send-verification-otp\nconst { data, error } = await authClient.emailOtp.sendVerificationOtp({\n    email: \"user@example.com\", // required\n    type: \"sign-in\", // required\n});\nProp\tDescription\tType\nemail\t\nEmail address to send the OTP.\n\tstring\ntype\t\nType of the OTP. sign-in, email-verification, or forget-password.\n\t\"email-verification\" | \"sign-in\" | \"forget-password\"\nCheck an OTP (optional)\n\nUse the checkVerificationOtp() method to check if an OTP is valid.\n\nClient\nServer\nPOST\n/email-otp/check-verification-otp\nconst { data, error } = await authClient.emailOtp.checkVerificationOtp({\n    email: \"user@example.com\", // required\n    type: \"sign-in\", // required\n    otp: \"123456\", // required\n});\nProp\tDescription\tType\nemail\t\nEmail address to send the OTP.\n\tstring\ntype\t\nType of the OTP. sign-in, email-verification, or forget-password.\n\t\"email-verification\" | \"sign-in\" | \"forget-password\"\notp\t\nOTP sent to the email.\n\tstring\nSign In with OTP\n\nTo sign in with OTP, use the sendVerificationOtp() method to send a \"sign-in\" OTP to the user's email address.\n\nClient\nServer\nPOST\n/email-otp/send-verification-otp\nconst { data, error } = await authClient.emailOtp.sendVerificationOtp({\n    email: \"user@example.com\", // required\n    type: \"sign-in\", // required\n});\nProp\tDescription\tType\nemail\t\nEmail address to send the OTP.\n\tstring\ntype\t\nType of the OTP.\n\t\"sign-in\"\n\nOnce the user provides the OTP, you can sign in the user using the signIn.emailOtp() method.\n\nClient\nServer\nPOST\n/sign-in/email-otp\nconst { data, error } = await authClient.signIn.emailOtp({\n    email: \"user@example.com\", // required\n    otp: \"123456\", // required\n});\nProp\tDescription\tType\nemail\t\nEmail address to sign in.\n\tstring\notp\t\nOTP sent to the email.\n\tstring\n\nIf the user is not registered, they'll be automatically registered. If you want to prevent this, you can pass disableSignUp as true in the options.\n\nVerify Email with OTP\n\nTo verify the user's email address with OTP, use the sendVerificationOtp() method to send an \"email-verification\" OTP to the user's email address.\n\nClient\nServer\nPOST\n/email-otp/send-verification-otp\nconst { data, error } = await authClient.emailOtp.sendVerificationOtp({\n    email: \"user@example.com\", // required\n    type: \"email-verification\", // required\n});\nProp\tDescription\tType\nemail\t\nEmail address to send the OTP.\n\tstring\ntype\t\nType of the OTP.\n\t\"email-verification\"\n\nOnce the user provides the OTP, use the verifyEmail() method to complete email verification.\n\nClient\nServer\nPOST\n/email-otp/verify-email\nconst { data, error } = await authClient.emailOtp.verifyEmail({\n    email: \"user@example.com\", // required\n    otp: \"123456\", // required\n});\nProp\tDescription\tType\nemail\t\nEmail address to verify.\n\tstring\notp\t\nOTP to verify.\n\tstring\nReset Password with OTP\n\nTo reset the user's password with OTP, use the forgetPassword.emailOTP() method to send a \"forget-password\" OTP to the user's email address.\n\nClient\nServer\nPOST\n/forget-password/email-otp\nconst { data, error } = await authClient.forgetPassword.emailOtp({\n    email: \"user@example.com\", // required\n});\nProp\tDescription\tType\nemail\t\nEmail address to send the OTP.\n\tstring\n\nOnce the user provides the OTP, use the checkVerificationOtp() method to check if it's valid (optional).\n\nClient\nServer\nPOST\n/email-otp/check-verification-otp\nconst { data, error } = await authClient.emailOtp.checkVerificationOtp({\n    email: \"user@example.com\", // required\n    type: \"forget-password\", // required\n    otp: \"123456\", // required\n});\nProp\tDescription\tType\nemail\t\nEmail address to send the OTP.\n\tstring\ntype\t\nType of the OTP.\n\t\"forget-password\"\notp\t\nOTP sent to the email.\n\tstring\n\nThen, use the resetPassword() method to reset the user's password.\n\nClient\nServer\nPOST\n/email-otp/reset-password\nconst { data, error } = await authClient.emailOtp.resetPassword({\n    email: \"user@example.com\", // required\n    otp: \"123456\", // required\n    password: \"new-secure-password\", // required\n});\nProp\tDescription\tType\nemail\t\nEmail address to reset the password.\n\tstring\notp\t\nOTP sent to the email.\n\tstring\npassword\t\nNew password.\n\tstring\nOverride Default Email Verification\n\nTo override the default email verification, pass overrideDefaultEmailVerification: true in the options. This will make the system use an email OTP instead of the default verification link whenever email verification is triggered. In other words, the user will verify their email using an OTP rather than clicking a link.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  plugins: [\n    emailOTP({\n      overrideDefaultEmailVerification: true, \n      async sendVerificationOTP({ email, otp, type }) {\n        // Implement the sendVerificationOTP method to send the OTP to the user's email address\n      },\n    }),\n  ],\n});\nOptions\n\nsendVerificationOTP: A function that sends the OTP to the user's email address. The function receives an object with the following properties:\n\nemail: The user's email address.\notp: The OTP to send.\ntype: The type of OTP to send. Can be \"sign-in\", \"email-verification\", or \"forget-password\".\n\notpLength: The length of the OTP. Defaults to 6.\n\nexpiresIn: The expiry time of the OTP in seconds. Defaults to 300 seconds.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    plugins: [\n        emailOTP({\n            otpLength: 8,\n            expiresIn: 600\n        })\n    ]\n})\n\nsendVerificationOnSignUp: A boolean value that determines whether to send the OTP when a user signs up. Defaults to false.\n\ndisableSignUp: A boolean value that determines whether to prevent automatic sign-up when the user is not registered. Defaults to false.\n\ngenerateOTP: A function that generates the OTP. Defaults to a random 6-digit number.\n\nallowedAttempts: The maximum number of attempts allowed for verifying an OTP. Defaults to 3. After exceeding this limit, the OTP becomes invalid and the user needs to request a new one.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    plugins: [\n        emailOTP({\n            allowedAttempts: 5, // Allow 5 attempts before invalidating the OTP\n            expiresIn: 300\n        })\n    ]\n})\n\nWhen the maximum attempts are exceeded, the verifyOTP, signIn.emailOtp, verifyEmail, and resetPassword methods will return an error with code TOO_MANY_ATTEMPTS.\n\nstoreOTP: The method to store the OTP in your database, whether encrypted, hashed or plain text. Default is plain text.\n\nNote: This will not affect the OTP sent to the user, it will only affect the OTP stored in your database.\n\nAlternatively, you can pass a custom encryptor or hasher to store the OTP in your database.\n\nCustom encryptor\n\nauth.ts\nemailOTP({\n    storeOTP: { \n        encrypt: async (otp) => {\n            return myCustomEncryptor(otp);\n        },\n        decrypt: async (otp) => {\n            return myCustomDecryptor(otp);\n        },\n    }\n})\n\nCustom hasher\n\nauth.ts\nemailOTP({\n    storeOTP: {\n        hash: async (otp) => {\n            return myCustomHasher(otp);\n        },\n    }\n})\nEdit on GitHub\n\nPrevious Page\n\nMagic Link\n\nNext Page\n\nPasskey"
  },
  {
    "title": "Next.js integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/next#server-action-cookies",
    "html": "Next.js integration\nCopy Markdown\nOpen in\n\nBetter Auth can be easily integrated with Next.js. Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the installation.\n\nCreate API Route\n\nWe need to mount the handler to an API route. Create a route file inside /api/auth/[...all] directory. And add the following code:\n\napi/auth/[...all]/route.ts\nimport { auth } from \"@/lib/auth\";\nimport { toNextJsHandler } from \"better-auth/next-js\";\nexport const { GET, POST } = toNextJsHandler(auth.handler);\n\nYou can change the path on your better-auth configuration but it's recommended to keep it as /api/auth/[...all]\n\nFor pages route, you need to use toNodeHandler instead of toNextJsHandler and set bodyParser to false in the config object. Here is an example:\n\npages/api/auth/[...all].ts\nimport { toNodeHandler } from \"better-auth/node\"\nimport { auth } from \"@/lib/auth\"\n// Disallow body parsing, we will parse it manually\nexport const config = { api: { bodyParser: false } }\nexport default toNodeHandler(auth.handler)\nCreate a client\n\nCreate a client instance. You can name the file anything you want. Here we are creating client.ts file inside the lib/ directory.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/react\" // make sure to import from better-auth/react\nexport const authClient =  createAuthClient({\n    //you can pass client configuration here\n})\n\nOnce you have created the client, you can use it to sign up, sign in, and perform other actions. Some of the actions are reactive. The client uses nano-store to store the state and re-render the components when the state changes.\n\nThe client also uses better-fetch to make the requests. You can pass the fetch configuration to the client.\n\nRSC and Server actions\n\nThe api object exported from the auth instance contains all the actions that you can perform on the server. Every endpoint made inside Better Auth is a invocable as a function. Including plugins endpoints.\n\nExample: Getting Session on a server action\n\nserver.ts\nimport { auth } from \"@/lib/auth\"\nimport { headers } from \"next/headers\"\nconst someAuthenticatedAction = async () => {\n    \"use server\";\n    const session = await auth.api.getSession({\n        headers: await headers()\n    })\n};\n\nExample: Getting Session on a RSC\n\nimport { auth } from \"@/lib/auth\"\nimport { headers } from \"next/headers\"\nexport async function ServerComponent() {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    })\n    if(!session) {\n        return <div>Not authenticated</div>\n    }\n    return (\n        <div>\n            <h1>Welcome {session.user.name}</h1>\n        </div>\n    )\n}\nAs RSCs cannot set cookies, the cookie cache will not be refreshed until the server is interacted with from the client via Server Actions or Route Handlers.\nServer Action Cookies\n\nWhen you call a function that needs to set cookies, like signInEmail or signUpEmail in a server action, cookies wonâ€™t be set. This is because server actions need to use the cookies helper from Next.js to set cookies.\n\nTo simplify this, you can use the nextCookies plugin, which will automatically set cookies for you whenever a Set-Cookie header is present in the response.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { nextCookies } from \"better-auth/next-js\";\nexport const auth = betterAuth({\n    //...your config\n    plugins: [nextCookies()] // make sure this is the last plugin in the array\n})\n\nNow, when you call functions that set cookies, they will be automatically set.\n\n\"use server\";\nimport { auth } from \"@/lib/auth\"\nconst signIn = async () => {\n    await auth.api.signInEmail({\n        body: {\n            email: \"user@email.com\",\n            password: \"password\",\n        }\n    })\n}\nMiddleware\n\nIn Next.js middleware, it's recommended to only check for the existence of a session cookie to handle redirection. To avoid blocking requests by making API or database calls.\n\nYou can use the getSessionCookie helper from Better Auth for this purpose:\n\nThe getSessionCookie() function does not automatically reference the auth config specified in auth.ts. Therefore, if you customized the cookie name or prefix, you need to ensure that the configuration in getSessionCookie() matches the config defined in your auth.ts.\n\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { getSessionCookie } from \"better-auth/cookies\";\nexport async function middleware(request: NextRequest) {\n\tconst sessionCookie = getSessionCookie(request);\n    // THIS IS NOT SECURE!\n    // This is the recommended approach to optimistically redirect users\n    // We recommend handling auth checks in each page/route\n\tif (!sessionCookie) {\n\t\treturn NextResponse.redirect(new URL(\"/\", request.url));\n\t}\n\treturn NextResponse.next();\n}\nexport const config = {\n\tmatcher: [\"/dashboard\"], // Specify the routes the middleware applies to\n};\n\nSecurity Warning: The getSessionCookie function only checks for the existence of a session cookie; it does not validate it. Relying solely on this check for security is dangerous, as anyone can manually create a cookie to bypass it. You must always validate the session on your server for any protected actions or pages.\n\nIf you have a custom cookie name or prefix, you can pass it to the getSessionCookie function.\n\nconst sessionCookie = getSessionCookie(request, {\n    cookieName: \"my_session_cookie\",\n    cookiePrefix: \"my_prefix\"\n});\n\nAlternatively, you can use the getCookieCache helper to get the session object from the cookie cache.\n\nimport { getCookieCache } from \"better-auth/cookies\";\nexport async function middleware(request: NextRequest) {\n\tconst session = await getCookieCache(request);\n\tif (!session) {\n\t\treturn NextResponse.redirect(new URL(\"/sign-in\", request.url));\n\t}\n\treturn NextResponse.next();\n}\nHow to handle auth checks in each page/route\n\nIn this example, we are using the auth.api.getSession function within a server component to get the session object, then we are checking if the session is valid. If it's not, we are redirecting the user to the sign-in page.\n\napp/dashboard/page.tsx\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { redirect } from \"next/navigation\";\nexport default async function DashboardPage() {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    })\n    if(!session) {\n        redirect(\"/sign-in\")\n    }\n    return (\n        <div>\n            <h1>Welcome {session.user.name}</h1>\n        </div>\n    )\n}\nFor Next.js release 15.1.7 and below\n\nIf you need the full session object, you'll have to fetch it from the /get-session API route. Since Next.js middleware doesn't support running Node.js APIs directly, you must make an HTTP request.\n\nThe example uses better-fetch, but you can use any fetch library.\n\nimport { betterFetch } from \"@better-fetch/fetch\";\nimport type { auth } from \"@/lib/auth\";\nimport { NextRequest, NextResponse } from \"next/server\";\ntype Session = typeof auth.$Infer.Session;\nexport async function middleware(request: NextRequest) {\n\tconst { data: session } = await betterFetch<Session>(\"/api/auth/get-session\", {\n\t\tbaseURL: request.nextUrl.origin,\n\t\theaders: {\n\t\t\tcookie: request.headers.get(\"cookie\") || \"\", // Forward the cookies from the request\n\t\t},\n\t});\n\tif (!session) {\n\t\treturn NextResponse.redirect(new URL(\"/sign-in\", request.url));\n\t}\n\treturn NextResponse.next();\n}\nexport const config = {\n\tmatcher: [\"/dashboard\"], // Apply middleware to specific routes\n};\nFor Next.js release 15.2.0 and above\n\nFrom the version 15.2.0, Next.js allows you to use the Node.js runtime in middleware. This means you can use the auth.api object directly in middleware.\n\nYou may refer to the Next.js documentation for more information about runtime configuration, and how to enable it. Be careful when using the new runtime. It's an experimental feature and it may be subject to breaking changes.\n\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { headers } from \"next/headers\";\nimport { auth } from \"@/lib/auth\";\nexport async function middleware(request: NextRequest) {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    })\n    if(!session) {\n        return NextResponse.redirect(new URL(\"/sign-in\", request.url));\n    }\n    return NextResponse.next();\n}\nexport const config = {\n  runtime: \"nodejs\",\n  matcher: [\"/dashboard\"], // Apply middleware to specific routes\n};\nEdit on GitHub\n\nPrevious Page\n\nRemix\n\nNext Page\n\nNuxt"
  },
  {
    "title": "Session Management | Better Auth",
    "url": "https://www.better-auth.com/docs/concepts/session-management",
    "html": "Session Management\nCopy Markdown\nOpen in\n\nBetter Auth manages session using a traditional cookie-based session management. The session is stored in a cookie and is sent to the server on every request. The server then verifies the session and returns the user data if the session is valid.\n\nSession table\n\nThe session table stores the session data. The session table has the following fields:\n\nid: The session token. Which is also used as the session cookie.\nuserId: The user ID of the user.\nexpiresAt: The expiration date of the session.\nipAddress: The IP address of the user.\nuserAgent: The user agent of the user. It stores the user agent header from the request.\nSession Expiration\n\nThe session expires after 7 days by default. But whenever the session is used and the updateAge is reached, the session expiration is updated to the current time plus the expiresIn value.\n\nYou can change both the expiresIn and updateAge values by passing the session object to the auth configuration.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    //... other config options\n    session: {\n        expiresIn: 60 * 60 * 24 * 7, // 7 days\n        updateAge: 60 * 60 * 24 // 1 day (every 1 day the session expiration is updated)\n    }\n})\nDisable Session Refresh\n\nYou can disable session refresh so that the session is not updated regardless of the updateAge option.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    //... other config options\n    session: {\n        disableSessionRefresh: true\n    }\n})\nSession Freshness\n\nSome endpoints in Better Auth require the session to be fresh. A session is considered fresh if its createdAt is within the freshAge limit. By default, the freshAge is set to 1 day (60 * 60 * 24).\n\nYou can customize the freshAge value by passing a session object in the auth configuration:\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    //... other config options\n    session: {\n        freshAge: 60 * 5 // 5 minutes (the session is fresh if created within the last 5 minutes)\n    }\n})\n\nTo disable the freshness check, set freshAge to 0:\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    //... other config options\n    session: {\n        freshAge: 0 // Disable freshness check\n    }\n})\nSession Management\n\nBetter Auth provides a set of functions to manage sessions.\n\nGet Session\n\nThe getSession function retrieves the current active session.\n\nimport { authClient } from \"@/lib/client\"\nconst { data: session } = await authClient.getSession()\n\nTo learn how to customize the session response check the Customizing Session Response section.\n\nUse Session\n\nThe useSession action provides a reactive way to access the current session.\n\nimport { authClient } from \"@/lib/client\"\nconst { data: session } = authClient.useSession()\nList Sessions\n\nThe listSessions function returns a list of sessions that are active for the user.\n\nauth-client.ts\nimport { authClient } from \"@/lib/client\"\nconst sessions = await authClient.listSessions()\nRevoke Session\n\nWhen a user signs out of a device, the session is automatically ended. However, you can also end a session manually from any device the user is signed into.\n\nTo end a session, use the revokeSession function. Just pass the session token as a parameter.\n\nauth-client.ts\nawait authClient.revokeSession({\n    token: \"session-token\"\n})\nRevoke Other Sessions\n\nTo revoke all other sessions except the current session, you can use the revokeOtherSessions function.\n\nauth-client.ts\nawait authClient.revokeOtherSessions()\nRevoke All Sessions\n\nTo revoke all sessions, you can use the revokeSessions function.\n\nauth-client.ts\nawait authClient.revokeSessions()\nRevoking Sessions on Password Change\n\nYou can revoke all sessions when the user changes their password by passing revokeOtherSessions as true on changePassword function.\n\nauth.ts\nawait authClient.changePassword({\n    newPassword: newPassword,\n    currentPassword: currentPassword,\n    revokeOtherSessions: true,\n})\nSession Caching\nCookie Cache\n\nCalling your database every time useSession or getSession invoked isnâ€™t ideal, especially if sessions donâ€™t change frequently. Cookie caching handles this by storing session data in a short-lived, signed cookieâ€”similar to how JWT access tokens are used with refresh tokens.\n\nWhen cookie caching is enabled, the server can check session validity from the cookie itself instead of hitting the database each time. The cookie is signed to prevent tampering, and a short maxAge ensures that the session data gets refreshed regularly. If a session is revoked or expires, the cookie will be invalidated automatically.\n\nTo turn on cookie caching, just set session.cookieCache in your auth config:\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    session: {\n        cookieCache: {\n            enabled: true,\n            maxAge: 5 * 60 // Cache duration in seconds\n        }\n    }\n});\n\nIf you want to disable returning from the cookie cache when fetching the session, you can pass disableCookieCache:true this will force the server to fetch the session from the database and also refresh the cookie cache.\n\nauth-client.ts\nconst session = await authClient.getSession({ query: {\n    disableCookieCache: true\n}})\n\nor on the server\n\nserver.ts\nawait auth.api.getSession({\n    query: {\n        disableCookieCache: true,\n    }, \n    headers: req.headers, // pass the headers\n});\nCustomizing Session Response\n\nWhen you call getSession or useSession, the session data is returned as a user and session object. You can customize this response using the customSession plugin.\n\nauth.ts\nimport { customSession } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n    plugins: [\n        customSession(async ({ user, session }) => {\n            const roles = findUserRoles(session.session.userId);\n            return {\n                roles,\n                user: {\n                    ...user,\n                    newField: \"newField\",\n                },\n                session\n            };\n        }),\n    ],\n});\n\nThis will add roles and user.newField to the session response.\n\nInfer on the Client\n\nauth-client.ts\nimport { customSessionClient } from \"better-auth/client/plugins\";\nimport type { auth } from \"@/lib/auth\"; // Import the auth instance as a type\nconst authClient = createAuthClient({\n    plugins: [customSessionClient<typeof auth>()],\n});\nconst { data } = authClient.useSession();\nconst { data: sessionData } = await authClient.getSession();\n// data.roles\n// data.user.newField\nCaveats on Customizing Session Response\nThe passed session object to the callback does not infer fields added by plugins.\n\nHowever, as a workaround, you can pull up your auth options and pass it to the plugin to infer the fields.\n\nimport { betterAuth, BetterAuthOptions } from \"better-auth\";\nconst options = {\n  //...config options\n  plugins: [\n    //...plugins \n  ]\n} satisfies BetterAuthOptions;\nexport const auth = betterAuth({\n    ...options,\n    plugins: [\n        ...(options.plugins ?? []),\n        customSession(async ({ user, session }, ctx) => {\n            // now both user and session will infer the fields added by plugins and your custom fields\n            return {\n                user,\n                session\n            }\n        }, options), // pass options here\n    ]\n})\nWhen your server and client code are in separate projects or repositories, and you cannot import the auth instance as a type reference, type inference for custom session fields will not work on the client side.\nSession caching, including secondary storage or cookie cache, does not include custom fields. Each time the session is fetched, your custom session function will be called.\n\nMutating the list-device-sessions endpoint The /multi-session/list-device-sessions endpoint from the multi-session plugin is used to list the devices that the user is signed into.\n\nYou can mutate the response of this endpoint by passing the shouldMutateListDeviceSessionsEndpoint option to the customSession plugin.\n\nBy default, we do not mutate the response of this endpoint.\n\nauth.ts\nimport { customSession } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n    plugins: [\n        customSession(async ({ user, session }, ctx) => {\n            return {\n                user,\n                session\n            }\n        }, {}, { shouldMutateListDeviceSessionsEndpoint: true }), \n    ],\n});\nEdit on GitHub\n\nPrevious Page\n\nRate Limit\n\nNext Page\n\nTypeScript"
  },
  {
    "title": "Two-Factor Authentication (2FA) | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/2fa#schema",
    "html": "Two-Factor Authentication (2FA)\nCopy Markdown\nOpen in\n\nOTP TOTP Backup Codes Trusted Devices\n\nTwo-Factor Authentication (2FA) adds an extra security step when users log in. Instead of just using a password, they'll need to provide a second form of verification. This makes it much harder for unauthorized people to access accounts, even if they've somehow gotten the password.\n\nThis plugin offers two main methods to do a second factor verification:\n\nOTP (One-Time Password): A temporary code sent to the user's email or phone.\nTOTP (Time-based One-Time Password): A code generated by an app on the user's device.\n\nAdditional features include:\n\nGenerating backup codes for account recovery\nEnabling/disabling 2FA\nManaging trusted devices\nInstallation\nAdd the plugin to your auth config\n\nAdd the two-factor plugin to your auth configuration and specify your app name as the issuer.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { twoFactor } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    // ... other config options\n    appName: \"My App\", // provide your app name. It'll be used as an issuer.\n    plugins: [\n        twoFactor() \n    ]\n})\nMigrate the database\n\nRun the migration or generate the schema to add the necessary fields and tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nSee the Schema section to add the fields manually.\n\nAdd the client plugin\n\nAdd the client plugin and Specify where the user should be redirected if they need to verify 2nd factor\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { twoFactorClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n    plugins: [\n        twoFactorClient()\n    ]\n})\nUsage\nEnabling 2FA\n\nTo enable two-factor authentication, call twoFactor.enable with the user's password and issuer (optional):\n\nClient\nServer\nPOST\n/two-factor/enable\nconst { data, error } = await authClient.twoFactor.enable({\n    password: \"secure-password\", // required\n    issuer: \"my-app-name\",\n});\nProp\tDescription\tType\npassword\t\nThe user's password\n\tstring\nissuer?\t\nAn optional custom issuer for the TOTP URI. Defaults to app-name defined in your auth config.\n\tstring\n\nWhen 2FA is enabled:\n\nAn encrypted secret and backupCodes are generated.\nenable returns totpURI and backupCodes.\n\nNote: twoFactorEnabled wonâ€™t be set to true until the user verifies their TOTP code. Learn more about verifying TOTP here. You can skip verification by setting skipVerificationOnEnable to true in your plugin config.\n\nTwo Factor can only be enabled for credential accounts at the moment. For social accounts, it's assumed the provider already handles 2FA.\n\nSign In with 2FA\n\nWhen a user with 2FA enabled tries to sign in via email, the response object will contain twoFactorRedirect set to true. This indicates that the user needs to verify their 2FA code.\n\nYou can handle this in the onSuccess callback or by providing a onTwoFactorRedirect callback in the plugin config.\n\nsign-in.tsx\nawait authClient.signIn.email({\n        email: \"user@example.com\",\n        password: \"password123\",\n    },\n    {\n        async onSuccess(context) {\n            if (context.data.twoFactorRedirect) {\n                // Handle the 2FA verification in place\n            }\n        },\n    }\n)\n\nUsing the onTwoFactorRedirect config:\n\nsign-in.ts\nimport { createAuthClient } from \"better-auth/client\";\nimport { twoFactorClient } from \"better-auth/client/plugins\";\nconst authClient = createAuthClient({\n    plugins: [\n        twoFactorClient({\n            onTwoFactorRedirect(){\n                // Handle the 2FA verification globally\n            },\n        }),\n    ],\n});\n\nWith auth.api\n\nWhen you call auth.api.signInEmail on the server, and the user has 2FA enabled, it will return an object where twoFactorRedirect is set to true. This behavior isnâ€™t inferred in TypeScript, which can be misleading. You can check using in instead to check if twoFactorRedirect is set to true.\n\nconst response = await auth.api.signInEmail({\n\tbody: {\n\t\temail: \"test@test.com\",\n\t\tpassword: \"test\",\n\t},\n});\nif (\"twoFactorRedirect\" in response) {\n\t// Handle the 2FA verification in place\n}\nDisabling 2FA\n\nTo disable two-factor authentication, call twoFactor.disable with the user's password:\n\nClient\nServer\nPOST\n/two-factor/disable\nconst { data, error } = await authClient.twoFactor.disable({\n    password, // required\n});\nProp\tDescription\tType\npassword\t\nThe user's password\n\tstring\nTOTP\n\nTOTP (Time-Based One-Time Password) is an algorithm that generates a unique password for each login attempt using time as a counter. Every fixed interval (Better Auth defaults to 30 seconds), a new password is generated. This addresses several issues with traditional passwords: they can be forgotten, stolen, or guessed. OTPs solve some of these problems, but their delivery via SMS or email can be unreliable (or even risky, considering it opens new attack vectors).\n\nTOTP, however, generates codes offline, making it both secure and convenient. You just need an authenticator app on your phone.\n\nGetting TOTP URI\n\nAfter enabling 2FA, you can get the TOTP URI to display to the user. This URI is generated by the server using the secret and issuer and can be used to generate a QR code for the user to scan with their authenticator app.\n\nClient\nServer\nPOST\n/two-factor/get-totp-uri\nconst { data, error } = await authClient.twoFactor.getTotpUri({\n    password, // required\n});\nProp\tDescription\tType\npassword\t\nThe user's password\n\tstring\n\nExample: Using React\n\nOnce you have the TOTP URI, you can use it to generate a QR code for the user to scan with their authenticator app.\n\nuser-card.tsx\nimport QRCode from \"react-qr-code\";\nexport default function UserCard({ password }: { password: string }){\n    const { data: session } = client.useSession();\n\tconst { data: qr } = useQuery({\n\t\tqueryKey: [\"two-factor-qr\"],\n\t\tqueryFn: async () => {\n\t\t\tconst res = await authClient.twoFactor.getTotpUri({ password });\n\t\t\treturn res.data;\n\t\t},\n\t\tenabled: !!session?.user.twoFactorEnabled,\n\t});\n    return (\n        <QRCode value={qr?.totpURI || \"\"} />\n   )\n}\n\nBy default the issuer for TOTP is set to the app name provided in the auth config or if not provided it will be set to Better Auth. You can override this by passing issuer to the plugin config.\n\nVerifying TOTP\n\nAfter the user has entered their 2FA code, you can verify it using twoFactor.verifyTotp method. Better Auth follows standard practice by accepting TOTP codes from one period before and one after the current code, ensuring users can authenticate even with minor time delays on their end.\n\nClient\nServer\nPOST\n/two-factor/verify-totp\nconst { data, error } = await authClient.twoFactor.verifyTotp({\n    code: \"012345\", // required\n    trustDevice: true,\n});\nProp\tDescription\tType\ncode\t\nThe otp code to verify.\n\tstring\ntrustDevice?\t\nIf true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time.\n\tboolean\nOTP\n\nOTP (One-Time Password) is similar to TOTP but a random code is generated and sent to the user's email or phone.\n\nBefore using OTP to verify the second factor, you need to configure sendOTP in your Better Auth instance. This function is responsible for sending the OTP to the user's email, phone, or any other method supported by your application.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { twoFactor } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    plugins: [\n        twoFactor({\n          \totpOptions: {\n\t\t\t\tasync sendOTP({ user, otp }, request) {\n                    // send otp to user\n\t\t\t\t},\n\t\t\t},\n        })\n    ]\n})\nSending OTP\n\nSending an OTP is done by calling the twoFactor.sendOtp function. This function will trigger your sendOTP implementation that you provided in the Better Auth configuration.\n\nClient\nServer\nPOST\n/two-factor/send-otp\nconst { data, error } = await authClient.twoFactor.sendOtp({\n    trustDevice: true,\n});\nif (data) {\n    // redirect or show the user to enter the code\n}\nProp\tDescription\tType\ntrustDevice?\t\nIf true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time.\n\tboolean\nVerifying OTP\n\nAfter the user has entered their OTP code, you can verify it\n\nClient\nServer\nPOST\n/two-factor/verify-otp\nconst { data, error } = await authClient.twoFactor.verifyOtp({\n    code: \"012345\", // required\n    trustDevice: true,\n});\nProp\tDescription\tType\ncode\t\nThe otp code to verify.\n\tstring\ntrustDevice?\t\nIf true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time.\n\tboolean\nBackup Codes\n\nBackup codes are generated and stored in the database. This can be used to recover access to the account if the user loses access to their phone or email.\n\nGenerating Backup Codes\n\nGenerate backup codes for account recovery:\n\nClient\nServer\nPOST\n/two-factor/generate-backup-codes\nconst { data, error } = await authClient.twoFactor.generateBackupCodes({\n    password, // required\n});\nif (data) {\n    // Show the backup codes to the user\n}\nProp\tDescription\tType\npassword\t\nThe users password.\n\tstring\n\nWhen you generate backup codes, the old backup codes will be deleted and new ones will be generated.\n\nUsing Backup Codes\n\nYou can now allow users to provider backup code as account recover method.\n\nClient\nServer\nPOST\n/two-factor/verify-backup-code\nconst { data, error } = await authClient.twoFactor.verifyBackupCode({\n    code: \"123456\", // required\n    disableSession: false,\n    trustDevice: true,\n});\nProp\tDescription\tType\ncode\t\nA backup code to verify.\n\tstring\ndisableSession?\t\nIf true, the session cookie will not be set.\n\tboolean\ntrustDevice?\t\nIf true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time.\n\tboolean\n\nOnce a backup code is used, it will be removed from the database and can't be used again.\n\nViewing Backup Codes\n\nTo display the backup codes to the user, you can call viewBackupCodes on the server. This will return the backup codes in the response. You should only this if the user has a fresh session - a session that was just created.\n\nClient\nServer\nGET\n/two-factor/view-backup-codes\nconst data = await auth.api.viewBackupCodes({\n    body: {\n        userId: \"user-id\",\n    },\n});\nProp\tDescription\tType\nuserId?\t\nThe user ID to view all backup codes.\n\tstring | null\nTrusted Devices\n\nYou can mark a device as trusted by passing trustDevice to verifyTotp or verifyOtp.\n\nconst verify2FA = async (code: string) => {\n    const { data, error } = await authClient.twoFactor.verifyTotp({\n        code,\n        callbackURL: \"/dashboard\",\n        trustDevice: true // Mark this device as trusted\n    })\n    if (data) {\n        // 2FA verified and device trusted\n    }\n}\n\nWhen trustDevice is set to true, the current device will be remembered for 60 days. During this period, the user won't be prompted for 2FA on subsequent sign-ins from this device. The trust period is refreshed each time the user signs in successfully.\n\nIssuer\n\nBy adding an issuer you can set your application name for the 2fa application.\n\nFor example, if your user uses Google Auth, the default appName will show up as Better Auth. However, by using the following code, it will show up as my-app-name.\n\ntwoFactor({\n    issuer: \"my-app-name\"\n})\nSchema\n\nThe plugin requires 1 additional fields in the user table and 1 additional table to store the two factor authentication data.\n\nTable: user\n\nField Name\tType\tKey\tDescription\ntwoFactorEnabled\tboolean\t?\tWhether two factor authentication is enabled for the user.\n\nTable: twoFactor\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tThe ID of the two factor authentication.\nuserId\tstring\t\nFK\tThe ID of the user\nsecret\tstring\t?\tThe secret used to generate the TOTP code.\nbackupCodes\tstring\t?\tThe backup codes used to recover access to the account if the user loses access to their phone or email.\nOptions\nServer\n\ntwoFactorTable: The name of the table that stores the two factor authentication data. Default: twoFactor.\n\nskipVerificationOnEnable: Skip the verification process before enabling two factor for a user.\n\nIssuer: The issuer is the name of your application. It's used to generate TOTP codes. It'll be displayed in the authenticator apps.\n\nTOTP options\n\nthese are options for TOTP.\n\nProp\n\nType\n\ndigits?\nnumber\nperiod?\nnumber\n\nOTP options\n\nthese are options for OTP.\n\nProp\n\nType\n\nsendOTP?\nfunction\nperiod?\nnumber\nstoreOTP?\nstring\n\nBackup Code Options\n\nbackup codes are generated and stored in the database when the user enabled two factor authentication. This can be used to recover access to the account if the user loses access to their phone or email.\n\nProp\n\nType\n\namount?\nnumber\nlength?\nnumber\ncustomBackupCodesGenerate?\nfunction\nstoreBackupCodes?\nstring\nClient\n\nTo use the two factor plugin in the client, you need to add it on your plugins list.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { twoFactorClient } from \"better-auth/client/plugins\"\nconst authClient =  createAuthClient({\n    plugins: [\n        twoFactorClient({ \n            onTwoFactorRedirect(){ \n                window.location.href = \"/2fa\" // Handle the 2FA verification redirect\n            } \n        }) \n    ]\n})\n\nOptions\n\nonTwoFactorRedirect: A callback that will be called when the user needs to verify their 2FA code. This can be used to redirect the user to the 2FA page.\n\nEdit on GitHub\n\nPrevious Page\n\nAuthentication\n\nNext Page\n\nUsername"
  },
  {
    "title": "API | Better Auth",
    "url": "https://www.better-auth.com/docs/concepts/api",
    "html": "API\nCopy Markdown\nOpen in\n\nWhen you create a new Better Auth instance, it provides you with an api object. This object exposes every endpoint that exists in your Better Auth instance. And you can use this to interact with Better Auth server side.\n\nAny endpoint added to Better Auth, whether from plugins or the core, will be accessible through the api object.\n\nCalling API Endpoints on the Server\n\nTo call an API endpoint on the server, import your auth instance and call the endpoint using the api object.\n\nserver.ts\nimport { betterAuth } from \"better-auth\";\nimport { headers } from \"next/headers\";\nexport const auth = betterAuth({\n    //...\n})\n// calling get session on the server\nawait auth.api.getSession({\n    headers: await headers() // some endpoints might require headers\n})\nBody, Headers, Query\n\nUnlike the client, the server needs the values to be passed as an object with the key body for the body, headers for the headers, and query for query parameters.\n\nserver.ts\nawait auth.api.getSession({\n    headers: await headers()\n})\nawait auth.api.signInEmail({\n    body: {\n        email: \"john@doe.com\",\n        password: \"password\"\n    },\n    headers: await headers() // optional but would be useful to get the user IP, user agent, etc.\n})\nawait auth.api.verifyEmail({\n    query: {\n        token: \"my_token\"\n    }\n})\n\nBetter Auth API endpoints are built on top of better-call, a tiny web framework that lets you call REST API endpoints as if they were regular functions and allows us to easily infer client types from the server.\n\nGetting headers and Response Object\n\nWhen you invoke an API endpoint on the server, it will return a standard JavaScript object or array directly as it's just a regular function call.\n\nBut there are times when you might want to get the headers or the Response object instead. For example, if you need to get the cookies or the headers.\n\nGetting headers\n\nTo get the headers, you can pass the returnHeaders option to the endpoint.\n\nconst { headers, response } = await auth.api.signUpEmail({\n\treturnHeaders: true,\n\tbody: {\n\t\temail: \"john@doe.com\",\n\t\tpassword: \"password\",\n\t\tname: \"John Doe\",\n\t},\n});\n\nThe headers will be a Headers object, which you can use to get the cookies or the headers.\n\nconst cookies = headers.get(\"set-cookie\");\nconst headers = headers.get(\"x-custom-header\");\nGetting Response Object\n\nTo get the Response object, you can pass the asResponse option to the endpoint.\n\nserver.ts\nconst response = await auth.api.signInEmail({\n    body: {\n        email: \"\",\n        password: \"\"\n    },\n    asResponse: true\n})\nError Handling\n\nWhen you call an API endpoint on the server, it will throw an error if the request fails. You can catch the error and handle it as you see fit. The error instance is an instance of APIError.\n\nserver.ts\nimport { APIError } from \"better-auth/api\";\ntry {\n    await auth.api.signInEmail({\n        body: {\n            email: \"\",\n            password: \"\"\n        }\n    })\n} catch (error) {\n    if (error instanceof APIError) {\n        console.log(error.message, error.status)\n    }\n}\nEdit on GitHub\n\nPrevious Page\n\nBasic Usage\n\nNext Page\n\nCLI"
  },
  {
    "title": "SQLite | Better Auth",
    "url": "https://www.better-auth.com/docs/adapters/sqlite",
    "html": "SQLite\nCopy Markdown\nOpen in\n\nSQLite is a lightweight, serverless, self-contained SQL database engine that is widely used for local data storage in applications. Read more here.\n\nExample Usage\n\nBetter Auth supports multiple SQLite drivers. Choose the one that best fits your environment:\n\nBetter-SQLite3 (Recommended)\n\nThe most popular and stable SQLite driver for Node.js:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport Database from \"better-sqlite3\";\nexport const auth = betterAuth({\n  database: new Database(\"database.sqlite\"),\n});\n\nFor more information, read Kysely's documentation to the SqliteDialect.\n\nNode.js Built-in SQLite (Experimental)\n\nThe node:sqlite module is still experimental and may change at any time. It requires Node.js 22.5.0 or later.\n\nStarting from Node.js 22.5.0, you can use the built-in SQLite module:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { DatabaseSync } from \"node:sqlite\";\nexport const auth = betterAuth({\n  database: new DatabaseSync(\"database.sqlite\"),\n});\n\nTo run your application with Node.js SQLite:\n\nnode your-app.js\nBun Built-in SQLite\n\nYou can also use the built-in SQLite module in Bun, which is similar to the Node.js version:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { Database } from \"bun:sqlite\";\nexport const auth = betterAuth({\n  database: new Database(\"database.sqlite\"),\n});\nSchema generation & migration\n\nThe Better Auth CLI allows you to generate or migrate your database schema based on your Better Auth configuration and plugins.\n\nSQLite Schema Generation\n\n\t\n\nSQLite Schema Migration\n\n\nâœ… Supported\tâœ… Supported\nSchema Generation\nnpx @better-auth/cli@latest generate\nSchema Migration\nnpx @better-auth/cli@latest migrate\nAdditional Information\n\nSQLite is supported under the hood via the Kysely adapter, any database supported by Kysely would also be supported. (Read more here)\n\nIf you're looking for performance improvements or tips, take a look at our guide to performance optimizations.\n\nEdit on GitHub\n\nPrevious Page\n\nMySQL\n\nNext Page\n\nPostgreSQL"
  },
  {
    "title": "MySQL | Better Auth",
    "url": "https://www.better-auth.com/docs/adapters/mysql",
    "html": "MySQL\nCopy Markdown\nOpen in\n\nMySQL is a popular open-source relational database management system (RDBMS) that is widely used for building web applications and other types of software. It provides a flexible and scalable database solution that allows for efficient storage and retrieval of data. Read more here: MySQL.\n\nExample Usage\n\nMake sure you have MySQL installed and configured. Then, you can connect it straight into Better Auth.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { createPool } from \"mysql2/promise\";\nexport const auth = betterAuth({\n  database: createPool({\n    host: \"localhost\",\n    user: \"root\",\n    password: \"password\",\n    database: \"database\",\n    timezone: \"Z\", // Important to ensure consistent timezone values\n  }),\n});\n\nFor more information, read Kysely's documentation to the MySQLDialect.\n\nSchema generation & migration\n\nThe Better Auth CLI allows you to generate or migrate your database schema based on your Better Auth configuration and plugins.\n\nMySQL Schema Generation\n\n\t\n\nMySQL Schema Migration\n\n\nâœ… Supported\tâœ… Supported\nSchema Generation\nnpx @better-auth/cli@latest generate\nSchema Migration\nnpx @better-auth/cli@latest migrate\nAdditional Information\n\nMySQL is supported under the hood via the Kysely adapter, any database supported by Kysely would also be supported. (Read more here)\n\nIf you're looking for performance improvements or tips, take a look at our guide to performance optimizations.\n\nEdit on GitHub\n\nPrevious Page\n\nOther Social Providers\n\nNext Page\n\nSQLite"
  },
  {
    "title": "MS SQL | Better Auth",
    "url": "https://www.better-auth.com/docs/adapters/mssql",
    "html": "MS SQL\nCopy Markdown\nOpen in\n\nMicrosoft SQL Server is a relational database management system developed by Microsoft, designed for enterprise-level data storage, management, and analytics with robust security and scalability features. Read more here.\n\nExample Usage\n\nMake sure you have MS SQL installed and configured. Then, you can connect it straight into Better Auth.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { MssqlDialect } from \"kysely\";\nimport * as Tedious from 'tedious'\nimport * as Tarn from 'tarn'\nconst dialect = new MssqlDialect({\n  tarn: {\n    ...Tarn,\n    options: {\n      min: 0,\n      max: 10,\n    },\n  },\n  tedious: {\n    ...Tedious,\n    connectionFactory: () => new Tedious.Connection({\n      authentication: {\n        options: {\n          password: 'password',\n          userName: 'username',\n        },\n        type: 'default',\n      },\n      options: {\n        database: 'some_db',\n        port: 1433,\n        trustServerCertificate: true,\n      },\n      server: 'localhost',\n    }),\n  },\n  TYPES: {\n\t\t...Tedious.TYPES,\n\t\tDateTime: Tedious.TYPES.DateTime2,\n\t},\n})\nexport const auth = betterAuth({\n  database: {\n    dialect,\n    type: \"mssql\"\n  }\n});\n\nFor more information, read Kysely's documentation to the MssqlDialect.\n\nSchema generation & migration\n\nThe Better Auth CLI allows you to generate or migrate your database schema based on your Better Auth configuration and plugins.\n\nMS SQL Schema Generation\n\n\t\n\nMS SQL Schema Migration\n\n\nâœ… Supported\tâœ… Supported\nSchema Generation\nnpx @better-auth/cli@latest generate\nSchema Migration\nnpx @better-auth/cli@latest migrate\nAdditional Information\n\nMS SQL is supported under the hood via the Kysely adapter, any database supported by Kysely would also be supported. (Read more here)\n\nIf you're looking for performance improvements or tips, take a look at our guide to performance optimizations.\n\nEdit on GitHub\n\nPrevious Page\n\nPostgreSQL\n\nNext Page\n\nOther Relational Databases"
  },
  {
    "title": "PostgreSQL | Better Auth",
    "url": "https://www.better-auth.com/docs/adapters/postgresql",
    "html": "PostgreSQL\nCopy Markdown\nOpen in\n\nPostgreSQL is a powerful, open-source relational database management system known for its advanced features, extensibility, and support for complex queries and large datasets. Read more here.\n\nExample Usage\n\nMake sure you have PostgreSQL installed and configured. Then, you can connect it straight into Better Auth.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { Pool } from \"pg\";\nexport const auth = betterAuth({\n  database: new Pool({\n    connectionString: \"postgres://user:password@localhost:5432/database\",\n  }),\n});\n\nFor more information, read Kysely's documentation to the PostgresDialect.\n\nSchema generation & migration\n\nThe Better Auth CLI allows you to generate or migrate your database schema based on your Better Auth configuration and plugins.\n\nPostgreSQL Schema Generation\n\n\t\n\nPostgreSQL Schema Migration\n\n\nâœ… Supported\tâœ… Supported\nSchema Generation\nnpx @better-auth/cli@latest generate\nSchema Migration\nnpx @better-auth/cli@latest migrate\nUse a non-default schema\n\nIn most cases, the default schema is public. To have Better Auth use a non-default schema (e.g., auth) for its tables, you have several options:\n\nOption 1: Set search_path in connection string (Recommended)\n\nAppend the options parameter to your connection URI:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { Pool } from \"pg\";\nexport const auth = betterAuth({\n  database: new Pool({\n    connectionString: \"postgres://user:password@localhost:5432/database?options=-c search_path=auth\",\n  }),\n});\n\nURL-encode if needed: ?options=-c%20search_path%3Dauth.\n\nOption 2: Set search_path using Pool options\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { Pool } from \"pg\";\nexport const auth = betterAuth({\n  database: new Pool({\n    host: \"localhost\",\n    port: 5432,\n    user: \"postgres\",\n    password: \"password\",\n    database: \"mydb\",\n    options: \"-c search_path=auth\",\n  }),\n});\nOption 3: Set default schema for database user\n\nSet the PostgreSQL user's default schema:\n\nALTER USER your_user SET search_path TO auth;\n\nAfter setting this, reconnect to apply the changes.\n\nPrerequisites\n\nBefore using a non-default schema, ensure:\n\nThe schema exists:\n\nCREATE SCHEMA IF NOT EXISTS auth;\n\nThe user has appropriate permissions:\n\nGRANT ALL PRIVILEGES ON SCHEMA auth TO your_user;\nGRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA auth TO your_user;\nALTER DEFAULT PRIVILEGES IN SCHEMA auth GRANT ALL ON TABLES TO your_user;\nHow it works\n\nThe Better Auth CLI migration system automatically detects your configured search_path:\n\nWhen running npx @better-auth/cli migrate, it inspects only the tables in your configured schema\nTables in other schemas (e.g., public) are ignored, preventing conflicts\nAll new tables are created in your specified schema\nTroubleshooting\n\nIssue: \"relation does not exist\" error during migration\n\nSolution: This usually means the schema doesn't exist or the user lacks permissions. Create the schema and grant permissions as shown above.\n\nVerifying your schema configuration:\n\nYou can verify which schema Better Auth will use by checking the search_path:\n\nSHOW search_path;\n\nThis should return your custom schema (e.g., auth) as the first value.\n\nAdditional Information\n\nPostgreSQL is supported under the hood via the Kysely adapter, any database supported by Kysely would also be supported. (Read more here)\n\nIf you're looking for performance improvements or tips, take a look at our guide to performance optimizations.\n\nEdit on GitHub\n\nPrevious Page\n\nSQLite\n\nNext Page\n\nMS SQL"
  },
  {
    "title": "Drizzle ORM Adapter | Better Auth",
    "url": "https://www.better-auth.com/docs/adapters/drizzle",
    "html": "Drizzle ORM Adapter\nCopy Markdown\nOpen in\n\nDrizzle ORM is a powerful and flexible ORM for Node.js and TypeScript. It provides a simple and intuitive API for working with databases, and supports a wide range of databases including MySQL, PostgreSQL, SQLite, and more. Read more here: Drizzle ORM.\n\nExample Usage\n\nMake sure you have Drizzle installed and configured. Then, you can use the Drizzle adapter to connect to your database.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { drizzleAdapter } from \"better-auth/adapters/drizzle\";\nimport { db } from \"./database.ts\";\nexport const auth = betterAuth({\n  database: drizzleAdapter(db, {\n    provider: \"sqlite\", // or \"pg\" or \"mysql\"\n  }), \n  //... the rest of your config\n});\nSchema generation & migration\n\nThe Better Auth CLI allows you to generate or migrate your database schema based on your Better Auth configuration and plugins.\n\nTo generate the schema required by Better Auth, run the following command:\n\nSchema Generation\nnpx @better-auth/cli@latest generate\n\nTo generate and apply the migration, run the following commands:\n\nSchema Migration\nnpx drizzle-kit generate # generate the migration file\nnpx drizzle-kit migrate # apply the migration\nAdditional Information\n\nThe Drizzle adapter expects the schema you define to match the table names. For example, if your Drizzle schema maps the user table to users, you need to manually pass the schema and map it to the user table.\n\nimport { betterAuth } from \"better-auth\";\nimport { db } from \"./drizzle\";\nimport { drizzleAdapter } from \"better-auth/adapters/drizzle\";\nimport { schema } from \"./schema\";\nexport const auth = betterAuth({\n  database: drizzleAdapter(db, {\n    provider: \"sqlite\", // or \"pg\" or \"mysql\"\n    schema: {\n      ...schema,\n      user: schema.users,\n    },\n  }),\n});\n\nIf all your tables are using plural form, you can just pass the usePlural option:\n\nexport const auth = betterAuth({\n  database: drizzleAdapter(db, {\n    ...\n    usePlural: true,\n  }),\n});\n\nIf you're looking for performance improvements or tips, take a look at our guide to performance optimizations.\n\nEdit on GitHub\n\nPrevious Page\n\nAdapters\n\nNext Page\n\nPrisma"
  },
  {
    "title": "Prisma | Better Auth",
    "url": "https://www.better-auth.com/docs/adapters/prisma",
    "html": "Prisma\nCopy Markdown\nOpen in\n\nPrisma ORM is an open-source database toolkit that simplifies database access and management in applications by providing a type-safe query builder and an intuitive data modeling interface. Read more here.\n\nExample Usage\n\nMake sure you have Prisma installed and configured. Then, you can use the Prisma adapter to connect to your database.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { prismaAdapter } from \"better-auth/adapters/prisma\";\nimport { PrismaClient } from \"@prisma/client\";\nconst prisma = new PrismaClient();\nexport const auth = betterAuth({\n  database: prismaAdapter(prisma, {\n    provider: \"sqlite\",\n  }),\n});\n\nIf you have configured a custom output directory in your schema.prisma file (e.g., output = \"../src/generated/prisma\"), make sure to import the Prisma client from that location instead of @prisma/client. Learn more about custom output directories in the Prisma documentation.\n\nSchema generation & migration\n\nThe Better Auth CLI allows you to generate or migrate your database schema based on your Better Auth configuration and plugins.\n\nPrisma Schema Generation\n\n\t\n\nPrisma Schema Migration\n\n\nâœ… Supported\tâŒ Not Supported\nSchema Generation\nnpx @better-auth/cli@latest generate\nAdditional Information\n\nIf you're looking for performance improvements or tips, take a look at our guide to performance optimizations.\n\nEdit on GitHub\n\nPrevious Page\n\nDrizzle\n\nNext Page\n\nMongoDB"
  },
  {
    "title": "MongoDB Adapter | Better Auth",
    "url": "https://www.better-auth.com/docs/adapters/mongo",
    "html": "MongoDB Adapter\nCopy Markdown\nOpen in\n\nMongoDB is a popular NoSQL database that is widely used for building scalable and flexible applications. It provides a flexible schema that allows for easy data modeling and querying. Read more here: MongoDB.\n\nExample Usage\n\nMake sure you have MongoDB installed and configured. Then, you can use the mongodb adapter.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { MongoClient } from \"mongodb\";\nimport { mongodbAdapter } from \"better-auth/adapters/mongodb\";\nconst client = new MongoClient(\"mongodb://localhost:27017/database\");\nconst db = client.db();\nexport const auth = betterAuth({\n  database: mongodbAdapter(db, {\n    // Optional: if you don't provide a client, database transactions won't be enabled.\n    client\n  }),\n});\nSchema generation & migration\n\nFor MongoDB, we don't need to generate or migrate the schema.\n\nEdit on GitHub\n\nPrevious Page\n\nPrisma\n\nNext Page\n\nOthers"
  },
  {
    "title": "Community Adapters | Better Auth",
    "url": "https://www.better-auth.com/docs/adapters/community-adapters",
    "html": "Community Adapters\nCopy Markdown\nOpen in\n\nThis page showcases a list of recommended community made database adapters. We encourage you to create any missing database adapters and maybe get added to the list!\n\nAdapter\tDatabase Dialect\tAuthor\nconvex-better-auth\tConvex Database\t erquhart\nsurreal-better-auth\tSurrealDB\t Oskar Gmerek\nsurrealdb-better-auth\tSurreal Database\t Necmttn\nbetter-auth-surrealdb\tSurreal Database\t msanchezdev\npayload-better-auth\tPayload CMS\t forrestdevs\n@ronin/better-auth\tRONIN\t ronin-co\nbetter-auth-instantdb\tInstantDB\t daveycodez\n@nerdfolio/remult-better-auth\tRemult\t Tai Vo\nEdit on GitHub\n\nPrevious Page\n\nOthers\n\nNext Page\n\nFull Stack"
  },
  {
    "title": "Client | Better Auth",
    "url": "https://www.better-auth.com/docs/concepts/client",
    "html": "Client\nCopy Markdown\nOpen in\n\nBetter Auth offers a client library compatible with popular frontend frameworks like React, Vue, Svelte, and more. This client library includes a set of functions for interacting with the Better Auth server. Each framework's client library is built on top of a core client library that is framework-agnostic, so that all methods and hooks are consistently available across all client libraries.\n\nInstallation\n\nIf you haven't already, install better-auth.\n\nnpm\npnpm\nyarn\nbun\nnpm i better-auth\nCreate Client Instance\n\nImport createAuthClient from the package for your framework (e.g., \"better-auth/react\" for React). Call the function to create your client. Pass the base URL of your auth server. If the auth server is running on the same domain as your client, you can skip this step.\n\nIf you're using a different base path other than /api/auth, make sure to pass the whole URL, including the path. (e.g., http://localhost:3000/custom-path/auth)\n\nreact\nvue\nsvelte\nsolid\nvanilla\nlib/auth-client.ts\nimport { createAuthClient } from \"better-auth/react\"\nexport const authClient = createAuthClient({\n    baseURL: \"http://localhost:3000\" // The base URL of your auth server\n})\nUsage\n\nOnce you've created your client instance, you can use the client to interact with the Better Auth server. The client provides a set of functions by default and they can be extended with plugins.\n\nExample: Sign In\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient = createAuthClient()\nawait authClient.signIn.email({\n    email: \"test@user.com\",\n    password: \"password1234\"\n})\nHooks\n\nIn addition to the standard methods, the client provides hooks to easily access different reactive data. Every hook is available in the root object of the client and they all start with use.\n\nExample: useSession\n\nReact\nVue\nSvelte\nSolid\nuser.tsx\n//make sure you're using the react client\nimport { createAuthClient } from \"better-auth/react\"\nconst { useSession } = createAuthClient() \nexport function User() {\n    const {\n        data: session,\n        isPending, //loading state\n        error, //error object \n        refetch //refetch the session\n    } = useSession()\n    return (\n        //...\n    )\n}\nFetch Options\n\nThe client uses a library called better fetch to make requests to the server.\n\nBetter fetch is a wrapper around the native fetch API that provides a more convenient way to make requests. It's created by the same team behind Better Auth and is designed to work seamlessly with it.\n\nYou can pass any default fetch options to the client by passing fetchOptions object to the createAuthClient.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient = createAuthClient({\n    fetchOptions: {\n        //any better-fetch options\n    },\n})\n\nYou can also pass fetch options to most of the client functions. Either as the second argument or as a property in the object.\n\nauth-client.ts\nawait authClient.signIn.email({\n    email: \"email@email.com\",\n    password: \"password1234\",\n}, {\n    onSuccess(ctx) {\n            //      \n    }\n})\n//or\nawait authClient.signIn.email({\n    email: \"email@email.com\",\n    password: \"password1234\",\n    fetchOptions: {\n        onSuccess(ctx) {\n            //      \n        }\n    },\n})\nHandling Errors\n\nMost of the client functions return a response object with the following properties:\n\ndata: The response data.\nerror: The error object if there was an error.\n\nThe error object contains the following properties:\n\nmessage: The error message. (e.g., \"Invalid email or password\")\nstatus: The HTTP status code.\nstatusText: The HTTP status text.\nauth-client.ts\nconst { data, error } = await authClient.signIn.email({\n    email: \"email@email.com\",\n    password: \"password1234\"\n})\nif (error) {\n    //handle error\n}\n\nIf the action accepts a fetchOptions option, you can pass an onError callback to handle errors.\n\nauth-client.ts\nawait authClient.signIn.email({\n    email: \"email@email.com\",\n    password: \"password1234\",\n}, {\n    onError(ctx) {\n        //handle error\n    }\n})\n//or\nawait authClient.signIn.email({\n    email: \"email@email.com\",\n    password: \"password1234\",\n    fetchOptions: {\n        onError(ctx) {\n            //handle error\n        }\n    }\n})\n\nHooks like useSession also return an error object if there was an error fetching the session. On top of that, they also return an isPending property to indicate if the request is still pending.\n\nauth-client.ts\nconst { data, error, isPending } = useSession()\nif (error) {\n    //handle error\n}\nError Codes\n\nThe client instance contains $ERROR_CODES object that contains all the error codes returned by the server. You can use this to handle error translations or custom error messages.\n\nauth-client.ts\nconst authClient = createAuthClient();\ntype ErrorTypes = Partial<\n\tRecord<\n\t\tkeyof typeof authClient.$ERROR_CODES,\n\t\t{\n\t\t\ten: string;\n\t\t\tes: string;\n\t\t}\n\t>\n>;\nconst errorCodes = {\n\tUSER_ALREADY_EXISTS: {\n\t\ten: \"user already registered\",\n\t\tes: \"usuario ya registrada\",\n\t},\n} satisfies ErrorTypes;\nconst getErrorMessage = (code: string, lang: \"en\" | \"es\") => {\n\tif (code in errorCodes) {\n\t\treturn errorCodes[code as keyof typeof errorCodes][lang];\n\t}\n\treturn \"\";\n};\nconst { error } = await authClient.signUp.email({\n\temail: \"user@email.com\",\n\tpassword: \"password\",\n\tname: \"User\",\n});\nif(error?.code){\n    alert(getErrorMessage(error.code, \"en\"));\n}\nPlugins\n\nYou can extend the client with plugins to add more functionality. Plugins can add new functions to the client or modify existing ones.\n\nExample: Magic Link Plugin\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { magicLinkClient } from \"better-auth/client/plugins\"\nconst authClient = createAuthClient({\n    plugins: [\n        magicLinkClient()\n    ]\n})\n\nonce you've added the plugin, you can use the new functions provided by the plugin.\n\nauth-client.ts\nawait authClient.signIn.magicLink({\n    email: \"test@email.com\"\n})\nEdit on GitHub\n\nPrevious Page\n\nCLI\n\nNext Page\n\nCookies"
  },
  {
    "title": "Cookies | Better Auth",
    "url": "https://www.better-auth.com/docs/concepts/cookies",
    "html": "Cookies\nCopy Markdown\nOpen in\n\nCookies are used to store data such as session tokens, OAuth state, and more. All cookies are signed using the secret key provided in the auth options.\n\nCookie Prefix\n\nBy default, Better Auth cookies follow the format ${prefix}.${cookie_name}. The default prefix is \"better-auth\". You can change the prefix by setting cookiePrefix in the advanced object of the auth options.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    advanced: {\n        cookiePrefix: \"my-app\"\n    }\n})\nCustom Cookies\n\nAll cookies are httpOnly and secure when the server is running in production mode.\n\nIf you want to set custom cookie names and attributes, you can do so by setting cookieOptions in the advanced object of the auth options.\n\nBy default, Better Auth uses the following cookies:\n\nsession_token to store the session token\nsession_data to store the session data if cookie cache is enabled\ndont_remember to store the flag when rememberMe is disabled\n\nPlugins may also use cookies to store data. For example, the Two Factor Authentication plugin uses the two_factor cookie to store the two-factor authentication state.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    advanced: {\n        cookies: {\n            session_token: {\n                name: \"custom_session_token\",\n                attributes: {\n                    // Set custom cookie attributes\n                }\n            },\n        }\n    }\n})\nCross Subdomain Cookies\n\nSometimes you may need to share cookies across subdomains. For example, if you authenticate on auth.example.com, you may also want to access the same session on app.example.com.\n\nThe domain attribute controls which domains can access the cookie. Setting it to your root domain (e.g. example.com) makes the cookie accessible across all subdomains. For security, follow these guidelines:\n\nOnly enable cross-subdomain cookies if it's necessary\nSet the domain to the most specific scope needed (e.g. app.example.com instead of .example.com)\nBe cautious of untrusted subdomains that could potentially access these cookies\nConsider using separate domains for untrusted services (e.g. status.company.com vs app.company.com)\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    advanced: {\n        crossSubDomainCookies: {\n            enabled: true,\n            domain: \"app.example.com\", // your domain\n        },\n    },\n    trustedOrigins: [\n        'https://example.com',\n        'https://app1.example.com',\n        'https://app2.example.com',\n    ],\n})\nSecure Cookies\n\nBy default, cookies are secure only when the server is running in production mode. You can force cookies to be always secure by setting useSecureCookies to true in the advanced object in the auth options.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    advanced: {\n        useSecureCookies: true\n    }\n})\nEdit on GitHub\n\nPrevious Page\n\nClient\n\nNext Page\n\nDatabase"
  },
  {
    "title": "Email | Better Auth",
    "url": "https://www.better-auth.com/docs/concepts/email",
    "html": "Email\nCopy Markdown\nOpen in\n\nEmail is a key part of Better Auth, required for all users regardless of their authentication method. Better Auth provides email and password authentication out of the box, and a lot of utilities to help you manage email verification, password reset, and more.\n\nEmail Verification\n\nEmail verification is a security feature that ensures users provide a valid email address. It helps prevent spam and abuse by confirming that the email address belongs to the user. In this guide, you'll get a walk through of how to implement token based email verification in your app. To use otp based email verification, check out the OTP Verification guide.\n\nAdding Email Verification to Your App\n\nTo enable email verification, you need to pass a function that sends a verification email with a link.\n\nsendVerificationEmail: This function is triggered when email verification starts. It accepts a data object with the following properties:\nuser: The user object containing the email address.\nurl: The verification URL the user must click to verify their email.\ntoken: The verification token used to complete the email verification to be used when implementing a custom verification URL.\n\nand a request object as the second parameter.\n\nauth.ts\nimport { betterAuth } from 'better-auth';\nimport { sendEmail } from './email'; // your email sending function\nexport const auth = betterAuth({\n    emailVerification: {\n        sendVerificationEmail: async ({ user, url, token }, request) => {\n            await sendEmail({\n                to: user.email,\n                subject: 'Verify your email address',\n                text: `Click the link to verify your email: ${url}`\n            })\n        }\n    }\n})\nTriggering Email Verification\n\nYou can initiate email verification in several ways:\n\n1. During Sign-up\n\nTo automatically send a verification email at signup, set emailVerification.sendOnSignUp to true.\n\nauth.ts\nimport { betterAuth } from 'better-auth';\nexport const auth = betterAuth({\n    emailVerification: {\n        sendOnSignUp: true\n    }\n})\n\nThis sends a verification email when a user signs up. For social logins, email verification status is read from the SSO.\n\nWith sendOnSignUp enabled, when the user logs in with an SSO that does not claim the email as verified, Better Auth will dispatch a verification email, but the verification is not required to login even when requireEmailVerification is enabled.\n\n2. Require Email Verification\n\nIf you enable require email verification, users must verify their email before they can log in. And every time a user tries to sign in, sendVerificationEmail is called.\n\nThis only works if you have sendVerificationEmail implemented, if sendOnSignIn is set to true and if the user is trying to sign in with email and password.\n\nauth.ts\nexport const auth = betterAuth({\n  emailVerification: {\n    sendVerificationEmail: async ({ user, url }) => {\n      await sendEmail({\n        to: user.email,\n        subject: \"Verify your email address\",\n        text: `Click the link to verify your email: ${url}`,\n      });\n    sendOnSignIn: true,\n    },\n  },\n  emailAndPassword: {\n    requireEmailVerification: true,\n  },\n});\n\nIf a user tries to sign in without verifying their email, you can handle the error and show a message to the user.\n\nauth-client.ts\nawait authClient.signIn.email({\n    email: \"email@example.com\",\n    password: \"password\"\n}, {\n    onError: (ctx) => {\n        // Handle the error\n        if(ctx.error.status === 403) {\n            alert(\"Please verify your email address\")\n        }\n        //you can also show the original error message\n        alert(ctx.error.message)\n    }\n})\n3. Manually\n\nYou can also manually trigger email verification by calling sendVerificationEmail.\n\nawait authClient.sendVerificationEmail({\n    email: \"user@email.com\",\n    callbackURL: \"/\" // The redirect URL after verification\n})\nVerifying the Email\n\nIf the user clicks the provided verification URL, their email is automatically verified, and they are redirected to the callbackURL.\n\nFor manual verification, you can send the user a custom link with the token and call the verifyEmail function.\n\nawait authClient.verifyEmail({\n    query: {\n        token: \"\" // Pass the token here\n    }\n})\nAuto Sign In After Verification\n\nTo sign in the user automatically after they successfully verify their email, set the autoSignInAfterVerification option to true:\n\nconst auth = betterAuth({\n    //...your other options\n    emailVerification: {\n        autoSignInAfterVerification: true\n    }\n})\nCallback after successful email verification\n\nYou can run custom code immediately after a user verifies their email using the afterEmailVerification callback. This is useful for any side-effects you want to trigger, like granting access to special features or logging the event.\n\nThe afterEmailVerification function runs automatically when a user's email is confirmed, receiving the user object and request details so you can perform actions for that specific user.\n\nHere's how you can set it up:\n\nauth.ts\nimport { betterAuth } from 'better-auth';\nexport const auth = betterAuth({\n    emailVerification: {\n        async afterEmailVerification(user, request) {\n            // Your custom logic here, e.g., grant access to premium features\n            console.log(`${user.email} has been successfully verified!`);\n        }\n    }\n})\nPassword Reset Email\n\nPassword reset allows users to reset their password if they forget it. Better Auth provides a simple way to implement password reset functionality.\n\nYou can enable password reset by passing a function that sends a password reset email with a link.\n\nauth.ts\nimport { betterAuth } from 'better-auth';\nimport { sendEmail } from './email'; // your email sending function\nexport const auth = betterAuth({\n    emailAndPassword: {\n        enabled: true,\n        sendResetPassword: async ({ user, url, token }, request) => {\n            await sendEmail({\n                to: user.email,\n                subject: 'Reset your password',\n                text: `Click the link to reset your password: ${url}`\n            })\n        }\n    }\n})\n\nCheck out the Email and Password guide for more details on how to implement password reset in your app. Also you can check out the Otp verification guide for how to implement password reset with OTP in your app.\n\nEdit on GitHub\n\nPrevious Page\n\nDatabase\n\nNext Page\n\nHooks"
  },
  {
    "title": "Hooks | Better Auth",
    "url": "https://www.better-auth.com/docs/concepts/hooks",
    "html": "Hooks\nCopy Markdown\nOpen in\n\nHooks in Better Auth let you \"hook into\" the lifecycle and execute custom logic. They provide a way to customize Better Auth's behavior without writing a full plugin.\n\nWe highly recommend using hooks if you need to make custom adjustments to an endpoint rather than making another endpoint outside of Better Auth.\n\nBefore Hooks\n\nBefore hooks run before an endpoint is executed. Use them to modify requests, pre validate data, or return early.\n\nExample: Enforce Email Domain Restriction\n\nThis hook ensures that users can only sign up if their email ends with @example.com:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { createAuthMiddleware, APIError } from \"better-auth/api\";\nexport const auth = betterAuth({\n    hooks: {\n        before: createAuthMiddleware(async (ctx) => {\n            if (ctx.path !== \"/sign-up/email\") {\n                return;\n            }\n            if (!ctx.body?.email.endsWith(\"@example.com\")) {\n                throw new APIError(\"BAD_REQUEST\", {\n                    message: \"Email must end with @example.com\",\n                });\n            }\n        }),\n    },\n});\nExample: Modify Request Context\n\nTo adjust the request context before proceeding:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { createAuthMiddleware } from \"better-auth/api\";\nexport const auth = betterAuth({\n    hooks: {\n        before: createAuthMiddleware(async (ctx) => {\n            if (ctx.path === \"/sign-up/email\") {\n                return {\n                    context: {\n                        ...ctx,\n                        body: {\n                            ...ctx.body,\n                            name: \"John Doe\",\n                        },\n                    }\n                };\n            }\n        }),\n    },\n});\nAfter Hooks\n\nAfter hooks run after an endpoint is executed. Use them to modify responses.\n\nExample: Send a notification to your channel when a new user is registered\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { createAuthMiddleware } from \"better-auth/api\";\nimport { sendMessage } from \"@/lib/notification\"\nexport const auth = betterAuth({\n    hooks: {\n        after: createAuthMiddleware(async (ctx) => {\n            if(ctx.path.startsWith(\"/sign-up\")){\n                const newSession = ctx.context.newSession;\n                if(newSession){\n                    sendMessage({\n                        type: \"user-register\",\n                        name: newSession.user.name,\n                    })\n                }\n            }\n        }),\n    },\n});\nCtx\n\nWhen you call createAuthMiddleware a ctx object is passed that provides a lot of useful properties. Including:\n\nPath: ctx.path to get the current endpoint path.\nBody: ctx.body for parsed request body (available for POST requests).\nHeaders: ctx.headers to access request headers.\nRequest: ctx.request to access the request object (may not exist in server-only endpoints).\nQuery Parameters: ctx.query to access query parameters.\nContext: ctx.context auth related context, useful for accessing new session, auth cookies configuration, password hashing, config...\n\nand more.\n\nRequest Response\n\nThis utilities allows you to get request information and to send response from a hook.\n\nJSON Responses\n\nUse ctx.json to send JSON responses:\n\nconst hook = createAuthMiddleware(async (ctx) => {\n    return ctx.json({\n        message: \"Hello World\",\n    });\n});\nRedirects\n\nUse ctx.redirect to redirect users:\n\nimport { createAuthMiddleware } from \"better-auth/api\";\nconst hook = createAuthMiddleware(async (ctx) => {\n    throw ctx.redirect(\"/sign-up/name\");\n});\nCookies\nSet cookies: ctx.setCookies or ctx.setSignedCookie.\nGet cookies: ctx.getCookies or ctx.getSignedCookie.\n\nExample:\n\nimport { createAuthMiddleware } from \"better-auth/api\";\nconst hook = createAuthMiddleware(async (ctx) => {\n    ctx.setCookies(\"my-cookie\", \"value\");\n    await ctx.setSignedCookie(\"my-signed-cookie\", \"value\", ctx.context.secret, {\n        maxAge: 1000,\n    });\n    const cookie = ctx.getCookies(\"my-cookie\");\n    const signedCookie = await ctx.getSignedCookie(\"my-signed-cookie\");\n});\nErrors\n\nThrow errors with APIError for a specific status code and message:\n\nimport { createAuthMiddleware, APIError } from \"better-auth/api\";\nconst hook = createAuthMiddleware(async (ctx) => {\n    throw new APIError(\"BAD_REQUEST\", {\n        message: \"Invalid request\",\n    });\n});\nContext\n\nThe ctx object contains another context object inside that's meant to hold contexts related to auth. Including a newly created session on after hook, cookies configuration, password hasher and so on.\n\nNew Session\n\nThe newly created session after an endpoint is run. This only exist in after hook.\n\nauth.ts\ncreateAuthMiddleware(async (ctx) => {\n    const newSession = ctx.context.newSession\n});\nReturned\n\nThe returned value from the hook is passed to the next hook in the chain.\n\nauth.ts\ncreateAuthMiddleware(async (ctx) => {\n    const returned = ctx.context.returned; //this could be a successful response or an APIError\n});\nResponse Headers\n\nThe response headers added by endpoints and hooks that run before this hook.\n\nauth.ts\ncreateAuthMiddleware(async (ctx) => {\n    const responseHeaders = ctx.context.responseHeaders;\n});\nPredefined Auth Cookies\n\nAccess BetterAuthâ€™s predefined cookie properties:\n\nauth.ts\ncreateAuthMiddleware(async (ctx) => {\n    const cookieName = ctx.context.authCookies.sessionToken.name;\n});\nSecret\n\nYou can access the secret for your auth instance on ctx.context.secret\n\nPassword\n\nThe password object provider hash and verify\n\nctx.context.password.hash: let's you hash a given password.\nctx.context.password.verify: let's you verify given password and a hash.\nAdapter\n\nAdapter exposes the adapter methods used by Better Auth. Including findOne, findMany, create, delete, update and updateMany. You generally should use your actually db instance from your orm rather than this adapter.\n\nInternal Adapter\n\nThese are calls to your db that perform specific actions. createUser, createSession, updateSession...\n\nThis may be useful to use instead of using your db directly to get access to databaseHooks, proper secondaryStorage support and so on. If you're make a query similar to what exist in this internal adapter actions it's worth a look.\n\ngenerateId\n\nYou can use ctx.context.generateId to generate Id for various reasons.\n\nReusable Hooks\n\nIf you need to reuse a hook across multiple endpoints, consider creating a plugin. Learn more in the Plugins Documentation.\n\nEdit on GitHub\n\nPrevious Page\n\nEmail\n\nNext Page\n\nPlugins"
  },
  {
    "title": "Plugins | Better Auth",
    "url": "https://www.better-auth.com/docs/concepts/plugins",
    "html": "Plugins\nCopy Markdown\nOpen in\n\nPlugins are a key part of Better Auth, they let you extend the base functionalities. You can use them to add new authentication methods, features, or customize behaviors.\n\nBetter Auth comes with many built-in plugins ready to use. Check the plugins section for details. You can also create your own plugins.\n\nUsing a Plugin\n\nPlugins can be a server-side plugin, a client-side plugin, or both.\n\nTo add a plugin on the server, include it in the plugins array in your auth configuration. The plugin will initialize with the provided options.\n\nserver.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    plugins: [\n        // Add your plugins here\n    ]\n});\n\nClient plugins are added when creating the client. Most plugin require both server and client plugins to work correctly. The Better Auth auth client on the frontend uses the createAuthClient function provided by better-auth/client.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nconst authClient =  createAuthClient({\n    plugins: [\n        // Add your client plugins here\n    ]\n});\n\nWe recommend keeping the auth-client and your normal auth instance in separate files.\n\nauth\nserver.ts\nauth-client.ts\nCreating a Plugin\n\nTo get started, you'll need a server plugin. Server plugins are the backbone of all plugins, and client plugins are there to provide an interface with frontend APIs to easily work with your server plugins.\n\nIf your server plugins has endpoints that needs to be called from the client, you'll also need to create a client plugin.\n\nWhat can a plugin do?\nCreate custom endpoints to perform any action you want.\nExtend database tables with custom schemas.\nUse a middleware to target a group of routes using it's route matcher, and run only when those routes are called through a request.\nUse hooks to target a specific route or request. And if you want to run the hook even if the endpoint is called directly.\nUse onRequest or onResponse if you want to do something that affects all requests or responses.\nCreate custom rate-limit rule.\nCreate a Server plugin\n\nTo create a server plugin you need to pass an object that satisfies the BetterAuthPlugin interface.\n\nThe only required property is id, which is a unique identifier for the plugin. Both server and client plugins can use the same id.\n\nplugin.ts\nimport type { BetterAuthPlugin } from \"better-auth\";\nexport const myPlugin = ()=>{\n    return {\n        id: \"my-plugin\",\n    } satisfies BetterAuthPlugin\n}\n\nYou don't have to make the plugin a function, but it's recommended to do so. This way you can pass options to the plugin and it's consistent with the built-in plugins.\n\nEndpoints\n\nTo add endpoints to the server, you can pass endpoints which requires an object with the key being any string and the value being an AuthEndpoint.\n\nTo create an Auth Endpoint you'll need to import createAuthEndpoint from better-auth.\n\nBetter Auth uses wraps around another library called Better Call to create endpoints. Better call is a simple ts web framework made by the same team behind Better Auth.\n\nplugin.ts\nimport { createAuthEndpoint } from \"better-auth/api\";\nconst myPlugin = ()=> {\n    return {\n        id: \"my-plugin\",\n        endpoints: {\n            getHelloWorld: createAuthEndpoint(\"/my-plugin/hello-world\", {\n                method: \"GET\",\n            }, async(ctx) => {\n                return ctx.json({\n                    message: \"Hello World\"\n                })\n            })\n        }\n    } satisfies BetterAuthPlugin\n}\n\nCreate Auth endpoints wraps around createEndpoint from Better Call. Inside the ctx object, it'll provide another object called context that give you access better-auth specific contexts including options, db, baseURL and more.\n\nContext Object\n\nappName: The name of the application. Defaults to \"Better Auth\".\noptions: The options passed to the Better Auth instance.\ntables: Core tables definition. It is an object which has the table name as the key and the schema definition as the value.\nbaseURL: the baseURL of the auth server. This includes the path. For example, if the server is running on http://localhost:3000, the baseURL will be http://localhost:3000/api/auth by default unless changed by the user.\nsession: The session configuration. Includes updateAge and expiresIn values.\nsecret: The secret key used for various purposes. This is defined by the user.\nauthCookie: The default cookie configuration for core auth cookies.\nlogger: The logger instance used by Better Auth.\ndb: The Kysely instance used by Better Auth to interact with the database.\nadapter: This is the same as db but it give you orm like functions to interact with the database. (we recommend using this over db unless you need raw sql queries or for performance reasons)\ninternalAdapter: These are internal db calls that are used by Better Auth. For example, you can use these calls to create a session instead of using adapter directly. internalAdapter.createSession(userId)\ncreateAuthCookie: This is a helper function that let's you get a cookie name and options for either to set or get cookies. It implements things like __secure prefix and __host prefix for cookies based on\n\nFor other properties, you can check the Better Call documentation and the source code .\n\nRules for Endpoints\n\nMakes sure you use kebab-case for the endpoint path\nMake sure to only use POST or GET methods for the endpoints.\nAny function that modifies a data should be a POST method.\nAny function that fetches data should be a GET method.\nMake sure to use the createAuthEndpoint function to create API endpoints.\nMake sure your paths are unique to avoid conflicts with other plugins. If you're using a common path, add the plugin name as a prefix to the path. (/my-plugin/hello-world instead of /hello-world.)\nSchema\n\nYou can define a database schema for your plugin by passing a schema object. The schema object should have the table name as the key and the schema definition as the value.\n\nplugin.ts\nimport { BetterAuthPlugin } from \"better-auth/plugins\";\nconst myPlugin = ()=> {\n    return {\n        id: \"my-plugin\",\n        schema: {\n            myTable: {\n                fields: {\n                    name: {\n                        type: \"string\"\n                    }\n                },\n                modelName: \"myTable\" // optional if you want to use a different name than the key\n            }\n        }\n    } satisfies BetterAuthPlugin\n}\n\nFields\n\nBy default better-auth will create an id field for each table. You can add additional fields to the table by adding them to the fields object.\n\nThe key is the column name and the value is the column definition. The column definition can have the following properties:\n\ntype: The type of the field. It can be string, number, boolean, date.\n\nrequired: if the field should be required on a new record. (default: false)\n\nunique: if the field should be unique. (default: false)\n\nreference: if the field is a reference to another table. (default: null) It takes an object with the following properties:\n\nmodel: The table name to reference.\nfield: The field name to reference.\nonDelete: The action to take when the referenced record is deleted. (default: null)\n\nOther Schema Properties\n\ndisableMigration: if the table should not be migrated. (default: false)\n\nplugin.ts\nconst myPlugin = (opts: PluginOptions)=>{\n    return {\n        id: \"my-plugin\",\n        schema: {\n            rateLimit: {\n                fields: {\n                    key: {\n                        type: \"string\",\n                    },\n                },\n                disableMigration: opts.storage.provider !== \"database\", \n            },\n        },\n    } satisfies BetterAuthPlugin\n}\n\nif you add additional fields to a user or session table, the types will be inferred automatically on getSession and signUpEmail calls.\n\nplugin.ts\nconst myPlugin = ()=>{\n    return {\n        id: \"my-plugin\",\n        schema: {\n            user: {\n                fields: {\n                    age: {\n                        type: \"number\",\n                    },\n                },\n            },\n        },\n    } satisfies BetterAuthPlugin\n}\n\nThis will add an age field to the user table and all user returning endpoints will include the age field and it'll be inferred properly by typescript.\n\nDon't store sensitive information in user or session table. Crate a new table if you need to store sensitive information.\n\nHooks\n\nHooks are used to run code before or after an action is performed, either from a client or directly on the server. You can add hooks to the server by passing a hooks object, which should contain before and after properties.\n\nplugin.ts\nimport {  createAuthMiddleware } from \"better-auth/plugins\";\nconst myPlugin = ()=>{\n    return {\n        id: \"my-plugin\",\n        hooks: {\n            before: [{\n                    matcher: (context)=>{\n                        return context.headers.get(\"x-my-header\") === \"my-value\"\n                    },\n                    handler: createAuthMiddleware(async (ctx)=>{\n                        //do something before the request\n                        return  {\n                            context: ctx // if you want to modify the context\n                        }\n                    })\n                }],\n            after: [{\n                matcher: (context)=>{\n                    return context.path === \"/sign-up/email\"\n                },\n                handler: createAuthMiddleware(async (ctx)=>{\n                    return ctx.json({\n                        message: \"Hello World\"\n                    }) // if you want to modify the response\n                })\n            }]\n        }\n    } satisfies BetterAuthPlugin\n}\nMiddleware\n\nYou can add middleware to the server by passing a middlewares array. This array should contain middleware objects, each with a path and a middleware property. Unlike hooks, middleware only runs on api requests from a client. If the endpoint is invoked directly, the middleware will not run.\n\nThe path can be either a string or a path matcher, using the same path-matching system as better-call.\n\nIf you throw an APIError from the middleware or returned a Response object, the request will be stopped and the response will be sent to the client.\n\nplugin.ts\nconst myPlugin = ()=>{\n    return {\n        id: \"my-plugin\",\n        middlewares: [\n            {\n                path: \"/my-plugin/hello-world\",\n                middleware: createAuthMiddleware(async(ctx)=>{\n                    //do something\n                })\n            }\n        ]\n    } satisfies BetterAuthPlugin\n}\nOn Request & On Response\n\nAdditional to middlewares, you can also hook into right before a request is made and right after a response is returned. This is mostly useful if you want to do something that affects all requests or responses.\n\nOn Request\n\nThe onRequest function is called right before the request is made. It takes two parameters: the request and the context object.\n\nHereâ€™s how it works:\n\nContinue as Normal: If you don't return anything, the request will proceed as usual.\nInterrupt the Request: To stop the request and send a response, return an object with a response property that contains a Response object.\nModify the Request: You can also return a modified request object to change the request before it's sent.\nplugin.ts\nconst myPlugin = ()=> {\n    return  {\n        id: \"my-plugin\",\n        onRequest: async (request, context) => {\n            //do something\n        },\n    } satisfies BetterAuthPlugin\n}\nOn Response\n\nThe onResponse function is executed immediately after a response is returned. It takes two parameters: the response and the context object.\n\nHereâ€™s how to use it:\n\nModify the Response: You can return a modified response object to change the response before it is sent to the client.\nContinue Normally: If you don't return anything, the response will be sent as is.\nplugin.ts\nconst myPlugin = ()=>{\n    return {\n        id: \"my-plugin\",\n        onResponse: async (response, context) => {\n            //do something\n        },\n    } satisfies BetterAuthPlugin\n}\nRate Limit\n\nYou can define custom rate limit rules for your plugin by passing a rateLimit array. The rate limit array should contain an array of rate limit objects.\n\nplugin.ts\nconst myPlugin = ()=>{\n    return {\n        id: \"my-plugin\",\n        rateLimit: [\n            {\n                pathMatcher: (path)=>{\n                    return path === \"/my-plugin/hello-world\"\n                },\n                limit: 10,\n                window: 60,\n            }\n        ]\n    } satisfies BetterAuthPlugin\n}\nServer-plugin helper functions\n\nSome additional helper functions for creating server plugins.\n\ngetSessionFromCtx\n\nAllows you to get the client's session data by passing the auth middleware's context.\n\nplugin.ts\nimport {  createAuthMiddleware } from \"better-auth/plugins\";\nimport { getSessionFromCtx } from \"better-auth/api\";\nconst myPlugin = {\n    id: \"my-plugin\",\n    hooks: {\n        before: [{\n                matcher: (context)=>{\n                    return context.headers.get(\"x-my-header\") === \"my-value\"\n                },\n                handler: createAuthMiddleware(async (ctx) => {\n                    const session = await getSessionFromCtx(ctx);\n                    //do something with the client's session.\n                    return  {\n                        context: ctx\n                    }\n                })\n            }],\n    }\n} satisfies BetterAuthPlugin\nsessionMiddleware\n\nA middleware that checks if the client has a valid session. If the client has a valid session, it'll add the session data to the context object.\n\nplugin.ts\nimport { createAuthMiddleware } from \"better-auth/plugins\";\nimport { sessionMiddleware } from \"better-auth/api\";\nconst myPlugin = ()=>{\n    return {\n        id: \"my-plugin\",\n        endpoints: {\n            getHelloWorld: createAuthEndpoint(\"/my-plugin/hello-world\", {\n                method: \"GET\",\n                use: [sessionMiddleware], \n            }, async(ctx) => {\n                const session = ctx.context.session;\n                return ctx.json({\n                    message: \"Hello World\"\n                })\n            })\n        }\n    } satisfies BetterAuthPlugin\n}\nCreating a client plugin\n\nIf your endpoints needs to be called from the client, you'll need to also create a client plugin. Better Auth clients can infer the endpoints from the server plugins. You can also add additional client side logic.\n\nclient-plugin.ts\nimport type { BetterAuthClientPlugin } from \"better-auth\";\nexport const myPluginClient = ()=>{\n    return {\n        id: \"my-plugin\",\n    } satisfies BetterAuthClientPlugin\n}\nEndpoint Interface\n\nEndpoints are inferred from the server plugin by adding a $InferServerPlugin key to the client plugin.\n\nThe client infers the path as an object and converts kebab-case to camelCase. For example, /my-plugin/hello-world becomes myPlugin.helloWorld.\n\nclient-plugin.ts\nimport type { BetterAuthClientPlugin } from \"better-auth/client\";\nimport type { myPlugin } from \"./plugin\";\nconst myPluginClient = ()=> {\n    return  {\n        id: \"my-plugin\",\n        $InferServerPlugin: {} as ReturnType<typeof myPlugin>,\n    } satisfies BetterAuthClientPlugin\n}\nGet actions\n\nIf you need to add additional methods or what not to the client you can use the getActions function. This function is called with the fetch function from the client.\n\nBetter Auth uses Better fetch to make requests. Better fetch is a simple fetch wrapper made by the same author of Better Auth.\n\nclient-plugin.ts\nimport type { BetterAuthClientPlugin } from \"better-auth/client\";\nimport type { myPlugin } from \"./plugin\";\nimport type { BetterFetchOption } from \"@better-fetch/fetch\";\nconst myPluginClient = {\n    id: \"my-plugin\",\n    $InferServerPlugin: {} as ReturnType<typeof myPlugin>,\n    getActions: ($fetch)=>{\n        return {\n            myCustomAction: async (data: {\n                foo: string,\n            }, fetchOptions?: BetterFetchOption)=>{\n                const res = $fetch(\"/custom/action\", {\n                    method: \"POST\",\n                    body: {\n                        foo: data.foo\n                    },\n                    ...fetchOptions\n                })\n                return res\n            }\n        }\n    }\n} satisfies BetterAuthClientPlugin\n\nAs a general guideline, ensure that each function accepts only one argument, with an optional second argument for fetchOptions to allow users to pass additional options to the fetch call. The function should return an object containing data and error keys.\n\nIf your use case involves actions beyond API calls, feel free to deviate from this rule.\n\nGet Atoms\n\nThis is only useful if you want to provide hooks like useSession.\n\nGet atoms is called with the fetch function from better fetch and it should return an object with the atoms. The atoms should be created using nanostores. The atoms will be resolved by each framework useStore hook provided by nanostores.\n\nclient-plugin.ts\nimport { atom } from \"nanostores\";\nimport type { BetterAuthClientPlugin } from \"better-auth/client\";\nconst myPluginClient = {\n    id: \"my-plugin\",\n    $InferServerPlugin: {} as ReturnType<typeof myPlugin>,\n    getAtoms: ($fetch)=>{\n        const myAtom = atom<null>()\n        return {\n            myAtom\n        }\n    }\n} satisfies BetterAuthClientPlugin\n\nSee built-in plugins for examples of how to use atoms properly.\n\nPath methods\n\nBy default, inferred paths use GET method if they don't require a body and POST if they do. You can override this by passing a pathMethods object. The key should be the path and the value should be the method (\"POST\" | \"GET\").\n\nclient-plugin.ts\nimport type { BetterAuthClientPlugin } from \"better-auth/client\";\nimport type { myPlugin } from \"./plugin\";\nconst myPluginClient = {\n    id: \"my-plugin\",\n    $InferServerPlugin: {} as ReturnType<typeof myPlugin>,\n    pathMethods: {\n        \"/my-plugin/hello-world\": \"POST\"\n    }\n} satisfies BetterAuthClientPlugin\nFetch plugins\n\nIf you need to use better fetch plugins you can pass them to the fetchPlugins array. You can read more about better fetch plugins in the better fetch documentation.\n\nAtom Listeners\n\nThis is only useful if you want to provide hooks like useSession and you want to listen to atoms and re-evaluate them when they change.\n\nYou can see how this is used in the built-in plugins.\n\nEdit on GitHub\n\nPrevious Page\n\nHooks\n\nNext Page\n\nOAuth"
  },
  {
    "title": "OAuth | Better Auth",
    "url": "https://www.better-auth.com/docs/concepts/oauth",
    "html": "OAuth\nCopy Markdown\nOpen in\n\nBetter Auth comes with built-in support for OAuth 2.0 and OpenID Connect. This allows you to authenticate users via popular OAuth providers like Google, Facebook, GitHub, and more.\n\nIf your desired provider isn't directly supported, you can use the Generic OAuth Plugin for custom integrations.\n\nConfiguring Social Providers\n\nTo enable a social provider, you need to provide clientId and clientSecret for the provider.\n\nHere's an example of how to configure Google as a provider:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  // Other configurations...\n  socialProviders: {\n    google: {\n      clientId: \"YOUR_GOOGLE_CLIENT_ID\",\n      clientSecret: \"YOUR_GOOGLE_CLIENT_SECRET\",\n    },\n  },\n});\nUsage\nSign In\n\nTo sign in with a social provider, you can use the signIn.social function with the authClient or auth.api for server-side usage.\n\n// client-side usage\nawait authClient.signIn.social({\n  provider: \"google\", // or any other provider id\n})\n// server-side usage\nawait auth.api.signInSocial({\n  body: {\n    provider: \"google\", // or any other provider id\n  },\n});\nLink account\n\nTo link an account to a social provider, you can use the linkAccount function with the authClient or auth.api for server-side usage.\n\nawait authClient.linkSocial({\n  provider: \"google\", // or any other provider id\n})\n\nserver-side usage:\n\nawait auth.api.linkSocialAccount({\n  body: {\n    provider: \"google\", // or any other provider id\n  },\n  headers: // pass headers with authenticated token\n});\nGet Access Token\n\nTo get the access token for a social provider, you can use the getAccessToken function with the authClient or auth.api for server-side usage. When you use this endpoint, if the access token is expired, it will be refreshed.\n\nconst { accessToken } = await authClient.getAccessToken({\n  providerId: \"google\", // or any other provider id\n  accountId: \"accountId\", // optional, if you want to get the access token for a specific account\n})\n\nserver-side usage:\n\nawait auth.api.getAccessToken({\n  body: {\n    providerId: \"google\", // or any other provider id\n    accountId: \"accountId\", // optional, if you want to get the access token for a specific account\n    userId: \"userId\", // optional, if you don't provide headers with authenticated token\n  },\n  headers: // pass headers with authenticated token\n});\nGet Account Info Provided by the provider\n\nTo get provider specific account info you can use the accountInfo function with the authClient or auth.api for server-side usage.\n\nconst info = await authClient.accountInfo({\n  accountId: \"accountId\", // here you pass in the provider given account id, the provider is automatically detected from the account id\n})\n\nserver-side usage:\n\nawait auth.api.accountInfo({\n  body: { accountId: \"accountId\" },\n  headers: // pass headers with authenticated token\n});\nRequesting Additional Scopes\n\nSometimes your application may need additional OAuth scopes after the user has already signed up (e.g., for accessing GitHub repositories or Google Drive). Users may not want to grant extensive permissions initially, preferring to start with minimal permissions and grant additional access as needed.\n\nYou can request additional scopes by using the linkSocial method with the same provider. This will trigger a new OAuth flow that requests the additional scopes while maintaining the existing account connection.\n\nconst requestAdditionalScopes = async () => {\n    await authClient.linkSocial({\n        provider: \"google\",\n        scopes: [\"https://www.googleapis.com/auth/drive.file\"],\n    });\n};\n\nMake sure you're running Better Auth version 1.2.7 or later. Earlier versions (like 1.2.2) may show a \"Social account already linked\" error when trying to link with an existing provider for additional scopes.\n\nProvider Options\nscope\n\nThe scope of the access request. For example, email or profile.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  // Other configurations...\n  socialProviders: {\n    google: {\n      clientId: \"YOUR_GOOGLE_CLIENT_ID\",\n      clientSecret: \"YOUR_GOOGLE_CLIENT_SECRET\",\n      scope: [\"email\", \"profile\"],\n    },\n  },\n});\nredirectURI\n\nCustom redirect URI for the provider. By default, it uses /api/auth/callback/${providerName}\n\nauth.ts\nexport const auth = betterAuth({\n  // Other configurations...\n  socialProviders: {\n    google: {\n      clientId: \"YOUR_GOOGLE_CLIENT_ID\",\n      clientSecret: \"YOUR_GOOGLE_CLIENT_SECRET\",\n      redirectURI: \"https://your-app.com/auth/callback\",\n    },\n  },\n});\ndisableSignUp\n\nDisables sign-up for new users.\n\ndisableIdTokenSignIn\n\nDisables the use of the ID token for sign-in. By default, it's enabled for some providers like Google and Apple.\n\nverifyIdToken\n\nA custom function to verify the ID token.\n\noverrideUserInfoOnSignIn\n\nA boolean value that determines whether to override the user information in the database when signing in. By default, it is set to false, meaning that the user information will not be overridden during sign-in. If you want to update the user information every time they sign in, set this to true.\n\nmapProfileToUser\n\nA custom function to map the user profile returned from the provider to the user object in your database.\n\nUseful, if you have additional fields in your user object you want to populate from the provider's profile. Or if you want to change how by default the user object is mapped.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  // Other configurations...\n  socialProviders: {\n    google: {\n      clientId: \"YOUR_GOOGLE_CLIENT_ID\",\n      clientSecret: \"YOUR_GOOGLE_CLIENT_SECRET\",\n      mapProfileToUser: (profile) => {\n        return {\n          firstName: profile.given_name,\n          lastName: profile.family_name,\n        };\n      },\n    },\n  },\n});\nrefreshAccessToken\n\nA custom function to refresh the token. This feature is only supported for built-in social providers (Google, Facebook, GitHub, etc.) and is not currently supported for custom OAuth providers configured through the Generic OAuth Plugin. For built-in providers, you can provide a custom function to refresh the token if needed.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  // Other configurations...\n  socialProviders: {\n    google: {\n      clientId: \"YOUR_GOOGLE_CLIENT_ID\",\n      clientSecret: \"YOUR_GOOGLE_CLIENT_SECRET\",\n      refreshAccessToken: async (token) => {\n        return {\n          accessToken: \"new-access-token\",\n          refreshToken: \"new-refresh-token\",\n        };\n      },\n    },\n  },\n});\nclientKey\n\nThe client key of your application. This is used by TikTok Social Provider instead of clientId.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  // Other configurations...\n  socialProviders: {\n    tiktok: {\n      clientKey: \"YOUR_TIKTOK_CLIENT_KEY\",\n      clientSecret: \"YOUR_TIKTOK_CLIENT_SECRET\",\n    },\n  },\n});\ngetUserInfo\n\nA custom function to get user info from the provider. This allows you to override the default user info retrieval process.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  // Other configurations...\n  socialProviders: {\n    google: {\n      clientId: \"YOUR_GOOGLE_CLIENT_ID\",\n      clientSecret: \"YOUR_GOOGLE_CLIENT_SECRET\",\n      getUserInfo: async (token) => {\n        // Custom implementation to get user info\n        const response = await fetch(\"https://www.googleapis.com/oauth2/v2/userinfo\", {\n          headers: {\n            Authorization: `Bearer ${token.accessToken}`,\n          },\n        });\n        const profile = await response.json();\n        return {\n          user: {\n            id: profile.id,\n            name: profile.name,\n            email: profile.email,\n            image: profile.picture,\n            emailVerified: profile.verified_email,\n          },\n          data: profile,\n        };\n      },\n    },\n  },\n});\ndisableImplicitSignUp\n\nDisables implicit sign up for new users. When set to true for the provider, sign-in needs to be called with requestSignUp as true to create new users.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  // Other configurations...\n  socialProviders: {\n    google: {\n      clientId: \"YOUR_GOOGLE_CLIENT_ID\",\n      clientSecret: \"YOUR_GOOGLE_CLIENT_SECRET\",\n      disableImplicitSignUp: true,\n    },\n  },\n});\nprompt\n\nThe prompt to use for the authorization code request. This controls the authentication flow behavior.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  // Other configurations...\n  socialProviders: {\n    google: {\n      clientId: \"YOUR_GOOGLE_CLIENT_ID\",\n      clientSecret: \"YOUR_GOOGLE_CLIENT_SECRET\",\n      prompt: \"select_account\", // or \"consent\", \"login\", \"none\", \"select_account+consent\"\n    },\n  },\n});\nresponseMode\n\nThe response mode to use for the authorization code request. This determines how the authorization response is returned.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  // Other configurations...\n  socialProviders: {\n    google: {\n      clientId: \"YOUR_GOOGLE_CLIENT_ID\",\n      clientSecret: \"YOUR_GOOGLE_CLIENT_SECRET\",\n      responseMode: \"query\", // or \"form_post\"\n    },\n  },\n});\ndisableDefaultScope\n\nRemoves the default scopes of the provider. By default, providers include certain scopes like email and profile. Set this to true to remove these default scopes and use only the scopes you specify.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  // Other configurations...\n  socialProviders: {\n    google: {\n      clientId: \"YOUR_GOOGLE_CLIENT_ID\",\n      clientSecret: \"YOUR_GOOGLE_CLIENT_SECRET\",\n      disableDefaultScope: true,\n      scope: [\"https://www.googleapis.com/auth/userinfo.email\"], // Only this scope will be used\n    },\n  },\n});\nOther Provider Configurations\n\nEach provider may have additional options, check the specific provider documentation for more details.\n\nEdit on GitHub\n\nPrevious Page\n\nPlugins\n\nNext Page\n\nRate Limit"
  },
  {
    "title": "Rate Limit | Better Auth",
    "url": "https://www.better-auth.com/docs/concepts/rate-limit",
    "html": "Rate Limit\nCopy Markdown\nOpen in\n\nBetter Auth includes a built-in rate limiter to help manage traffic and prevent abuse. By default, in production mode, the rate limiter is set to:\n\nWindow: 60 seconds\nMax Requests: 100 requests\n\nServer-side requests made using auth.api aren't affected by rate limiting. Rate limits only apply to client-initiated requests.\n\nYou can easily customize these settings by passing the rateLimit object to the betterAuth function.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    rateLimit: {\n        window: 10, // time window in seconds\n        max: 100, // max requests in the window\n    },\n})\n\nRate limiting is disabled in development mode by default. In order to enable it, set enabled to true:\n\nauth.ts\nexport const auth = betterAuth({\n    rateLimit: {\n        enabled: true,\n        //...other options\n    },\n})\n\nIn addition to the default settings, Better Auth provides custom rules for specific paths. For example:\n\n/sign-in/email: Is limited to 3 requests within 10 seconds.\n\nIn addition, plugins also define custom rules for specific paths. For example, twoFactor plugin has custom rules:\n\n/two-factor/verify: Is limited to 3 requests within 10 seconds.\n\nThese custom rules ensure that sensitive operations are protected with stricter limits.\n\nConfiguring Rate Limit\nConnecting IP Address\n\nRate limiting uses the connecting IP address to track the number of requests made by a user. The default header checked is x-forwarded-for, which is commonly used in production environments. If you are using a different header to track the user's IP address, you'll need to specify it.\n\nauth.ts\nexport const auth = betterAuth({\n    //...other options\n    advanced: {\n        ipAddress: {\n          ipAddressHeaders: [\"cf-connecting-ip\"], // Cloudflare specific header example\n      },\n    },\n    rateLimit: {\n        enabled: true,\n        window: 60, // time window in seconds\n        max: 100, // max requests in the window\n    },\n})\nRate Limit Window\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    //...other options\n    rateLimit: {\n        window: 60, // time window in seconds\n        max: 100, // max requests in the window\n    },\n})\n\nYou can also pass custom rules for specific paths.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    //...other options\n    rateLimit: {\n        window: 60, // time window in seconds\n        max: 100, // max requests in the window\n        customRules: {\n            \"/sign-in/email\": {\n                window: 10,\n                max: 3,\n            },\n            \"/two-factor/*\": async (request)=> {\n                // custom function to return rate limit window and max\n                return {\n                    window: 10,\n                    max: 3,\n                }\n            }\n        },\n    },\n})\n\nIf you like to disable rate limiting for a specific path, you can set it to false or return false from the custom rule function.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    //...other options\n    rateLimit: {\n        customRules: {\n            \"/get-session\": false,\n        },\n    },\n})\nStorage\n\nBy default, rate limit data is stored in memory, which may not be suitable for many use cases, particularly in serverless environments. To address this, you can use a database, secondary storage, or custom storage for storing rate limit data.\n\nUsing Database\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    //...other options\n    rateLimit: {\n        storage: \"database\",\n        modelName: \"rateLimit\", //optional by default \"rateLimit\" is used\n    },\n})\n\nMake sure to run migrate to create the rate limit table in your database.\n\nnpx @better-auth/cli migrate\n\nUsing Secondary Storage\n\nIf a Secondary Storage has been configured you can use that to store rate limit data.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    //...other options\n    rateLimit: {\n\t\tstorage: \"secondary-storage\"\n    },\n})\n\nCustom Storage\n\nIf none of the above solutions suits your use case you can implement a customStorage.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    //...other options\n    rateLimit: {\n        customStorage: {\n            get: async (key) => {\n                // get rate limit data\n            },\n            set: async (key, value) => {\n                // set rate limit data\n            },\n        },\n    },\n})\nHandling Rate Limit Errors\n\nWhen a request exceeds the rate limit, Better Auth returns the following header:\n\nX-Retry-After: The number of seconds until the user can make another request.\n\nTo handle rate limit errors on the client side, you can manage them either globally or on a per-request basis. Since Better Auth clients wrap over Better Fetch, you can pass fetchOptions to handle rate limit errors\n\nGlobal Handling\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nexport const authClient = createAuthClient({\n    fetchOptions: {\n        onError: async (context) => {\n            const { response } = context;\n            if (response.status === 429) {\n                const retryAfter = response.headers.get(\"X-Retry-After\");\n                console.log(`Rate limit exceeded. Retry after ${retryAfter} seconds`);\n            }\n        },\n    }\n})\n\nPer Request Handling\n\nauth-client.ts\nimport { authClient } from \"./auth-client\";\nawait authClient.signIn.email({\n    fetchOptions: {\n        onError: async (context) => {\n            const { response } = context;\n            if (response.status === 429) {\n                const retryAfter = response.headers.get(\"X-Retry-After\");\n                console.log(`Rate limit exceeded. Retry after ${retryAfter} seconds`);\n            }\n        },\n    }\n})\nSchema\n\nIf you are using a database to store rate limit data you need this schema:\n\nTable Name: rateLimit\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tDatabase ID\nkey\tstring\t-\tUnique identifier for each rate limit key\ncount\tinteger\t-\tTime window in seconds\nlastRequest\tbigint\t-\tMax requests in the window\nEdit on GitHub\n\nPrevious Page\n\nOAuth\n\nNext Page\n\nSessions"
  },
  {
    "title": "TypeScript | Better Auth",
    "url": "https://www.better-auth.com/docs/concepts/typescript",
    "html": "TypeScript\nCopy Markdown\nOpen in\n\nBetter Auth is designed to be type-safe. Both the client and server are built with TypeScript, allowing you to easily infer types.\n\nTypeScript Config\nStrict Mode\n\nBetter Auth is designed to work with TypeScript's strict mode. We recommend enabling strict mode in your TypeScript config file:\n\ntsconfig.json\n{\n  \"compilerOptions\": {\n    \"strict\": true\n  }\n}\n\nif you can't set strict to true, you can enable strictNullChecks:\n\ntsconfig.json\n{\n  \"compilerOptions\": {\n    \"strictNullChecks\": true,\n  }\n}\n\nIf you're running into issues with TypeScript inference exceeding maximum length the compiler will serialize, then please make sure you're following the instructions above, as well as ensuring that both declaration and composite are not enabled.\n\nInferring Types\n\nBoth the client SDK and the server offer types that can be inferred using the $Infer property. Plugins can extend base types like User and Session, and you can use $Infer to infer these types. Additionally, plugins can provide extra types that can also be inferred through $Infer.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient = createAuthClient()\nexport type Session = typeof authClient.$Infer.Session\n\nThe Session type includes both session and user properties. The user property represents the user object type, and the session property represents the session object type.\n\nYou can also infer types on the server side.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport Database from \"better-sqlite3\"\nexport const auth = betterAuth({\n    database: new Database(\"database.db\")\n})\ntype Session = typeof auth.$Infer.Session\nAdditional Fields\n\nBetter Auth allows you to add additional fields to the user and session objects. All additional fields are properly inferred and available on the server and client side.\n\nimport { betterAuth } from \"better-auth\"\nimport Database from \"better-sqlite3\"\nexport const auth = betterAuth({\n    database: new Database(\"database.db\"),\n    user: {\n       additionalFields: {\n          role: {\n              type: \"string\",\n              input: false\n            } \n        }\n    }\n   \n})\ntype Session = typeof auth.$Infer.Session\n\nIn the example above, we added a role field to the user object. This field is now available on the Session type.\n\nThe input property\n\nThe input property in an additional field configuration determines whether the field should be included in the user input. This property defaults to true, meaning the field will be part of the user input during operations like registration.\n\nTo prevent a field from being part of the user input, you must explicitly set input: false:\n\nadditionalFields: {\n    role: {\n        type: \"string\",\n        input: false\n    }\n}\n\nWhen input is set to false, the field will be excluded from user input, preventing users from passing a value for it.\n\nBy default, additional fields are included in the user input, which can lead to security vulnerabilities if not handled carefully. For fields that should not be set by the user, like a role, it is crucial to set input: false in the configuration.\n\nInferring Additional Fields on Client\n\nTo make sure proper type inference for additional fields on the client side, you need to inform the client about these fields. There are two approaches to achieve this, depending on your project structure:\n\nFor Monorepo or Single-Project Setups\n\nIf your server and client code reside in the same project, you can use the inferAdditionalFields plugin to automatically infer the additional fields from your server configuration.\n\nimport { inferAdditionalFields } from \"better-auth/client/plugins\";\nimport { createAuthClient } from \"better-auth/react\";\nimport type { auth } from \"./auth\";\nexport const authClient = createAuthClient({\n  plugins: [inferAdditionalFields<typeof auth>()],\n});\nFor Separate Client-Server Projects\n\nIf your client and server are in separate projects, you'll need to manually specify the additional fields when creating the auth client.\n\nimport { inferAdditionalFields } from \"better-auth/client/plugins\";\nexport const authClient = createAuthClient({\n  plugins: [inferAdditionalFields({\n      user: {\n        role: {\n          type: \"string\"\n        }\n      }\n  })],\n});\nEdit on GitHub\n\nPrevious Page\n\nSessions\n\nNext Page\n\nUsers & Accounts"
  },
  {
    "title": "User & Accounts | Better Auth",
    "url": "https://www.better-auth.com/docs/concepts/users-accounts",
    "html": "User & Accounts\nCopy Markdown\nOpen in\n\nBeyond authenticating users, Better Auth also provides a set of methods to manage users. This includes, updating user information, changing passwords, and more.\n\nThe user table stores the authentication data of the user Click here to view the schema.\n\nThe user table can be extended using additional fields or by plugins to store additional data.\n\nUpdate User\nUpdate User Information\n\nTo update user information, you can use the updateUser function provided by the client. The updateUser function takes an object with the following properties:\n\nawait authClient.updateUser({\n    image: \"https://example.com/image.jpg\",\n    name: \"John Doe\",\n})\nChange Email\n\nTo allow users to change their email, first enable the changeEmail feature, which is disabled by default. Set changeEmail.enabled to true:\n\nexport const auth = betterAuth({\n    user: {\n        changeEmail: {\n            enabled: true,\n        }\n    }\n})\n\nFor users with a verified email, provide the sendChangeEmailVerification function. This function triggers when a user changes their email, sending a verification email with a URL and token. If the current email isn't verified, the change happens immediately without verification.\n\nexport const auth = betterAuth({\n    user: {\n        changeEmail: {\n            enabled: true,\n            sendChangeEmailVerification: async ({ user, newEmail, url, token }, request) => {\n                await sendEmail({\n                    to: user.email, // verification email must be sent to the current user email to approve the change\n                    subject: 'Approve email change',\n                    text: `Click the link to approve the change: ${url}`\n                })\n            }\n        }\n    }\n})\n\nOnce enabled, use the changeEmail function on the client to update a userâ€™s email. The user must verify their current email before changing it.\n\nawait authClient.changeEmail({\n    newEmail: \"new-email@email.com\",\n    callbackURL: \"/dashboard\", //to redirect after verification\n});\n\nAfter verification, the new email is updated in the user table, and a confirmation is sent to the new address.\n\nIf the current email is unverified, the new email is updated without the verification step.\n\nChange Password\n\nA user's password isn't stored in the user table. Instead, it's stored in the account table. To change the password of a user, you can use one of the following approaches:\n\nClient\nServer\nPOST\n/change-password\nconst { data, error } = await authClient.changePassword({\n    newPassword: \"newpassword1234\", // required\n    currentPassword: \"oldpassword1234\", // required\n    revokeOtherSessions: true,\n});\nProp\tDescription\tType\nnewPassword\t\nThe new password to set\n\tstring\ncurrentPassword\t\nThe current user password\n\tstring\nrevokeOtherSessions?\t\nWhen set to true, all other active sessions for this user will be invalidated\n\tboolean\nSet Password\n\nIf a user was registered using OAuth or other providers, they won't have a password or a credential account. In this case, you can use the setPassword action to set a password for the user. For security reasons, this function can only be called from the server. We recommend having users go through a 'forgot password' flow to set a password for their account.\n\nawait auth.api.setPassword({\n    body: { newPassword: \"password\" },\n    headers: // headers containing the user's session token\n});\nDelete User\n\nBetter Auth provides a utility to hard delete a user from your database. It's disabled by default, but you can enable it easily by passing enabled:true\n\nexport const auth = betterAuth({\n    //...other config\n    user: {\n        deleteUser: { \n            enabled: true\n        } \n    }\n})\n\nOnce enabled, you can call authClient.deleteUser to permanently delete user data from your database.\n\nAdding Verification Before Deletion\n\nFor added security, youâ€™ll likely want to confirm the userâ€™s intent before deleting their account. A common approach is to send a verification email. Better Auth provides a sendDeleteAccountVerification utility for this purpose. This is especially needed if you have OAuth setup and want them to be able to delete their account without forcing them to login again for a fresh session.\n\nHereâ€™s how you can set it up:\n\nexport const auth = betterAuth({\n    user: {\n        deleteUser: {\n            enabled: true,\n            sendDeleteAccountVerification: async (\n                {\n                    user,   // The user object\n                    url, // The auto-generated URL for deletion\n                    token  // The verification token  (can be used to generate custom URL)\n                },\n                request  // The original request object (optional)\n            ) => {\n                // Your email sending logic here\n                // Example: sendEmail(data.user.email, \"Verify Deletion\", data.url);\n            },\n        },\n    },\n});\n\nHow callback verification works:\n\nCallback URL: The URL provided in sendDeleteAccountVerification is a pre-generated link that deletes the user data when accessed.\ndelete-user.ts\nawait authClient.deleteUser({\n    callbackURL: \"/goodbye\" // you can provide a callback URL to redirect after deletion\n});\nAuthentication Check: The user must be signed in to the account theyâ€™re attempting to delete. If they arenâ€™t signed in, the deletion process will fail.\n\nIf you have sent a custom URL, you can use the deleteUser method with the token to delete the user.\n\ndelete-user.ts\nawait authClient.deleteUser({\n    token\n});\nAuthentication Requirements\n\nTo delete a user, the user must meet one of the following requirements:\n\nA valid password\n\nif the user has a password, they can delete their account by providing the password.\n\ndelete-user.ts\nawait authClient.deleteUser({\n    password: \"password\"\n});\nFresh session\n\nThe user must have a fresh session token, meaning the user must have signed in recently. This is checked if the password is not provided.\n\nBy default session.freshAge is set to 60 * 60 * 24 (1 day). You can change this value by passing the session object to the auth configuration. If it is set to 0, the freshness check is disabled. It is recommended not to disable this check if you are not using email verification for deleting the account.\n\ndelete-user.ts\nawait authClient.deleteUser();\nEnabled email verification (needed for OAuth users)\n\nAs OAuth users don't have a password, we need to send a verification email to confirm the user's intent to delete their account. If you have already added the sendDeleteAccountVerification callback, you can just call the deleteUser method without providing any other information.\n\ndelete-user.ts\nawait authClient.deleteUser();\nIf you have a custom delete account page and sent that url via the sendDeleteAccountVerification callback. Then you need to call the deleteUser method with the token to complete the deletion.\ndelete-user.ts\nawait authClient.deleteUser({\n    token\n});\nCallbacks\n\nbeforeDelete: This callback is called before the user is deleted. You can use this callback to perform any cleanup or additional checks before deleting the user.\n\nauth.ts\nexport const auth = betterAuth({\n    user: {\n        deleteUser: {\n            enabled: true,\n            beforeDelete: async (user) => {\n                // Perform any cleanup or additional checks here\n            },\n        },\n    },\n});\n\nyou can also throw APIError to interrupt the deletion process.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { APIError } from \"better-auth/api\";\nexport const auth = betterAuth({\n    user: {\n        deleteUser: {\n            enabled: true,\n            beforeDelete: async (user, request) => {\n                if (user.email.includes(\"admin\")) {\n                    throw new APIError(\"BAD_REQUEST\", {\n                        message: \"Admin accounts can't be deleted\",\n                    });\n                }\n            },\n        },\n    },\n});\n\nafterDelete: This callback is called after the user is deleted. You can use this callback to perform any cleanup or additional actions after the user is deleted.\n\nauth.ts\nexport const auth = betterAuth({\n    user: {\n        deleteUser: {\n            enabled: true,\n            afterDelete: async (user, request) => {\n                // Perform any cleanup or additional actions here\n            },\n        },\n    },\n});\nAccounts\n\nBetter Auth supports multiple authentication methods. Each authentication method is called a provider. For example, email and password authentication is a provider, Google authentication is a provider, etc.\n\nWhen a user signs in using a provider, an account is created for the user. The account stores the authentication data returned by the provider. This data includes the access token, refresh token, and other information returned by the provider.\n\nThe account table stores the authentication data of the user Click here to view the schema\n\nList User Accounts\n\nTo list user accounts you can use client.user.listAccounts method. Which will return all accounts associated with a user.\n\nconst accounts = await authClient.listAccounts();\nToken Encryption\n\nBetter Auth doesnâ€™t encrypt tokens by default and thatâ€™s intentional. We want you to have full control over how encryption and decryption are handled, rather than baking in behavior that could be confusing or limiting. If you need to store encrypted tokens (like accessToken or refreshToken), you can use databaseHooks to encrypt them before theyâ€™re saved to your database.\n\nexport const auth = betterAuth({\n    databaseHooks: {\n        account: {\n            create: {\n                before(account, context) {\n                    const withEncryptedTokens = { ...account };\n                    if (account.accessToken) {\n                        const encryptedAccessToken = encrypt(account.accessToken)  \n                        withEncryptedTokens.accessToken = encryptedAccessToken;\n                    }\n                    if (account.refreshToken) {\n                        const encryptedRefreshToken = encrypt(account.refreshToken); \n                        withEncryptedTokens.refreshToken = encryptedRefreshToken;\n                    }\n                    return {\n                        data: withEncryptedTokens\n                    }\n                },\n            }\n        }\n    }\n})\n\nThen whenever you retrieve back the account make sure to decrypt the tokens before using them.\n\nAccount Linking\n\nAccount linking enables users to associate multiple authentication methods with a single account. With Better Auth, users can connect additional social sign-ons or OAuth providers to their existing accounts if the provider confirms the user's email as verified.\n\nIf account linking is disabled, no accounts can be linked, regardless of the provider or email verification status.\n\nauth.ts\nexport const auth = betterAuth({\n    account: {\n        accountLinking: {\n            enabled: true, \n        }\n    },\n});\nForced Linking\n\nYou can specify a list of \"trusted providers.\" When a user logs in using a trusted provider, their account will be automatically linked even if the provider doesnâ€™t confirm the email verification status. Use this with caution as it may increase the risk of account takeover.\n\nauth.ts\nexport const auth = betterAuth({\n    account: {\n        accountLinking: {\n            enabled: true,\n            trustedProviders: [\"google\", \"github\"]\n        }\n    },\n});\nManually Linking Accounts\n\nUsers already signed in can manually link their account to additional social providers or credential-based accounts.\n\nLinking Social Accounts: Use the linkSocial method on the client to link a social provider to the user's account.\n\nawait authClient.linkSocial({\n    provider: \"google\", // Provider to link\n    callbackURL: \"/callback\" // Callback URL after linking completes\n});\n\nYou can also request specific scopes when linking a social account, which can be different from the scopes used during the initial authentication:\n\nawait authClient.linkSocial({\n    provider: \"google\",\n    callbackURL: \"/callback\",\n    scopes: [\"https://www.googleapis.com/auth/drive.readonly\"] // Request additional scopes\n});\n\nYou can also link accounts using ID tokens directly, without redirecting to the provider's OAuth flow:\n\nawait authClient.linkSocial({\n    provider: \"google\",\n    idToken: {\n        token: \"id_token_from_provider\",\n        nonce: \"nonce_used_for_token\", // Optional\n        accessToken: \"access_token\", // Optional, may be required by some providers\n        refreshToken: \"refresh_token\" // Optional\n    }\n});\n\nThis is useful when you already have valid tokens from the provider, for example:\n\nAfter signing in with a native SDK\nWhen using a mobile app that handles authentication\nWhen implementing custom OAuth flows\n\nThe ID token must be valid and the provider must support ID token verification.\n\nIf you want your users to be able to link a social account with a different email address than the user, or if you want to use a provider that does not return email addresses, you will need to enable this in the account linking settings.\n\nauth.ts\nexport const auth = betterAuth({\n    account: {\n        accountLinking: {\n            allowDifferentEmails: true\n        }\n    },\n});\n\nIf you want the newly linked accounts to update the user information, you need to enable this in the account linking settings.\n\nauth.ts\nexport const auth = betterAuth({\n    account: {\n        accountLinking: {\n            updateUserInfoOnLink: true\n        }\n    },\n});\n\nLinking Credential-Based Accounts: To link a credential-based account (e.g., email and password), users can initiate a \"forgot password\" flow, or you can call the setPassword method on the server.\n\nawait auth.api.setPassword({\n    headers: /* headers containing the user's session token */,\n    password: /* new password */\n});\n\nsetPassword can't be called from the client for security reasons.\n\nAccount Unlinking\n\nYou can unlink a user account by providing a providerId.\n\nawait authClient.unlinkAccount({\n    providerId: \"google\"\n});\n// Unlink a specific account\nawait authClient.unlinkAccount({\n    providerId: \"google\",\n    accountId: \"123\"\n});\n\nIf the account doesn't exist, it will throw an error. Additionally, if the user only has one account, unlinking will be prevented to stop account lockout (unless allowUnlinkingAll is set to true).\n\nauth.ts\nexport const auth = betterAuth({\n    account: {\n        accountLinking: {\n            allowUnlinkingAll: true\n        }\n    },\n});\nEdit on GitHub\n\nPrevious Page\n\nTypeScript\n\nNext Page\n\nEmail & Password"
  },
  {
    "title": "Astro Example | Better Auth",
    "url": "https://www.better-auth.com/docs/examples/astro",
    "html": "Astro Example\nCopy Markdown\nOpen in\n\nThis is an example of how to use Better Auth with Astro. It uses Solid for building the components.\n\nImplements the following features: Email & Password . Social Sign-in with Google . Passkeys . Email Verification . Password Reset . Two Factor Authentication . Profile Update . Session Management\n\nOpen in Stackblitz\nView on GitHub\nHow to run\n\nClone the code sandbox (or the repo) and open it in your code editor\n\nProvide .env file with the following variables\n\nGOOGLE_CLIENT_ID=\nGOOGLE_CLIENT_SECRET=\nBETTER_AUTH_SECRET=\n\n//if you don't have these, you can get them from the google developer console. If you don't want to use google sign-in, you can remove the google config from the auth.ts file.\n\nRun the following commands\n\npnpm install\npnpm run dev\n\nOpen the browser and navigate to http://localhost:3000\n\nEdit on GitHub\n\nPrevious Page\n\nExamples\n\nNext Page\n\nRemix"
  },
  {
    "title": "Remix Example | Better Auth",
    "url": "https://www.better-auth.com/docs/examples/remix",
    "html": "Remix Example\nCopy Markdown\nOpen in\n\nThis is an example of how to use Better Auth with Remix.\n\nImplements the following features: Email & Password . Social Sign-in with Google . Passkeys . Email Verification . Password Reset . Two Factor Authentication . Profile Update . Session Management\n\nOpen in Stackblitz\nView on GitHub\nHow to run\nClone the code sandbox (or the repo) and open it in your code editor\nProvide .env file with by copying the .env.example file and adding the variables\nRun the following commands\npnpm install\npnpm run dev\nOpen the browser and navigate to http://localhost:3000\nEdit on GitHub\n\nPrevious Page\n\nAstro + SolidJs\n\nNext Page\n\nNext.js"
  },
  {
    "title": "SvelteKit Example | Better Auth",
    "url": "https://www.better-auth.com/docs/examples/svelte-kit",
    "html": "SvelteKit Example\nCopy Markdown\nOpen in\n\nThis is an example of how to use Better Auth with SvelteKit.\n\nImplements the following features: Email & Password . Social Sign-in with Google . Passkeys . Email Verification . Password Reset . Two Factor Authentication . Profile Update . Session Management\n\nOpen in Stackblitz\nView on GitHub\nHow to run\nClone the code sandbox (or the repo) and open it in your code editor\nMove .env.example to .env and provide necessary variables\nRun the following commands\npnpm install\npnpm dev\nOpen the browser and navigate to http://localhost:3000\nEdit on GitHub\n\nPrevious Page\n\nNuxt"
  },
  {
    "title": "Nuxt Example | Better Auth",
    "url": "https://www.better-auth.com/docs/examples/nuxt",
    "html": "Nuxt Example\nCopy Markdown\nOpen in\n\nThis is an example of how to use Better Auth with Nuxt.\n\nImplements the following features: Email & Password . Social Sign-in with Google\n\nOpen in Stackblitz\nView on GitHub\nHow to run\nClone the code sandbox (or the repo) and open it in your code editor\nMove .env.example to .env and provide necessary variables\nRun the following commands\npnpm install\npnpm dev\nOpen the browser and navigate to http://localhost:3000\nEdit on GitHub\n\nPrevious Page\n\nNext.js\n\nNext Page\n\nSvelteKit"
  },
  {
    "title": "Anonymous | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/anonymous",
    "html": "Anonymous\nCopy Markdown\nOpen in\n\nThe Anonymous plugin allows users to have an authenticated experience without requiring them to provide an email address, password, OAuth provider, or any other Personally Identifiable Information (PII). Users can later link an authentication method to their account when ready.\n\nInstallation\nAdd the plugin to your auth config\n\nTo enable anonymous authentication, add the anonymous plugin to your authentication configuration.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { anonymous } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    // ... other config options\n    plugins: [\n        anonymous() \n    ]\n})\nMigrate the database\n\nRun the migration or generate the schema to add the necessary fields and tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nSee the Schema section to add the fields manually.\n\nAdd the client plugin\n\nNext, include the anonymous client plugin in your authentication client instance.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { anonymousClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n    plugins: [\n        anonymousClient()\n    ]\n})\nUsage\nSign In\n\nTo sign in a user anonymously, use the signIn.anonymous() method.\n\nexample.ts\nconst user = await authClient.signIn.anonymous()\nLink Account\n\nIf a user is already signed in anonymously and tries to signIn or signUp with another method, their anonymous activities can be linked to the new account.\n\nTo do that you first need to provide onLinkAccount callback to the plugin.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    plugins: [\n        anonymous({\n            onLinkAccount: async ({ anonymousUser, newUser }) => {\n               // perform actions like moving the cart items from anonymous user to the new user\n            }\n        })\n    ]\n\nThen when you call signIn or signUp with another method, the onLinkAccount callback will be called. And the anonymousUser will be deleted by default.\n\nexample.ts\nconst user = await authClient.signIn.email({\n    email,\n})\nOptions\nemailDomainName: The domain name to use when generating an email address for anonymous users. Defaults to the domain name of the current site.\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    plugins: [\n        anonymous({\n            emailDomainName: \"example.com\"\n        })\n    ]\n})\n\nonLinkAccount: A callback function that is called when an anonymous user links their account to a new authentication method. The callback receives an object with the anonymousUser and the newUser.\n\ndisableDeleteAnonymousUser: By default, the anonymous user is deleted when the account is linked to a new authentication method. Set this option to true to disable this behavior.\n\ngenerateName: A callback function that is called to generate a name for the anonymous user. Useful if you want to have random names for anonymous users, or if name is unique in your database.\n\nSchema\n\nThe anonymous plugin requires an additional field in the user table:\n\nField Name\tType\tKey\tDescription\nisAnonymous\tboolean\t?\tIndicates whether the user is anonymous.\nEdit on GitHub\n\nPrevious Page\n\nUsername\n\nNext Page\n\nPhone Number"
  },
  {
    "title": "Phone Number | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/phone-number",
    "html": "Phone Number\nCopy Markdown\nOpen in\n\nThe phone number plugin extends the authentication system by allowing users to sign in and sign up using their phone number. It includes OTP (One-Time Password) functionality to verify phone numbers.\n\nInstallation\nAdd Plugin to the server\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { phoneNumber } from \"better-auth/plugins\"\nconst auth = betterAuth({\n    plugins: [ \n        phoneNumber({  \n            sendOTP: ({ phoneNumber, code }, request) => { \n                // Implement sending OTP code via SMS\n            } \n        }) \n    ] \n})\nMigrate the database\n\nRun the migration or generate the schema to add the necessary fields and tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nSee the Schema section to add the fields manually.\n\nAdd the client plugin\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { phoneNumberClient } from \"better-auth/client/plugins\"\nconst authClient =  createAuthClient({\n    plugins: [ \n        phoneNumberClient() \n    ] \n})\nUsage\nSend OTP for Verification\n\nTo send an OTP to a user's phone number for verification, you can use the sendVerificationCode endpoint.\n\nClient\nServer\nPOST\n/phone-number/send-otp\nconst { data, error } = await authClient.phoneNumber.sendOtp({\n    phoneNumber: \"+1234567890\", // required\n});\nProp\tDescription\tType\nphoneNumber\t\nPhone number to send OTP.\n\tstring\nVerify Phone Number\n\nAfter the OTP is sent, users can verify their phone number by providing the code.\n\nClient\nServer\nPOST\n/phone-number/verify\nconst { data, error } = await authClient.phoneNumber.verify({\n    phoneNumber: \"+1234567890\", // required\n    code: \"123456\", // required\n    disableSession: false,\n    updatePhoneNumber: true,\n});\nProp\tDescription\tType\nphoneNumber\t\nPhone number to verify.\n\tstring\ncode\t\nOTP code.\n\tstring\ndisableSession?\t\nDisable session creation after verification.\n\tboolean\nupdatePhoneNumber?\t\nCheck if there is a session and update the phone number.\n\tboolean\n\nWhen the phone number is verified, the phoneNumberVerified field in the user table is set to true. If disableSession is not set to true, a session is created for the user. Additionally, if callbackOnVerification is provided, it will be called.\n\nAllow Sign-Up with Phone Number\n\nTo allow users to sign up using their phone number, you can pass signUpOnVerification option to your plugin configuration. It requires you to pass getTempEmail function to generate a temporary email for the user.\n\nauth.ts\nexport const auth = betterAuth({\n    plugins: [\n        phoneNumber({\n            sendOTP: ({ phoneNumber, code }, request) => {\n                // Implement sending OTP code via SMS\n            },\n            signUpOnVerification: {\n                getTempEmail: (phoneNumber) => {\n                    return `${phoneNumber}@my-site.com`\n                },\n                //optionally, you can also pass `getTempName` function to generate a temporary name for the user\n                getTempName: (phoneNumber) => {\n                    return phoneNumber //by default, it will use the phone number as the name\n                }\n            }\n        })\n    ]\n})\nSign In with Phone Number\n\nIn addition to signing in a user using send-verify flow, you can also use phone number as an identifier and sign in a user using phone number and password.\n\nClient\nServer\nPOST\n/sign-in/phone-number\nconst { data, error } = await authClient.signIn.phoneNumber({\n    phoneNumber: \"+1234567890\", // required\n    password, // required\n    rememberMe: true,\n});\nProp\tDescription\tType\nphoneNumber\t\nPhone number to sign in.\n\tstring\npassword\t\nPassword to use for sign in.\n\tstring\nrememberMe?\t\nRemember the session.\n\tboolean\nUpdate Phone Number\n\nUpdating phone number uses the same process as verifying a phone number. The user will receive an OTP code to verify the new phone number.\n\nauth-client.ts\nawait authClient.phoneNumber.sendOtp({\n    phoneNumber: \"+1234567890\" // New phone number\n})\n\nThen verify the new phone number with the OTP code.\n\nauth-client.ts\nconst isVerified = await authClient.phoneNumber.verify({\n    phoneNumber: \"+1234567890\",\n    code: \"123456\",\n    updatePhoneNumber: true // Set to true to update the phone number\n})\n\nIf a user session exist the phone number will be updated automatically.\n\nDisable Session Creation\n\nBy default, the plugin creates a session for the user after verifying the phone number. You can disable this behavior by passing disableSession: true to the verify method.\n\nauth-client.ts\nconst isVerified = await authClient.phoneNumber.verify({\n    phoneNumber: \"+1234567890\",\n    code: \"123456\",\n    disableSession: true\n})\nRequest Password Reset\n\nTo initiate a request password reset flow using phoneNumber, you can start by calling requestPasswordReset on the client to send an OTP code to the user's phone number.\n\nClient\nServer\nPOST\n/phone-number/request-password-reset\nconst { data, error } = await authClient.phoneNumber.requestPasswordReset({\n    phoneNumber: \"+1234567890\", // required\n});\nProp\tDescription\tType\nphoneNumber\t\nThe phone number which is associated with the user.\n\tstring\n\nThen, you can reset the password by calling resetPassword on the client with the OTP code and the new password.\n\nClient\nServer\nPOST\n/phone-number/reset-password\nconst { data, error } = await authClient.phoneNumber.resetPassword({\n    otp: \"123456\", // required\n    phoneNumber: \"+1234567890\", // required\n    newPassword: \"new-and-secure-password\", // required\n});\nProp\tDescription\tType\notp\t\nThe one time password to reset the password.\n\tstring\nphoneNumber\t\nThe phone number to the account which intends to reset the password for.\n\tstring\nnewPassword\t\nThe new password.\n\tstring\nOptions\notpLength: The length of the OTP code to be generated. Default is 6.\nsendOTP: A function that sends the OTP code to the user's phone number. It takes the phone number and the OTP code as arguments.\nexpiresIn: The time in seconds after which the OTP code expires. Default is 300 seconds.\ncallbackOnVerification: A function that is called after the phone number is verified. It takes the phone number and the user object as the first argument and a request object as the second argument.\nexport const auth = betterAuth({\n    plugins: [\n        phoneNumber({\n            sendOTP: ({ phoneNumber, code }, request) => {\n                // Implement sending OTP code via SMS\n            },\n            callbackOnVerification: async ({ phoneNumber, user }, request) => {\n                // Implement callback after phone number verification\n            }\n        })\n    ]\n})\n\nsendPasswordResetOTP: A function that sends the OTP code to the user's phone number for password reset. It takes the phone number and the OTP code as arguments.\n\nphoneNumberValidator: A custom function to validate the phone number. It takes the phone number as an argument and returns a boolean indicating whether the phone number is valid.\n\nsignUpOnVerification: An object with the following properties:\n\ngetTempEmail: A function that generates a temporary email for the user. It takes the phone number as an argument and returns the temporary email.\ngetTempName: A function that generates a temporary name for the user. It takes the phone number as an argument and returns the temporary name.\n\nrequireVerification: When enabled, users cannot sign in with their phone number until it has been verified. If an unverified user attempts to sign in, the server will respond with a 401 error (PHONE_NUMBER_NOT_VERIFIED) and automatically trigger an OTP send to start the verification process.\n\nSchema\n\nThe plugin requires 2 fields to be added to the user table\n\nUser Table\nField Name\tType\tKey\tDescription\nphoneNumber\tstring\t?\tThe phone number of the user\nphoneNumberVerified\tboolean\t?\tWhether the phone number is verified or not\nOTP Verification Attempts\n\nThe phone number plugin includes a built-in protection against brute force attacks by limiting the number of verification attempts for each OTP code.\n\nphoneNumber({\n  allowedAttempts: 3, // default is 3\n  // ... other options\n})\n\nWhen a user exceeds the allowed number of verification attempts:\n\nThe OTP code is automatically deleted\nFurther verification attempts will return a 403 (Forbidden) status with \"Too many attempts\" message\nThe user will need to request a new OTP code to continue\n\nExample error response after exceeding attempts:\n\n{\n  \"error\": {\n    \"status\": 403,\n    \"message\": \"Too many attempts\"\n  }\n}\n\nWhen receiving a 403 status, prompt the user to request a new OTP code\n\nEdit on GitHub\n\nPrevious Page\n\nAnonymous\n\nNext Page\n\nMagic Link"
  },
  {
    "title": "One Tap | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/one-tap",
    "html": "One Tap\nCopy Markdown\nOpen in\n\nThe One Tap plugin allows users to log in with a single tap using Google's One Tap API. The plugin provides a simple way to integrate One Tap into your application, handling the client-side and server-side logic for you.\n\nInstallation\nAdd the Server Plugin\n\nAdd the One Tap plugin to your auth configuration:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { oneTap } from \"better-auth/plugins\"; \nexport const auth = betterAuth({\n    plugins: [ \n        oneTap(), // Add the One Tap server plugin\n    ] \n});\nAdd the Client Plugin\n\nAdd the client plugin and specify where the user should be redirected after sign-in or if additional verification (like 2FA) is needed.\n\nimport { createAuthClient } from \"better-auth/client\";\nimport { oneTapClient } from \"better-auth/client/plugins\";\nexport const authClient = createAuthClient({\n  plugins: [\n    oneTapClient({\n      clientId: \"YOUR_CLIENT_ID\",\n      // Optional client configuration:\n      autoSelect: false,\n      cancelOnTapOutside: true,\n      context: \"signin\",\n      additionalOptions: {\n        // Any extra options for the Google initialize method\n      },\n      // Configure prompt behavior and exponential backoff:\n      promptOptions: {\n        baseDelay: 1000,   // Base delay in ms (default: 1000)\n        maxAttempts: 5     // Maximum number of attempts before triggering onPromptNotification (default: 5)\n      }\n    })\n  ]\n});\nUsage\n\nTo display the One Tap popup, simply call the oneTap method on your auth client:\n\nawait authClient.oneTap();\nCustomizing Redirect Behavior\n\nBy default, after a successful login the plugin will hard redirect the user to /. You can customize this behavior as follows:\n\nAvoiding a Hard Redirect\n\nPass fetchOptions with an onSuccess callback to handle the login response without a page reload:\n\nawait authClient.oneTap({\n  fetchOptions: {\n    onSuccess: () => {\n      // For example, use a router to navigate without a full reload:\n      router.push(\"/dashboard\");\n    }\n  }\n});\nSpecifying a Custom Callback URL\n\nTo perform a hard redirect to a different page after login, use the callbackURL option:\n\nawait authClient.oneTap({\n  callbackURL: \"/dashboard\"\n});\nHandling Prompt Dismissals with Exponential Backoff\n\nIf the user dismisses or skips the prompt, the plugin will retry showing the One Tap prompt using exponential backoff based on your configured promptOptions.\n\nIf the maximum number of attempts is reached without a successful sign-in, you can use the onPromptNotification callback to be notifiedâ€”allowing you to render an alternative UI (e.g., a traditional Google Sign-In button) so users can restart the process manually:\n\nawait authClient.oneTap({\n  onPromptNotification: (notification) => {\n    console.warn(\"Prompt was dismissed or skipped. Consider displaying an alternative sign-in option.\", notification);\n    // Render your alternative UI here\n  }\n});\nClient Options\nclientId: The client ID for your Google One Tap API.\nautoSelect: Automatically select the account if the user is already signed in. Default is false.\ncontext: The context in which the One Tap API should be used (e.g., \"signin\"). Default is \"signin\".\ncancelOnTapOutside: Cancel the One Tap popup when the user taps outside it. Default is true.\nadditionalOptions: Extra options to pass to Google's initialize method as per the Google Identity Services docs.\npromptOptions: Configuration for the prompt behavior and exponential backoff:\nbaseDelay: Base delay in milliseconds for retries. Default is 1000.\nmaxAttempts: Maximum number of prompt attempts before invoking the onPromptNotification callback. Default is 5.\nServer Options\ndisableSignUp: Disable the sign-up option, allowing only existing users to sign in. Default is false.\nClientId: Optionally, pass a client ID here if it is not provided in your social provider configuration.\nEdit on GitHub\n\nPrevious Page\n\nGeneric OAuth\n\nNext Page\n\nSign In With Ethereum"
  },
  {
    "title": "Generic OAuth | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/generic-oauth",
    "html": "Generic OAuth\nCopy Markdown\nOpen in\n\nThe Generic OAuth plugin provides a flexible way to integrate authentication with any OAuth provider. It supports both OAuth 2.0 and OpenID Connect (OIDC) flows, allowing you to easily add social login or custom OAuth authentication to your application.\n\nInstallation\nAdd the plugin to your auth config\n\nTo use the Generic OAuth plugin, add it to your auth config.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { genericOAuth } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    // ... other config options\n    plugins: [ \n        genericOAuth({ \n            config: [ \n                { \n                    providerId: \"provider-id\", \n                    clientId: \"test-client-id\", \n                    clientSecret: \"test-client-secret\", \n                    discoveryUrl: \"https://auth.example.com/.well-known/openid-configuration\", \n                    // ... other config options\n                }, \n                // Add more providers as needed\n            ] \n        }) \n    ]\n})\nAdd the client plugin\n\nInclude the Generic OAuth client plugin in your authentication client instance.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { genericOAuthClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n    plugins: [\n        genericOAuthClient()\n    ]\n})\nUsage\n\nThe Generic OAuth plugin provides endpoints for initiating the OAuth flow and handling the callback. Here's how to use them:\n\nInitiate OAuth Sign-In\n\nTo start the OAuth sign-in process:\n\nClient\nServer\nPOST\n/sign-in/oauth2\nconst { data, error } = await authClient.signIn.oauth2({\n    providerId: \"provider-id\", // required\n    callbackURL: \"/dashboard\",\n    errorCallbackURL: \"/error-page\",\n    newUserCallbackURL: \"/welcome\",\n    disableRedirect: false,\n    scopes: [\"my-scope\"],\n    requestSignUp: false,\n});\nProp\tDescription\tType\nproviderId\t\nThe provider ID for the OAuth provider.\n\tstring\ncallbackURL?\t\nThe URL to redirect to after sign in.\n\tstring\nerrorCallbackURL?\t\nThe URL to redirect to if an error occurs.\n\tstring\nnewUserCallbackURL?\t\nThe URL to redirect to after login if the user is new.\n\tstring\ndisableRedirect?\t\nDisable redirect.\n\tboolean\nscopes?\t\nScopes to be passed to the provider authorization request.\n\tstring[]\nrequestSignUp?\t\nExplicitly request sign-up. Useful when disableImplicitSignUp is true for this provider.\n\tboolean\nLinking OAuth Accounts\n\nTo link an OAuth account to an existing user:\n\nClient\nServer\nPOST\n/oauth2/link\nconst { data, error } = await authClient.oauth2.link({\n    providerId: \"my-provider-id\", // required\n    callbackURL: \"/successful-link\", // required\n});\nProp\tDescription\tType\nproviderId\t\nThe OAuth provider ID.\n\tstring\ncallbackURL\t\nThe URL to redirect to once the account linking was complete.\n\tstring\nHandle OAuth Callback\n\nThe plugin mounts a route to handle the OAuth callback /oauth2/callback/:providerId. This means by default ${baseURL}/api/auth/oauth2/callback/:providerId will be used as the callback URL. Make sure your OAuth provider is configured to use this URL.\n\nConfiguration\n\nWhen adding the plugin to your auth config, you can configure multiple OAuth providers. Each provider configuration object supports the following options:\n\ninterface GenericOAuthConfig {\n  providerId: string;\n  discoveryUrl?: string;\n  authorizationUrl?: string;\n  tokenUrl?: string;\n  userInfoUrl?: string;\n  clientId: string;\n  clientSecret: string;\n  scopes?: string[];\n  redirectURI?: string;\n  responseType?: string;\n  prompt?: string;\n  pkce?: boolean;\n  accessType?: string;\n  getUserInfo?: (tokens: OAuth2Tokens) => Promise<User | null>;\n}\nOther Provider Configurations\n\nproviderId: A unique string to identify the OAuth provider configuration.\n\ndiscoveryUrl: (Optional) URL to fetch the provider's OAuth 2.0/OIDC configuration. If provided, endpoints like authorizationUrl, tokenUrl, and userInfoUrl can be auto-discovered.\n\nauthorizationUrl: (Optional) The OAuth provider's authorization endpoint. Not required if using discoveryUrl.\n\ntokenUrl: (Optional) The OAuth provider's token endpoint. Not required if using discoveryUrl.\n\nuserInfoUrl: (Optional) The endpoint to fetch user profile information. Not required if using discoveryUrl.\n\nclientId: The OAuth client ID issued by your provider.\n\nclientSecret: The OAuth client secret issued by your provider.\n\nscopes: (Optional) An array of scopes to request from the provider (e.g., [\"openid\", \"email\", \"profile\"]).\n\nredirectURI: (Optional) The redirect URI to use for the OAuth flow. If not set, a default is constructed based on your app's base URL.\n\nresponseType: (Optional) The OAuth response type. Defaults to \"code\" for authorization code flow.\n\nresponseMode: (Optional) The response mode for the authorization code request, such as \"query\" or \"form_post\".\n\nprompt: (Optional) Controls the authentication experience (e.g., force login, consent, etc.).\n\npkce: (Optional) If true, enables PKCE (Proof Key for Code Exchange) for enhanced security. Defaults to false.\n\naccessType: (Optional) The access type for the authorization request. Use \"offline\" to request a refresh token.\n\ngetUserInfo: (Optional) A custom function to fetch user info from the provider, given the OAuth tokens. If not provided, a default fetch is used.\n\nmapProfileToUser: (Optional) A function to map the provider's user profile to your app's user object. Useful for custom field mapping or transformations.\n\nauthorizationUrlParams: (Optional) Additional query parameters to add to the authorization URL. These can override default parameters. You can also provide a function that returns the parameters.\n\ntokenUrlParams: (Optional) Additional query parameters to add to the token URL. These can override default parameters. You can also provide a function that returns the parameters.\n\ndisableImplicitSignUp: (Optional) If true, disables automatic sign-up for new users. Sign-in must be explicitly requested with sign-up intent.\n\ndisableSignUp: (Optional) If true, disables sign-up for new users entirely. Only existing users can sign in.\n\nauthentication: (Optional) The authentication method for token requests. Can be 'basic' or 'post'. Defaults to 'post'.\n\ndiscoveryHeaders: (Optional) Custom headers to include in the discovery request. Useful for providers that require special headers.\n\nauthorizationHeaders: (Optional) Custom headers to include in the authorization request. Useful for providers that require special headers.\n\noverrideUserInfo: (Optional) If true, the user's info in your database will be updated with the provider's info every time they sign in. Defaults to false.\n\nAdvanced Usage\nCustom User Info Fetching\n\nYou can provide a custom getUserInfo function to handle specific provider requirements:\n\ngenericOAuth({\n  config: [\n    {\n      providerId: \"custom-provider\",\n      // ... other config options\n      getUserInfo: async (tokens) => {\n        // Custom logic to fetch and return user info\n        const userInfo = await fetchUserInfoFromCustomProvider(tokens);\n        return {\n          id: userInfo.sub,\n          email: userInfo.email,\n          name: userInfo.name,\n          // ... map other fields as needed\n        };\n      }\n    }\n  ]\n})\nMap User Info Fields\n\nIf the user info returned by the provider does not match the expected format, or you need to map additional fields, you can use the mapProfileToUser:\n\ngenericOAuth({\n  config: [\n    {\n      providerId: \"custom-provider\",\n      // ... other config options\n      mapProfileToUser: async (profile) => {\n        return {\n          firstName: profile.given_name,\n          // ... map other fields as needed\n        };\n      }\n    }\n  ]\n})\nError Handling\n\nThe plugin includes built-in error handling for common OAuth issues. Errors are typically redirected to your application's error page with an appropriate error message in the URL parameters. If the callback URL is not provided, the user will be redirected to Better Auth's default error page.\n\nEdit on GitHub\n\nPrevious Page\n\nPasskey\n\nNext Page\n\nOne Tap"
  },
  {
    "title": "Admin | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/admin",
    "html": "Admin\nCopy Markdown\nOpen in\n\nThe Admin plugin provides a set of administrative functions for user management in your application. It allows administrators to perform various operations such as creating users, managing user roles, banning/unbanning users, impersonating users, and more.\n\nInstallation\nAdd the plugin to your auth config\n\nTo use the Admin plugin, add it to your auth config.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { admin } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    // ... other config options\n    plugins: [\n        admin() \n    ]\n})\nMigrate the database\n\nRun the migration or generate the schema to add the necessary fields and tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nSee the Schema section to add the fields manually.\n\nAdd the client plugin\n\nNext, include the admin client plugin in your authentication client instance.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { adminClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n    plugins: [\n        adminClient()\n    ]\n})\nUsage\n\nBefore performing any admin operations, the user must be authenticated with an admin account. An admin is any user assigned the admin role or any user whose ID is included in the adminUserIds option.\n\nCreate User\n\nAllows an admin to create a new user.\n\nClient\nServer\nPOST\n/admin/create-user\nconst { data: newUser, error } = await authClient.admin.createUser({\n    email: \"user@example.com\", // required\n    password: \"some-secure-password\", // required\n    name: \"James Smith\", // required\n    role: \"user\",\n    data: { customField: \"customValue\" },\n});\nProp\tDescription\tType\nemail\t\nThe email of the user.\n\tstring\npassword\t\nThe password of the user.\n\tstring\nname\t\nThe name of the user.\n\tstring\nrole?\t\nA string or array of strings representing the roles to apply to the new user.\n\tstring | string[]\ndata?\t\nExtra fields for the user. Including custom additional fields.\n\tRecord<string, any>\nList Users\n\nAllows an admin to list all users in the database.\n\nClient\nServer\nGET\n/admin/list-users\nNotes\n\nAll properties are optional to configure. By default, 100 rows are returned, you can configure this by the limit property.\n\nconst { data: users, error } = await authClient.admin.listUsers({\n    query: {\n        searchValue: \"some name\",\n        searchField: \"name\",\n        searchOperator: \"contains\",\n        limit: 100,\n        offset: 100,\n        sortBy: \"name\",\n        sortDirection: \"desc\",\n        filterField: \"email\",\n        filterValue: \"hello@example.com\",\n        filterOperator: \"eq\",\n    },\n});\nProp\tDescription\tType\nsearchValue?\t\nThe value to search for.\n\tstring\nsearchField?\t\nThe field to search in, defaults to email. Can be email or name.\n\t\"email\" | \"name\"\nsearchOperator?\t\nThe operator to use for the search. Can be contains, starts_with or ends_with.\n\t\"contains\" | \"starts_with\" | \"ends_with\"\nlimit?\t\nThe number of users to return. Defaults to 100.\n\tstring | number\noffset?\t\nThe offset to start from.\n\tstring | number\nsortBy?\t\nThe field to sort by.\n\tstring\nsortDirection?\t\nThe direction to sort by.\n\t\"asc\" | \"desc\"\nfilterField?\t\nThe field to filter by.\n\tstring\nfilterValue?\t\nThe value to filter by.\n\tstring | number | boolean\nfilterOperator?\t\nThe operator to use for the filter.\n\t\"eq\" | \"ne\" | \"lt\" | \"lte\" | \"gt\" | \"gte\"\nQuery Filtering\n\nThe listUsers function supports various filter operators including eq, contains, starts_with, and ends_with.\n\nPagination\n\nThe listUsers function supports pagination by returning metadata alongside the user list. The response includes the following fields:\n\n{\n  users: User[],   // Array of returned users\n  total: number,   // Total number of users after filters and search queries\n  limit: number | undefined,   // The limit provided in the query\n  offset: number | undefined   // The offset provided in the query\n}\nHow to Implement Pagination\n\nTo paginate results, use the total, limit, and offset values to calculate:\n\nTotal pages: Math.ceil(total / limit)\nCurrent page: (offset / limit) + 1\nNext page offset: Math.min(offset + limit, (total - 1)) â€“ The value to use as offset for the next page, ensuring it does not exceed the total number of pages.\nPrevious page offset: Math.max(0, offset - limit) â€“ The value to use as offset for the previous page (ensuring it doesnâ€™t go below zero).\nExample Usage\n\nFetching the second page with 10 users per page:\n\nadmin.ts\nconst pageSize = 10;\nconst currentPage = 2;\nconst users = await authClient.admin.listUsers({\n    query: {\n        limit: pageSize,\n        offset: (currentPage - 1) * pageSize\n    }\n});\nconst totalUsers = users.total;\nconst totalPages = Math.ceil(totalUsers / pageSize)\nSet User Role\n\nChanges the role of a user.\n\nClient\nServer\nPOST\n/admin/set-role\nconst { data, error } = await authClient.admin.setRole({\n    userId: \"user-id\",\n    role: \"admin\", // required\n});\nProp\tDescription\tType\nuserId?\t\nThe user id which you want to set the role for.\n\tstring\nrole\t\nThe role to set, this can be a string or an array of strings.\n\tstring | string[]\nSet User Password\n\nChanges the password of a user.\n\nClient\nServer\nPOST\n/admin/set-user-password\nconst { data, error } = await authClient.admin.setUserPassword({\n    newPassword: 'new-password', // required\n    userId: 'user-id', // required\n});\nProp\tDescription\tType\nnewPassword\t\nThe new password.\n\tstring\nuserId\t\nThe user id which you want to set the password for.\n\tstring\nUpdate user\n\nUpdate a user's details.\n\nClient\nServer\nPOST\n/admin/update-user\nconst { data, error } = await authClient.admin.updateUser({\n    userId: \"user-id\", // required\n    data: { name: \"John Doe\" }, // required\n});\nProp\tDescription\tType\nuserId\t\nThe user id which you want to update.\n\tstring\ndata\t\nThe data to update.\n\tRecord<string, any>\nBan User\n\nBans a user, preventing them from signing in and revokes all of their existing sessions.\n\nClient\nServer\nPOST\n/admin/ban-user\nawait authClient.admin.banUser({\n    userId: \"user-id\", // required\n    banReason: \"Spamming\",\n    banExpiresIn: 60 * 60 * 24 * 7,\n});\nProp\tDescription\tType\nuserId\t\nThe user id which you want to ban.\n\tstring\nbanReason?\t\nThe reason for the ban.\n\tstring\nbanExpiresIn?\t\nThe number of seconds until the ban expires. If not provided, the ban will never expire.\n\tnumber\nUnban User\n\nRemoves the ban from a user, allowing them to sign in again.\n\nClient\nServer\nPOST\n/admin/unban-user\nawait authClient.admin.unbanUser({\n    userId: \"user-id\", // required\n});\nProp\tDescription\tType\nuserId\t\nThe user id which you want to unban.\n\tstring\nList User Sessions\n\nLists all sessions for a user.\n\nClient\nServer\nPOST\n/admin/list-user-sessions\nconst { data, error } = await authClient.admin.listUserSessions({\n    userId: \"user-id\", // required\n});\nProp\tDescription\tType\nuserId\t\nThe user id.\n\tstring\nRevoke User Session\n\nRevokes a specific session for a user.\n\nClient\nServer\nPOST\n/admin/revoke-user-session\nconst { data, error } = await authClient.admin.revokeUserSession({\n    sessionToken: \"session_token_here\", // required\n});\nProp\tDescription\tType\nsessionToken\t\nThe session token which you want to revoke.\n\tstring\nRevoke All Sessions for a User\n\nRevokes all sessions for a user.\n\nClient\nServer\nPOST\n/admin/revoke-user-sessions\nconst { data, error } = await authClient.admin.revokeUserSessions({\n    userId: \"user-id\", // required\n});\nProp\tDescription\tType\nuserId\t\nThe user id which you want to revoke all sessions for.\n\tstring\nImpersonate User\n\nThis feature allows an admin to create a session that mimics the specified user. The session will remain active until either the browser session ends or it reaches 1 hour. You can change this duration by setting the impersonationSessionDuration option.\n\nClient\nServer\nPOST\n/admin/impersonate-user\nconst { data, error } = await authClient.admin.impersonateUser({\n    userId: \"user-id\", // required\n});\nProp\tDescription\tType\nuserId\t\nThe user id which you want to impersonate.\n\tstring\nStop Impersonating User\n\nTo stop impersonating a user and continue with the admin account, you can use stopImpersonating\n\nClient\nServer\nPOST\n/admin/stop-impersonating\nawait authClient.admin.stopImpersonating();\nRemove User\n\nHard deletes a user from the database.\n\nClient\nServer\nPOST\n/admin/remove-user\nconst { data: deletedUser, error } = await authClient.admin.removeUser({\n    userId: \"user-id\", // required\n});\nProp\tDescription\tType\nuserId\t\nThe user id which you want to remove.\n\tstring\nAccess Control\n\nThe admin plugin offers a highly flexible access control system, allowing you to manage user permissions based on their role. You can define custom permission sets to fit your needs.\n\nRoles\n\nBy default, there are two roles:\n\nadmin: Users with the admin role have full control over other users.\n\nuser: Users with the user role have no control over other users.\n\nA user can have multiple roles. Multiple roles are stored as string separated by comma (\",\").\n\nPermissions\n\nBy default, there are two resources with up to six permissions.\n\nuser: create list set-role ban impersonate delete set-password\n\nsession: list revoke delete\n\nUsers with the admin role have full control over all the resources and actions. Users with the user role have no control over any of those actions.\n\nCustom Permissions\n\nThe plugin provides an easy way to define your own set of permissions for each role.\n\nCreate Access Control\n\nYou first need to create an access controller by calling the createAccessControl function and passing the statement object. The statement object should have the resource name as the key and the array of actions as the value.\n\npermissions.ts\nimport { createAccessControl } from \"better-auth/plugins/access\";\n/**\n * make sure to use `as const` so typescript can infer the type correctly\n */\nconst statement = { \n    project: [\"create\", \"share\", \"update\", \"delete\"], \n} as const; \nconst ac = createAccessControl(statement); \nCreate Roles\n\nOnce you have created the access controller you can create roles with the permissions you have defined.\n\npermissions.ts\nimport { createAccessControl } from \"better-auth/plugins/access\";\nexport const statement = {\n    project: [\"create\", \"share\", \"update\", \"delete\"], // <-- Permissions available for created roles\n} as const;\nconst ac = createAccessControl(statement);\nexport const user = ac.newRole({ \n    project: [\"create\"], \n}); \nexport const admin = ac.newRole({ \n    project: [\"create\", \"update\"], \n}); \nexport const myCustomRole = ac.newRole({ \n    project: [\"create\", \"update\", \"delete\"], \n    user: [\"ban\"], \n}); \n\nWhen you create custom roles for existing roles, the predefined permissions for those roles will be overridden. To add the existing permissions to the custom role, you need to import defaultStatements and merge it with your new statement, plus merge the roles' permissions set with the default roles.\n\npermissions.ts\nimport { createAccessControl } from \"better-auth/plugins/access\";\nimport { defaultStatements, adminAc } from \"better-auth/plugins/admin/access\";\nconst statement = {\n    ...defaultStatements, \n    project: [\"create\", \"share\", \"update\", \"delete\"],\n} as const;\nconst ac = createAccessControl(statement);\nconst admin = ac.newRole({\n    project: [\"create\", \"update\"],\n    ...adminAc.statements, \n});\nPass Roles to the Plugin\n\nOnce you have created the roles you can pass them to the admin plugin both on the client and the server.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { admin as adminPlugin } from \"better-auth/plugins\"\nimport { ac, admin, user } from \"@/auth/permissions\"\nexport const auth = betterAuth({\n    plugins: [\n        adminPlugin({\n            ac,\n            roles: {\n                admin,\n                user,\n                myCustomRole\n            }\n        }),\n    ],\n});\n\nYou also need to pass the access controller and the roles to the client plugin.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { adminClient } from \"better-auth/client/plugins\"\nimport { ac, admin, user, myCustomRole } from \"@/auth/permissions\"\nexport const client = createAuthClient({\n    plugins: [\n        adminClient({\n            ac,\n            roles: {\n                admin,\n                user,\n                myCustomRole\n            }\n        })\n    ]\n})\nAccess Control Usage\n\nHas Permission:\n\nTo check a user's permissions, you can use the hasPermission function provided by the client.\n\nClient\nServer\nPOST\n/admin/has-permission\nconst { data, error } = await authClient.admin.hasPermission({\n    userId: \"user-id\",\n    permission: { \"project\": [\"create\", \"update\"] } /* Must use this, or permissions */,\n    permissions,\n});\nProp\tDescription\tType\nuserId?\t\nThe user id which you want to check the permissions for.\n\tstring\npermission?\t\nOptionally check if a single permission is granted. Must use this, or permissions.\n\tRecord<string, string[]>\npermissions?\t\nOptionally check if multiple permissions are granted. Must use this, or permission.\n\tRecord<string, string[]>\n\nExample usage:\n\nauth-client.ts\nconst canCreateProject = await authClient.admin.hasPermission({\n  permissions: {\n    project: [\"create\"],\n  },\n});\n// You can also check multiple resource permissions at the same time\nconst canCreateProjectAndCreateSale = await authClient.admin.hasPermission({\n  permissions: {\n    project: [\"create\"],\n    sale: [\"create\"]\n  },\n});\n\nIf you want to check a user's permissions server-side, you can use the userHasPermission action provided by the api to check the user's permissions.\n\napi.ts\nimport { auth } from \"@/auth\";\nawait auth.api.userHasPermission({\n  body: {\n    userId: 'id', //the user id\n    permissions: {\n      project: [\"create\"], // This must match the structure in your access control\n    },\n  },\n});\n// You can also just pass the role directly\nawait auth.api.userHasPermission({\n  body: {\n   role: \"admin\",\n    permissions: {\n      project: [\"create\"], // This must match the structure in your access control\n    },\n  },\n});\n// You can also check multiple resource permissions at the same time\nawait auth.api.userHasPermission({\n  body: {\n   role: \"admin\",\n    permissions: {\n      project: [\"create\"], // This must match the structure in your access control\n      sale: [\"create\"]\n    },\n  },\n});\n\nCheck Role Permission:\n\nUse the checkRolePermission function on the client side to verify whether a given role has a specific permission. This is helpful after defining roles and their permissions, as it allows you to perform permission checks without needing to contact the server.\n\nNote that this function does not check the permissions of the currently logged-in user directly. Instead, it checks what permissions are assigned to a specified role. The function is synchronous, so you don't need to use await when calling it.\n\nauth-client.ts\nconst canCreateProject = authClient.admin.checkRolePermission({\n  permissions: {\n    user: [\"delete\"],\n  },\n  role: \"admin\",\n});\n// You can also check multiple resource permissions at the same time\nconst canDeleteUserAndRevokeSession = authClient.admin.checkRolePermission({\n  permissions: {\n    user: [\"delete\"],\n    session: [\"revoke\"]\n  },\n  role: \"admin\",\n});\nSchema\n\nThis plugin adds the following fields to the user table:\n\nField Name\tType\tKey\tDescription\nrole\tstring\t?\tThe user's role. Defaults to `user`. Admins will have the `admin` role.\nbanned\tboolean\t?\tIndicates whether the user is banned.\nbanReason\tstring\t?\tThe reason for the user's ban.\nbanExpires\tdate\t?\tThe date when the user's ban will expire.\n\nAnd adds one field in the session table:\n\nField Name\tType\tKey\tDescription\nimpersonatedBy\tstring\t?\tThe ID of the admin that is impersonating this session.\nOptions\nDefault Role\n\nThe default role for a user. Defaults to user.\n\nauth.ts\nadmin({\n  defaultRole: \"regular\",\n});\nAdmin Roles\n\nThe roles that are considered admin roles when not using custom access control. Defaults to [\"admin\"].\n\nauth.ts\nadmin({\n  adminRoles: [\"admin\", \"superadmin\"],\n});\n\nNote: The adminRoles option is not required when using custom access control (via ac and roles). When you define custom roles with specific permissions, those roles will have exactly the permissions you grant them through the access control system.\n\nWarning: When not using custom access control, any role that isn't in the adminRoles list will not be able to perform admin operations.\n\nAdmin userIds\n\nYou can pass an array of userIds that should be considered as admin. Default to []\n\nauth.ts\nadmin({\n    adminUserIds: [\"user_id_1\", \"user_id_2\"]\n})\n\nIf a user is in the adminUserIds list, they will be able to perform any admin operation.\n\nimpersonationSessionDuration\n\nThe duration of the impersonation session in seconds. Defaults to 1 hour.\n\nauth.ts\nadmin({\n  impersonationSessionDuration: 60 * 60 * 24, // 1 day\n});\nDefault Ban Reason\n\nThe default ban reason for a user created by the admin. Defaults to No reason.\n\nauth.ts\nadmin({\n  defaultBanReason: \"Spamming\",\n});\nDefault Ban Expires In\n\nThe default ban expires in for a user created by the admin in seconds. Defaults to undefined (meaning the ban never expires).\n\nauth.ts\nadmin({\n  defaultBanExpiresIn: 60 * 60 * 24, // 1 day\n});\nbannedUserMessage\n\nThe message to show when a banned user tries to sign in. Defaults to \"You have been banned from this application. Please contact support if you believe this is an error.\"\n\nauth.ts\nadmin({\n  bannedUserMessage: \"Custom banned user message\",\n});\nEdit on GitHub\n\nPrevious Page\n\nAuthorization\n\nNext Page\n\nAPI Key"
  },
  {
    "title": "Sign In With Ethereum (SIWE) | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/siwe",
    "html": "Sign In With Ethereum (SIWE)\nCopy Markdown\nOpen in\n\nThe Sign in with Ethereum (SIWE) plugin allows users to authenticate using their Ethereum wallets following the ERC-4361 standard. This plugin provides flexibility by allowing you to implement your own message verification and nonce generation logic.\n\nInstallation\nAdd the Server Plugin\n\nAdd the SIWE plugin to your auth configuration:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { siwe } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n    plugins: [\n        siwe({\n            domain: \"example.com\",\n            emailDomainName: \"example.com\", // optional\n            anonymous: false, // optional, default is true\n            getNonce: async () => {\n                // Implement your nonce generation logic here\n                return \"your-secure-random-nonce\";\n            },\n            verifyMessage: async (args) => {\n                // Implement your SIWE message verification logic here\n                // This should verify the signature against the message\n                return true; // return true if signature is valid\n            },\n            ensLookup: async (args) => {\n                // Optional: Implement ENS lookup for user names and avatars\n                return {\n                    name: \"user.eth\",\n                    avatar: \"https://example.com/avatar.png\"\n                };\n            },\n        }),\n    ],\n});\nMigrate the database\n\nRun the migration or generate the schema to add the necessary fields and tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nSee the Schema section to add the fields manually.\n\nAdd the Client Plugin\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nimport { siweClient } from \"better-auth/client/plugins\";\nexport const authClient = createAuthClient({\n    plugins: [siweClient()],\n});\nUsage\nGenerate a Nonce\n\nBefore signing a SIWE message, you need to generate a nonce for the wallet address:\n\ngenerate-nonce.ts\nconst { data, error } = await authClient.siwe.nonce({\n  walletAddress: \"0x1234567890abcdef1234567890abcdef12345678\",\n  chainId: 1, // optional for Ethereum mainnet, required for other chains. Defaults to 1\n});\nif (data) {\n  console.log(\"Nonce:\", data.nonce);\n}\nSign In with Ethereum\n\nAfter generating a nonce and creating a SIWE message, verify the signature to authenticate:\n\nsign-in-siwe.ts\nconst { data, error } = await authClient.siwe.verify({\n  message: \"Your SIWE message string\",\n  signature: \"0x...\", // The signature from the user's wallet\n  walletAddress: \"0x1234567890abcdef1234567890abcdef12345678\",\n  chainId: 1, // optional for Ethereum mainnet, required for other chains. Must match Chain ID in SIWE message\n  email: \"user@example.com\", // optional, required if anonymous is false\n});\nif (data) {\n  console.log(\"Authentication successful:\", data.user);\n}\nChain-Specific Examples\n\nHere are examples for different blockchain networks:\n\nethereum-mainnet.ts\n// Ethereum Mainnet (chainId can be omitted, defaults to 1)\nconst { data, error } = await authClient.siwe.verify({\n  message,\n  signature,\n  walletAddress,\n  // chainId: 1 (default)\n});\npolygon.ts\n// Polygon (chainId REQUIRED)\nconst { data, error } = await authClient.siwe.verify({\n  message,\n  signature,\n  walletAddress,\n  chainId: 137, // Required for Polygon\n});\narbitrum.ts\n// Arbitrum (chainId REQUIRED)\nconst { data, error } = await authClient.siwe.verify({\n  message,\n  signature,\n  walletAddress,\n  chainId: 42161, // Required for Arbitrum\n});\nbase.ts\n// Base (chainId REQUIRED)\nconst { data, error } = await authClient.siwe.verify({\n  message,\n  signature,\n  walletAddress,\n  chainId: 8453, // Required for Base\n});\n\nThe chainId must match the Chain ID specified in your SIWE message. Verification will fail with a 401 error if there's a mismatch between the message's Chain ID and the chainId parameter.\n\nConfiguration Options\nServer Options\n\nThe SIWE plugin accepts the following configuration options:\n\ndomain: The domain name of your application (required for SIWE message generation)\nemailDomainName: The email domain name for creating user accounts when not using anonymous mode. Defaults to the domain from your base URL\nanonymous: Whether to allow anonymous sign-ins without requiring an email. Default is true\ngetNonce: Function to generate a unique nonce for each sign-in attempt. You must implement this function to return a cryptographically secure random string. Must return a Promise<string>\nverifyMessage: Function to verify the signed SIWE message. Receives message details and should return Promise<boolean>\nensLookup: Optional function to lookup ENS names and avatars for Ethereum addresses\nClient Options\n\nThe SIWE client plugin doesn't require any configuration options, but you can pass them if needed for future extensibility:\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nimport { siweClient } from \"better-auth/client/plugins\";\nexport const authClient = createAuthClient({\n  plugins: [\n    siweClient({\n      // Optional client configuration can go here\n    }),\n  ],\n});\nSchema\n\nThe SIWE plugin adds a walletAddress table to store user wallet associations:\n\nField\tType\tDescription\nid\tstring\tPrimary key\nuserId\tstring\tReference to user.id\naddress\tstring\tEthereum wallet address\nchainId\tnumber\tChain ID (e.g., 1 for Ethereum mainnet)\nisPrimary\tboolean\tWhether this is the user's primary wallet\ncreatedAt\tdate\tCreation timestamp\nExample Implementation\n\nHere's a complete example showing how to implement SIWE authentication:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { siwe } from \"better-auth/plugins\";\nimport { generateRandomString } from \"better-auth/crypto\";\nimport { verifyMessage, createPublicClient, http } from \"viem\";\nimport { mainnet } from \"viem/chains\";\nexport const auth = betterAuth({\n  database: {\n    // your database configuration\n  },\n  plugins: [\n    siwe({\n      domain: \"myapp.com\",\n      emailDomainName: \"myapp.com\",\n      anonymous: false,\n      getNonce: async () => {\n        // Generate a cryptographically secure random nonce\n        return generateRandomString(32);\n      },\n      verifyMessage: async ({ message, signature, address }) => {\n        try {\n          // Verify the signature using viem (recommended)\n          const isValid = await verifyMessage({\n            address: address as `0x${string}`,\n            message,\n            signature: signature as `0x${string}`,\n          });\n          return isValid;\n        } catch (error) {\n          console.error(\"SIWE verification failed:\", error);\n          return false;\n        }\n      },\n      ensLookup: async ({ walletAddress }) => {\n        try {\n          // Optional: lookup ENS name and avatar using viem\n          // You can use viem's ENS utilities here\n          const client = createPublicClient({\n            chain: mainnet,\n            transport: http(),\n          });\n          const ensName = await client.getEnsName({\n            address: walletAddress as `0x${string}`,\n          });\n          const ensAvatar = ensName\n            ? await client.getEnsAvatar({\n                name: ensName,\n              })\n            : null;\n          return {\n            name: ensName || walletAddress,\n            avatar: ensAvatar || \"\",\n          };\n        } catch {\n          return {\n            name: walletAddress,\n            avatar: \"\",\n          };\n        }\n      },\n    }),\n  ],\n});\nEdit on GitHub\n\nPrevious Page\n\nOne Tap\n\nNext Page\n\nAuthorization"
  },
  {
    "title": "MCP | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/mcp",
    "html": "MCP\nCopy Markdown\nOpen in\n\nOAuth MCP\n\nThe MCP plugin lets your app act as an OAuth provider for MCP clients. It handles authentication and makes it easy to issue and manage access tokens for MCP applications.\n\nInstallation\nAdd the Plugin\n\nAdd the MCP plugin to your auth configuration and specify the login page path.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { mcp } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n    plugins: [\n        mcp({\n            loginPage: \"/sign-in\" // path to your login page\n        })\n    ]\n});\n\nThis doesn't have a client plugin, so you don't need to make any changes to your authClient.\n\nGenerate Schema\n\nRun the migration or generate the schema to add the necessary fields and tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nThe MCP plugin uses the same schema as the OIDC Provider plugin. See the OIDC Provider Schema section for details.\n\nUsage\nOAuth Discovery Metadata\n\nBetter Auth already handles the /api/auth/.well-known/oauth-authorization-server route automatically but some client may fail to parse the WWW-Authenticate header and default to /.well-known/oauth-authorization-server (this can happen, for example, if your CORS configuration doesn't expose the WWW-Authenticate). For this reason it's better to add a route to expose OAuth metadata for MCP clients:\n\n.well-known/oauth-authorization-server/route.ts\nimport { oAuthDiscoveryMetadata } from \"better-auth/plugins\";\nimport { auth } from \"../../../lib/auth\";\nexport const GET = oAuthDiscoveryMetadata(auth);\nOAuth Protected Resource Metadata\n\nBetter Auth already handles the /api/auth/.well-known/oauth-protected-resource route automatically but some client may fail to parse the WWW-Authenticate header and default to /.well-known/oauth-protected-resource (this can happen, for example, if your CORS configuration doesn't expose the WWW-Authenticate). For this reason it's better to add a route to expose OAuth metadata for MCP clients:\n\n/.well-known/oauth-protected-resource/route.ts\nimport { oAuthProtectedResourceMetadata } from \"better-auth/plugins\";\nimport { auth } from \"@/lib/auth\";\nexport const GET = oAuthProtectedResourceMetadata(auth);\nMCP Session Handling\n\nYou can use the helper function withMcpAuth to get the session and handle unauthenticated calls automatically.\n\napi/[transport]/route.ts\nimport { auth } from \"@/lib/auth\";\nimport { createMcpHandler } from \"@vercel/mcp-adapter\";\nimport { withMcpAuth } from \"better-auth/plugins\";\nimport { z } from \"zod\";\nconst handler = withMcpAuth(auth, (req, session) => {\n    // session contains the access token record with scopes and user ID\n    return createMcpHandler(\n        (server) => {\n            server.tool(\n                \"echo\",\n                \"Echo a message\",\n                { message: z.string() },\n                async ({ message }) => {\n                    return {\n                        content: [{ type: \"text\", text: `Tool echo: ${message}` }],\n                    };\n                },\n            );\n        },\n        {\n            capabilities: {\n                tools: {\n                    echo: {\n                        description: \"Echo a message\",\n                    },\n                },\n            },\n        },\n        {\n            redisUrl: process.env.REDIS_URL,\n            basePath: \"/api\",\n            verboseLogs: true,\n            maxDuration: 60,\n        },\n    )(req);\n});\nexport { handler as GET, handler as POST, handler as DELETE };\n\nYou can also use auth.api.getMcpSession to get the session using the access token sent from the MCP client:\n\napi/[transport]/route.ts\nimport { auth } from \"@/lib/auth\";\nimport { createMcpHandler } from \"@vercel/mcp-adapter\";\nimport { z } from \"zod\";\nconst handler = async (req: Request) => {\n     // session contains the access token record with scopes and user ID\n    const session = await auth.api.getMcpSession({\n        headers: req.headers\n    })\n    if(!session){\n        //this is important and you must return 401\n        return new Response(null, {\n            status: 401\n        })\n    }\n    return createMcpHandler(\n        (server) => {\n            server.tool(\n                \"echo\",\n                \"Echo a message\",\n                { message: z.string() },\n                async ({ message }) => {\n                    return {\n                        content: [{ type: \"text\", text: `Tool echo: ${message}` }],\n                    };\n                },\n            );\n        },\n        {\n            capabilities: {\n                tools: {\n                    echo: {\n                        description: \"Echo a message\",\n                    },\n                },\n            },\n        },\n        {\n            redisUrl: process.env.REDIS_URL,\n            basePath: \"/api\",\n            verboseLogs: true,\n            maxDuration: 60,\n        },\n    )(req);\n}\nexport { handler as GET, handler as POST, handler as DELETE };\nConfiguration\n\nThe MCP plugin accepts the following configuration options:\n\nProp\n\nType\n\nloginPage\nstring\nresource?\nstring\noidcConfig?\nobject\nOIDC Configuration\n\nThe plugin supports additional OIDC configuration options through the oidcConfig parameter:\n\nProp\n\nType\n\ncodeExpiresIn?\nnumber\naccessTokenExpiresIn?\nnumber\nrefreshTokenExpiresIn?\nnumber\ndefaultScope?\nstring\nscopes?\nstring[]\nSchema\n\nThe MCP plugin uses the same schema as the OIDC Provider plugin. See the OIDC Provider Schema section for details.\n\nEdit on GitHub\n\nPrevious Page\n\nAPI Key\n\nNext Page\n\nOrganization"
  },
  {
    "title": "API Key | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/api-key",
    "html": "API Key\nCopy Markdown\nOpen in\n\nThe API Key plugin allows you to create and manage API keys for your application. It provides a way to authenticate and authorize API requests by verifying API keys.\n\nFeatures\nCreate, manage, and verify API keys\nBuilt-in rate limiting\nCustom expiration times, remaining count, and refill systems\nmetadata for API keys\nCustom prefix\nSessions from API keys\nInstallation\nAdd Plugin to the server\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { apiKey } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    plugins: [ \n        apiKey() \n    ] \n})\nMigrate the database\n\nRun the migration or generate the schema to add the necessary fields and tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nSee the Schema section to add the fields manually.\n\nAdd the client plugin\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { apiKeyClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n    plugins: [ \n        apiKeyClient() \n    ] \n})\nUsage\n\nYou can view the list of API Key plugin options here.\n\nCreate an API key\nClient\nServer\nPOST\n/api-key/create\nNotes\n\nYou can adjust more specific API key configurations by using the server method instead.\n\nconst { data, error } = await authClient.apiKey.create({\n    name: 'project-api-key',\n    expiresIn: 60 * 60 * 24 * 7,\n    prefix: 'project-api-key',\n    metadata: { someKey: 'someValue' },\n    permissions,\n});\nProp\tDescription\tType\nname?\t\nName of the Api Key.\n\tstring\nexpiresIn?\t\nExpiration time of the Api Key in seconds.\n\tnumber\nprefix?\t\nPrefix of the Api Key.\n\tstring\nmetadata?\t\nMetadata of the Api Key.\n\tany | null\npermissions?\t\nPermissions of the Api Key.\n\tRecord<string, string[]>\nAPI keys are assigned to a user.\nResult\n\nIt'll return the ApiKey object which includes the key value for you to use. Otherwise if it throws, it will throw an APIError.\n\nVerify an API key\nClient\nServer\nPOST\n/api-key/verify\nconst permissions = { // Permissions to check are optional.\n  projects: [\"read\", \"read-write\"],\n}\nconst data = await auth.api.verifyApiKey({\n    body: {\n        key: \"your_api_key_here\", // required\n        permissions,\n    },\n});\nProp\tDescription\tType\nkey\t\nThe key to verify.\n\tstring\npermissions?\t\nThe permissions to verify. Optional.\n\tRecord<string, string[]>\nResult\ntype Result = {\n  valid: boolean;\n  error: { message: string; code: string } | null;\n  key: Omit<ApiKey, \"key\"> | null;\n};\nGet an API key\nClient\nServer\nGET\n/api-key/get\nconst { data, error } = await authClient.apiKey.get({\n    query: {\n        id: \"some-api-key-id\", // required\n    },\n});\nProp\tDescription\tType\nid\t\nThe id of the Api Key.\n\tstring\nResult\n\nYou'll receive everything about the API key details, except for the key value itself. If it fails, it will throw an APIError.\n\ntype Result = Omit<ApiKey, \"key\">;\nUpdate an API key\nClient\nServer\nPOST\n/api-key/update\nconst { data, error } = await authClient.apiKey.update({\n    keyId: \"some-api-key-id\", // required\n    name: \"some-api-key-name\",\n});\nProp\tDescription\tType\nkeyId\t\nThe id of the Api Key to update.\n\tstring\nname?\t\nThe name of the key.\n\tstring\nResult\n\nIf fails, throws APIError. Otherwise, you'll receive the API Key details, except for the key value itself.\n\nDelete an API Key\nClient\nServer\nPOST\n/api-key/delete\nNotes\n\nThis endpoint is attempting to delete the API key from the perspective of the user. It will check if the user's ID matches the key owner to be able to delete it. If you want to delete a key without these checks, we recommend you use an ORM to directly mutate your DB instead.\n\nconst { data, error } = await authClient.apiKey.delete({\n    keyId: \"some-api-key-id\", // required\n});\nProp\tDescription\tType\nkeyId\t\nThe id of the Api Key to delete.\n\tstring\nResult\n\nIf fails, throws APIError. Otherwise, you'll receive:\n\ntype Result = {\n  success: boolean;\n};\nList API keys\nClient\nServer\nGET\n/api-key/list\nconst { data, error } = await authClient.apiKey.list();\nResult\n\nIf fails, throws APIError. Otherwise, you'll receive:\n\ntype Result = ApiKey[];\nDelete all expired API keys\n\nThis function will delete all API keys that have an expired expiration date.\n\nClient\nServer\nPOST\n/api-key/delete-all-expired-api-keys\nconst data = await auth.api.deleteAllExpiredApiKeys();\n\nWe automatically delete expired API keys every time any apiKey plugin endpoints were called, however they are rate-limited to a 10 second cool down each call to prevent multiple calls to the database.\n\nSessions from API keys\n\nAny time an endpoint in Better Auth is called that has a valid API key in the headers, you can automatically create a mock session to represent the user by enabling sessionForAPIKeys option.\n\nThis is generally not recommended, as it can lead to security issues if not used carefully. A leaked api key can be used to impersonate a user.\n\nexport const auth = betterAuth({\n  plugins: [\n    apiKey({\n      enableSessionForAPIKeys: true,\n    }),\n  ],\n});\nServer\nconst session = await auth.api.getSession({\n      headers: new Headers({\n            'x-api-key': apiKey,\n      }),\n});\n\nThe default header key is x-api-key, but this can be changed by setting the apiKeyHeaders option in the plugin options.\n\nexport const auth = betterAuth({\n  plugins: [\n    apiKey({\n      apiKeyHeaders: [\"x-api-key\", \"xyz-api-key\"], // or you can pass just a string, eg: \"x-api-key\"\n    }),\n  ],\n});\n\nOr optionally, you can pass an apiKeyGetter function to the plugin options, which will be called with the GenericEndpointContext, and from there, you should return the API key, or null if the request is invalid.\n\nexport const auth = betterAuth({\n  plugins: [\n    apiKey({\n      apiKeyGetter: (ctx) => {\n        const has = ctx.request.headers.has(\"x-api-key\");\n        if (!has) return null;\n        return ctx.request.headers.get(\"x-api-key\");\n      },\n    }),\n  ],\n});\nRate Limiting\n\nEvery API key can have its own rate limit settings, however, the built-in rate-limiting only applies to the verification process for a given API key. For every other endpoint/method, you should utilize Better Auth's built-in rate-limiting.\n\nYou can refer to the rate-limit default configurations below in the API Key plugin options.\n\nAn example default value:\n\nexport const auth = betterAuth({\n  plugins: [\n    apiKey({\n      rateLimit: {\n        enabled: true,\n        timeWindow: 1000 * 60 * 60 * 24, // 1 day\n        maxRequests: 10, // 10 requests per day\n      },\n    }),\n  ],\n});\n\nFor each API key, you can customize the rate-limit options on create.\n\nYou can only customize the rate-limit options on the server auth instance.\n\nconst apiKey = await auth.api.createApiKey({\n  body: {\n    rateLimitEnabled: true,\n    rateLimitTimeWindow: 1000 * 60 * 60 * 24, // 1 day\n    rateLimitMax: 10, // 10 requests per day\n  },\n  headers: user_headers,\n});\nHow does it work?\n\nFor each request, a counter (internally called requestCount) is incremented. If the rateLimitMax is reached, the request will be rejected until the timeWindow has passed, at which point the timeWindow will be reset.\n\nRemaining, refill, and expiration\n\nThe remaining count is the number of requests left before the API key is disabled. The refill interval is the interval in milliseconds where the remaining count is refilled by day. The expiration time is the expiration date of the API key.\n\nHow does it work?\nRemaining:\n\nWhenever an API key is used, the remaining count is updated. If the remaining count is null, then there is no cap to key usage. Otherwise, the remaining count is decremented by 1. If the remaining count is 0, then the API key is disabled & removed.\n\nrefillInterval & refillAmount:\n\nWhenever an API key is created, the refillInterval and refillAmount are set to null. This means that the API key will not be refilled automatically. However, if refillInterval & refillAmount are set, then the API key will be refilled accordingly.\n\nExpiration:\n\nWhenever an API key is created, the expiresAt is set to null. This means that the API key will never expire. However, if the expiresIn is set, then the API key will expire after the expiresIn time.\n\nCustom Key generation & verification\n\nYou can customize the key generation and verification process straight from the plugin options.\n\nHere's an example:\n\nexport const auth = betterAuth({\n  plugins: [\n    apiKey({\n      customKeyGenerator: (options: {\n        length: number;\n        prefix: string | undefined;\n      }) => {\n        const apiKey = mySuperSecretApiKeyGenerator(\n          options.length,\n          options.prefix\n        );\n        return apiKey;\n      },\n      customAPIKeyValidator: async ({ ctx, key }) => {\n        const res = await keyService.verify(key)\n        return res.valid\n      },\n    }),\n  ],\n});\n\nIf you're not using the length property provided by customKeyGenerator, you must set the defaultKeyLength property to how long generated keys will be.\n\nexport const auth = betterAuth({\n  plugins: [\n    apiKey({\n      customKeyGenerator: () => {\n        return crypto.randomUUID();\n      },\n      defaultKeyLength: 36, // Or whatever the length is\n    }),\n  ],\n});\n\nIf an API key is validated from your customAPIKeyValidator, we still must match that against the database's key. However, by providing this custom function, you can improve the performance of the API key verification process, as all failed keys can be invalidated without having to query your database.\n\nMetadata\n\nWe allow you to store metadata alongside your API keys. This is useful for storing information about the key, such as a subscription plan for example.\n\nTo store metadata, make sure you haven't disabled the metadata feature in the plugin options.\n\nexport const auth = betterAuth({\n  plugins: [\n    apiKey({\n      enableMetadata: true,\n    }),\n  ],\n});\n\nThen, you can store metadata in the metadata field of the API key object.\n\nconst apiKey = await auth.api.createApiKey({\n  body: {\n    metadata: {\n      plan: \"premium\",\n    },\n  },\n});\n\nYou can then retrieve the metadata from the API key object.\n\nconst apiKey = await auth.api.getApiKey({\n  body: {\n    keyId: \"your_api_key_id_here\",\n  },\n});\nconsole.log(apiKey.metadata.plan); // \"premium\"\nAPI Key plugin options\n\napiKeyHeaders string | string[];\n\nThe header name to check for API key. Default is x-api-key.\n\ncustomAPIKeyGetter (ctx: GenericEndpointContext) => string | null\n\nA custom function to get the API key from the context.\n\ncustomAPIKeyValidator (options: { ctx: GenericEndpointContext; key: string; }) => boolean | Promise<boolean>\n\nA custom function to validate the API key.\n\ncustomKeyGenerator (options: { length: number; prefix: string | undefined; }) => string | Promise<string>\n\nA custom function to generate the API key.\n\nstartingCharactersConfig { shouldStore?: boolean; charactersLength?: number; }\n\nCustomize the starting characters configuration.\n\nstartingCharactersConfig Options\n\ndefaultKeyLength number\n\nThe length of the API key. Longer is better. Default is 64. (Doesn't include the prefix length)\n\ndefaultPrefix string\n\nThe prefix of the API key.\n\nNote: We recommend you append an underscore to the prefix to make the prefix more identifiable. (eg hello_)\n\nmaximumPrefixLength number\n\nThe maximum length of the prefix.\n\nminimumPrefixLength number\n\nThe minimum length of the prefix.\n\nrequireName boolean\n\nWhether to require a name for the API key. Default is false.\n\nmaximumNameLength number\n\nThe maximum length of the name.\n\nminimumNameLength number\n\nThe minimum length of the name.\n\nenableMetadata boolean\n\nWhether to enable metadata for an API key.\n\nkeyExpiration { defaultExpiresIn?: number | null; disableCustomExpiresTime?: boolean; minExpiresIn?: number; maxExpiresIn?: number; }\n\nCustomize the key expiration.\n\nkeyExpiration options\n\nrateLimit { enabled?: boolean; timeWindow?: number; maxRequests?: number; }\n\nCustomize the rate-limiting.\n\nrateLimit options\n\nschema InferOptionSchema<ReturnType<typeof apiKeySchema>>\n\nCustom schema for the API key plugin.\n\nenableSessionForAPIKeys boolean\n\nAn API Key can represent a valid session, so we can mock a session for the user if we find a valid API key in the request headers. Default is false.\n\npermissions { defaultPermissions?: Statements | ((userId: string, ctx: GenericEndpointContext) => Statements | Promise<Statements>) }\n\nPermissions for the API key.\n\nRead more about permissions here.\n\npermissions Options\n\ndisableKeyHashing boolean\n\nDisable hashing of the API key.\n\nâš ï¸ Security Warning: It's strongly recommended to not disable hashing. Storing API keys in plaintext makes them vulnerable to database breaches, potentially exposing all your users' API keys.\n\nPermissions\n\nAPI keys can have permissions associated with them, allowing you to control access at a granular level. Permissions are structured as a record of resource types to arrays of allowed actions.\n\nSetting Default Permissions\n\nYou can configure default permissions that will be applied to all newly created API keys:\n\nexport const auth = betterAuth({\n  plugins: [\n    apiKey({\n      permissions: {\n        defaultPermissions: {\n          files: [\"read\"],\n          users: [\"read\"],\n        },\n      },\n    }),\n  ],\n});\n\nYou can also provide a function that returns permissions dynamically:\n\nexport const auth = betterAuth({\n  plugins: [\n    apiKey({\n      permissions: {\n        defaultPermissions: async (userId, ctx) => {\n          // Fetch user role or other data to determine permissions\n          return {\n            files: [\"read\"],\n            users: [\"read\"],\n          };\n        },\n      },\n    }),\n  ],\n});\nCreating API Keys with Permissions\n\nWhen creating an API key, you can specify custom permissions:\n\nconst apiKey = await auth.api.createApiKey({\n  body: {\n    name: \"My API Key\",\n    permissions: {\n      files: [\"read\", \"write\"],\n      users: [\"read\"],\n    },\n    userId: \"userId\",\n  },\n});\nVerifying API Keys with Required Permissions\n\nWhen verifying an API key, you can check if it has the required permissions:\n\nconst result = await auth.api.verifyApiKey({\n  body: {\n    key: \"your_api_key_here\",\n    permissions: {\n      files: [\"read\"],\n    },\n  },\n});\nif (result.valid) {\n  // API key is valid and has the required permissions\n} else {\n  // API key is invalid or doesn't have the required permissions\n}\nUpdating API Key Permissions\n\nYou can update the permissions of an existing API key:\n\nconst apiKey = await auth.api.updateApiKey({\n  body: {\n    keyId: existingApiKeyId,\n    permissions: {\n      files: [\"read\", \"write\", \"delete\"],\n      users: [\"read\", \"write\"],\n    },\n  },\n  headers: user_headers,\n});\nPermissions Structure\n\nPermissions follow a resource-based structure:\n\ntype Permissions = {\n  [resourceType: string]: string[];\n};\n// Example:\nconst permissions = {\n  files: [\"read\", \"write\", \"delete\"],\n  users: [\"read\"],\n  projects: [\"read\", \"write\"],\n};\n\nWhen verifying an API key, all required permissions must be present in the API key's permissions for validation to succeed.\n\nSchema\n\nTable: apiKey\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tThe ID of the API key.\nname\tstring\t?\tThe name of the API key.\nstart\tstring\t?\tThe starting characters of the API key. Useful for showing the first few characters of the API key in the UI for the users to easily identify.\nprefix\tstring\t?\tThe API Key prefix. Stored as plain text.\nkey\tstring\t-\tThe hashed API key itself.\nuserId\tstring\t\nFK\tThe ID of the user associated with the API key.\nrefillInterval\tnumber\t?\tThe interval to refill the key in milliseconds.\nrefillAmount\tnumber\t?\tThe amount to refill the remaining count of the key.\nlastRefillAt\tDate\t?\tThe date and time when the key was last refilled.\nenabled\tboolean\t-\tWhether the API key is enabled.\nrateLimitEnabled\tboolean\t-\tWhether the API key has rate limiting enabled.\nrateLimitTimeWindow\tnumber\t?\tThe time window in milliseconds for the rate limit.\nrateLimitMax\tnumber\t?\tThe maximum number of requests allowed within the `rateLimitTimeWindow`.\nrequestCount\tnumber\t-\tThe number of requests made within the rate limit time window.\nremaining\tnumber\t?\tThe number of requests remaining.\nlastRequest\tDate\t?\tThe date and time of the last request made to the key.\nexpiresAt\tDate\t?\tThe date and time when the key will expire.\ncreatedAt\tDate\t-\tThe date and time the API key was created.\nupdatedAt\tDate\t-\tThe date and time the API key was updated.\npermissions\tstring\t?\tThe permissions of the key.\nmetadata\tObject\t?\tAny additional metadata you want to store with the key.\nEdit on GitHub\n\nPrevious Page\n\nAdmin\n\nNext Page\n\nMCP"
  },
  {
    "title": "OIDC Provider | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/oidc-provider",
    "html": "OIDC Provider\nCopy Markdown\nOpen in\n\nThe OIDC Provider Plugin enables you to build and manage your own OpenID Connect (OIDC) provider, granting full control over user authentication without relying on third-party services like Okta or Azure AD. It also allows other services to authenticate users through your OIDC provider.\n\nKey Features:\n\nClient Registration: Register clients to authenticate with your OIDC provider.\nDynamic Client Registration: Allow clients to register dynamically.\nTrusted Clients: Configure hard-coded trusted clients with optional consent bypass.\nAuthorization Code Flow: Support the Authorization Code Flow.\nPublic Clients: Support public clients for SPA, mobile apps, CLI tools, etc.\nJWKS Endpoint: Publish a JWKS endpoint to allow clients to verify tokens. (Not fully implemented)\nRefresh Tokens: Issue refresh tokens and handle access token renewal using the refresh_token grant.\nOAuth Consent: Implement OAuth consent screens for user authorization, with an option to bypass consent for trusted applications.\nUserInfo Endpoint: Provide a UserInfo endpoint for clients to retrieve user details.\n\nThis plugin is in active development and may not be suitable for production use. Please report any issues or bugs on GitHub.\n\nInstallation\nMount the Plugin\n\nAdd the OIDC plugin to your auth config. See OIDC Configuration on how to configure the plugin.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { oidcProvider } from \"better-auth/plugins\";\nconst auth = betterAuth({\n    plugins: [oidcProvider({\n        loginPage: \"/sign-in\", // path to the login page\n        // ...other options\n    })]\n})\nMigrate the Database\n\nRun the migration or generate the schema to add the necessary fields and tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nSee the Schema section to add the fields manually.\n\nAdd the Client Plugin\n\nAdd the OIDC client plugin to your auth client config.\n\nimport { createAuthClient } from \"better-auth/client\";\nimport { oidcClient } from \"better-auth/client/plugins\"\nconst authClient = createAuthClient({\n    plugins: [oidcClient({\n        // Your OIDC configuration\n    })]\n})\nUsage\n\nOnce installed, you can utilize the OIDC Provider to manage authentication flows within your application.\n\nRegister a New Client\n\nTo register a new OIDC client, use the oauth2.register method.\n\nSimple Example\nconst application = await client.oauth2.register({\n    client_name: \"My Client\",\n    redirect_uris: [\"https://client.example.com/callback\"],\n});\nFull Method\nClient\nServer\nPOST\n/oauth2/register\nconst { data, error } = await authClient.oauth2.register({\n    redirect_uris: [\"https://client.example.com/callback\"], // required\n    token_endpoint_auth_method: \"client_secret_basic\",\n    grant_types: [\"authorization_code\"],\n    response_types: [\"code\"],\n    client_name: \"My App\",\n    client_uri: \"https://client.example.com\",\n    logo_uri: \"https://client.example.com/logo.png\",\n    scope: \"profile email\",\n    contacts: [\"admin@example.com\"],\n    tos_uri: \"https://client.example.com/tos\",\n    policy_uri: \"https://client.example.com/policy\",\n    jwks_uri: \"https://client.example.com/jwks\",\n    jwks: {\"keys\": [{\"kty\": \"RSA\", \"alg\": \"RS256\", \"use\": \"sig\", \"n\": \"...\", \"e\": \"...\"}]},\n    metadata: {\"key\": \"value\"},\n    software_id: \"my-software\",\n    software_version: \"1.0.0\",\n    software_statement,\n});\nProp\tDescription\tType\nredirect_uris\t\nA list of redirect URIs.\n\tstring[]\ntoken_endpoint_auth_method?\t\nThe authentication method for the token endpoint.\n\t\"none\" | \"client_secret_basic\" | \"client_secret_post\"\ngrant_types?\t\nThe grant types supported by the application.\n\t(\"authorization_code\" | \"implicit\" | \"password\" | \"client_credentials\" | \"refresh_token\" | \"urn:ietf:params:oauth:grant-type:jwt-bearer\" | \"urn:ietf:params:oauth:grant-type:saml2-bearer\")[]\nresponse_types?\t\nThe response types supported by the application.\n\t(\"code\" | \"token\")[]\nclient_name?\t\nThe name of the application.\n\tstring\nclient_uri?\t\nThe URI of the application.\n\tstring\nlogo_uri?\t\nThe URI of the application logo.\n\tstring\nscope?\t\nThe scopes supported by the application. Separated by spaces.\n\tstring\ncontacts?\t\nThe contact information for the application.\n\tstring[]\ntos_uri?\t\nThe URI of the application terms of service.\n\tstring\npolicy_uri?\t\nThe URI of the application privacy policy.\n\tstring\njwks_uri?\t\nThe URI of the application JWKS.\n\tstring\njwks?\t\nThe JWKS of the application.\n\tRecord<string, any>\nmetadata?\t\nThe metadata of the application.\n\tRecord<string, any>\nsoftware_id?\t\nThe software ID of the application.\n\tstring\nsoftware_version?\t\nThe software version of the application.\n\tstring\nsoftware_statement?\t\nThe software statement of the application.\n\tstring\n\nThis endpoint supports RFC7591 compliant client registration.\n\nOnce the application is created, you will receive a client_id and client_secret that you can display to the user.\n\nTrusted Clients\n\nFor first-party applications and internal services, you can configure trusted clients directly in your OIDC provider configuration. Trusted clients bypass database lookups for better performance and can optionally skip consent screens for improved user experience.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { oidcProvider } from \"better-auth/plugins\";\nconst auth = betterAuth({\n    plugins: [\n      oidcProvider({\n        loginPage: \"/sign-in\",\n        trustedClients: [\n            {\n                clientId: \"internal-dashboard\",\n                clientSecret: \"secure-secret-here\",\n                name: \"Internal Dashboard\",\n                type: \"web\",\n                redirectURLs: [\"https://dashboard.company.com/auth/callback\"],\n                disabled: false,\n                skipConsent: true, // Skip consent for this trusted client\n                metadata: { internal: true }\n            },\n            {\n                clientId: \"mobile-app\",\n                clientSecret: \"mobile-secret\", \n                name: \"Company Mobile App\",\n                type: \"native\",\n                redirectURLs: [\"com.company.app://auth\"],\n                disabled: false,\n                skipConsent: false, // Still require consent if needed\n                metadata: {}\n            }\n        ]\n    })]\n})\nUserInfo Endpoint\n\nThe OIDC Provider includes a UserInfo endpoint that allows clients to retrieve information about the authenticated user. This endpoint is available at /oauth2/userinfo and requires a valid access token.\n\nGET\n/oauth2/userinfo\nclient-app.ts\n// Example of how a client would use the UserInfo endpoint\nconst response = await fetch('https://your-domain.com/api/auth/oauth2/userinfo', {\n  headers: {\n    'Authorization': 'Bearer ACCESS_TOKEN'\n  }\n});\nconst userInfo = await response.json();\n// userInfo contains user details based on the scopes granted\n\nThe UserInfo endpoint returns different claims based on the scopes that were granted during authorization:\n\nWith openid scope: Returns the user's ID (sub claim)\nWith profile scope: Returns name, picture, given_name, family_name\nWith email scope: Returns email and email_verified\n\nThe getAdditionalUserInfoClaim function receives the user object, requested scopes array, and the client, allowing you to conditionally include claims based on the scopes granted during authorization. These additional claims will be included in both the UserInfo endpoint response and the ID token.\n\nConsent Screen\n\nWhen a user is redirected to the OIDC provider for authentication, they may be prompted to authorize the application to access their data. This is known as the consent screen. By default, Better Auth will display a sample consent screen. You can customize the consent screen by providing a consentPage option during initialization.\n\nNote: Trusted clients with skipConsent: true will bypass the consent screen entirely, providing a seamless experience for first-party applications.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    plugins: [oidcProvider({\n        consentPage: \"/path/to/consent/page\"\n    })]\n})\n\nThe plugin will redirect the user to the specified path with consent_code, client_id and scope query parameters. You can use this information to display a custom consent screen. Once the user consents, you can call oauth2.consent to complete the authorization.\n\nPOST\n/oauth2/consent\n\nThe consent endpoint supports two methods for passing the consent code:\n\nMethod 1: URL Parameter\n\nconsent-page.ts\n// Get the consent code from the URL\nconst params = new URLSearchParams(window.location.search);\n// Submit consent with the code in the request body\nconst consentCode = params.get('consent_code');\nif (!consentCode) {\n\tthrow new Error('Consent code not found in URL parameters');\n}\nconst res = await client.oauth2.consent({\n\taccept: true, // or false to deny\n\tconsent_code: consentCode,\n});\n\nMethod 2: Cookie-Based\n\nconsent-page.ts\n// The consent code is automatically stored in a signed cookie\n// Just submit the consent decision\nconst res = await client.oauth2.consent({\n\taccept: true, // or false to deny\n\t// consent_code not needed when using cookie-based flow\n});\n\nBoth methods are fully supported. The URL parameter method works well with mobile apps and third-party contexts, while the cookie-based method provides a simpler implementation for web applications.\n\nHandling Login\n\nWhen a user is redirected to the OIDC provider for authentication, if they are not already logged in, they will be redirected to the login page. You can customize the login page by providing a loginPage option during initialization.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    plugins: [oidcProvider({\n        loginPage: \"/sign-in\"\n    })]\n})\n\nYou don't need to handle anything from your side; when a new session is created, the plugin will handle continuing the authorization flow.\n\nConfiguration\nOIDC Metadata\n\nCustomize the OIDC metadata by providing a configuration object during initialization.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { oidcProvider } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n    plugins: [oidcProvider({\n        metadata: {\n            issuer: \"https://your-domain.com\",\n            authorization_endpoint: \"/custom/oauth2/authorize\",\n            token_endpoint: \"/custom/oauth2/token\",\n            // ...other custom metadata\n        }\n    })]\n})\nJWKS Endpoint\n\nThe OIDC Provider plugin can integrate with the JWT plugin to provide asymmetric key signing for ID tokens verifiable at a JWKS endpoint.\n\nTo make your plugin OIDC compliant, you MUST disable the /token endpoint, the OAuth equivalent is located at /oauth2/token instead.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { oidcProvider } from \"better-auth/plugins\";\nimport { jwt } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n    disabledPaths: [\n        \"/token\",\n    ],\n    plugins: [\n        jwt(), // Make sure to add the JWT plugin\n        oidcProvider({\n            useJWTPlugin: true, // Enable JWT plugin integration\n            loginPage: \"/sign-in\",\n            // ... other options\n        })\n    ]\n})\n\nWhen useJWTPlugin: false (default), ID tokens are signed with the application secret.\n\nDynamic Client Registration\n\nIf you want to allow clients to register dynamically, you can enable this feature by setting the allowDynamicClientRegistration option to true.\n\nauth.ts\nconst auth = betterAuth({\n    plugins: [oidcProvider({\n        allowDynamicClientRegistration: true,\n    })]\n})\n\nThis will allow clients to register using the /register endpoint to be publicly available.\n\nSchema\n\nThe OIDC Provider plugin adds the following tables to the database:\n\nOAuth Application\n\nTable Name: oauthApplication\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tDatabase ID of the OAuth client\nclientId\tstring\t\nPK\tUnique identifier for each OAuth client\nclientSecret\tstring\t?\tSecret key for the OAuth client. Optional for public clients using PKCE.\nname\tstring\t-\tName of the OAuth client\nredirectURLs\tstring\t-\tComma-separated list of redirect URLs\nmetadata\tstring\t?\tAdditional metadata for the OAuth client\ntype\tstring\t-\tType of OAuth client (e.g., web, mobile)\ndisabled\tboolean\t-\tIndicates if the client is disabled\nuserId\tstring\t?\tID of the user who owns the client. (optional)\ncreatedAt\tDate\t-\tTimestamp of when the OAuth client was created\nupdatedAt\tDate\t-\tTimestamp of when the OAuth client was last updated\nOAuth Access Token\n\nTable Name: oauthAccessToken\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tDatabase ID of the access token\naccessToken\tstring\t-\tAccess token issued to the client\nrefreshToken\tstring\t-\tRefresh token issued to the client\naccessTokenExpiresAt\tDate\t-\tExpiration date of the access token\nrefreshTokenExpiresAt\tDate\t-\tExpiration date of the refresh token\nclientId\tstring\t\nFK\tID of the OAuth client\nuserId\tstring\t\nFK\tID of the user associated with the token\nscopes\tstring\t-\tComma-separated list of scopes granted\ncreatedAt\tDate\t-\tTimestamp of when the access token was created\nupdatedAt\tDate\t-\tTimestamp of when the access token was last updated\nOAuth Consent\n\nTable Name: oauthConsent\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tDatabase ID of the consent\nuserId\tstring\t\nFK\tID of the user who gave consent\nclientId\tstring\t\nFK\tID of the OAuth client\nscopes\tstring\t-\tComma-separated list of scopes consented to\nconsentGiven\tboolean\t-\tIndicates if consent was given\ncreatedAt\tDate\t-\tTimestamp of when the consent was given\nupdatedAt\tDate\t-\tTimestamp of when the consent was last updated\nOptions\n\nallowDynamicClientRegistration: boolean - Enable or disable dynamic client registration.\n\nmetadata: OIDCMetadata - Customize the OIDC provider metadata.\n\nloginPage: string - Path to the custom login page.\n\nconsentPage: string - Path to the custom consent page.\n\ntrustedClients: (Client & { skipConsent?: boolean })[] - Array of trusted clients that are configured directly in the provider options. These clients bypass database lookups and can optionally skip consent screens.\n\ngetAdditionalUserInfoClaim: (user: User, scopes: string[], client: Client) => Record<string, any> - Function to get additional user info claims.\n\nuseJWTPlugin: boolean - When true, ID tokens are signed using the JWT plugin's asymmetric keys. When false (default), ID tokens are signed with HMAC-SHA256 using the application secret.\n\nschema: AuthPluginSchema - Customize the OIDC provider schema.\n\nEdit on GitHub\n\nPrevious Page\n\nEnterprise\n\nNext Page\n\nSSO"
  },
  {
    "title": "Organization | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/organization",
    "html": "Organization\nCopy Markdown\nOpen in\n\nOrganizations simplifies user access and permissions management. Assign roles and permissions to streamline project management, team coordination, and partnerships.\n\nInstallation\nAdd the plugin to your auth config\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { organization } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    plugins: [ \n        organization() \n    ] \n})\nMigrate the database\n\nRun the migration or generate the schema to add the necessary fields and tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nSee the Schema section to add the fields manually.\n\nAdd the client plugin\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { organizationClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n    plugins: [ \n        organizationClient() \n    ] \n})\nUsage\n\nOnce you've installed the plugin, you can start using the organization plugin to manage your organization's members and teams. The client plugin will provide you with methods under the organization namespace, and the server api will provide you with the necessary endpoints to manage your organization and give you an easier way to call the functions on your own backend.\n\nOrganization\nCreate an organization\nClient\nServer\nPOST\n/organization/create\nconst metadata = { someKey: \"someValue\" };\nconst { data, error } = await authClient.organization.create({\n    name: \"My Organization\", // required\n    slug: \"my-org\", // required\n    logo: \"https://example.com/logo.png\",\n    metadata,\n    keepCurrentActiveOrganization: false,\n});\nProp\tDescription\tType\nname\t\nThe organization name.\n\tstring\nslug\t\nThe organization slug.\n\tstring\nlogo?\t\nThe organization logo.\n\tstring\nmetadata?\t\nThe metadata of the organization.\n\tRecord<string, any>\nkeepCurrentActiveOrganization?\t\nWhether to keep the current active organization active after creating a new one.\n\tboolean\nRestrict who can create an organization\n\nBy default, any user can create an organization. To restrict this, set the allowUserToCreateOrganization option to a function that returns a boolean, or directly to true or false.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { organization } from \"better-auth/plugins\";\nconst auth = betterAuth({\n  //...\n  plugins: [\n    organization({\n      allowUserToCreateOrganization: async (user) => {\n        const subscription = await getSubscription(user.id); \n        return subscription.plan === \"pro\"; \n      }, \n    }),\n  ],\n});\nCheck if organization slug is taken\n\nTo check if an organization slug is taken or not you can use the checkSlug function provided by the client. The function takes an object with the following properties:\n\nClient\nServer\nPOST\n/organization/check-slug\nconst { data, error } = await authClient.organization.checkSlug({\n    slug: \"my-org\", // required\n});\nProp\tDescription\tType\nslug\t\nThe organization slug to check.\n\tstring\nOrganization Hooks\n\nYou can customize organization operations using hooks that run before and after various organization-related activities. Better Auth provides two ways to configure hooks:\n\nLegacy organizationCreation hooks (deprecated, use organizationHooks instead)\nModern organizationHooks (recommended) - provides comprehensive control over all organization-related activities\nOrganization Creation and Management Hooks\n\nControl organization lifecycle operations:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { organization } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n  plugins: [\n    organization({\n      organizationHooks: {\n        // Organization creation hooks\n        beforeCreateOrganization: async ({ organization, user }) => {\n          // Run custom logic before organization is created\n          // Optionally modify the organization data\n          return {\n            data: {\n              ...organization,\n              metadata: {\n                customField: \"value\",\n              },\n            },\n          };\n        },\n        afterCreateOrganization: async ({ organization, member, user }) => {\n          // Run custom logic after organization is created\n          // e.g., create default resources, send notifications\n          await setupDefaultResources(organization.id);\n        },\n        // Organization update hooks\n        beforeUpdateOrganization: async ({ organization, user, member }) => {\n          // Validate updates, apply business rules\n          return {\n            data: {\n              ...organization,\n              name: organization.name?.toLowerCase(),\n            },\n          };\n        },\n        afterUpdateOrganization: async ({ organization, user, member }) => {\n          // Sync changes to external systems\n          await syncOrganizationToExternalSystems(organization);\n        },\n      },\n    }),\n  ],\n});\n\nThe legacy organizationCreation hooks are still supported but deprecated. Use organizationHooks.beforeCreateOrganization and organizationHooks.afterCreateOrganization instead for new projects.\n\nMember Hooks\n\nControl member operations within organizations:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { organization } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n  plugins: [\n    organization({\n      organizationHooks: {\n        // Before a member is added to an organization\n        beforeAddMember: async ({ member, user, organization }) => {\n          // Custom validation or modification\n          console.log(`Adding ${user.email} to ${organization.name}`);\n          // Optionally modify member data\n          return {\n            data: {\n              ...member,\n              role: \"custom-role\", // Override the role\n            },\n          };\n        },\n        // After a member is added\n        afterAddMember: async ({ member, user, organization }) => {\n          // Send welcome email, create default resources, etc.\n          await sendWelcomeEmail(user.email, organization.name);\n        },\n        // Before a member is removed\n        beforeRemoveMember: async ({ member, user, organization }) => {\n          // Cleanup user's resources, send notification, etc.\n          await cleanupUserResources(user.id, organization.id);\n        },\n        // After a member is removed\n        afterRemoveMember: async ({ member, user, organization }) => {\n          await logMemberRemoval(user.id, organization.id);\n        },\n        // Before updating a member's role\n        beforeUpdateMemberRole: async ({\n          member,\n          newRole,\n          user,\n          organization,\n        }) => {\n          // Validate role change permissions\n          if (newRole === \"owner\" && !hasOwnerUpgradePermission(user)) {\n            throw new Error(\"Cannot upgrade to owner role\");\n          }\n          // Optionally modify the role\n          return {\n            data: {\n              role: newRole,\n            },\n          };\n        },\n        // After updating a member's role\n        afterUpdateMemberRole: async ({\n          member,\n          previousRole,\n          user,\n          organization,\n        }) => {\n          await logRoleChange(user.id, previousRole, member.role);\n        },\n      },\n    }),\n  ],\n});\nInvitation Hooks\n\nControl invitation lifecycle:\n\nauth.ts\nexport const auth = betterAuth({\n  plugins: [\n    organization({\n      organizationHooks: {\n        // Before creating an invitation\n        beforeCreateInvitation: async ({\n          invitation,\n          inviter,\n          organization,\n        }) => {\n          // Custom validation or expiration logic\n          const customExpiration = new Date(\n            Date.now() + 1000 * 60 * 60 * 24 * 7\n          ); // 7 days\n          return {\n            data: {\n              ...invitation,\n              expiresAt: customExpiration,\n            },\n          };\n        },\n        // After creating an invitation\n        afterCreateInvitation: async ({\n          invitation,\n          inviter,\n          organization,\n        }) => {\n          // Send custom invitation email, track metrics, etc.\n          await sendCustomInvitationEmail(invitation, organization);\n        },\n        // Before accepting an invitation\n        beforeAcceptInvitation: async ({ invitation, user, organization }) => {\n          // Additional validation before acceptance\n          await validateUserEligibility(user, organization);\n        },\n        // After accepting an invitation\n        afterAcceptInvitation: async ({\n          invitation,\n          member,\n          user,\n          organization,\n        }) => {\n          // Setup user account, assign default resources\n          await setupNewMemberResources(user, organization);\n        },\n        // Before/after rejecting invitations\n        beforeRejectInvitation: async ({ invitation, user, organization }) => {\n          // Log rejection reason, send notification to inviter\n        },\n        afterRejectInvitation: async ({ invitation, user, organization }) => {\n          await notifyInviterOfRejection(invitation.inviterId, user.email);\n        },\n        // Before/after cancelling invitations\n        beforeCancelInvitation: async ({\n          invitation,\n          cancelledBy,\n          organization,\n        }) => {\n          // Verify cancellation permissions\n        },\n        afterCancelInvitation: async ({\n          invitation,\n          cancelledBy,\n          organization,\n        }) => {\n          await logInvitationCancellation(invitation.id, cancelledBy.id);\n        },\n      },\n    }),\n  ],\n});\nTeam Hooks\n\nControl team operations (when teams are enabled):\n\nauth.ts\nexport const auth = betterAuth({\n  plugins: [\n    organization({\n      teams: { enabled: true },\n      organizationHooks: {\n        // Before creating a team\n        beforeCreateTeam: async ({ team, user, organization }) => {\n          // Validate team name, apply naming conventions\n          return {\n            data: {\n              ...team,\n              name: team.name.toLowerCase().replace(/\\s+/g, \"-\"),\n            },\n          };\n        },\n        // After creating a team\n        afterCreateTeam: async ({ team, user, organization }) => {\n          // Create default team resources, channels, etc.\n          await createDefaultTeamResources(team.id);\n        },\n        // Before updating a team\n        beforeUpdateTeam: async ({ team, updates, user, organization }) => {\n          // Validate updates, apply business rules\n          return {\n            data: {\n              ...updates,\n              name: updates.name?.toLowerCase(),\n            },\n          };\n        },\n        // After updating a team\n        afterUpdateTeam: async ({ team, user, organization }) => {\n          await syncTeamChangesToExternalSystems(team);\n        },\n        // Before deleting a team\n        beforeDeleteTeam: async ({ team, user, organization }) => {\n          // Backup team data, notify members\n          await backupTeamData(team.id);\n        },\n        // After deleting a team\n        afterDeleteTeam: async ({ team, user, organization }) => {\n          await cleanupTeamResources(team.id);\n        },\n        // Team member operations\n        beforeAddTeamMember: async ({\n          teamMember,\n          team,\n          user,\n          organization,\n        }) => {\n          // Validate team membership limits, permissions\n          const memberCount = await getTeamMemberCount(team.id);\n          if (memberCount >= 10) {\n            throw new Error(\"Team is full\");\n          }\n        },\n        afterAddTeamMember: async ({\n          teamMember,\n          team,\n          user,\n          organization,\n        }) => {\n          await grantTeamAccess(user.id, team.id);\n        },\n        beforeRemoveTeamMember: async ({\n          teamMember,\n          team,\n          user,\n          organization,\n        }) => {\n          // Backup user's team-specific data\n          await backupTeamMemberData(user.id, team.id);\n        },\n        afterRemoveTeamMember: async ({\n          teamMember,\n          team,\n          user,\n          organization,\n        }) => {\n          await revokeTeamAccess(user.id, team.id);\n        },\n      },\n    }),\n  ],\n});\nHook Error Handling\n\nAll hooks support error handling. Throwing an error in a before hook will prevent the operation from proceeding:\n\nauth.ts\nimport { APIError } from \"better-auth/api\";\nexport const auth = betterAuth({\n  plugins: [\n    organization({\n      organizationHooks: {\n        beforeAddMember: async ({ member, user, organization }) => {\n          // Check if user has pending violations\n          const violations = await checkUserViolations(user.id);\n          if (violations.length > 0) {\n            throw new APIError(\"BAD_REQUEST\", {\n              message:\n                \"User has pending violations and cannot join organizations\",\n            });\n          }\n        },\n        beforeCreateTeam: async ({ team, user, organization }) => {\n          // Validate team name uniqueness\n          const existingTeam = await findTeamByName(team.name, organization.id);\n          if (existingTeam) {\n            throw new APIError(\"BAD_REQUEST\", {\n              message: \"Team name already exists in this organization\",\n            });\n          }\n        },\n      },\n    }),\n  ],\n});\nList User's Organizations\n\nTo list the organizations that a user is a member of, you can use useListOrganizations hook. It implements a reactive way to get the organizations that the user is a member of.\n\nReact\nVue\nSvelte\nclient.tsx\nimport { authClient } from \"@/lib/auth-client\"\nfunction App(){\nconst { data: organizations } = authClient.useListOrganizations()\nreturn (\n  <div>\n    {organizations.map((org) => (\n      <p>{org.name}</p>\n    ))}\n  </div>)\n}\n\nOr alternatively, you can call organization.list if you don't want to use a hook.\n\nClient\nServer\nGET\n/organization/list\nconst { data, error } = await authClient.organization.list();\nActive Organization\n\nActive organization is the workspace the user is currently working on. By default when the user is signed in the active organization is set to null. You can set the active organization to the user session.\n\nIt's not always you want to persist the active organization in the session. You can manage the active organization in the client side only. For example, multiple tabs can have different active organizations.\n\nSet Active Organization\n\nYou can set the active organization by calling the organization.setActive function. It'll set the active organization for the user session.\n\nIn some applications, you may want the ability to unset an active organization. In this case, you can call this endpoint with organizationId set to null.\n\nClient\nServer\nPOST\n/organization/set-active\nconst { data, error } = await authClient.organization.setActive({\n    organizationId: \"org-id\",\n    organizationSlug: \"org-slug\",\n});\nProp\tDescription\tType\norganizationId?\t\nThe organization ID to set as active. It can be null to unset the active organization.\n\tstring | null\norganizationSlug?\t\nThe organization slug to set as active. It can be null to unset the active organization if organizationId is not provided.\n\tstring\n\nTo set active organization when a session is created you can use database hooks.\n\nauth.ts\nexport const auth = betterAuth({\n  databaseHooks: {\n    session: {\n      create: {\n        before: async (session) => {\n          const organization = await getActiveOrganization(session.userId);\n          return {\n            data: {\n              ...session,\n              activeOrganizationId: organization.id,\n            },\n          };\n        },\n      },\n    },\n  },\n});\nUse Active Organization\n\nTo retrieve the active organization for the user, you can call the useActiveOrganization hook. It returns the active organization for the user. Whenever the active organization changes, the hook will re-evaluate and return the new active organization.\n\nReact\nVue\nSvelte\nclient.tsx\nimport { authClient } from \"@/lib/auth-client\"\nfunction App(){\n    const { data: activeOrganization } = authClient.useActiveOrganization()\n    return (\n        <div>\n            {activeOrganization ? <p>{activeOrganization.name}</p> : null}\n        </div>\n    )\n}\nGet Full Organization\n\nTo get the full details of an organization, you can use the getFullOrganization function. By default, if you don't pass any properties, it will use the active organization.\n\nClient\nServer\nGET\n/organization/get-full-organization\nconst { data, error } = await authClient.organization.getFullOrganization({\n    query: {\n        organizationId: \"org-id\",\n        organizationSlug: \"org-slug\",\n        membersLimit: 100,\n    },\n});\nProp\tDescription\tType\norganizationId?\t\nThe organization ID to get. By default, it will use the active organization.\n\tstring\norganizationSlug?\t\nThe organization slug to get.\n\tstring\nmembersLimit?\t\nThe limit of members to get. By default, it uses the membershipLimit option which defaults to 100.\n\tnumber\nUpdate Organization\n\nTo update organization info, you can use organization.update\n\nClient\nServer\nPOST\n/organization/update\nconst { data, error } = await authClient.organization.update({\n    data: { // required\n        name: \"updated-name\",\n        slug: \"updated-slug\",\n        logo: \"new-logo.url\",\n        metadata: { customerId: \"test\" },\n    },\n    organizationId: \"org-id\",\n});\nProp\tDescription\tType\ndata\t\nA partial list of data to update the organization.\n\tObject\ndata.name?\t\nThe name of the organization.\n\tstring\ndata.slug?\t\nThe slug of the organization.\n\tstring\ndata.logo?\t\nThe logo of the organization.\n\tstring\ndata.metadata?\t\nThe metadata of the organization.\n\tRecord<string, any> | null\norganizationId?\t\nThe organization ID. to update.\n\tstring\nDelete Organization\n\nTo remove user owned organization, you can use organization.delete\n\nClient\nServer\nPOST\n/organization/delete\nconst { data, error } = await authClient.organization.delete({\n    organizationId: \"org-id\", // required\n});\nProp\tDescription\tType\norganizationId\t\nThe organization ID to delete.\n\tstring\n\nIf the user has the necessary permissions (by default: role is owner) in the specified organization, all members, invitations and organization information will be removed.\n\nYou can configure how organization deletion is handled through organizationDeletion option:\n\nconst auth = betterAuth({\n  plugins: [\n    organization({\n      disableOrganizationDeletion: true, //to disable it altogether\n      organizationHooks: {\n        beforeDeleteOrganization: async (data, request) => {\n          // a callback to run before deleting org\n        },\n        afterDeleteOrganization: async (data, request) => {\n          // a callback to run after deleting org\n        },\n      },\n    }),\n  ],\n});\nInvitations\n\nTo add a member to an organization, we first need to send an invitation to the user. The user will receive an email/sms with the invitation link. Once the user accepts the invitation, they will be added to the organization.\n\nSetup Invitation Email\n\nFor member invitation to work we first need to provide sendInvitationEmail to the better-auth instance. This function is responsible for sending the invitation email to the user.\n\nYou'll need to construct and send the invitation link to the user. The link should include the invitation ID, which will be used with the acceptInvitation function when the user clicks on it.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { organization } from \"better-auth/plugins\";\nimport { sendOrganizationInvitation } from \"./email\";\nexport const auth = betterAuth({\n  plugins: [\n    organization({\n      async sendInvitationEmail(data) {\n        const inviteLink = `https://example.com/accept-invitation/${data.id}`;\n        sendOrganizationInvitation({\n          email: data.email,\n          invitedByUsername: data.inviter.user.name,\n          invitedByEmail: data.inviter.user.email,\n          teamName: data.organization.name,\n          inviteLink,\n        });\n      },\n    }),\n  ],\n});\nSend Invitation\n\nTo invite users to an organization, you can use the invite function provided by the client. The invite function takes an object with the following properties:\n\nClient\nServer\nPOST\n/organization/invite-member\nconst { data, error } = await authClient.organization.inviteMember({\n    email: \"example@gmail.com\", // required\n    role: \"member\", // required\n    organizationId: \"org-id\",\n    resend: true,\n    teamId: \"team-id\",\n});\nProp\tDescription\tType\nemail\t\nThe email address of the user to invite.\n\tstring\nrole\t\nThe role(s) to assign to the user. It can be admin, member, or guest.\n\tstring | string[]\norganizationId?\t\nThe organization ID to invite the user to. Defaults to the active organization.\n\tstring\nresend?\t\nResend the invitation email, if the user is already invited.\n\tboolean\nteamId?\t\nThe team ID to invite the user to.\n\tstring\nIf the user is already a member of the organization, the invitation will be canceled. - If the user is already invited to the organization, unless resend is set to true, the invitation will not be sent again. - If cancelPendingInvitationsOnReInvite is set to true, the invitation will be canceled if the user is already invited to the organization and a new invitation is sent.\nAccept Invitation\n\nWhen a user receives an invitation email, they can click on the invitation link to accept the invitation. The invitation link should include the invitation ID, which will be used to accept the invitation.\n\nMake sure to call the acceptInvitation function after the user is logged in.\n\nClient\nServer\nPOST\n/organization/accept-invitation\nconst { data, error } = await authClient.organization.acceptInvitation({\n    invitationId: \"invitation-id\", // required\n});\nProp\tDescription\tType\ninvitationId\t\nThe ID of the invitation to accept.\n\tstring\nEmail Verification Requirement\n\nIf the requireEmailVerificationOnInvitation option is enabled in your organization configuration, users must verify their email address before they can accept invitations. This adds an extra security layer to ensure that only verified users can join your organization.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { organization } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n  plugins: [\n    organization({\n      requireEmailVerificationOnInvitation: true, \n      async sendInvitationEmail(data) {\n        // ... your email sending logic\n      },\n    }),\n  ],\n});\nInvitation Accepted Callback\n\nYou can configure Better Auth to execute a callback function when an invitation is accepted. This is useful for logging events, updating analytics, sending notifications, or any other custom logic you need to run when someone joins your organization.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { organization } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n  plugins: [\n    organization({\n      async sendInvitationEmail(data) {\n        // ... your invitation email logic\n      },\n      async onInvitationAccepted(data) {\n        // This callback gets triggered when an invitation is accepted\n      },\n    }),\n  ],\n});\n\nThe callback receives the following data:\n\nid: The invitation ID\nrole: The role assigned to the user\norganization: The organization the user joined\ninvitation: The invitation object\ninviter: The member who sent the invitation (including user details)\nacceptedUser: The user who accepted the invitation\nCancel Invitation\n\nIf a user has sent out an invitation, you can use this method to cancel it.\n\nIf you're looking for how a user can reject an invitation, you can find that here.\n\nClient\nServer\nPOST\n/organization/cancel-invitation\nawait authClient.organization.cancelInvitation({\n    invitationId: \"invitation-id\", // required\n});\nProp\tDescription\tType\ninvitationId\t\nThe ID of the invitation to cancel.\n\tstring\nReject Invitation\n\nIf this user has received an invitation, but wants to decline it, this method will allow you to do so by rejecting it.\n\nClient\nServer\nPOST\n/organization/reject-invitation\nawait authClient.organization.rejectInvitation({\n    invitationId: \"invitation-id\", // required\n});\nProp\tDescription\tType\ninvitationId\t\nThe ID of the invitation to reject.\n\tstring\n\nLike accepting invitations, rejecting invitations also requires email verification when the requireEmailVerificationOnInvitation option is enabled. Users with unverified emails will receive an error when attempting to reject invitations.\n\nGet Invitation\n\nTo get an invitation you can use the organization.getInvitation function provided by the client. You need to provide the invitation id as a query parameter.\n\nClient\nServer\nGET\n/organization/get-invitation\nconst { data, error } = await authClient.organization.getInvitation({\n    query: {\n        id: \"invitation-id\", // required\n    },\n});\nProp\tDescription\tType\nid\t\nThe ID of the invitation to get.\n\tstring\nList Invitations\n\nTo list all invitations for a given organization you can use the listInvitations function provided by the client.\n\nClient\nServer\nGET\n/organization/list-invitations\nconst { data, error } = await authClient.organization.listInvitations({\n    query: {\n        organizationId: \"organization-id\",\n    },\n});\nProp\tDescription\tType\norganizationId?\t\nAn optional ID of the organization to list invitations for. If not provided, will default to the user's active organization.\n\tstring\nList user invitations\n\nTo list all invitations for a given user you can use the listUserInvitations function provided by the client.\n\nauth-client.ts\nconst invitations = await authClient.organization.listUserInvitations();\n\nOn the server, you can pass the user ID as a query parameter.\n\napi.ts\nconst invitations = await auth.api.listUserInvitations({\n  query: {\n    email: \"user@example.com\",\n  },\n});\n\nThe email query parameter is only available on the server to query for invitations for a specific user.\n\nMembers\nList Members\n\nTo list all members of an organization you can use the listMembers function.\n\nClient\nServer\nGET\n/organization/list-members\nconst { data, error } = await authClient.organization.listMembers({\n    query: {\n        organizationId: \"organization-id\",\n        limit: 100,\n        offset: 0,\n        sortBy: \"createdAt\",\n        sortDirection: \"desc\",\n        filterField: \"createdAt\",\n        filterOperator: \"eq\",\n        filterValue: \"value\",\n    },\n});\nProp\tDescription\tType\norganizationId?\t\nAn optional organization ID to list members for. If not provided, will default to the user's active organization.\n\tstring\nlimit?\t\nThe limit of members to return.\n\tnumber\noffset?\t\nThe offset to start from.\n\tnumber\nsortBy?\t\nThe field to sort by.\n\tstring\nsortDirection?\t\nThe direction to sort by.\n\t\"asc\" | \"desc\"\nfilterField?\t\nThe field to filter by.\n\tstring\nfilterOperator?\t\nThe operator to filter by.\n\t\"eq\" | \"ne\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\" | \"nin\" | \"contains\"\nfilterValue?\t\nThe value to filter by.\n\tstring\nRemove Member\n\nTo remove you can use organization.removeMember\n\nClient\nServer\nPOST\n/organization/remove-member\nconst { data, error } = await authClient.organization.removeMember({\n    memberIdOrEmail: \"user@example.com\", // required\n    organizationId: \"org-id\",\n});\nProp\tDescription\tType\nmemberIdOrEmail\t\nThe ID or email of the member to remove.\n\tstring\norganizationId?\t\nThe ID of the organization to remove the member from. If not provided, the active organization will be used.\n\tstring\nUpdate Member Role\n\nTo update the role of a member in an organization, you can use the organization.updateMemberRole. If the user has the permission to update the role of the member, the role will be updated.\n\nClient\nServer\nPOST\n/organization/update-member-role\nawait authClient.organization.updateMemberRole({\n    role: [\"admin\", \"sale\"], // required\n    memberId: \"member-id\", // required\n    organizationId: \"organization-id\",\n});\nProp\tDescription\tType\nrole\t\nThe new role to be applied. This can be a string or array of strings representing the roles.\n\tstring | string[]\nmemberId\t\nThe member id to apply the role update to.\n\tstring\norganizationId?\t\nAn optional organization ID which the member is a part of to apply the role update. If not provided, you must provide session headers to get the active organization.\n\tstring\nGet Active Member\n\nTo get the current member of the active organization you can use the organization.getActiveMember function. This function will return the user's member details in their active organization.\n\nClient\nServer\nGET\n/organization/get-active-member\nconst { data: member, error } = await authClient.organization.getActiveMember();\nGet Active Member Role\n\nTo get the current role member of the active organization you can use the organization.getActiveMemberRole function. This function will return the user's member role in their active organization.\n\nClient\nServer\nGET\n/organization/get-active-member-role\nconst { data: { role }, error } = await authClient.organization.getActiveMemberRole();\nAdd Member\n\nIf you want to add a member directly to an organization without sending an invitation, you can use the addMember function which can only be invoked on the server.\n\nClient\nServer\nPOST\n/organization/add-member\nconst data = await auth.api.addMember({\n    body: {\n        userId: \"user-id\",\n        role: [\"admin\", \"sale\"], // required\n        organizationId: \"org-id\",\n        teamId: \"team-id\",\n    },\n});\nProp\tDescription\tType\nuserId?\t\nThe user ID which represents the user to be added as a member. If null is provided, then it's expected to provide session headers.\n\tstring | null\nrole\t\nThe role(s) to assign to the new member.\n\tstring | string[]\norganizationId?\t\nAn optional organization ID to pass. If not provided, will default to the user's active organization.\n\tstring\nteamId?\t\nAn optional team ID to add the member to.\n\tstring\nLeave Organization\n\nTo leave organization you can use organization.leave function. This function will remove the current user from the organization.\n\nClient\nServer\nPOST\n/organization/leave\nawait authClient.organization.leave({\n    organizationId: \"organization-id\", // required\n});\nProp\tDescription\tType\norganizationId\t\nThe organization ID for the member to leave.\n\tstring\nAccess Control\n\nThe organization plugin provides a very flexible access control system. You can control the access of the user based on the role they have in the organization. You can define your own set of permissions based on the role of the user.\n\nRoles\n\nBy default, there are three roles in the organization:\n\nowner: The user who created the organization by default. The owner has full control over the organization and can perform any action.\n\nadmin: Users with the admin role have full control over the organization except for deleting the organization or changing the owner.\n\nmember: Users with the member role have limited control over the organization. They can create projects, invite users, and manage projects they have created.\n\nA user can have multiple roles. Multiple roles are stored as string separated by comma (\",\").\n\nPermissions\n\nBy default, there are three resources, and these have two to three actions.\n\norganization:\n\nupdate delete\n\nmember:\n\ncreate update delete\n\ninvitation:\n\ncreate cancel\n\nThe owner has full control over all the resources and actions. The admin has full control over all the resources except for deleting the organization or changing the owner. The member has no control over any of those actions other than reading the data.\n\nCustom Permissions\n\nThe plugin provides an easy way to define your own set of permissions for each role.\n\nCreate Access Control\n\nYou first need to create access controller by calling createAccessControl function and passing the statement object. The statement object should have the resource name as the key and the array of actions as the value.\n\npermissions.ts\nimport { createAccessControl } from \"better-auth/plugins/access\";\n/**\n * make sure to use `as const` so typescript can infer the type correctly\n */\nconst statement = { \n    project: [\"create\", \"share\", \"update\", \"delete\"], \n} as const; \nconst ac = createAccessControl(statement); \nCreate Roles\n\nOnce you have created the access controller you can create roles with the permissions you have defined.\n\npermissions.ts\nimport { createAccessControl } from \"better-auth/plugins/access\";\nconst statement = {\n    project: [\"create\", \"share\", \"update\", \"delete\"],\n} as const;\nconst ac = createAccessControl(statement);\nconst member = ac.newRole({ \n    project: [\"create\"], \n}); \nconst admin = ac.newRole({ \n    project: [\"create\", \"update\"], \n}); \nconst owner = ac.newRole({ \n    project: [\"create\", \"update\", \"delete\"], \n}); \nconst myCustomRole = ac.newRole({ \n    project: [\"create\", \"update\", \"delete\"], \n    organization: [\"update\"], \n}); \n\nWhen you create custom roles for existing roles, the predefined permissions for those roles will be overridden. To add the existing permissions to the custom role, you need to import defaultStatements and merge it with your new statement, plus merge the roles' permissions set with the default roles.\n\npermissions.ts\nimport { createAccessControl } from \"better-auth/plugins/access\";\nimport { defaultStatements, adminAc } from 'better-auth/plugins/organization/access'\nconst statement = {\n    ...defaultStatements, \n    project: [\"create\", \"share\", \"update\", \"delete\"],\n} as const;\nconst ac = createAccessControl(statement);\nconst admin = ac.newRole({\n    project: [\"create\", \"update\"],\n    ...adminAc.statements, \n});\nPass Roles to the Plugin\n\nOnce you have created the roles you can pass them to the organization plugin both on the client and the server.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { organization } from \"better-auth/plugins\"\nimport { ac, owner, admin, member } from \"@/auth/permissions\"\nexport const auth = betterAuth({\n    plugins: [\n        organization({\n            ac,\n            roles: {\n                owner,\n                admin,\n                member,\n                myCustomRole\n            }\n        }),\n    ],\n});\n\nYou also need to pass the access controller and the roles to the client plugin.\n\nauth-client\nimport { createAuthClient } from \"better-auth/client\"\nimport { organizationClient } from \"better-auth/client/plugins\"\nimport { ac, owner, admin, member, myCustomRole } from \"@/auth/permissions\"\nexport const authClient = createAuthClient({\n    plugins: [\n        organizationClient({\n            ac,\n            roles: {\n                owner,\n                admin,\n                member,\n                myCustomRole\n            }\n        })\n  ]\n})\nAccess Control Usage\n\nHas Permission:\n\nYou can use the hasPermission action provided by the api to check the permission of the user.\n\napi.ts\nimport { auth } from \"@/auth\";\nawait auth.api.hasPermission({\n  headers: await headers(),\n  body: {\n    permissions: {\n      project: [\"create\"], // This must match the structure in your access control\n    },\n  },\n});\n// You can also check multiple resource permissions at the same time\nawait auth.api.hasPermission({\n  headers: await headers(),\n  body: {\n    permissions: {\n      project: [\"create\"], // This must match the structure in your access control\n      sale: [\"create\"],\n    },\n  },\n});\n\nIf you want to check the permission of the user on the client from the server you can use the hasPermission function provided by the client.\n\nauth-client.ts\nconst canCreateProject = await authClient.organization.hasPermission({\n  permissions: {\n    project: [\"create\"],\n  },\n});\n// You can also check multiple resource permissions at the same time\nconst canCreateProjectAndCreateSale =\n  await authClient.organization.hasPermission({\n    permissions: {\n      project: [\"create\"],\n      sale: [\"create\"],\n    },\n  });\n\nCheck Role Permission:\n\nOnce you have defined the roles and permissions to avoid checking the permission from the server you can use the checkRolePermission function provided by the client.\n\nauth-client.ts\nconst canCreateProject = authClient.organization.checkRolePermission({\n  permissions: {\n    organization: [\"delete\"],\n  },\n  role: \"admin\",\n});\n// You can also check multiple resource permissions at the same time\nconst canCreateProjectAndCreateSale =\n  authClient.organization.checkRolePermission({\n    permissions: {\n      organization: [\"delete\"],\n      member: [\"delete\"],\n    },\n    role: \"admin\",\n  });\n\nThis will not include any dynamic roles as everything is ran synchronously on the client side. Please use the hasPermission APIs to include checks for any dynamic roles & permissions.\n\nDynamic Access Control\n\nDynamic access control allows you to create roles at runtime for organizations. This is achieved by storing the created roles and permissions associated with an organization in a database table.\n\nEnabling Dynamic Access Control\n\nTo enable dynamic access control, pass the dynamicAccessControl configuration option with enabled set to true to both server and client plugins.\n\nEnsure you have pre-defined an ac instance on the server auth plugin. This is important as this is how we can infer the permissions that are available for use.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { organization } from \"better-auth/plugins\";\nimport { ac } from \"@/auth/permissions\";\nexport const auth = betterAuth({\n    plugins: [ \n        organization({ \n            ac, // Must be defined in order for dynamic access control to work\n            dynamicAccessControl: { \n              enabled: true, \n            }, \n        }) \n    ] \n})\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nimport { organizationClient } from \"better-auth/client/plugins\";\nexport const authClient = createAuthClient({\n    plugins: [ \n        organizationClient({ \n            dynamicAccessControl: { \n              enabled: true, \n            }, \n        }) \n    ] \n})\n\nThis will require you to run migrations to add the new organizationRole table to the database.\n\nThe authClient.organization.checkRolePermission function will not include any dynamic roles as everything is ran synchronously on the client side. Please use the hasPermission APIs to include checks for any dynamic roles.\n\nCreating a role\n\nTo create a new role for an organization at runtime, you can use the createRole function.\n\nOnly users with roles which contain the ac resource with the create permission can create a new role. By default, only the admin and owner roles have this permission. You also cannot add permissions that your current role in that organization can't already access.\n\nTIP: You can validate role names by using the dynamicAccessControl.validateRoleName option in the organization plugin config. Learn more here.\n\nClient\nServer\nPOST\n/organization/create-role\n// To use custom resources or permissions,\n// make sure they are defined in the `ac` instance of your organization config.\nconst permission = {\n  project: [\"create\", \"update\", \"delete\"]\n}\nawait authClient.organization.createRole({\n    role: \"my-unique-role\", // required\n    permission: permission,\n    organizationId: \"organization-id\",\n});\nProp\tDescription\tType\nrole\t\nA unique name of the role to create.\n\tstring\npermission?\t\nThe permissions to assign to the role.\n\tRecord<string, string[]>\norganizationId?\t\nThe organization ID which the role will be created in. Defaults to the active organization.\n\tstring\n\nNow you can freely call updateMemberRole to update the role of a member with your newly created role!\n\nDeleting a role\n\nTo delete a role, you can use the deleteRole function, then provide either a roleName or roleId parameter along with the organizationId parameter.\n\nClient\nServer\nPOST\n/organization/delete-role\nawait authClient.organization.deleteRole({\n    roleName: \"my-role\",\n    roleId: \"role-id\",\n    organizationId: \"organization-id\",\n});\nProp\tDescription\tType\nroleName?\t\nThe name of the role to delete. Alternatively, you can pass a roleId parameter instead.\n\tstring\nroleId?\t\nThe id of the role to delete. Alternatively, you can pass a roleName parameter instead.\n\tstring\norganizationId?\t\nThe organization ID which the role will be deleted in. Defaults to the active organization.\n\tstring\nListing roles\n\nTo list roles, you can use the listOrgRoles function. This requires the ac resource with the read permission for the member to be able to list roles.\n\nClient\nServer\nGET\n/organization/list-roles\nconst { data: roles, error } = await authClient.organization.listRoles({\n    query: {\n        organizationId: \"organization-id\",\n    },\n});\nProp\tDescription\tType\norganizationId?\t\nThe organization ID which the roles are under to list. Defaults to the user's active organization.\n\tstring\nGetting a specific role\n\nTo get a specific role, you can use the getOrgRole function and pass either a roleName or roleId parameter. This requires the ac resource with the read permission for the member to be able to get a role.\n\nClient\nServer\nGET\n/organization/get-role\nconst { data: role, error } = await authClient.organization.getRole({\n    query: {\n        roleName: \"my-role\",\n        roleId: \"role-id\",\n        organizationId: \"organization-id\",\n    },\n});\nProp\tDescription\tType\nroleName?\t\nThe name of the role to get. Alternatively, you can pass a roleId parameter instead.\n\tstring\nroleId?\t\nThe id of the role to get. Alternatively, you can pass a roleName parameter instead.\n\tstring\norganizationId?\t\nThe organization ID which the role will be deleted in. Defaults to the active organization.\n\tstring\nUpdating a role\n\nTo update a role, you can use the updateOrgRole function and pass either a roleName or roleId parameter.\n\nClient\nServer\nPOST\n/organization/update-role\nconst { data: updatedRole, error } = await authClient.organization.updateRole({\n    roleName: \"my-role\",\n    roleId: \"role-id\",\n    organizationId: \"organization-id\",\n    data: { // required\n        permission: { project: [\"create\", \"update\", \"delete\"] },\n        roleName: \"my-new-role\",\n    },\n});\nProp\tDescription\tType\nroleName?\t\nThe name of the role to update. Alternatively, you can pass a roleId parameter instead.\n\tstring\nroleId?\t\nThe id of the role to update. Alternatively, you can pass a roleName parameter instead.\n\tstring\norganizationId?\t\nThe organization ID which the role will be updated in. Defaults to the active organization.\n\tstring\ndata\t\nThe data which will be updated\n\tObject\ndata.permission?\t\nOptionally update the permissions of the role.\n\tRecord<string, string[]>\ndata.roleName?\t\nOptionally update the name of the role.\n\tstring\nConfiguration Options\n\nBelow is a list of options that can be passed to the dynamicAccessControl object.\n\nenabled\n\nThis option is used to enable or disable dynamic access control. By default, it is disabled.\n\norganization({\n  dynamicAccessControl: {\n    enabled: true\n  }\n})\nmaximumRolesPerOrganization\n\nThis option is used to limit the number of roles that can be created for an organization.\n\nBy default, the maximum number of roles that can be created for an organization is infinite.\n\norganization({\n  dynamicAccessControl: {\n    maximumRolesPerOrganization: 10\n  }\n})\n\nYou can also pass a function that returns a number.\n\norganization({\n  dynamicAccessControl: {\n    maximumRolesPerOrganization: async (organizationId) => { \n      const organization = await getOrganization(organizationId); \n      return organization.plan === \"pro\" ? 100 : 10; \n    } \n  }\n})\nAdditional Fields\n\nTo add additional fields to the organizationRole table, you can pass the additionalFields configuration option to the organization plugin.\n\norganization({\n  schema: {\n    organizationRole: {\n      additionalFields: {\n        // Role colors!\n        color: {\n          type: \"string\",\n          defaultValue: \"#ffffff\",\n        },\n        //... other fields\n      },\n    },\n  },\n})\n\nThen, if you don't already use inferOrgAdditionalFields to infer the additional fields, you can use it to infer the additional fields.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { organizationClient, inferOrgAdditionalFields } from \"better-auth/client/plugins\"\nimport type { auth } from \"./auth\"\nexport const authClient = createAuthClient({\n    plugins: [\n        organizationClient({\n            schema: inferOrgAdditionalFields<typeof auth>()\n        })\n    ]\n})\n\nOtherwise, you can pass the schema values directly, the same way you do on the org plugin in the server.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { organizationClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n    plugins: [\n        organizationClient({\n            schema: {\n                organizationRole: {\n                    additionalFields: {\n                        color: {\n                            type: \"string\",\n                            defaultValue: \"#ffffff\",\n                        }\n                    }\n                }\n            }\n        })\n    ]\n})\nTeams\n\nTeams allow you to group members within an organization. The teams feature provides additional organization structure and can be used to manage permissions at a more granular level.\n\nEnabling Teams\n\nTo enable teams, pass the teams configuration option to both server and client plugins:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { organization } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n  plugins: [\n    organization({\n      teams: {\n        enabled: true,\n        maximumTeams: 10, // Optional: limit teams per organization\n        allowRemovingAllTeams: false, // Optional: prevent removing the last team\n      },\n    }),\n  ],\n});\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nimport { organizationClient } from \"better-auth/client/plugins\";\nexport const authClient = createAuthClient({\n  plugins: [\n    organizationClient({\n      teams: {\n        enabled: true,\n      },\n    }),\n  ],\n});\nManaging Teams\nCreate Team\n\nCreate a new team within an organization:\n\nClient\nServer\nPOST\n/organization/create-team\nconst { data, error } = await authClient.organization.createTeam({\n    name: \"my-team\", // required\n    organizationId: \"organization-id\",\n});\nProp\tDescription\tType\nname\t\nThe name of the team.\n\tstring\norganizationId?\t\nThe organization ID which the team will be created in. Defaults to the active organization.\n\tstring\nList Teams\n\nGet all teams in an organization:\n\nClient\nServer\nGET\n/organization/list-teams\nconst { data, error } = await authClient.organization.listTeams({\n    query: {\n        organizationId: \"organization-id\",\n    },\n});\nProp\tDescription\tType\norganizationId?\t\nThe organization ID which the teams are under to list. Defaults to the user's active organization.\n\tstring\nUpdate Team\n\nUpdate a team's details:\n\nClient\nServer\nPOST\n/organization/update-team\nconst { data, error } = await authClient.organization.updateTeam({\n    teamId: \"team-id\", // required\n    data: { // required\n        name: \"My new team name\",\n        organizationId: \"My new organization ID for this team\",\n        createdAt: new Date(),\n        updatedAt: new Date(),\n    },\n});\nProp\tDescription\tType\nteamId\t\nThe ID of the team to be updated.\n\tstring\ndata\t\nA partial object containing options for you to update.\n\tObject\ndata.name?\t\nThe name of the team to be updated.\n\tstring\ndata.organizationId?\t\nThe organization ID which the team falls under.\n\tstring\ndata.createdAt?\t\nThe timestamp of when the team was created.\n\tDate\ndata.updatedAt?\t\nThe timestamp of when the team was last updated.\n\tDate\nRemove Team\n\nDelete a team from an organization:\n\nClient\nServer\nPOST\n/organization/remove-team\nconst { data, error } = await authClient.organization.removeTeam({\n    teamId: \"team-id\", // required\n    organizationId: \"organization-id\",\n});\nProp\tDescription\tType\nteamId\t\nThe team ID of the team to remove.\n\tstring\norganizationId?\t\nThe organization ID which the team falls under. If not provided, it will default to the user's active organization.\n\tstring\nSet Active Team\n\nSets the given team as the current active team. If teamId is null the current active team is unset.\n\nClient\nServer\nPOST\n/organization/set-active-team\nconst { data, error } = await authClient.organization.setActiveTeam({\n    teamId: \"team-id\",\n});\nProp\tDescription\tType\nteamId?\t\nThe team ID of the team to set as the current active team.\n\tstring\nList User Teams\n\nList all teams that the current user is a part of.\n\nClient\nServer\nGET\n/organization/list-user-teams\nconst { data, error } = await authClient.organization.listUserTeams();\nList Team Members\n\nList the members of the given team.\n\nClient\nServer\nPOST\n/organization/list-team-members\nconst { data, error } = await authClient.organization.listTeamMembers({\n    query: {\n        teamId: \"team-id\",\n    },\n});\nProp\tDescription\tType\nteamId?\t\nThe team whose members we should return. If this is not provided the members of the current active team get returned.\n\tstring\nAdd Team Member\n\nAdd a member to a team.\n\nClient\nServer\nPOST\n/organization/add-team-member\nconst { data, error } = await authClient.organization.addTeamMember({\n    teamId: \"team-id\", // required\n    userId: \"user-id\", // required\n});\nProp\tDescription\tType\nteamId\t\nThe team the user should be a member of.\n\tstring\nuserId\t\nThe user ID which represents the user to be added as a member.\n\tstring\nRemove Team Member\n\nRemove a member from a team.\n\nClient\nServer\nPOST\n/organization/remove-team-member\nconst { data, error } = await authClient.organization.removeTeamMember({\n    teamId: \"team-id\", // required\n    userId: \"user-id\", // required\n});\nProp\tDescription\tType\nteamId\t\nThe team the user should be removed from.\n\tstring\nuserId\t\nThe user which should be removed from the team.\n\tstring\nTeam Permissions\n\nTeams follow the organization's permission system. To manage teams, users need the following permissions:\n\nteam:create - Create new teams\nteam:update - Update team details\nteam:delete - Remove teams\n\nBy default:\n\nOrganization owners and admins can manage teams\nRegular members cannot create, update, or delete teams\nTeam Configuration Options\n\nThe teams feature supports several configuration options:\n\nmaximumTeams: Limit the number of teams per organization\n\nteams: {\n  enabled: true,\n  maximumTeams: 10 // Fixed number\n  // OR\n  maximumTeams: async ({ organizationId, session }, request) => {\n    // Dynamic limit based on organization plan\n    const plan = await getPlan(organizationId)\n    return plan === 'pro' ? 20 : 5\n  },\n  maximumMembersPerTeam: 10 // Fixed number\n  // OR\n  maximumMembersPerTeam: async ({ teamId, session, organizationId }, request) => {\n    // Dynamic limit based on team plan\n    const plan = await getPlan(organizationId, teamId)\n    return plan === 'pro' ? 50 : 10\n  },\n}\n\nallowRemovingAllTeams: Control whether the last team can be removed\n\nteams: {\n  enabled: true,\n  allowRemovingAllTeams: false // Prevent removing the last team\n}\nTeam Members\n\nWhen inviting members to an organization, you can specify a team:\n\nawait authClient.organization.inviteMember({\n  email: \"user@example.com\",\n  role: \"member\",\n  teamId: \"team-id\",\n});\n\nThe invited member will be added to the specified team upon accepting the invitation.\n\nDatabase Schema\n\nWhen teams are enabled, new team and teamMember tables are added to the database.\n\nTable Name: team\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for each team\nname\tstring\t-\tThe name of the team\norganizationId\tstring\t\nFK\tThe ID of the organization\ncreatedAt\tDate\t-\tTimestamp of when the team was created\nupdatedAt\tDate\t?\tTimestamp of when the team was created\n\nTable Name: teamMember\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for each team member\nteamId\tstring\t\nFK\tUnique identifier for each team\nuserId\tstring\t\nFK\tThe ID of the user\ncreatedAt\tDate\t-\tTimestamp of when the team member was created\nSchema\n\nThe organization plugin adds the following tables to the database:\n\nOrganization\n\nTable Name: organization\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for each organization\nname\tstring\t-\tThe name of the organization\nslug\tstring\t-\tThe slug of the organization\nlogo\tstring\t?\tThe logo of the organization\nmetadata\tstring\t?\tAdditional metadata for the organization\ncreatedAt\tDate\t-\tTimestamp of when the organization was created\nMember\n\nTable Name: member\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for each member\nuserId\tstring\t\nFK\tThe ID of the user\norganizationId\tstring\t\nFK\tThe ID of the organization\nrole\tstring\t-\tThe role of the user in the organization\ncreatedAt\tDate\t-\tTimestamp of when the member was added to the organization\nInvitation\n\nTable Name: invitation\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for each invitation\nemail\tstring\t-\tThe email address of the user\ninviterId\tstring\t\nFK\tThe ID of the inviter\norganizationId\tstring\t\nFK\tThe ID of the organization\nrole\tstring\t-\tThe role of the user in the organization\nstatus\tstring\t-\tThe status of the invitation\nexpiresAt\tDate\t-\tTimestamp of when the invitation expires\n\nIf teams are enabled, you need to add the following fields to the invitation table:\n\nField Name\tType\tKey\tDescription\nteamId\tstring\t?\tThe ID of the team\nSession\n\nTable Name: session\n\nYou need to add two more fields to the session table to store the active organization ID and the active team ID.\n\nField Name\tType\tKey\tDescription\nactiveOrganizationId\tstring\t?\tThe ID of the active organization\nactiveTeamId\tstring\t?\tThe ID of the active team\nTeams (optional)\n\nTable Name: team\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for each team\nname\tstring\t-\tThe name of the team\norganizationId\tstring\t\nFK\tThe ID of the organization\ncreatedAt\tDate\t-\tTimestamp of when the team was created\nupdatedAt\tDate\t?\tTimestamp of when the team was created\n\nTable Name: teamMember\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for each team member\nteamId\tstring\t\nFK\tUnique identifier for each team\nuserId\tstring\t\nFK\tThe ID of the user\ncreatedAt\tDate\t-\tTimestamp of when the team member was created\n\nTable Name: invitation\n\nField Name\tType\tKey\tDescription\nteamId\tstring\t?\tThe ID of the team\nCustomizing the Schema\n\nTo change the schema table name or fields, you can pass schema option to the organization plugin.\n\nauth.ts\nconst auth = betterAuth({\n  plugins: [\n    organization({\n      schema: {\n        organization: {\n          modelName: \"organizations\", //map the organization table to organizations\n          fields: {\n            name: \"title\", //map the name field to title\n          },\n          additionalFields: {\n            // Add a new field to the organization table\n            myCustomField: {\n              type: \"string\",\n              input: true,\n              required: false,\n            },\n          },\n        },\n      },\n    }),\n  ],\n});\nAdditional Fields\n\nStarting with Better Auth v1.3, you can easily add custom fields to the organization, invitation, member, and team tables.\n\nWhen you add extra fields to a model, the relevant API endpoints will automatically accept and return these new properties. For instance, if you add a custom field to the organization table, the createOrganization endpoint will include this field in its request and response payloads as needed.\n\nauth.ts\nconst auth = betterAuth({\n  plugins: [\n    organization({\n      schema: {\n        organization: {\n          additionalFields: {\n            myCustomField: {\n              type: \"string\", \n              input: true, \n              required: false, \n            }, \n          },\n        },\n      },\n    }),\n  ],\n});\n\nFor inferring the additional fields, you can use the inferOrgAdditionalFields function. This function will infer the additional fields from the auth object type.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nimport {\n  inferOrgAdditionalFields,\n  organizationClient,\n} from \"better-auth/client/plugins\";\nimport type { auth } from \"@/auth\"; // import the auth object type only\nconst client = createAuthClient({\n  plugins: [\n    organizationClient({\n      schema: inferOrgAdditionalFields<typeof auth>(),\n    }),\n  ],\n});\n\nif you can't import the auth object type, you can use the inferOrgAdditionalFields function without the generic. This function will infer the additional fields from the schema object.\n\nauth-client.ts\nconst client = createAuthClient({\n  plugins: [\n    organizationClient({\n      schema: inferOrgAdditionalFields({\n        organization: {\n          additionalFields: {\n            newField: {\n              type: \"string\", \n            }, \n          },\n        },\n      }),\n    }),\n  ],\n});\n//example usage\nawait client.organization.create({\n  name: \"Test\",\n  slug: \"test\",\n  newField: \"123\", //this should be allowed\n  //@ts-expect-error - this field is not available\n  unavalibleField: \"123\", //this should be not allowed\n});\nOptions\n\nallowUserToCreateOrganization: boolean | ((user: User) => Promise<boolean> | boolean) - A function that determines whether a user can create an organization. By default, it's true. You can set it to false to restrict users from creating organizations.\n\norganizationLimit: number | ((user: User) => Promise<boolean> | boolean) - The maximum number of organizations allowed for a user. By default, it's 5. You can set it to any number you want or a function that returns a boolean.\n\ncreatorRole: admin | owner - The role of the user who creates the organization. By default, it's owner. You can set it to admin.\n\nmembershipLimit: number - The maximum number of members allowed in an organization. By default, it's 100. You can set it to any number you want.\n\nsendInvitationEmail: async (data) => Promise<void> - A function that sends an invitation email to the user.\n\ninvitationExpiresIn : number - How long the invitation link is valid for in seconds. By default, it's 48 hours (2 days).\n\ncancelPendingInvitationsOnReInvite: boolean - Whether to cancel pending invitations if the user is already invited to the organization. By default, it's false.\n\ninvitationLimit: number | ((user: User) => Promise<boolean> | boolean) - The maximum number of invitations allowed for a user. By default, it's 100. You can set it to any number you want or a function that returns a boolean.\n\nrequireEmailVerificationOnInvitation: boolean - Whether to require email verification before accepting or rejecting invitations. By default, it's false. When enabled, users must have verified their email address before they can accept or reject organization invitations.\n\nEdit on GitHub\n\nPrevious Page\n\nMCP\n\nNext Page\n\nEnterprise"
  },
  {
    "title": "Single Sign-On (SSO) | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/sso",
    "html": "Single Sign-On (SSO)\nCopy Markdown\nOpen in\n\nOIDC OAuth2 SSO SAML\n\nSingle Sign-On (SSO) allows users to authenticate with multiple applications using a single set of credentials. This plugin supports OpenID Connect (OIDC), OAuth2 providers, and SAML 2.0.\n\nInstallation\nInstall the plugin\nnpm install @better-auth/sso\nAdd Plugin to the server\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { sso } from \"@better-auth/sso\";\nconst auth = betterAuth({\n    plugins: [ \n        sso() \n    ] \n})\nMigrate the database\n\nRun the migration or generate the schema to add the necessary fields and tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nSee the Schema section to add the fields manually.\n\nAdd the client plugin\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { ssoClient } from \"@better-auth/sso/client\"\nconst authClient = createAuthClient({\n    plugins: [ \n        ssoClient() \n    ] \n})\nUsage\nRegister an OIDC Provider\n\nTo register an OIDC provider, use the registerSSOProvider endpoint and provide the necessary configuration details for the provider.\n\nA redirect URL will be automatically generated using the provider ID. For instance, if the provider ID is hydra, the redirect URL would be {baseURL}/api/auth/sso/callback/hydra. Note that /api/auth may vary depending on your base path configuration.\n\nExample\nclient\nserver\nregister-oidc-provider.ts\nimport { authClient } from \"@/lib/auth-client\";\n// Register with OIDC configuration\nawait authClient.sso.register({\n    providerId: \"example-provider\",\n    issuer: \"https://idp.example.com\",\n    domain: \"example.com\",\n    oidcConfig: {\n        clientId: \"client-id\",\n        clientSecret: \"client-secret\",\n        authorizationEndpoint: \"https://idp.example.com/authorize\",\n        tokenEndpoint: \"https://idp.example.com/token\",\n        jwksEndpoint: \"https://idp.example.com/jwks\",\n        discoveryEndpoint: \"https://idp.example.com/.well-known/openid-configuration\",\n        scopes: [\"openid\", \"email\", \"profile\"],\n        pkce: true,\n        mapping: {\n            id: \"sub\",\n            email: \"email\",\n            emailVerified: \"email_verified\",\n            name: \"name\",\n            image: \"picture\",\n            extraFields: {\n                department: \"department\",\n                role: \"role\"\n            }\n        }\n    }\n});\nRegister a SAML Provider\n\nTo register a SAML provider, use the registerSSOProvider endpoint with SAML configuration details. The provider will act as a Service Provider (SP) and integrate with your Identity Provider (IdP).\n\nclient\nserver\nregister-saml-provider.ts\nimport { authClient } from \"@/lib/auth-client\";\nawait authClient.sso.register({\n    providerId: \"saml-provider\",\n    issuer: \"https://idp.example.com\",\n    domain: \"example.com\",\n    samlConfig: {\n        entryPoint: \"https://idp.example.com/sso\",\n        cert: \"-----BEGIN CERTIFICATE-----\\n...\\n-----END CERTIFICATE-----\",\n        callbackUrl: \"https://yourapp.com/api/auth/sso/saml2/callback/saml-provider\",\n        audience: \"https://yourapp.com\",\n        wantAssertionsSigned: true,\n        signatureAlgorithm: \"sha256\",\n        digestAlgorithm: \"sha256\",\n        identifierFormat: \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n        idpMetadata: {\n            metadata: \"<!-- IdP Metadata XML -->\",\n            privateKey: \"-----BEGIN RSA PRIVATE KEY-----\\n...\\n-----END RSA PRIVATE KEY-----\",\n            privateKeyPass: \"your-private-key-password\",\n            isAssertionEncrypted: true,\n            encPrivateKey: \"-----BEGIN RSA PRIVATE KEY-----\\n...\\n-----END RSA PRIVATE KEY-----\",\n            encPrivateKeyPass: \"your-encryption-key-password\"\n        },\n        spMetadata: {\n            metadata: \"<!-- SP Metadata XML -->\",\n            binding: \"post\",\n            privateKey: \"-----BEGIN RSA PRIVATE KEY-----\\n...\\n-----END RSA PRIVATE KEY-----\",\n            privateKeyPass: \"your-sp-private-key-password\",\n            isAssertionEncrypted: true,\n            encPrivateKey: \"-----BEGIN RSA PRIVATE KEY-----\\n...\\n-----END RSA PRIVATE KEY-----\",\n            encPrivateKeyPass: \"your-sp-encryption-key-password\"\n        },\n        mapping: {\n            id: \"nameID\",\n            email: \"email\",\n            name: \"displayName\",\n            firstName: \"givenName\",\n            lastName: \"surname\",\n            emailVerified: \"email_verified\",\n            extraFields: {\n                department: \"department\",\n                role: \"role\"\n            }\n        }\n    }\n});\nGet Service Provider Metadata\n\nFor SAML providers, you can retrieve the Service Provider metadata XML that needs to be configured in your Identity Provider:\n\nget-sp-metadata.ts\nconst response = await auth.api.spMetadata({\n    query: {\n        providerId: \"saml-provider\",\n        format: \"xml\" // or \"json\"\n    }\n});\nconst metadataXML = await response.text();\nconsole.log(metadataXML);\nSign In with SSO\n\nTo sign in with an SSO provider, you can call signIn.sso\n\nYou can sign in using the email with domain matching:\n\nsign-in.ts\nconst res = await authClient.signIn.sso({\n    email: \"user@example.com\",\n    callbackURL: \"/dashboard\",\n});\n\nor you can specify the domain:\n\nsign-in-domain.ts\nconst res = await authClient.signIn.sso({\n    domain: \"example.com\",\n    callbackURL: \"/dashboard\",\n});\n\nYou can also sign in using the organization slug if a provider is associated with an organization:\n\nsign-in-org.ts\nconst res = await authClient.signIn.sso({\n    organizationSlug: \"example-org\",\n    callbackURL: \"/dashboard\",\n});\n\nAlternatively, you can sign in using the provider's ID:\n\nsign-in-provider-id.ts\nconst res = await authClient.signIn.sso({\n    providerId: \"example-provider-id\",\n    callbackURL: \"/dashboard\",\n});\n\nTo use the server API you can use signInSSO\n\nsign-in-org.ts\nconst res = await auth.api.signInSSO({\n    body: {\n        organizationSlug: \"example-org\",\n        callbackURL: \"/dashboard\",\n    }\n});\nFull method\nClient\nServer\nPOST\n/sign-in/sso\nconst { data, error } = await authClient.signIn.sso({\n    email: \"john@example.com\",\n    organizationSlug: \"example-org\",\n    providerId: \"example-provider\",\n    domain: \"example.com\",\n    callbackURL: \"https://example.com/callback\", // required\n    errorCallbackURL: \"https://example.com/callback\",\n    newUserCallbackURL: \"https://example.com/new-user\",\n    scopes: [\"openid\", \"email\", \"profile\", \"offline_access\"],\n    requestSignUp: true,\n});\nProp\tDescription\tType\nemail?\t\nThe email address to sign in with. This is used to identify the issuer to sign in with. It's optional if the issuer is provided.\n\tstring\norganizationSlug?\t\nThe slug of the organization to sign in with.\n\tstring\nproviderId?\t\nThe ID of the provider to sign in with. This can be provided instead of email or issuer.\n\tstring\ndomain?\t\nThe domain of the provider.\n\tstring\ncallbackURL\t\nThe URL to redirect to after login.\n\tstring\nerrorCallbackURL?\t\nThe URL to redirect to after login.\n\tstring\nnewUserCallbackURL?\t\nThe URL to redirect to after login if the user is new.\n\tstring\nscopes?\t\nScopes to request from the provider.\n\tstring[]\nrequestSignUp?\t\nExplicitly request sign-up. Useful when disableImplicitSignUp is true for this provider.\n\tboolean\n\nWhen a user is authenticated, if the user does not exist, the user will be provisioned using the provisionUser function. If the organization provisioning is enabled and a provider is associated with an organization, the user will be added to the organization.\n\nauth.ts\nconst auth = betterAuth({\n    plugins: [\n        sso({\n            provisionUser: async (user) => {\n                // provision user\n            },\n            organizationProvisioning: {\n                disabled: false,\n                defaultRole: \"member\",\n                getRole: async (user) => {\n                    // get role if needed\n                },\n            },\n        }),\n    ],\n});\nProvisioning\n\nThe SSO plugin provides powerful provisioning capabilities to automatically set up users and manage their organization memberships when they sign in through SSO providers.\n\nUser Provisioning\n\nUser provisioning allows you to run custom logic whenever a user signs in through an SSO provider. This is useful for:\n\nSetting up user profiles with additional data from the SSO provider\nSynchronizing user attributes with external systems\nCreating user-specific resources\nLogging SSO sign-ins\nUpdating user information from the SSO provider\nauth.ts\nconst auth = betterAuth({\n    plugins: [\n        sso({\n            provisionUser: async ({ user, userInfo, token, provider }) => {\n                // Update user profile with SSO data\n                await updateUserProfile(user.id, {\n                    department: userInfo.attributes?.department,\n                    jobTitle: userInfo.attributes?.jobTitle,\n                    manager: userInfo.attributes?.manager,\n                    lastSSOLogin: new Date(),\n                });\n                // Create user-specific resources\n                await createUserWorkspace(user.id);\n                // Sync with external systems\n                await syncUserWithCRM(user.id, userInfo);\n                // Log the SSO sign-in\n                await auditLog.create({\n                    userId: user.id,\n                    action: 'sso_signin',\n                    provider: provider.providerId,\n                    metadata: {\n                        email: userInfo.email,\n                        ssoProvider: provider.issuer,\n                    },\n                });\n            },\n        }),\n    ],\n});\n\nThe provisionUser function receives:\n\nuser: The user object from the database\nuserInfo: User information from the SSO provider (includes attributes, email, name, etc.)\ntoken: OAuth2 tokens (for OIDC providers) - may be undefined for SAML\nprovider: The SSO provider configuration\nOrganization Provisioning\n\nOrganization provisioning automatically manages user memberships in organizations when SSO providers are linked to specific organizations. This is particularly useful for:\n\nEnterprise SSO where each company/domain maps to an organization\nAutomatic role assignment based on SSO attributes\nManaging team memberships through SSO\nBasic Organization Provisioning\nauth.ts\nconst auth = betterAuth({\n    plugins: [\n        sso({\n            organizationProvisioning: {\n                disabled: false,           // Enable org provisioning\n                defaultRole: \"member\",     // Default role for new members\n            },\n        }),\n    ],\n});\nAdvanced Organization Provisioning with Custom Roles\nauth.ts\nconst auth = betterAuth({\n    plugins: [\n        sso({\n            organizationProvisioning: {\n                disabled: false,\n                defaultRole: \"member\",\n                getRole: async ({ user, userInfo, provider }) => {\n                    // Assign roles based on SSO attributes\n                    const department = userInfo.attributes?.department;\n                    const jobTitle = userInfo.attributes?.jobTitle;\n                    \n                    // Admins based on job title\n                    if (jobTitle?.toLowerCase().includes('manager') || \n                        jobTitle?.toLowerCase().includes('director') ||\n                        jobTitle?.toLowerCase().includes('vp')) {\n                        return \"admin\";\n                    }\n                    \n                    // Special roles for IT department\n                    if (department?.toLowerCase() === 'it') {\n                        return \"admin\";\n                    }\n                    \n                    // Default to member for everyone else\n                    return \"member\";\n                },\n            },\n        }),\n    ],\n});\nLinking SSO Providers to Organizations\n\nWhen registering an SSO provider, you can link it to a specific organization:\n\nregister-org-provider.ts\nawait auth.api.registerSSOProvider({\n    body: {\n        providerId: \"acme-corp-saml\",\n        issuer: \"https://acme-corp.okta.com\",\n        domain: \"acmecorp.com\",\n        organizationId: \"org_acme_corp_id\", // Link to organization\n        samlConfig: {\n            // SAML configuration...\n        },\n    },\n    headers,\n});\n\nNow when users from acmecorp.com sign in through this provider, they'll automatically be added to the \"Acme Corp\" organization with the appropriate role.\n\nMultiple Organizations Example\n\nYou can set up multiple SSO providers for different organizations:\n\nmulti-org-setup.ts\n// Acme Corp SAML provider\nawait auth.api.registerSSOProvider({\n    body: {\n        providerId: \"acme-corp\",\n        issuer: \"https://acme.okta.com\",\n        domain: \"acmecorp.com\",\n        organizationId: \"org_acme_id\",\n        samlConfig: { /* ... */ },\n    },\n    headers,\n});\n// TechStart OIDC provider\nawait auth.api.registerSSOProvider({\n    body: {\n        providerId: \"techstart-google\",\n        issuer: \"https://accounts.google.com\",\n        domain: \"techstart.io\",\n        organizationId: \"org_techstart_id\",\n        oidcConfig: { /* ... */ },\n    },\n    headers,\n});\nOrganization Provisioning Flow\nUser signs in through an SSO provider linked to an organization\nUser is authenticated and either found or created in the database\nOrganization membership is checked - if the user isn't already a member of the linked organization\nRole is determined using either the defaultRole or getRole function\nUser is added to the organization with the determined role\nUser provisioning runs (if configured) for additional setup\nProvisioning Best Practices\n1. Idempotent Operations\n\nMake sure your provisioning functions can be safely run multiple times:\n\nprovisionUser: async ({ user, userInfo }) => {\n    // Check if already provisioned\n    const existingProfile = await getUserProfile(user.id);\n    if (!existingProfile.ssoProvisioned) {\n        await createUserResources(user.id);\n        await markAsProvisioned(user.id);\n    }\n    \n    // Always update attributes (they might change)\n    await updateUserAttributes(user.id, userInfo.attributes);\n},\n2. Error Handling\n\nHandle errors gracefully to avoid blocking user sign-in:\n\nprovisionUser: async ({ user, userInfo }) => {\n    try {\n        await syncWithExternalSystem(user, userInfo);\n    } catch (error) {\n        // Log error but don't throw - user can still sign in\n        console.error('Failed to sync user with external system:', error);\n        await logProvisioningError(user.id, error);\n    }\n},\n3. Conditional Provisioning\n\nOnly run certain provisioning steps when needed:\n\norganizationProvisioning: {\n    disabled: false,\n    getRole: async ({ user, userInfo, provider }) => {\n        // Only process role assignment for certain providers\n        if (provider.providerId.includes('enterprise')) {\n            return determineEnterpriseRole(userInfo);\n        }\n        return \"member\";\n    },\n},\nSAML Configuration\nDefault SSO Provider\nauth.ts\nconst auth = betterAuth({\n    plugins: [\n        sso({\n            defaultSSO: {\n                providerId: \"default-saml\", // Provider ID for the default provider\n                samlConfig: {\n                    issuer: \"https://your-app.com\",\n                    entryPoint: \"https://idp.example.com/sso\",\n                    cert: \"-----BEGIN CERTIFICATE-----\\n...\\n-----END CERTIFICATE-----\",\n                    callbackUrl: \"http://localhost:3000/api/auth/sso/saml2/sp/acs\",\n                    spMetadata: {\n                        entityID: \"http://localhost:3000/api/auth/sso/saml2/sp/metadata\",\n                        metadata: \"<!-- Your SP Metadata XML -->\",\n                    }\n                }\n            }\n        })\n    ]\n});\n\nThe defaultSSO provider will be used when:\n\nNo matching provider is found in the database\n\nThis allows you to test SAML authentication without setting up providers in the database. The defaultSSO provider supports all the same configuration options as regular SAML providers.\n\nService Provider Configuration\n\nWhen registering a SAML provider, you need to provide Service Provider (SP) metadata configuration:\n\nmetadata: XML metadata for the Service Provider\nbinding: The binding method, typically \"post\" or \"redirect\"\nprivateKey: Private key for signing (optional)\nprivateKeyPass: Password for the private key (if encrypted)\nisAssertionEncrypted: Whether assertions should be encrypted\nencPrivateKey: Private key for decryption (if encryption is enabled)\nencPrivateKeyPass: Password for the encryption private key\nIdentity Provider Configuration\n\nYou also need to provide Identity Provider (IdP) configuration:\n\nmetadata: XML metadata from your Identity Provider\nprivateKey: Private key for the IdP communication (optional)\nprivateKeyPass: Password for the IdP private key (if encrypted)\nisAssertionEncrypted: Whether assertions from IdP are encrypted\nencPrivateKey: Private key for IdP assertion decryption\nencPrivateKeyPass: Password for the IdP decryption key\nSAML Attribute Mapping\n\nConfigure how SAML attributes map to user fields:\n\nmapping: {\n    id: \"nameID\",           // Default: \"nameID\"\n    email: \"email\",         // Default: \"email\" or \"nameID\"\n    name: \"displayName\",    // Default: \"displayName\"\n    firstName: \"givenName\", // Default: \"givenName\"\n    lastName: \"surname\",    // Default: \"surname\"\n    extraFields: {\n        department: \"department\",\n        role: \"jobTitle\",\n        phone: \"telephoneNumber\"\n    }\n}\nSAML Endpoints\n\nThe plugin automatically creates the following SAML endpoints:\n\nSP Metadata: /api/auth/sso/saml2/sp/metadata?providerId={providerId}\nSAML Callback: /api/auth/sso/saml2/callback/{providerId}\nSchema\n\nThe plugin requires additional fields in the ssoProvider table to store the provider's configuration.\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tA database identifier\nissuer\tstring\t-\tThe issuer identifier\ndomain\tstring\t-\tThe domain of the provider\noidcConfig\tstring\t-\tThe OIDC configuration (JSON string)\nsamlConfig\tstring\t-\tThe SAML configuration (JSON string)\nuserId\tstring\t-\tThe user ID\nproviderId\tstring\t-\tThe provider ID. Used to identify a provider and to generate a redirect URL.\norganizationId\tstring\t-\tThe organization Id. If provider is linked to an organization.\n\nFor a detailed guide on setting up SAML SSO with examples for Okta and testing with DummyIDP, see our SAML SSO with Okta.\n\nOptions\nServer\n\nprovisionUser: A custom function to provision a user when they sign in with an SSO provider.\n\norganizationProvisioning: Options for provisioning users to an organization.\n\ndefaultOverrideUserInfo: Override user info with the provider info by default.\n\ndisableImplicitSignUp: Disable implicit sign up for new users.\n\ntrustEmailVerified: Trust the email verified flag from the provider.\n\nProp\n\nType\n\nprovisionUser?\nfunction\norganizationProvisioning?\nobject\ndefaultOverrideUserInfo?\nboolean\ndisableImplicitSignUp?\nboolean\nprovidersLimit?\nnumber | function\ndefaultSSO?\nobject\nEdit on GitHub\n\nPrevious Page\n\nOIDC Provider\n\nNext Page\n\nUtility"
  },
  {
    "title": "Bearer Token Authentication | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/bearer",
    "html": "Bearer Token Authentication\nCopy Markdown\nOpen in\n\nThe Bearer plugin enables authentication using Bearer tokens as an alternative to browser cookies. It intercepts requests, adding the Bearer token to the Authorization header before forwarding them to your API.\n\nUse this cautiously; it is intended only for APIs that don't support cookies or require Bearer tokens for authentication. Improper implementation could easily lead to security vulnerabilities.\n\nInstalling the Bearer Plugin\n\nAdd the Bearer plugin to your authentication setup:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { bearer } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n    plugins: [bearer()]\n});\nHow to Use Bearer Tokens\n1. Obtain the Bearer Token\n\nAfter a successful sign-in, you'll receive a session token in the response headers. Store this token securely (e.g., in localStorage):\n\nauth-client.ts\nconst { data } = await authClient.signIn.email({\n    email: \"user@example.com\",\n    password: \"securepassword\"\n}, {\n  onSuccess: (ctx)=>{\n    const authToken = ctx.response.headers.get(\"set-auth-token\") // get the token from the response headers\n    // Store the token securely (e.g., in localStorage)\n    localStorage.setItem(\"bearer_token\", authToken);\n  }\n});\n\nYou can also set this up globally in your auth client:\n\nauth-client.ts\nexport const authClient = createAuthClient({\n    fetchOptions: {\n        onSuccess: (ctx) => {\n            const authToken = ctx.response.headers.get(\"set-auth-token\") // get the token from the response headers\n            // Store the token securely (e.g., in localStorage)\n            if(authToken){\n              localStorage.setItem(\"bearer_token\", authToken);\n            }\n        }\n    }\n});\n\nYou may want to clear the token based on the response status code or other conditions:\n\n2. Configure the Auth Client\n\nSet up your auth client to include the Bearer token in all requests:\n\nauth-client.ts\nexport const authClient = createAuthClient({\n    fetchOptions: {\n        auth: {\n           type:\"Bearer\",\n           token: () => localStorage.getItem(\"bearer_token\") || \"\" // get the token from localStorage\n        }\n    }\n});\n3. Make Authenticated Requests\n\nNow you can make authenticated API calls:\n\nauth-client.ts\n// This request is automatically authenticated\nconst { data } = await authClient.listSessions();\n4. Per-Request Token (Optional)\n\nYou can also provide the token for individual requests:\n\nauth-client.ts\nconst { data } = await authClient.listSessions({\n    fetchOptions: {\n        headers: {\n            Authorization: `Bearer ${token}`\n        }\n    }\n});\n5. Using Bearer Tokens Outside the Auth Client\n\nThe Bearer token can be used to authenticate any request to your API, even when not using the auth client:\n\napi-call.ts\nconst token = localStorage.getItem(\"bearer_token\");\nconst response = await fetch(\"https://api.example.com/data\", {\n  headers: {\n    Authorization: `Bearer ${token}`\n  }\n});\nconst data = await response.json();\n\nAnd in the server, you can use the auth.api.getSession function to authenticate requests:\n\nserver.ts\nimport { auth } from \"@/auth\";\nexport async function handler(req, res) {\n  const session = await auth.api.getSession({\n    headers: req.headers\n  });\n  \n  if (!session) {\n    return res.status(401).json({ error: \"Unauthorized\" });\n  }\n  \n  // Process authenticated request\n  // ...\n}\nOptions\n\nrequireSignature (boolean): Require the token to be signed. Default: false.\n\nEdit on GitHub\n\nPrevious Page\n\nUtility\n\nNext Page\n\nDevice Authorization"
  },
  {
    "title": "Device Authorization | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/device-authorization",
    "html": "Device Authorization\nCopy Markdown\nOpen in\n\nRFC 8628 CLI Smart TV IoT\n\nThe Device Authorization plugin implements the OAuth 2.0 Device Authorization Grant (RFC 8628), enabling authentication for devices with limited input capabilities such as smart TVs, CLI applications, IoT devices, and gaming consoles.\n\nTry It Out\n\nYou can test the device authorization flow right now using the Better Auth CLI:\n\nnpx @better-auth/cli login\n\nThis will demonstrate the complete device authorization flow by:\n\nRequesting a device code from the Better Auth demo server\nDisplaying a user code for you to enter\nOpening your browser to the verification page\nPolling for authorization completion\n\nThe CLI login command is a demo feature that connects to the Better Auth demo server to showcase the device authorization flow in action.\n\nInstallation\nAdd the plugin to your auth config\n\nAdd the device authorization plugin to your server configuration.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { deviceAuthorization } from \"better-auth/plugins\"; \nexport const auth = betterAuth({\n  // ... other config\n  plugins: [ \n    deviceAuthorization({ \n      // Optional configuration\n      expiresIn: \"30m\", // Device code expiration time\n      interval: \"5s\",    // Minimum polling interval\n    }), \n  ], \n});\nMigrate the database\n\nRun the migration or generate the schema to add the necessary tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nSee the Schema section to add the fields manually.\n\nAdd the client plugin\n\nAdd the device authorization plugin to your client.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nimport { deviceAuthorizationClient } from \"better-auth/client/plugins\"; \nexport const authClient = createAuthClient({\n  plugins: [ \n    deviceAuthorizationClient(), \n  ], \n});\nHow It Works\n\nThe device flow follows these steps:\n\nDevice requests codes: The device requests a device code and user code from the authorization server\nUser authorizes: The user visits a verification URL and enters the user code\nDevice polls for token: The device polls the server until the user completes authorization\nAccess granted: Once authorized, the device receives an access token\nBasic Usage\nRequesting Device Authorization\n\nTo initiate device authorization, call device.code with the client ID:\n\nClient\nServer\nPOST\n/device/code\nconst { data, error } = await authClient.device.code({\n    client_id, // required\n    scope,\n});\nProp\tDescription\tType\nclient_id\t\nThe OAuth client identifier\n\tstring;\nscope?\t\nSpace-separated list of requested scopes (optional)\n\tstring;\n\nExample usage:\n\nconst { data } = await authClient.device.code({\n  client_id: \"your-client-id\",\n  scope: \"openid profile email\",\n});\nif (data) {\n  console.log(`Please visit: ${data.verification_uri}`);\n  console.log(`And enter code: ${data.user_code}`);\n}\nPolling for Token\n\nAfter displaying the user code, poll for the access token:\n\nClient\nServer\nPOST\n/device/token\nconst { data, error } = await authClient.device.token({\n    grant_type, // required\n    device_code, // required\n    client_id, // required\n});\nProp\tDescription\tType\ngrant_type\t\nMust be \"urn:ietf:params:oauth:grant-type:device_code\"\n\tstring;\ndevice_code\t\nThe device code from the initial request\n\tstring;\nclient_id\t\nThe OAuth client identifier\n\tstring;\n\nExample polling implementation:\n\nlet pollingInterval = 5; // Start with 5 seconds\nconst pollForToken = async () => {\n  const { data, error } = await authClient.device.token({\n    grant_type: \"urn:ietf:params:oauth:grant-type:device_code\",\n    device_code,\n    client_id: yourClientId,\n    fetchOptions: {\n      headers: {\n        \"user-agent\": `My CLI`,\n      },\n    },\n  });\n  if (data?.access_token) {\n    console.log(\"Authorization successful!\");\n  } else if (error) {\n    switch (error.error) {\n      case \"authorization_pending\":\n        // Continue polling\n        break;\n      case \"slow_down\":\n        pollingInterval += 5;\n        break;\n      case \"access_denied\":\n        console.error(\"Access was denied by the user\");\n        return;\n      case \"expired_token\":\n        console.error(\"The device code has expired. Please try again.\");\n        return;\n      default:\n        console.error(`Error: ${error.error_description}`);\n        return;\n    }\n    setTimeout(pollForToken, pollingInterval * 1000);\n  }\n};\npollForToken();\nUser Authorization Flow\n\nThe user authorization flow requires two steps:\n\nCode Verification: Check if the entered user code is valid\nAuthorization: User must be authenticated to approve/deny the device\n\nUsers must be authenticated before they can approve or deny device authorization requests. If not authenticated, redirect them to the login page with a return URL.\n\nCreate a page where users can enter their code:\n\napp/device/page.tsx\nexport default function DeviceAuthorizationPage() {\n  const [userCode, setUserCode] = useState(\"\");\n  const [error, setError] = useState(null);\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    \n    try {\n      // Format the code: remove dashes and convert to uppercase\n      const formattedCode = userCode.trim().replace(/-/g, \"\").toUpperCase();\n      // Check if the code is valid using GET /device endpoint\n      const response = await authClient.device({\n        query: { user_code: formattedCode },\n      });\n      \n      if (response.data) {\n        // Redirect to approval page\n        window.location.href = `/device/approve?user_code=${formattedCode}`;\n      }\n    } catch (err) {\n      setError(\"Invalid or expired code\");\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        value={userCode}\n        onChange={(e) => setUserCode(e.target.value)}\n        placeholder=\"Enter device code (e.g., ABCD-1234)\"\n        maxLength={12}\n      />\n      <button type=\"submit\">Continue</button>\n      {error && <p>{error}</p>}\n    </form>\n  );\n}\nApproving or Denying Device\n\nUsers must be authenticated to approve or deny device authorization requests:\n\nApprove Device\nClient\nServer\nPOST\n/device/approve\nconst { data, error } = await authClient.device.approve({\n    userCode, // required\n});\nProp\tDescription\tType\nuserCode\t\nThe user code to approve\n\tstring;\nDeny Device\nClient\nServer\nPOST\n/device/deny\nconst { data, error } = await authClient.device.deny({\n    userCode, // required\n});\nProp\tDescription\tType\nuserCode\t\nThe user code to deny\n\tstring;\nExample Approval Page\napp/device/approve/page.tsx\nexport default function DeviceApprovalPage() {\n  const { user } = useAuth(); // Must be authenticated\n  const searchParams = useSearchParams();\n  const userCode = searchParams.get(\"userCode\");\n  const [isProcessing, setIsProcessing] = useState(false);\n  \n  const handleApprove = async () => {\n    setIsProcessing(true);\n    try {\n      await authClient.device.approve({\n        userCode: userCode,\n      });\n      // Show success message\n      alert(\"Device approved successfully!\");\n      window.location.href = \"/\";\n    } catch (error) {\n      alert(\"Failed to approve device\");\n    }\n    setIsProcessing(false);\n  };\n  \n  const handleDeny = async () => {\n    setIsProcessing(true);\n    try {\n      await authClient.device.deny({\n        userCode: userCode,\n      });\n      alert(\"Device denied\");\n      window.location.href = \"/\";\n    } catch (error) {\n      alert(\"Failed to deny device\");\n    }\n    setIsProcessing(false);\n  };\n  if (!user) {\n    // Redirect to login if not authenticated\n    window.location.href = `/login?redirect=/device/approve?user_code=${userCode}`;\n    return null;\n  }\n  \n  return (\n    <div>\n      <h2>Device Authorization Request</h2>\n      <p>A device is requesting access to your account.</p>\n      <p>Code: {userCode}</p>\n      \n      <button onClick={handleApprove} disabled={isProcessing}>\n        Approve\n      </button>\n      <button onClick={handleDeny} disabled={isProcessing}>\n        Deny\n      </button>\n    </div>\n  );\n}\nAdvanced Configuration\nClient Validation\n\nYou can validate client IDs to ensure only authorized applications can use the device flow:\n\ndeviceAuthorization({\n  validateClient: async (clientId) => {\n    // Check if client is authorized\n    const client = await db.oauth_clients.findOne({ id: clientId });\n    return client && client.allowDeviceFlow;\n  },\n  \n  onDeviceAuthRequest: async (clientId, scope) => {\n    // Log device authorization requests\n    await logDeviceAuthRequest(clientId, scope);\n  },\n})\nCustom Code Generation\n\nCustomize how device and user codes are generated:\n\ndeviceAuthorization({\n  generateDeviceCode: async () => {\n    // Custom device code generation\n    return crypto.randomBytes(32).toString(\"hex\");\n  },\n  \n  generateUserCode: async () => {\n    // Custom user code generation\n    // Default uses: ABCDEFGHJKLMNPQRSTUVWXYZ23456789\n    // (excludes 0, O, 1, I to avoid confusion)\n    const charset = \"ABCDEFGHJKLMNPQRSTUVWXYZ23456789\";\n    let code = \"\";\n    for (let i = 0; i < 8; i++) {\n      code += charset[Math.floor(Math.random() * charset.length)];\n    }\n    return code;\n  },\n})\nError Handling\n\nThe device flow defines specific error codes:\n\nError Code\tDescription\nauthorization_pending\tUser hasn't approved yet (continue polling)\nslow_down\tPolling too frequently (increase interval)\nexpired_token\tDevice code has expired\naccess_denied\tUser denied the authorization\ninvalid_grant\tInvalid device code or client ID\nExample: CLI Application\n\nHere's a complete example for a CLI application based on the actual demo:\n\ncli-auth.ts\nimport { createAuthClient } from \"better-auth/client\";\nimport { deviceAuthorizationClient } from \"better-auth/client/plugins\";\nimport open from \"open\";\nconst authClient = createAuthClient({\n  baseURL: \"http://localhost:3000\",\n  plugins: [deviceAuthorizationClient()],\n});\nasync function authenticateCLI() {\n  console.log(\"ðŸ” Better Auth Device Authorization Demo\");\n  console.log(\"â³ Requesting device authorization...\");\n  \n  try {\n    // Request device code\n    const { data, error } = await authClient.device.code({\n      client_id: \"demo-cli\",\n      scope: \"openid profile email\",\n    });\n    \n    if (error || !data) {\n      console.error(\"âŒ Error:\", error?.error_description);\n      process.exit(1);\n    }\n    \n    const {\n      device_code,\n      user_code,\n      verification_uri,\n      verification_uri_complete,\n      interval = 5,\n    } = data;\n    \n    console.log(\"\\nðŸ“± Device Authorization in Progress\");\n    console.log(`Please visit: ${verification_uri}`);\n    console.log(`Enter code: ${user_code}\\n`);\n    \n    // Open browser with the complete URL\n    const urlToOpen = verification_uri_complete || verification_uri;\n    if (urlToOpen) {\n      console.log(\"ðŸŒ Opening browser...\");\n      await open(urlToOpen);\n    }\n    \n    console.log(`â³ Waiting for authorization... (polling every ${interval}s)`);\n    \n    // Poll for token\n    await pollForToken(device_code, interval);\n  } catch (err) {\n    console.error(\"âŒ Error:\", err.message);\n    process.exit(1);\n  }\n}\nasync function pollForToken(deviceCode: string, interval: number) {\n  let pollingInterval = interval;\n  \n  return new Promise<void>((resolve) => {\n    const poll = async () => {\n      try {\n        const { data, error } = await authClient.device.token({\n          grant_type: \"urn:ietf:params:oauth:grant-type:device_code\",\n          device_code: deviceCode,\n          client_id: \"demo-cli\",\n        });\n        \n        if (data?.access_token) {\n          console.log(\"\\nAuthorization Successful!\");\n          console.log(\"Access token received!\");\n          \n          // Get user session\n          const { data: session } = await authClient.getSession({\n            fetchOptions: {\n              headers: {\n                Authorization: `Bearer ${data.access_token}`,\n              },\n            },\n          });\n          \n          console.log(`Hello, ${session?.user?.name || \"User\"}!`);\n          resolve();\n          process.exit(0);\n        } else if (error) {\n          switch (error.error) {\n            case \"authorization_pending\":\n              // Continue polling silently\n              break;\n            case \"slow_down\":\n              pollingInterval += 5;\n              console.log(`âš ï¸  Slowing down polling to ${pollingInterval}s`);\n              break;\n            case \"access_denied\":\n              console.error(\"âŒ Access was denied by the user\");\n              process.exit(1);\n              break;\n            case \"expired_token\":\n              console.error(\"âŒ The device code has expired. Please try again.\");\n              process.exit(1);\n              break;\n            default:\n              console.error(\"âŒ Error:\", error.error_description);\n              process.exit(1);\n          }\n        }\n      } catch (err) {\n        console.error(\"âŒ Network error:\", err.message);\n        process.exit(1);\n      }\n      \n      // Schedule next poll\n      setTimeout(poll, pollingInterval * 1000);\n    };\n    \n    // Start polling\n    setTimeout(poll, pollingInterval * 1000);\n  });\n}\n// Run the authentication flow\nauthenticateCLI().catch((err) => {\n  console.error(\"âŒ Fatal error:\", err);\n  process.exit(1);\n});\nSecurity Considerations\nRate Limiting: The plugin enforces polling intervals to prevent abuse\nCode Expiration: Device and user codes expire after the configured time (default: 30 minutes)\nClient Validation: Always validate client IDs in production to prevent unauthorized access\nHTTPS Only: Always use HTTPS in production for device authorization\nUser Code Format: User codes use a limited character set (excluding similar-looking characters like 0/O, 1/I) to reduce typing errors\nAuthentication Required: Users must be authenticated before they can approve or deny device requests\nOptions\nServer\n\nexpiresIn: The expiration time for device codes. Default: \"30m\" (30 minutes).\n\ninterval: The minimum polling interval. Default: \"5s\" (5 seconds).\n\nuserCodeLength: The length of the user code. Default: 8.\n\ndeviceCodeLength: The length of the device code. Default: 40.\n\ngenerateDeviceCode: Custom function to generate device codes. Returns a string or Promise<string>.\n\ngenerateUserCode: Custom function to generate user codes. Returns a string or Promise<string>.\n\nvalidateClient: Function to validate client IDs. Takes a clientId and returns boolean or Promise<boolean>.\n\nonDeviceAuthRequest: Hook called when device authorization is requested. Takes clientId and optional scope.\n\nClient\n\nNo client-specific configuration options. The plugin adds the following methods:\n\ndevice(): Verify user code validity\ndevice.code(): Request device and user codes\ndevice.token(): Poll for access token\ndevice.approve(): Approve device (requires authentication)\ndevice.deny(): Deny device (requires authentication)\nSchema\n\nThe plugin requires a new table to store device authorization data.\n\nTable Name: deviceCode\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for the device authorization request\ndeviceCode\tstring\t-\tThe device verification code\nuserCode\tstring\t-\tThe user-friendly code for verification\nuserId\tstring\t\nFK?\tThe ID of the user who approved/denied\nclientId\tstring\t?\tThe OAuth client identifier\nscope\tstring\t?\tRequested OAuth scopes\nstatus\tstring\t-\tCurrent status: pending, approved, or denied\nexpiresAt\tDate\t-\tWhen the device code expires\nlastPolledAt\tDate\t?\tLast time the device polled for status\npollingInterval\tnumber\t?\tMinimum seconds between polls\ncreatedAt\tDate\t-\tWhen the request was created\nupdatedAt\tDate\t-\tWhen the request was last updated\nEdit on GitHub\n\nPrevious Page\n\nBearer\n\nNext Page\n\nCaptcha"
  },
  {
    "title": "Captcha | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/captcha",
    "html": "Captcha\nCopy Markdown\nOpen in\n\nThe Captcha Plugin integrates bot protection into your Better Auth system by adding captcha verification for key endpoints. This plugin ensures that only human users can perform actions like signing up, signing in, or resetting passwords. The following providers are currently supported:\n\nGoogle reCAPTCHA\nCloudflare Turnstile\nhCaptcha\nCaptchaFox\n\nThis plugin works out of the box with Email & Password authentication. To use it with other authentication methods, you will need to configure the endpoints array in the plugin options.\n\nInstallation\nAdd the plugin to your auth config\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { captcha } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n    plugins: [ \n        captcha({ \n            provider: \"cloudflare-turnstile\", // or google-recaptcha, hcaptcha, captchafox\n            secretKey: process.env.TURNSTILE_SECRET_KEY!, \n        }), \n    ], \n});\nAdd the captcha token to your request headers\n\nAdd the captcha token to your request headers for all protected endpoints. This example shows how to include it in a signIn request:\n\nawait authClient.signIn.email({\n    email: \"user@example.com\",\n    password: \"secure-password\",\n    fetchOptions: { \n        headers: { \n            \"x-captcha-response\": turnstileToken, \n            \"x-captcha-user-remote-ip\": userIp, // optional: forwards the user's IP address to the captcha service\n        }, \n    }, \n});\nTo implement Cloudflare Turnstile on the client side, follow the official Cloudflare Turnstile documentation or use a library like react-turnstile.\nTo implement Google reCAPTCHA on the client side, follow the official Google reCAPTCHA documentation or use libraries like react-google-recaptcha (v2) and react-google-recaptcha-v3 (v3).\nTo implement hCaptcha on the client side, follow the official hCaptcha documentation or use libraries like @hcaptcha/react-hcaptcha\nTo implement CaptchaFox on the client side, follow the official CaptchaFox documentation or use libraries like @captchafox/react\nHow it works\n\nThe plugin acts as a middleware: it intercepts all POST requests to configured endpoints (see endpoints in the Plugin Options section).\n\nit validates the captcha token on the server, by calling the captcha provider's /siteverify.\n\nif the token is missing, gets rejected by the captcha provider, or if the /siteverify endpoint is unavailable, the plugin returns an error and interrupts the request.\nif the token is accepted by the captcha provider, the middleware returns undefined, meaning the request is allowed to proceed.\nPlugin Options\nprovider (required): your captcha provider.\nsecretKey (required): your provider's secret key used for the server-side validation.\nendpoints (optional): overrides the default array of paths where captcha validation is enforced. Default is: [\"/sign-up/email\", \"/sign-in/email\", \"/forget-password\",].\nminScore (optional - only Google ReCAPTCHA v3): minimum score threshold. Default is 0.5.\nsiteKey (optional - only hCaptcha and CaptchaFox): prevents tokens issued on one sitekey from being redeemed elsewhere.\nsiteVerifyURLOverride (optional): overrides endpoint URL for the captcha verification request.\nEdit on GitHub\n\nPrevious Page\n\nDevice Authorization\n\nNext Page\n\nHave I Been Pwned"
  },
  {
    "title": "Have I Been Pwned | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/have-i-been-pwned",
    "html": "Have I Been Pwned\nCopy Markdown\nOpen in\n\nThe Have I Been Pwned plugin helps protect user accounts by preventing the use of passwords that have been exposed in known data breaches. It uses the Have I Been Pwned API to check if a password has been compromised.\n\nInstallation\nAdd the plugin to your auth config\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { haveIBeenPwned } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    plugins: [\n        haveIBeenPwned()\n    ]\n})\nUsage\n\nWhen a user attempts to create an account or update their password with a compromised password, they'll receive the following default error:\n\n{\n  \"code\": \"PASSWORD_COMPROMISED\",\n  \"message\": \"Password is compromised\"\n}\nConfig\n\nYou can customize the error message:\n\nhaveIBeenPwned({\n    customPasswordCompromisedMessage: \"Please choose a more secure password.\"\n})\nSecurity Notes\nOnly the first 5 characters of the password hash are sent to the API\nThe full password is never transmitted\nProvides an additional layer of account security\nEdit on GitHub\n\nPrevious Page\n\nCaptcha\n\nNext Page\n\nLast Login Method"
  },
  {
    "title": "Multi Session | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/multi-session",
    "html": "Multi Session\nCopy Markdown\nOpen in\n\nThe multi-session plugin allows users to maintain multiple active sessions across different accounts in the same browser. This plugin is useful for applications that require users to switch between multiple accounts without logging out.\n\nInstallation\nAdd the plugin to your auth config\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { multiSession } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    plugins: [ \n        multiSession(), \n    ] \n})\nAdd the client Plugin\n\nAdd the client plugin and Specify where the user should be redirected if they need to verify 2nd factor\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { multiSessionClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n    plugins: [\n        multiSessionClient()\n    ]\n})\nUsage\n\nWhenever a user logs in, the plugin will add additional cookie to the browser. This cookie will be used to maintain multiple sessions across different accounts.\n\nList all device sessions\n\nTo list all active sessions for the current user, you can call the listDeviceSessions method.\n\nClient\nServer\nGET\n/multi-session/list-device-sessions\nconst { data, error } = await authClient.multiSession.listDeviceSessions();\nSet active session\n\nTo set the active session, you can call the setActive method.\n\nClient\nServer\nPOST\n/multi-session/set-active\nconst { data, error } = await authClient.multiSession.setActive({\n    sessionToken: \"some-session-token\", // required\n});\nProp\tDescription\tType\nsessionToken\t\nThe session token to set as active.\n\tstring\nRevoke a session\n\nTo revoke a session, you can call the revoke method.\n\nClient\nServer\nPOST\n/multi-session/revoke\nconst { data, error } = await authClient.multiSession.revoke({\n    sessionToken: \"some-session-token\", // required\n});\nProp\tDescription\tType\nsessionToken\t\nThe session token to revoke.\n\tstring\nSignout and Revoke all sessions\n\nWhen a user logs out, the plugin will revoke all active sessions for the user. You can do this by calling the existing signOut method, which handles revoking all sessions automatically.\n\nMax Sessions\n\nYou can specify the maximum number of sessions a user can have by passing the maximumSessions option to the plugin. By default, the plugin allows 5 sessions per device.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    plugins: [\n        multiSession({\n            maximumSessions: 3\n        })\n    ]\n})\nEdit on GitHub\n\nPrevious Page\n\nLast Login Method\n\nNext Page\n\nOAuth Proxy"
  },
  {
    "title": "Last Login Method | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/last-login-method",
    "html": "Last Login Method\nCopy Markdown\nOpen in\n\nThe last login method plugin tracks the most recent authentication method used by users (email, OAuth providers, etc.). This enables you to display helpful indicators on login pages, such as \"Last signed in with Google\" or prioritize certain login methods based on user preferences.\n\nInstallation\nAdd the plugin to your auth config\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { lastLoginMethod } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    // ... other config options\n    plugins: [\n        lastLoginMethod() \n    ]\n})\nAdd the client plugin to your auth client\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { lastLoginMethodClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n    plugins: [\n        lastLoginMethodClient() \n    ]\n})\nUsage\n\nOnce installed, the plugin automatically tracks the last authentication method used by users. You can then retrieve and display this information in your application.\n\nGetting the Last Used Method\n\nThe client plugin provides several methods to work with the last login method:\n\napp.tsx\nimport { authClient } from \"@/lib/auth-client\"\n// Get the last used login method\nconst lastMethod = authClient.getLastUsedLoginMethod()\nconsole.log(lastMethod) // \"google\", \"email\", \"github\", etc.\n// Check if a specific method was last used\nconst wasGoogle = authClient.isLastUsedLoginMethod(\"google\")\n// Clear the stored method\nauthClient.clearLastUsedLoginMethod()\nUI Integration Example\n\nHere's how to use the plugin to enhance your login page:\n\nsign-in.tsx\nimport { authClient } from \"@/lib/auth-client\"\nimport { Button } from \"@/components/ui/button\"\nimport { Badge } from \"@/components/ui/badge\"\nexport function SignInPage() {\n    const lastMethod = authClient.getLastUsedLoginMethod()\n    \n    return (\n        <div className=\"space-y-4\">\n            <h1>Sign In</h1>\n            \n            {/* Email sign in */}\n            <div className=\"relative\">\n                <Button \n                    onClick={() => authClient.signIn.email({...})}\n                    variant={lastMethod === \"email\" ? \"default\" : \"outline\"}\n                    className=\"w-full\"\n                >\n                    Sign in with Email\n                    {lastMethod === \"email\" && (\n                        <Badge className=\"ml-2\">Last used</Badge>\n                    )}\n                </Button>\n            </div>\n            \n            {/* OAuth providers */}\n            <div className=\"relative\">\n                <Button \n                    onClick={() => authClient.signIn.social({ provider: \"google\" })}\n                    variant={lastMethod === \"google\" ? \"default\" : \"outline\"}\n                    className=\"w-full\"\n                >\n                    Continue with Google\n                    {lastMethod === \"google\" && (\n                        <Badge className=\"ml-2\">Last used</Badge>\n                    )}\n                </Button>\n            </div>\n            \n            <div className=\"relative\">\n                <Button \n                    onClick={() => authClient.signIn.social({ provider: \"github\" })}\n                    variant={lastMethod === \"github\" ? \"default\" : \"outline\"}\n                    className=\"w-full\"\n                >\n                    Continue with GitHub\n                    {lastMethod === \"github\" && (\n                        <Badge className=\"ml-2\">Last used</Badge>\n                    )}\n                </Button>\n            </div>\n        </div>\n    )\n}\nDatabase Persistence\n\nBy default, the last login method is stored only in cookies. For more persistent tracking and analytics, you can enable database storage.\n\nEnable database storage\n\nSet storeInDatabase to true in your plugin configuration:\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { lastLoginMethod } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    plugins: [\n        lastLoginMethod({\n            storeInDatabase: true\n        })\n    ]\n})\nRun database migration\n\nThe plugin will automatically add a lastLoginMethod field to your user table. Run the migration to apply the changes:\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\nAccess database field\n\nWhen database storage is enabled, the lastLoginMethod field becomes available in user objects:\n\nuser-profile.tsx\nimport { auth } from \"@/lib/auth\"\n// Server-side access\nconst session = await auth.api.getSession({ headers })\nconsole.log(session?.user.lastLoginMethod) // \"google\", \"email\", etc.\n// Client-side access via session\nconst { data: session } = authClient.useSession()\nconsole.log(session?.user.lastLoginMethod)\nDatabase Schema\n\nWhen storeInDatabase is enabled, the plugin adds the following field to the user table:\n\nTable: user\n\nField Name\tType\tKey\tDescription\nlastLoginMethod\tstring\t?\tThe last authentication method used by the user\nCustom Schema Configuration\n\nYou can customize the database field name:\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { lastLoginMethod } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    plugins: [\n        lastLoginMethod({\n            storeInDatabase: true,\n            schema: {\n                user: {\n                    lastLoginMethod: \"last_auth_method\" // Custom field name\n                }\n            }\n        })\n    ]\n})\nConfiguration Options\n\nThe last login method plugin accepts the following options:\n\nServer Options\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { lastLoginMethod } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    plugins: [\n        lastLoginMethod({\n            // Cookie configuration\n            cookieName: \"better-auth.last_used_login_method\", // Default: \"better-auth.last_used_login_method\"\n            maxAge: 60 * 60 * 24 * 30, // Default: 30 days in seconds\n            \n            // Database persistence\n            storeInDatabase: false, // Default: false\n            \n            // Custom method resolution\n            customResolveMethod: (ctx) => {\n                // Custom logic to determine the login method\n                if (ctx.path === \"/oauth/callback/custom-provider\") {\n                    return \"custom-provider\"\n                }\n                // Return null to use default resolution\n                return null\n            },\n            \n            // Schema customization (when storeInDatabase is true)\n            schema: {\n                user: {\n                    lastLoginMethod: \"custom_field_name\"\n                }\n            }\n        })\n    ]\n})\n\ncookieName: string\n\nThe name of the cookie used to store the last login method\nDefault: \"better-auth.last_used_login_method\"\nNote: This cookie is httpOnly: false to allow client-side JavaScript access for UI features\n\nmaxAge: number\n\nCookie expiration time in seconds\nDefault: 2592000 (30 days)\n\nstoreInDatabase: boolean\n\nWhether to store the last login method in the database\nDefault: false\nWhen enabled, adds a lastLoginMethod field to the user table\n\ncustomResolveMethod: (ctx: GenericEndpointContext) => string | null\n\nCustom function to determine the login method from the request context\nReturn null to use the default resolution logic\nUseful for custom OAuth providers or authentication flows\n\nschema: object\n\nCustomize database field names when storeInDatabase is enabled\nAllows mapping the lastLoginMethod field to a custom column name\nClient Options\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { lastLoginMethodClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n    plugins: [\n        lastLoginMethodClient({\n            cookieName: \"better-auth.last_used_login_method\" // Default: \"better-auth.last_used_login_method\"\n        })\n    ]\n})\n\ncookieName: string\n\nThe name of the cookie to read the last login method from\nMust match the server-side cookieName configuration\nDefault: \"better-auth.last_used_login_method\"\nDefault Method Resolution\n\nBy default, the plugin tracks these authentication methods:\n\nEmail authentication: \"email\"\nOAuth providers: Provider ID (e.g., \"google\", \"github\", \"discord\")\nOAuth2 callbacks: Provider ID from URL path\nSign up methods: Tracked the same as sign in methods\n\nThe plugin automatically detects the method from these endpoints:\n\n/callback/:id - OAuth callback with provider ID\n/oauth2/callback/:id - OAuth2 callback with provider ID\n/sign-in/email - Email sign in\n/sign-up/email - Email sign up\nCross-Domain Support\n\nThe plugin automatically inherits cookie settings from Better Auth's centralized cookie system. This solves the problem where the last login method wouldn't persist across:\n\nCross-subdomain setups: auth.example.com â†’ app.example.com\nCross-origin setups: api.company.com â†’ app.different.com\n\nWhen you enable crossSubDomainCookies or crossOriginCookies in your Better Auth config, the plugin will automatically use the same domain, secure, and sameSite settings as your session cookies, ensuring consistent behavior across your application.\n\nAdvanced Examples\nCustom Provider Tracking\n\nIf you have custom OAuth providers or authentication methods, you can use the customResolveMethod option:\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { lastLoginMethod } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    plugins: [\n        lastLoginMethod({\n            customResolveMethod: (ctx) => {\n                // Track custom SAML provider\n                if (ctx.path === \"/saml/callback\") {\n                    return \"saml\"\n                }\n                \n                // Track magic link authentication\n                if (ctx.path === \"/magic-link/verify\") {\n                    return \"magic-link\"\n                }\n                \n                // Track phone authentication\n                if (ctx.path === \"/sign-in/phone\") {\n                    return \"phone\"\n                }\n                \n                // Return null to use default logic\n                return null\n            }\n        })\n    ]\n})\nEdit on GitHub\n\nPrevious Page\n\nHave I Been Pwned\n\nNext Page\n\nMulti Session"
  },
  {
    "title": "OAuth Proxy | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/oauth-proxy",
    "html": "OAuth Proxy\nCopy Markdown\nOpen in\n\nA proxy plugin, that allows you to proxy OAuth requests. Useful for development and preview deployments where the redirect URL can't be known in advance to add to the OAuth provider.\n\nInstallation\nAdd the plugin to your auth config\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { oAuthProxy } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    plugins: [ \n        oAuthProxy({ \n            productionURL: \"https://my-main-app.com\", // Optional - if the URL isn't inferred correctly\n            currentURL: \"http://localhost:3000\", // Optional - if the URL isn't inferred correctly\n        }), \n    ] \n})\nAdd redirect URL to your OAuth provider\n\nFor the proxy server to work properly, youâ€™ll need to pass the redirect URL of your main production app registered with the OAuth provider in your social provider config. This needs to be done for each social provider you want to proxy requests for.\n\nexport const auth = betterAuth({\n   plugins: [\n       oAuthProxy(),\n   ], \n   socialProviders: {\n        github: {\n            clientId: \"your-client-id\",\n            clientSecret: \"your-client-secret\",\n            redirectURI: \"https://my-main-app.com/api/auth/callback/github\"\n        }\n   }\n})\nHow it works\n\nThe plugin adds an endpoint to your server that proxies OAuth requests. When you initiate a social sign-in, it sets the redirect URL to this proxy endpoint. After the OAuth provider redirects back to your server, the plugin then forwards the user to the original callback URL.\n\nawait authClient.signIn.social({\n    provider: \"github\",\n    callbackURL: \"/dashboard\" // the plugin will override this to something like \"http://localhost:3000/api/auth/oauth-proxy?callbackURL=/dashboard\"\n})\n\nWhen the OAuth provider returns the user to your server, the plugin automatically redirects them to the intended callback URL.\n\nTo share cookies between the proxy server and your main server it uses URL query parameters to pass the cookies encrypted in the URL. This is secure as the cookies are encrypted and can only be decrypted by the server.\n\nThis plugin requires skipping the state cookie check. This has security implications and should only be used in dev or staging environments. If baseURL and productionURL are the same, the plugin will not proxy the request.\n\nOptions\n\ncurrentURL: The application's current URL is automatically determined by the plugin. It first checks for the request URL if invoked by a client, then it checks the base URL from popular hosting providers, and finally falls back to the baseURL in your auth config. If the URL isnâ€™t inferred correctly, you can specify it manually here.\n\nproductionURL: If this value matches the baseURL in your auth config, requests will not be proxied. Defaults to the BETTER_AUTH_URL environment variable.\n\nEdit on GitHub\n\nPrevious Page\n\nMulti Session\n\nNext Page\n\nOne-Time Token"
  },
  {
    "title": "One-Time Token Plugin | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/one-time-token",
    "html": "One-Time Token Plugin\nCopy Markdown\nOpen in\n\nThe One-Time Token (OTT) plugin provides functionality to generate and verify secure, single-use session tokens. These are commonly used for across domains authentication.\n\nInstallation\nAdd the plugin to your auth config\n\nTo use the One-Time Token plugin, add it to your auth config.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { oneTimeToken } from \"better-auth/plugins/one-time-token\";\nexport const auth = betterAuth({\n    plugins: [\n      oneTimeToken()\n    ]\n    // ... other auth config\n});\nAdd the client plugin\n\nNext, include the one-time-token client plugin in your authentication client instance.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { oneTimeTokenClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n    plugins: [\n        oneTimeTokenClient()\n    ]\n})\nUsage\n1. Generate a Token\n\nGenerate a token using auth.api.generateOneTimeToken or authClient.oneTimeToken.generate\n\nClient\nServer\nGET\n/one-time-token/generate\nconst { data, error } = await authClient.oneTimeToken.generate();\n\nThis will return a token that is attached to the current session which can be used to verify the one-time token. By default, the token will expire in 3 minutes.\n\n2. Verify the Token\n\nWhen the user clicks the link or submits the token, use the auth.api.verifyOneTimeToken or authClient.oneTimeToken.verify method in another API route to validate it.\n\nClient\nServer\nPOST\n/one-time-token/verify\nconst { data, error } = await authClient.oneTimeToken.verify({\n    token: \"some-token\", // required\n});\nProp\tDescription\tType\ntoken\t\nThe token to verify.\n\tstring\n\nThis will return the session that was attached to the token.\n\nOptions\n\nThese options can be configured when adding the oneTimeToken plugin:\n\ndisableClientRequest (boolean): Optional. If true, the token will only be generated on the server side. Default: false.\nexpiresIn (number): Optional. The duration for which the token is valid in minutes. Default: 3.\noneTimeToken({\n    expiresIn: 10 // 10 minutes\n})\n\ngenerateToken: A custom token generator function that takes session object and a ctx as parameters.\n\nstoreToken: Optional. This option allows you to configure how the token is stored in your database.\n\nplain: The token is stored in plain text. (Default)\nhashed: The token is hashed using the default hasher.\ncustom-hasher: A custom hasher function that takes a token and returns a hashed token.\n\nNote: It will not affect the token that's sent, it will only affect the token stored in your database.\n\nExamples:\n\nNo hashing (default)\noneTimeToken({\n    storeToken: \"plain\"\n})\nbuilt-in hasher\noneTimeToken({\n    storeToken: \"hashed\"\n})\ncustom hasher\noneTimeToken({\n    storeToken: {\n        type: \"custom-hasher\",\n        hash: async (token) => {\n            return myCustomHasher(token);\n        }\n    }\n})\nEdit on GitHub\n\nPrevious Page\n\nOAuth Proxy\n\nNext Page\n\nOpen API"
  },
  {
    "title": "Open API | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/open-api",
    "html": "Open API\nCopy Markdown\nOpen in\n\nThis is a plugin that provides an Open API reference for Better Auth. It shows all endpoints added by plugins and the core. It also provides a way to test the endpoints. It uses Scalar to display the Open API reference.\n\nThis plugin is still in the early stages of development. We are working on adding more features to it and filling in the gaps.\n\nInstallation\nAdd the plugin to your auth config\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { openAPI } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    plugins: [ \n        openAPI(), \n    ] \n})\nNavigate to /api/auth/reference to view the Open API reference\n\nEach plugin endpoints are grouped by the plugin name. The core endpoints are grouped under the Default group. And Model schemas are grouped under the Models group.\n\nUsage\n\nThe Open API reference is generated using the OpenAPI 3.0 specification. You can use the reference to generate client libraries, documentation, and more.\n\nThe reference is generated using the Scalar library. Scalar provides a way to view and test the endpoints. You can test the endpoints by clicking on the Try it out button and providing the required parameters.\n\nGenerated Schema\n\nTo get the generated Open API schema directly as JSON, you can do auth.api.generateOpenAPISchema(). This will return the Open API schema as a JSON object.\n\nimport { auth } from \"~/lib/auth\"\nconst openAPISchema = await auth.api.generateOpenAPISchema()\nconsole.log(openAPISchema)\nUsing Scalar with Multiple Sources\n\nIf you're using Scalar for your API documentation, you can add Better Auth as an additional source alongside your main API:\n\nWhen using Hono with Scalar for OpenAPI documentation, you can integrate Better Auth by adding it as a source:\n\napp.get(\"/docs\", Scalar({\n  pageTitle: \"API Documentation\", \n  sources: [\n    { url: \"/api/open-api\", title: \"API\" },\n    // Better Auth schema generation endpoint\n    { url: \"/api/auth/open-api/generate-schema\", title: \"Auth\" },\n  ],\n}));\nConfiguration\n\npath - The path where the Open API reference is served. Default is /api/auth/reference. You can change it to any path you like, but keep in mind that it will be appended to the base path of your auth server.\n\ndisableDefaultReference - If set to true, the default Open API reference UI by Scalar will be disabled. Default is false.\n\nThis allows you to display both your application's API and Better Auth's authentication endpoints in a unified documentation interface.\n\ntheme - Allows you to change the theme of the OpenAPI reference page. Default is default.\n\nEdit on GitHub\n\nPrevious Page\n\nOne-Time Token\n\nNext Page\n\nJWT"
  },
  {
    "title": "JWT | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/jwt",
    "html": "JWT\nCopy Markdown\nOpen in\n\nThe JWT plugin provides endpoints to retrieve a JWT token and a JWKS endpoint to verify the token.\n\nThis plugin is not meant as a replacement for the session. It's meant to be used for services that require JWT tokens. If you're looking to use JWT tokens for authentication, check out the Bearer Plugin.\n\nInstallation\nAdd the plugin to your auth config\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { jwt } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    plugins: [ \n        jwt(), \n    ] \n})\nMigrate the database\n\nRun the migration or generate the schema to add the necessary fields and tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nSee the Schema section to add the fields manually.\n\nUsage\n\nOnce you've installed the plugin, you can start using the JWT & JWKS plugin to get the token and the JWKS through their respective endpoints.\n\nJWT\nRetrieve the token\n\nThere are multiple ways to retrieve JWT tokens:\n\nUsing the client plugin (recommended)\n\nAdd the jwtClient plugin to your auth client configuration:\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { jwtClient } from \"better-auth/client/plugins\"\nexport const authClient = createAuthClient({\n  plugins: [\n    jwtClient() \n  ]\n})\n\nThen use the client to get JWT tokens:\n\nconst { data, error } = await authClient.token()\nif (error) {\n  // handle error\n}\nif (data) {\n  const jwtToken = data.token\n  // Use this token for authenticated requests to external services\n}\n\nThis is the recommended approach for client applications that need JWT tokens for external API authentication.\n\nUsing your session token\n\nTo get the token, call the /token endpoint. This will return the following:\n\n  { \n    \"token\": \"ey...\"\n  }\n\nMake sure to include the token in the Authorization header of your requests if the bearer plugin is added in your auth configuration.\n\nawait fetch(\"/api/auth/token\", {\n  headers: {\n    \"Authorization\": `Bearer ${token}`\n  },\n})\nFrom set-auth-jwt header\n\nWhen you call getSession method, a JWT is returned in the set-auth-jwt header, which you can use to send to your services directly.\n\nawait authClient.getSession({\n  fetchOptions: {\n    onSuccess: (ctx)=>{\n      const jwt = ctx.response.headers.get(\"set-auth-jwt\")\n    }\n  }\n})\nVerifying the token\n\nThe token can be verified in your own service, without the need for an additional verify call or database check. For this JWKS is used. The public key can be fetched from the /api/auth/jwks endpoint.\n\nSince this key is not subject to frequent changes, it can be cached indefinitely. The key ID (kid) that was used to sign a JWT is included in the header of the token. In case a JWT with a different kid is received, it is recommended to fetch the JWKS again.\n\n  {\n    \"keys\": [\n        {\n            \"crv\": \"Ed25519\",\n            \"x\": \"bDHiLTt7u-VIU7rfmcltcFhaHKLVvWFy-_csKZARUEU\",\n            \"kty\": \"OKP\",\n            \"kid\": \"c5c7995d-0037-4553-8aee-b5b620b89b23\"\n        }\n    ]\n  }\nOAuth Provider Mode\n\nIf you are making your system oAuth compliant (such as when utilizing the OIDC or MCP plugins), you MUST disable the /token endpoint (oAuth equivalent /oauth2/token) and disable setting the jwt header (oAuth equivalent /oauth2/userinfo).\n\nauth.ts\nbetterAuth({\n  disabledPaths: [\n    \"/token\",\n  ],\n  plugins: [jwt({\n    disableSettingJwtHeader: true,\n  })]\n})\nExample using jose with remote JWKS\nimport { jwtVerify, createRemoteJWKSet } from 'jose'\nasync function validateToken(token: string) {\n  try {\n    const JWKS = createRemoteJWKSet(\n      new URL('http://localhost:3000/api/auth/jwks')\n    )\n    const { payload } = await jwtVerify(token, JWKS, {\n      issuer: 'http://localhost:3000', // Should match your JWT issuer, which is the BASE_URL\n      audience: 'http://localhost:3000', // Should match your JWT audience, which is the BASE_URL by default\n    })\n    return payload\n  } catch (error) {\n    console.error('Token validation failed:', error)\n    throw error\n  }\n}\n// Usage example\nconst token = 'your.jwt.token' // this is the token you get from the /api/auth/token endpoint\nconst payload = await validateToken(token)\nExample with local JWKS\nimport { jwtVerify, createLocalJWKSet } from 'jose'\nasync function validateToken(token: string) {\n  try {\n    /**\n     * This is the JWKS that you get from the /api/auth/\n     * jwks endpoint\n     */\n    const storedJWKS = {\n      keys: [{\n        //...\n      }]\n    };\n    const JWKS = createLocalJWKSet({\n      keys: storedJWKS.data?.keys!,\n    })\n    const { payload } = await jwtVerify(token, JWKS, {\n      issuer: 'http://localhost:3000', // Should match your JWT issuer, which is the BASE_URL\n      audience: 'http://localhost:3000', // Should match your JWT audience, which is the BASE_URL by default\n    })\n    return payload\n  } catch (error) {\n    console.error('Token validation failed:', error)\n    throw error\n  }\n}\n// Usage example\nconst token = 'your.jwt.token' // this is the token you get from the /api/auth/token endpoint\nconst payload = await validateToken(token)\nRemote JWKS Url\n\nDisables the /jwks endpoint and uses this endpoint in any discovery such as OIDC.\n\nUseful if your JWKS are not managed at /jwks or if your jwks are signed with a certificate and placed on your CDN.\n\nNOTE: you MUST specify which asymmetric algorithm is used for signing.\n\nauth.ts\njwt({\n  jwks: {\n    remoteUrl: \"https://example.com/.well-known/jwks.json\",\n    keyPairConfig: {\n      alg: 'ES256',\n    },\n  }\n})\nCustom Signing\n\nThis is an advanced feature. Configuration outside of this plugin MUST be provided.\n\nImplementers:\n\nremoteUrl must be defined if using the sign function. This shall store all active keys, not just the current one.\nIf using localized approach, ensure server uses the latest private key when rotated. Depending on deployment, the server may need to be restarted.\nWhen using remote approach, verify the payload is unchanged after transit. Use integrity validation like CRC32 or SHA256 checks if available.\nLocalized Signing\nauth.ts\njwt({\n  jwks: {\n    remoteUrl: \"https://example.com/.well-known/jwks.json\",\n    keyPairConfig: {\n      alg: 'EdDSA',\n    },\n  },\n  jwt: {\n    sign: async (jwtPayload: JWTPayload) => {\n      // this is pseudocode\n      return await new SignJWT(jwtPayload)\n        .setProtectedHeader({\n          alg: \"EdDSA\",\n          kid: process.env.currentKid,\n          typ: \"JWT\",\n        })\n        .sign(process.env.clientPrivateKey);\n    },\n  },\n})\nRemote Signing\n\nUseful if you are using a remote Key Management Service such as Google KMS, Amazon KMS, or Azure Key Vault.\n\nauth.ts\njwt({\n  jwks: {\n    remoteUrl: \"https://example.com/.well-known/jwks.json\",\n    keyPairConfig: {\n      alg: 'ES256',\n    },\n  },\n  jwt: {\n    sign: async (jwtPayload: JWTPayload) => {\n      // this is pseudocode\n      const headers = JSON.stringify({ kid: '123', alg: 'ES256', typ: 'JWT' })\n      const payload = JSON.stringify(jwtPayload)\n      const encodedHeaders = Buffer.from(headers).toString('base64url')\n      const encodedPayload = Buffer.from(payload).toString('base64url')\n      const hash = createHash('sha256')\n      const data = `${encodedHeaders}.${encodedPayload}`\n      hash.update(Buffer.from(data))\n      const digest = hash.digest()\n      const sig = await remoteSign(digest)\n      // integrityCheck(sig)\n      const jwt = `${data}.${sig}`\n      // verifyJwt(jwt)\n      return jwt\n    },\n  },\n})\nSchema\n\nThe JWT plugin adds the following tables to the database:\n\nJWKS\n\nTable Name: jwks\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for each web key\npublicKey\tstring\t-\tThe public part of the web key\nprivateKey\tstring\t-\tThe private part of the web key\ncreatedAt\tDate\t-\tTimestamp of when the web key was created\n\nYou can customize the table name and fields for the jwks table. See the Database concept documentation for more information on how to customize plugin schema.\n\nOptions\nAlgorithm of the Key Pair\n\nThe algorithm used for the generation of the key pair. The default is EdDSA with the Ed25519 curve. Below are the available options:\n\nauth.ts\njwt({\n  jwks: {\n    keyPairConfig: {\n      alg: \"EdDSA\",\n      crv: \"Ed25519\"\n    }\n  }\n})\nEdDSA\nDefault Curve: Ed25519\nOptional Property: crv\nAvailable options: Ed25519, Ed448\nDefault: Ed25519\nES256\nNo additional properties\nRSA256\nOptional Property: modulusLength\nExpects a number\nDefault: 2048\nPS256\nOptional Property: modulusLength\nExpects a number\nDefault: 2048\nECDH-ES\nOptional Property: crv\nAvailable options: P-256, P-384, P-521\nDefault: P-256\nES512\nNo additional properties\nDisable private key encryption\n\nBy default, the private key is encrypted using AES256 GCM. You can disable this by setting the disablePrivateKeyEncryption option to true.\n\nFor security reasons, it's recommended to keep the private key encrypted.\n\nauth.ts\njwt({\n  jwks: {\n    disablePrivateKeyEncryption: true\n  }\n})\nModify JWT payload\n\nBy default the entire user object is added to the JWT payload. You can modify the payload by providing a function to the definePayload option.\n\nauth.ts\njwt({\n  jwt: {\n    definePayload: ({user}) => {\n      return {\n        id: user.id,\n        email: user.email,\n        role: user.role\n      }\n    }\n  }\n})\nModify Issuer, Audience, Subject or Expiration time\n\nIf none is given, the BASE_URL is used as the issuer and the audience is set to the BASE_URL. The expiration time is set to 15 minutes.\n\nauth.ts\njwt({\n  jwt: {\n    issuer: \"https://example.com\",\n    audience: \"https://example.com\",\n    expirationTime: \"1h\",\n    getSubject: (session) => {\n      // by default the subject is the user id\n      return session.user.email\n    }\n  }\n})\nEdit on GitHub\n\nPrevious Page\n\nOpen API\n\nNext Page\n\n3rd party"
  },
  {
    "title": "Polar | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/polar",
    "html": "Polar\nCopy Markdown\nOpen in\n\nPolar is a developer first payment infrastructure. Out of the box it provides a lot of developer first integrations for payments, checkouts and more. This plugin helps you integrate Polar with Better Auth to make your auth + payments flow seamless.\n\nThis plugin is maintained by Polar team. For bugs, issues or feature requests, please visit the Polar GitHub repo.\n\nFeatures\nCheckout Integration\nCustomer Portal\nAutomatic Customer creation on signup\nEvent Ingestion & Customer Meters for flexible Usage Based Billing\nHandle Polar Webhooks securely with signature verification\nReference System to associate purchases with organizations\nInstallation\npnpm add better-auth @polar-sh/better-auth @polar-sh/sdk\nPreparation\n\nGo to your Polar Organization Settings, and create an Organization Access Token. Add it to your environment.\n\n# .env\nPOLAR_ACCESS_TOKEN=...\nConfiguring BetterAuth Server\n\nThe Polar plugin comes with a handful additional plugins which adds functionality to your stack.\n\nCheckout - Enables a seamless checkout integration\nPortal - Makes it possible for your customers to manage their orders, subscriptions & granted benefits\nUsage - Simple extension for listing customer meters & ingesting events for Usage Based Billing\nWebhooks - Listen for relevant Polar webhooks\nimport { betterAuth } from \"better-auth\";\nimport { polar, checkout, portal, usage, webhooks } from \"@polar-sh/better-auth\";\nimport { Polar } from \"@polar-sh/sdk\";\nconst polarClient = new Polar({\n    accessToken: process.env.POLAR_ACCESS_TOKEN,\n    // Use 'sandbox' if you're using the Polar Sandbox environment\n    // Remember that access tokens, products, etc. are completely separated between environments.\n    // Access tokens obtained in Production are for instance not usable in the Sandbox environment.\n    server: 'sandbox'\n});\nconst auth = betterAuth({\n    // ... Better Auth config\n    plugins: [\n        polar({\n            client: polarClient,\n            createCustomerOnSignUp: true,\n            use: [\n                checkout({\n                    products: [\n                        {\n                            productId: \"123-456-789\", // ID of Product from Polar Dashboard\n                            slug: \"pro\" // Custom slug for easy reference in Checkout URL, e.g. /checkout/pro\n                        }\n                    ],\n                    successUrl: \"/success?checkout_id={CHECKOUT_ID}\",\n                    authenticatedUsersOnly: true\n                }),\n                portal(),\n                usage(),\n                webhooks({\n                    secret: process.env.POLAR_WEBHOOK_SECRET,\n                    onCustomerStateChanged: (payload) => // Triggered when anything regarding a customer changes\n                    onOrderPaid: (payload) => // Triggered when an order was paid (purchase, subscription renewal, etc.)\n                    ...  // Over 25 granular webhook handlers\n                    onPayload: (payload) => // Catch-all for all events\n                })\n            ],\n        })\n    ]\n});\nConfiguring BetterAuth Client\n\nYou will be using the BetterAuth Client to interact with the Polar functionalities.\n\nimport { createAuthClient } from \"better-auth/react\";\nimport { polarClient } from \"@polar-sh/better-auth\";\n// This is all that is needed\n// All Polar plugins, etc. should be attached to the server-side BetterAuth config\nexport const authClient = createAuthClient({\n  plugins: [polarClient()],\n});\nConfiguration Options\nimport { betterAuth } from \"better-auth\";\nimport {\n  polar,\n  checkout,\n  portal,\n  usage,\n  webhooks,\n} from \"@polar-sh/better-auth\";\nimport { Polar } from \"@polar-sh/sdk\";\nconst polarClient = new Polar({\n  accessToken: process.env.POLAR_ACCESS_TOKEN,\n  // Use 'sandbox' if you're using the Polar Sandbox environment\n  // Remember that access tokens, products, etc. are completely separated between environments.\n  // Access tokens obtained in Production are for instance not usable in the Sandbox environment.\n  server: \"sandbox\",\n});\nconst auth = betterAuth({\n  // ... Better Auth config\n  plugins: [\n    polar({\n      client: polarClient,\n      createCustomerOnSignUp: true,\n      getCustomerCreateParams: ({ user }, request) => ({\n        metadata: {\n          myCustomProperty: 123,\n        },\n      }),\n      use: [\n        // This is where you add Polar plugins\n      ],\n    }),\n  ],\n});\nRequired Options\nclient: Polar SDK client instance\nOptional Options\ncreateCustomerOnSignUp: Automatically create a Polar customer when a user signs up\ngetCustomerCreateParams: Custom function to provide additional customer creation metadata\nCustomers\n\nWhen createCustomerOnSignUp is enabled, a new Polar Customer is automatically created when a new User is added in the Better-Auth Database.\n\nAll new customers are created with an associated externalId, which is the ID of your User in the Database. This allows us to skip any Polar to User mapping in your Database.\n\nCheckout Plugin\n\nTo support checkouts in your app, simply pass the Checkout plugin to the use-property.\n\nimport { polar, checkout } from \"@polar-sh/better-auth\";\nconst auth = betterAuth({\n    // ... Better Auth config\n    plugins: [\n        polar({\n            ...\n            use: [\n                checkout({\n                    // Optional field - will make it possible to pass a slug to checkout instead of Product ID\n                    products: [ { productId: \"123-456-789\", slug: \"pro\" } ],\n                    // Relative URL to return to when checkout is successfully completed\n                    successUrl: \"/success?checkout_id={CHECKOUT_ID}\",\n                    // Whether you want to allow unauthenticated checkout sessions or not\n                    authenticatedUsersOnly: true\n                })\n            ],\n        })\n    ]\n});\n\nWhen checkouts are enabled, you're able to initialize Checkout Sessions using the checkout-method on the BetterAuth Client. This will redirect the user to the Product Checkout.\n\nawait authClient.checkout({\n  // Any Polar Product ID can be passed here\n  products: [\"e651f46d-ac20-4f26-b769-ad088b123df2\"],\n  // Or, if you setup \"products\" in the Checkout Config, you can pass the slug\n  slug: \"pro\",\n});\n\nCheckouts will automatically carry the authenticated User as the customer to the checkout. Email-address will be \"locked-in\".\n\nIf authenticatedUsersOnly is false - then it will be possible to trigger checkout sessions without any associated customer.\n\nOrganization Support\n\nThis plugin supports the Organization plugin. If you pass the organization ID to the Checkout referenceId, you will be able to keep track of purchases made from organization members.\n\nconst organizationId = (await authClient.organization.list())?.data?.[0]?.id,\nawait authClient.checkout({\n    // Any Polar Product ID can be passed here\n    products: [\"e651f46d-ac20-4f26-b769-ad088b123df2\"],\n    // Or, if you setup \"products\" in the Checkout Config, you can pass the slug\n    slug: 'pro',\n    // Reference ID will be saved as `referenceId` in the metadata of the checkout, order & subscription object\n    referenceId: organizationId\n});\nPortal Plugin\n\nA plugin which enables customer management of their purchases, orders and subscriptions.\n\nimport { polar, checkout, portal } from \"@polar-sh/better-auth\";\nconst auth = betterAuth({\n    // ... Better Auth config\n    plugins: [\n        polar({\n            ...\n            use: [\n                checkout(...),\n                portal()\n            ],\n        })\n    ]\n});\n\nThe portal-plugin gives the BetterAuth Client a set of customer management methods, scoped under authClient.customer.\n\nCustomer Portal Management\n\nThe following method will redirect the user to the Polar Customer Portal, where they can see orders, purchases, subscriptions, benefits, etc.\n\nawait authClient.customer.portal();\nCustomer State\n\nThe portal plugin also adds a convenient state-method for retrieving the general Customer State.\n\nconst { data: customerState } = await authClient.customer.state();\n\nThe customer state object contains:\n\nAll the data about the customer.\nThe list of their active subscriptions\nNote: This does not include subscriptions done by a parent organization. See the subscription list-method below for more information.\nThe list of their granted benefits.\nThe list of their active meters, with their current balance.\n\nThus, with that single object, you have all the required information to check if you should provision access to your service or not.\n\nYou can learn more about the Polar Customer State in the Polar Docs.\n\nBenefits, Orders & Subscriptions\n\nThe portal plugin adds 3 convenient methods for listing benefits, orders & subscriptions relevant to the authenticated user/customer.\n\nAll of these methods use the Polar CustomerPortal APIs\n\nBenefits\n\nThis method only lists granted benefits for the authenticated user/customer.\n\nconst { data: benefits } = await authClient.customer.benefits.list({\n  query: {\n    page: 1,\n    limit: 10,\n  },\n});\nOrders\n\nThis method lists orders like purchases and subscription renewals for the authenticated user/customer.\n\nconst { data: orders } = await authClient.customer.orders.list({\n  query: {\n    page: 1,\n    limit: 10,\n    productBillingType: \"one_time\", // or 'recurring'\n  },\n});\nSubscriptions\n\nThis method lists the subscriptions associated with authenticated user/customer.\n\nconst { data: subscriptions } = await authClient.customer.subscriptions.list({\n  query: {\n    page: 1,\n    limit: 10,\n    active: true,\n  },\n});\n\nImportant - Organization Support\n\nThis will not return subscriptions made by a parent organization to the authenticated user.\n\nHowever, you can pass a referenceId to this method. This will return all subscriptions associated with that referenceId instead of subscriptions associated with the user.\n\nSo in order to figure out if a user should have access, pass the user's organization ID to see if there is an active subscription for that organization.\n\nconst organizationId = (await authClient.organization.list())?.data?.[0]?.id,\nconst { data: subscriptions } = await authClient.customer.orders.list({\n    query: {\n\t    page: 1,\n\t\tlimit: 10,\n\t\tactive: true,\n        referenceId: organizationId\n    },\n});\nconst userShouldHaveAccess = subscriptions.some(\n    sub => // Your logic to check subscription product or whatever.\n)\nUsage Plugin\n\nA simple plugin for Usage Based Billing.\n\nimport { polar, checkout, portal, usage } from \"@polar-sh/better-auth\";\nconst auth = betterAuth({\n    // ... Better Auth config\n    plugins: [\n        polar({\n            ...\n            use: [\n                checkout(...),\n                portal(),\n                usage()\n            ],\n        })\n    ]\n});\nEvent Ingestion\n\nPolar's Usage Based Billing builds entirely on event ingestion. Ingest events from your application, create Meters to represent that usage, and add metered prices to Products to charge for it.\n\nLearn more about Usage Based Billing in the Polar Docs.\n\nconst { data: ingested } = await authClient.usage.ingest({\n  event: \"file-uploads\",\n  metadata: {\n    uploadedFiles: 12,\n  },\n});\n\nThe authenticated user is automatically associated with the ingested event.\n\nCustomer Meters\n\nA simple method for listing the authenticated user's Usage Meters, or as we call them, Customer Meters.\n\nCustomer Meter's contains all information about their consumption on your defined meters.\n\nCustomer Information\nMeter Information\nCustomer Meter Information\nConsumed Units\nCredited Units\nBalance\nconst { data: customerMeters } = await authClient.usage.meters.list({\n  query: {\n    page: 1,\n    limit: 10,\n  },\n});\nWebhooks Plugin\n\nThe Webhooks plugin can be used to capture incoming events from your Polar organization.\n\nimport { polar, webhooks } from \"@polar-sh/better-auth\";\nconst auth = betterAuth({\n    // ... Better Auth config\n    plugins: [\n        polar({\n            ...\n            use: [\n                webhooks({\n                    secret: process.env.POLAR_WEBHOOK_SECRET,\n                    onCustomerStateChanged: (payload) => // Triggered when anything regarding a customer changes\n                    onOrderPaid: (payload) => // Triggered when an order was paid (purchase, subscription renewal, etc.)\n                    ...  // Over 25 granular webhook handlers\n                    onPayload: (payload) => // Catch-all for all events\n                })\n            ],\n        })\n    ]\n});\n\nConfigure a Webhook endpoint in your Polar Organization Settings page. Webhook endpoint is configured at /polar/webhooks.\n\nAdd the secret to your environment.\n\n# .env\nPOLAR_WEBHOOK_SECRET=...\n\nThe plugin supports handlers for all Polar webhook events:\n\nonPayload - Catch-all handler for any incoming Webhook event\nonCheckoutCreated - Triggered when a checkout is created\nonCheckoutUpdated - Triggered when a checkout is updated\nonOrderCreated - Triggered when an order is created\nonOrderPaid - Triggered when an order is paid\nonOrderRefunded - Triggered when an order is refunded\nonRefundCreated - Triggered when a refund is created\nonRefundUpdated - Triggered when a refund is updated\nonSubscriptionCreated - Triggered when a subscription is created\nonSubscriptionUpdated - Triggered when a subscription is updated\nonSubscriptionActive - Triggered when a subscription becomes active\nonSubscriptionCanceled - Triggered when a subscription is canceled\nonSubscriptionRevoked - Triggered when a subscription is revoked\nonSubscriptionUncanceled - Triggered when a subscription cancellation is reversed\nonProductCreated - Triggered when a product is created\nonProductUpdated - Triggered when a product is updated\nonOrganizationUpdated - Triggered when an organization is updated\nonBenefitCreated - Triggered when a benefit is created\nonBenefitUpdated - Triggered when a benefit is updated\nonBenefitGrantCreated - Triggered when a benefit grant is created\nonBenefitGrantUpdated - Triggered when a benefit grant is updated\nonBenefitGrantRevoked - Triggered when a benefit grant is revoked\nonCustomerCreated - Triggered when a customer is created\nonCustomerUpdated - Triggered when a customer is updated\nonCustomerDeleted - Triggered when a customer is deleted\nonCustomerStateChanged - Triggered when a customer is created\nEdit on GitHub\n\nPrevious Page\n\nStripe\n\nNext Page\n\nAutumn Billing"
  },
  {
    "title": "Stripe | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/stripe",
    "html": "Stripe\nCopy Markdown\nOpen in\n\nThe Stripe plugin integrates Stripe's payment and subscription functionality with Better Auth. Since payment and authentication are often tightly coupled, this plugin simplifies the integration of Stripe into your application, handling customer creation, subscription management, and webhook processing.\n\nFeatures\nCreate Stripe Customers automatically when users sign up\nManage subscription plans and pricing\nProcess subscription lifecycle events (creation, updates, cancellations)\nHandle Stripe webhooks securely with signature verification\nExpose subscription data to your application\nSupport for trial periods and subscription upgrades\nAutomatic trial abuse prevention - Users can only get one trial per account across all plans\nFlexible reference system to associate subscriptions with users or organizations\nTeam subscription support with seats management\nInstallation\nInstall the plugin\n\nFirst, install the plugin:\n\nnpm\npnpm\nyarn\nbun\nnpm install @better-auth/stripe\n\nIf you're using a separate client and server setup, make sure to install the plugin in both parts of your project.\n\nInstall the Stripe SDK\n\nNext, install the Stripe SDK on your server:\n\nnpm\npnpm\nyarn\nbun\nnpm install stripe@^19.1.0\nAdd the plugin to your auth config\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { stripe } from \"@better-auth/stripe\"\nimport Stripe from \"stripe\"\nconst stripeClient = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n    apiVersion: \"2025-09-30.clover\", // Latest API version as of Stripe SDK v19\n})\nexport const auth = betterAuth({\n    // ... your existing config\n    plugins: [\n        stripe({\n            stripeClient,\n            stripeWebhookSecret: process.env.STRIPE_WEBHOOK_SECRET!,\n            createCustomerOnSignUp: true,\n        })\n    ]\n})\n\nUpgrading from Stripe v18? Version 19 uses async webhook signature verification (constructEventAsync) which is handled internally by the plugin. No code changes required on your end!\n\nAdd the client plugin\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { stripeClient } from \"@better-auth/stripe/client\"\nexport const client = createAuthClient({\n    // ... your existing config\n    plugins: [\n        stripeClient({\n            subscription: true //if you want to enable subscription management\n        })\n    ]\n})\nMigrate the database\n\nRun the migration or generate the schema to add the necessary tables to the database.\n\nmigrate\ngenerate\nnpx @better-auth/cli migrate\n\nSee the Schema section to add the tables manually.\n\nSet up Stripe webhooks\n\nCreate a webhook endpoint in your Stripe dashboard pointing to:\n\nhttps://your-domain.com/api/auth/stripe/webhook\n\n/api/auth is the default path for the auth server.\n\nMake sure to select at least these events:\n\ncheckout.session.completed\ncustomer.subscription.updated\ncustomer.subscription.deleted\n\nSave the webhook signing secret provided by Stripe and add it to your environment variables as STRIPE_WEBHOOK_SECRET.\n\nUsage\nCustomer Management\n\nYou can use this plugin solely for customer management without enabling subscriptions. This is useful if you just want to link Stripe customers to your users.\n\nBy default, when a user signs up, a Stripe customer is automatically created if you set createCustomerOnSignUp: true. This customer is linked to the user in your database. You can customize the customer creation process:\n\nauth.ts\nstripe({\n    // ... other options\n    createCustomerOnSignUp: true,\n    onCustomerCreate: async ({ customer, stripeCustomer, user }, request) => {\n        // Do something with the newly created customer\n        console.log(`Customer ${customer.id} created for user ${user.id}`);\n    },\n    getCustomerCreateParams: async ({ user, session }, request) => {\n        // Customize the Stripe customer creation parameters\n        return {\n            metadata: {\n                referralSource: user.metadata?.referralSource\n            }\n        };\n    }\n})\nSubscription Management\nDefining Plans\n\nYou can define your subscription plans either statically or dynamically:\n\nauth.ts\n// Static plans\nsubscription: {\n    enabled: true,\n    plans: [\n        {\n            name: \"basic\", // the name of the plan, it'll be automatically lower cased when stored in the database\n            priceId: \"price_1234567890\", // the price ID from stripe\n            annualDiscountPriceId: \"price_1234567890\", // (optional) the price ID for annual billing with a discount\n            limits: {\n                projects: 5,\n                storage: 10\n            }\n        },\n        {\n            name: \"pro\",\n            priceId: \"price_0987654321\",\n            limits: {\n                projects: 20,\n                storage: 50\n            },\n            freeTrial: {\n                days: 14,\n            }\n        }\n    ]\n}\n// Dynamic plans (fetched from database or API)\nsubscription: {\n    enabled: true,\n    plans: async () => {\n        const plans = await db.query(\"SELECT * FROM plans\");\n        return plans.map(plan => ({\n            name: plan.name,\n            priceId: plan.stripe_price_id,\n            limits: JSON.parse(plan.limits)\n        }));\n    }\n}\n\nsee plan configuration for more.\n\nCreating a Subscription\n\nTo create a subscription, use the subscription.upgrade method:\n\nClient\nServer\nPOST\n/subscription/upgrade\nconst { data, error } = await authClient.subscription.upgrade({\n    plan: \"pro\", // required\n    annual: true,\n    referenceId: \"123\",\n    subscriptionId: \"sub_123\",\n    metadata,\n    seats: 1,\n    successUrl, // required\n    cancelUrl, // required\n    returnUrl,\n    disableRedirect: true, // required\n});\nProp\tDescription\tType\nplan\t\nThe name of the plan to upgrade to.\n\tstring\nannual?\t\nWhether to upgrade to an annual plan.\n\tboolean\nreferenceId?\t\nReference id of the subscription to upgrade.\n\tstring\nsubscriptionId?\t\nThe id of the subscription to upgrade.\n\tstring\nmetadata?\t\n\tRecord<string, any>\nseats?\t\nNumber of seats to upgrade to (if applicable).\n\tnumber\nsuccessUrl\t\nCallback URL to redirect back after successful subscription.\n\tstring\ncancelUrl\t\nIf set, checkout shows a back button and customers will be directed here if they cancel payment.\n\tstring\nreturnUrl?\t\nURL to take customers to when they click on the billing portalâ€™s link to return to your website.\n\tstring\ndisableRedirect\t\nDisable redirect after successful subscription.\n\tboolean\n\nSimple Example:\n\nclient.ts\nawait client.subscription.upgrade({\n    plan: \"pro\",\n    successUrl: \"/dashboard\",\n    cancelUrl: \"/pricing\",\n    annual: true, // Optional: upgrade to an annual plan\n    referenceId: \"org_123\", // Optional: defaults to the current logged in user ID\n    seats: 5 // Optional: for team plans\n});\n\nThis will create a Checkout Session and redirect the user to the Stripe Checkout page.\n\nIf the user already has an active subscription, you must provide the subscriptionId parameter. Otherwise, the user will be subscribed to (and pay for) both plans.\n\nImportant: The successUrl parameter will be internally modified to handle race conditions between checkout completion and webhook processing. The plugin creates an intermediate redirect that ensures subscription status is properly updated before redirecting to your success page.\n\nconst { error } = await client.subscription.upgrade({\n    plan: \"pro\",\n    successUrl: \"/dashboard\",\n    cancelUrl: \"/pricing\",\n});\nif(error) {\n    alert(error.message);\n}\n\nFor each reference ID (user or organization), only one active or trialing subscription is supported at a time. The plugin doesn't currently support multiple concurrent active subscriptions for the same reference ID.\n\nSwitching Plans\n\nTo switch a subscription to a different plan, use the subscription.upgrade method:\n\nclient.ts\nawait client.subscription.upgrade({\n    plan: \"pro\",\n    successUrl: \"/dashboard\",\n    cancelUrl: \"/pricing\",\n    subscriptionId: \"sub_123\", // the Stripe subscription ID of the user's current plan\n});\n\nThis ensures that the user only pays for the new plan, and not both.\n\nListing Active Subscriptions\n\nTo get the user's active subscriptions:\n\nClient\nServer\nGET\n/subscription/list\nconst { data: subscriptions, error } = await authClient.subscription.list({\n    query: {\n        referenceId: '123',\n    },\n});\n// get the active subscription\nconst activeSubscription = subscriptions.find(\n    sub => sub.status === \"active\" || sub.status === \"trialing\"\n);\n// Check subscription limits\nconst projectLimit = subscriptions?.limits?.projects || 0;\nProp\tDescription\tType\nreferenceId?\t\nReference id of the subscription to list.\n\tstring\nCanceling a Subscription\n\nTo cancel a subscription:\n\nClient\nServer\nPOST\n/subscription/cancel\nconst { data, error } = await authClient.subscription.cancel({\n    referenceId: 'org_123',\n    subscriptionId: 'sub_123',\n    returnUrl: '/account', // required\n});\nProp\tDescription\tType\nreferenceId?\t\nReference id of the subscription to cancel. Defaults to the userId.\n\tstring\nsubscriptionId?\t\nThe id of the subscription to cancel.\n\tstring\nreturnUrl\t\nURL to take customers to when they click on the billing portalâ€™s link to return to your website.\n\tstring\n\nThis will redirect the user to the Stripe Billing Portal where they can cancel their subscription.\n\nRestoring a Canceled Subscription\n\nIf a user changes their mind after canceling a subscription (but before the subscription period ends), you can restore the subscription:\n\nClient\nServer\nPOST\n/subscription/restore\nconst { data, error } = await authClient.subscription.restore({\n    referenceId: '123',\n    subscriptionId: 'sub_123',\n});\nProp\tDescription\tType\nreferenceId?\t\nReference id of the subscription to restore. Defaults to the userId.\n\tstring\nsubscriptionId?\t\nThe id of the subscription to restore.\n\tstring\n\nThis will reactivate a subscription that was previously set to cancel at the end of the billing period (cancelAtPeriodEnd: true). The subscription will continue to renew automatically.\n\nNote: This only works for subscriptions that are still active but marked to cancel at the end of the period. It cannot restore subscriptions that have already ended.\n\nCreating Billing Portal Sessions\n\nTo create a Stripe billing portal session where customers can manage their subscriptions, update payment methods, and view billing history:\n\nClient\nServer\nPOST\n/subscription/billing-portal\nconst { data, error } = await authClient.subscription.billingPortal({\n    locale,\n    referenceId: \"123\",\n    returnUrl,\n});\nProp\tDescription\tType\nlocale?\t\nThe IETF language tag of the locale customer portal is displayed in. If blank or auto, browser's locale is used.\n\tstring\nreferenceId?\t\nReference id of the subscription to upgrade.\n\tstring\nreturnUrl?\t\nReturn URL to redirect back after successful subscription.\n\tstring\n\nFor supported locales, see the IETF language tag documentation.\n\nThis endpoint creates a Stripe billing portal session and returns a URL in the response as data.url. You can redirect users to this URL to allow them to manage their subscription, payment methods, and billing history.\n\nReference System\n\nBy default, subscriptions are associated with the user ID. However, you can use a custom reference ID to associate subscriptions with other entities, such as organizations:\n\nclient.ts\n// Create a subscription for an organization\nawait client.subscription.upgrade({\n    plan: \"pro\",\n    referenceId: \"org_123456\",\n    successUrl: \"/dashboard\",\n    cancelUrl: \"/pricing\",\n    seats: 5 // Number of seats for team plans\n});\n// List subscriptions for an organization\nconst { data: subscriptions } = await client.subscription.list({\n    query: {\n        referenceId: \"org_123456\"\n    }\n});\nTeam Subscriptions with Seats\n\nFor team or organization plans, you can specify the number of seats:\n\nawait client.subscription.upgrade({\n    plan: \"team\",\n    referenceId: \"org_123456\",\n    seats: 10, // 10 team members\n    successUrl: \"/org/billing/success\",\n    cancelUrl: \"/org/billing\"\n});\n\nThe seats parameter is passed to Stripe as the quantity for the subscription item. You can use this value in your application logic to limit the number of members in a team or organization.\n\nTo authorize reference IDs, implement the authorizeReference function:\n\nauth.ts\nsubscription: {\n    // ... other options\n    authorizeReference: async ({ user, session, referenceId, action }) => {\n        // Check if the user has permission to manage subscriptions for this reference\n        if (action === \"upgrade-subscription\" || action === \"cancel-subscription\" || action === \"restore-subscription\") {\n            const org = await db.member.findFirst({\n                where: {\n                    organizationId: referenceId,\n                    userId: user.id\n                }   \n            });\n            return org?.role === \"owner\"\n        }\n        return true;\n    }\n}\nWebhook Handling\n\nThe plugin automatically handles common webhook events:\n\ncheckout.session.completed: Updates subscription status after checkout\ncustomer.subscription.updated: Updates subscription details when changed\ncustomer.subscription.deleted: Marks subscription as canceled\n\nYou can also handle custom events:\n\nauth.ts\nstripe({\n    // ... other options\n    onEvent: async (event) => {\n        // Handle any Stripe event\n        switch (event.type) {\n            case \"invoice.paid\":\n                // Handle paid invoice\n                break;\n            case \"payment_intent.succeeded\":\n                // Handle successful payment\n                break;\n        }\n    }\n})\nSubscription Lifecycle Hooks\n\nYou can hook into various subscription lifecycle events:\n\nauth.ts\nsubscription: {\n    // ... other options\n    onSubscriptionComplete: async ({ event, subscription, stripeSubscription, plan }) => {\n        // Called when a subscription is successfully created\n        await sendWelcomeEmail(subscription.referenceId, plan.name);\n    },\n    onSubscriptionUpdate: async ({ event, subscription }) => {\n        // Called when a subscription is updated\n        console.log(`Subscription ${subscription.id} updated`);\n    },\n    onSubscriptionCancel: async ({ event, subscription, stripeSubscription, cancellationDetails }) => {\n        // Called when a subscription is canceled\n        await sendCancellationEmail(subscription.referenceId);\n    },\n    onSubscriptionDeleted: async ({ event, subscription, stripeSubscription }) => {\n        // Called when a subscription is deleted\n        console.log(`Subscription ${subscription.id} deleted`);\n    }\n}\nTrial Periods\n\nYou can configure trial periods for your plans:\n\nauth.ts\n{\n    name: \"pro\",\n    priceId: \"price_0987654321\",\n    freeTrial: {\n        days: 14,\n        onTrialStart: async (subscription) => {\n            // Called when a trial starts\n            await sendTrialStartEmail(subscription.referenceId);\n        },\n        onTrialEnd: async ({ subscription, user }, request) => {\n            // Called when a trial ends\n            await sendTrialEndEmail(user.email);\n        },\n        onTrialExpired: async (subscription) => {\n            // Called when a trial expires without conversion\n            await sendTrialExpiredEmail(subscription.referenceId);\n        }\n    }\n}\nSchema\n\nThe Stripe plugin adds the following tables to your database:\n\nUser\n\nTable Name: user\n\nField Name\tType\tKey\tDescription\nstripeCustomerId\tstring\t?\tThe Stripe customer ID\nSubscription\n\nTable Name: subscription\n\nField Name\tType\tKey\tDescription\nid\tstring\t\nPK\tUnique identifier for each subscription\nplan\tstring\t-\tThe name of the subscription plan\nreferenceId\tstring\t-\tThe ID this subscription is associated with (user ID by default)\nstripeCustomerId\tstring\t?\tThe Stripe customer ID\nstripeSubscriptionId\tstring\t?\tThe Stripe subscription ID\nstatus\tstring\t-\tThe status of the subscription (active, canceled, etc.)\nperiodStart\tDate\t?\tStart date of the current billing period\nperiodEnd\tDate\t?\tEnd date of the current billing period\ncancelAtPeriodEnd\tboolean\t?\tWhether the subscription will be canceled at the end of the period\nseats\tnumber\t?\tNumber of seats for team plans\ntrialStart\tDate\t?\tStart date of the trial period\ntrialEnd\tDate\t?\tEnd date of the trial period\nCustomizing the Schema\n\nTo change the schema table names or fields, you can pass a schema option to the Stripe plugin:\n\nauth.ts\nstripe({\n    // ... other options\n    schema: {\n        subscription: {\n            modelName: \"stripeSubscriptions\", // map the subscription table to stripeSubscriptions\n            fields: {\n                plan: \"planName\" // map the plan field to planName\n            }\n        }\n    }\n})\nOptions\nMain Options\n\nstripeClient: Stripe - The Stripe client instance. Required.\n\nstripeWebhookSecret: string - The webhook signing secret from Stripe. Required.\n\ncreateCustomerOnSignUp: boolean - Whether to automatically create a Stripe customer when a user signs up. Default: false.\n\nonCustomerCreate: (data: { customer: Customer, stripeCustomer: Stripe.Customer, user: User }, request?: Request) => Promise<void> - A function called after a customer is created.\n\ngetCustomerCreateParams: (data: { user: User, session: Session }, request?: Request) => Promise<{}> - A function to customize the Stripe customer creation parameters.\n\nonEvent: (event: Stripe.Event) => Promise<void> - A function called for any Stripe webhook event.\n\nSubscription Options\n\nenabled: boolean - Whether to enable subscription functionality. Required.\n\nplans: Plan[] | (() => Promise<Plan[]>) - An array of subscription plans or a function that returns plans. Required if subscriptions are enabled.\n\nrequireEmailVerification: boolean - Whether to require email verification before allowing subscription upgrades. Default: false.\n\nauthorizeReference: (data: { user: User, session: Session, referenceId: string, action: \"upgrade-subscription\" | \"list-subscription\" | \"cancel-subscription\" | \"restore-subscription\"}, request?: Request) => Promise<boolean> - A function to authorize reference IDs.\n\nPlan Configuration\n\nEach plan can have the following properties:\n\nname: string - The name of the plan. Required.\n\npriceId: string - The Stripe price ID. Required unless using lookupKey.\n\nlookupKey: string - The Stripe price lookup key. Alternative to priceId.\n\nannualDiscountPriceId: string - A price ID for annual billing.\n\nannualDiscountLookupKey: string - The Stripe price lookup key for annual billing. Alternative to annualDiscountPriceId.\n\nlimits: Record<string, number> - Limits associated with the plan (e.g., { projects: 10, storage: 5 }).\n\ngroup: string - A group name for the plan, useful for categorizing plans.\n\nfreeTrial: Object containing trial configuration:\n\ndays: number - Number of trial days.\nonTrialStart: (subscription: Subscription) => Promise<void> - Called when a trial starts.\nonTrialEnd: (data: { subscription: Subscription, user: User }, request?: Request) => Promise<void> - Called when a trial ends.\nonTrialExpired: (subscription: Subscription) => Promise<void> - Called when a trial expires without conversion.\nAdvanced Usage\nUsing with Organizations\n\nThe Stripe plugin works well with the organization plugin. You can associate subscriptions with organizations instead of individual users:\n\nclient.ts\n// Get the active organization\nconst { data: activeOrg } = client.useActiveOrganization();\n// Create a subscription for the organization\nawait client.subscription.upgrade({\n    plan: \"team\",\n    referenceId: activeOrg.id,\n    seats: 10,\n    annual: true, // upgrade to an annual plan (optional)\n    successUrl: \"/org/billing/success\",\n    cancelUrl: \"/org/billing\"\n});\n\nMake sure to implement the authorizeReference function to verify that the user has permission to manage subscriptions for the organization:\n\nauth.ts\nauthorizeReference: async ({ user, referenceId, action }) => {\n    const member = await db.members.findFirst({\n        where: {\n            userId: user.id,\n            organizationId: referenceId\n        }\n    });\n    \n    return member?.role === \"owner\" || member?.role === \"admin\";\n}\nCustom Checkout Session Parameters\n\nYou can customize the Stripe Checkout session with additional parameters:\n\nauth.ts\ngetCheckoutSessionParams: async ({ user, session, plan, subscription }, request) => {\n    return {\n        params: {\n            allow_promotion_codes: true,\n            tax_id_collection: {\n                enabled: true\n            },\n            billing_address_collection: \"required\",\n            custom_text: {\n                submit: {\n                    message: \"We'll start your subscription right away\"\n                }\n            },\n            metadata: {\n                planType: \"business\",\n                referralCode: user.metadata?.referralCode\n            }\n        },\n        options: {\n            idempotencyKey: `sub_${user.id}_${plan.name}_${Date.now()}`\n        }\n    };\n}\nTax Collection\n\nTo collect tax IDs from the customer, set tax_id_collection to true:\n\nauth.ts\nsubscription: {\n    // ... other options\n    getCheckoutSessionParams: async ({ user, session, plan, subscription }, request) => {\n        return {\n            params: {\n                tax_id_collection: {\n                    enabled: true\n                }\n            }\n        };\n    }\n}\nAutomatic Tax Calculation\n\nTo enable automatic tax calculation using the customer's location, set automatic_tax to true. Enabling this parameter causes Checkout to collect any billing address information necessary for tax calculation. You need to have tax registration setup and configured in the Stripe dashboard first for this to work.\n\nauth.ts\nsubscription: {\n    // ... other options\n    getCheckoutSessionParams: async ({ user, session, plan, subscription }, request) => {\n        return {\n            params: {\n                automatic_tax: {\n                    enabled: true\n                }\n            }\n        };\n    }\n}\nTrial Period Management\n\nThe Stripe plugin automatically prevents users from getting multiple free trials. Once a user has used a trial period (regardless of which plan), they will not be eligible for additional trials on any plan.\n\nHow it works:\n\nThe system tracks trial usage across all plans for each user\nWhen a user subscribes to a plan with a trial, the system checks their subscription history\nIf the user has ever had a trial (indicated by trialStart/trialEnd fields or trialing status), no new trial will be offered\nThis prevents abuse where users cancel subscriptions and resubscribe to get multiple free trials\n\nExample scenario:\n\nUser subscribes to \"Starter\" plan with 7-day trial\nUser cancels the subscription after the trial\nUser tries to subscribe to \"Premium\" plan - no trial will be offered\nUser will be charged immediately for the Premium plan\n\nThis behavior is automatic and requires no additional configuration. The trial eligibility is determined at the time of subscription creation and cannot be overridden through configuration.\n\nTroubleshooting\nWebhook Issues\n\nIf webhooks aren't being processed correctly:\n\nCheck that your webhook URL is correctly configured in the Stripe dashboard\nVerify that the webhook signing secret is correct\nEnsure you've selected all the necessary events in the Stripe dashboard\nCheck your server logs for any errors during webhook processing\nSubscription Status Issues\n\nIf subscription statuses aren't updating correctly:\n\nMake sure the webhook events are being received and processed\nCheck that the stripeCustomerId and stripeSubscriptionId fields are correctly populated\nVerify that the reference IDs match between your application and Stripe\nTesting Webhooks Locally\n\nFor local development, you can use the Stripe CLI to forward webhooks to your local environment:\n\nstripe listen --forward-to localhost:3000/api/auth/stripe/webhook\n\nThis will provide you with a webhook signing secret that you can use in your local environment.\n\nEdit on GitHub\n\nPrevious Page\n\n3rd party\n\nNext Page\n\nPolar"
  },
  {
    "title": "Dodo Payments | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/dodopayments",
    "html": "Dodo Payments\nCopy Markdown\nOpen in\n\nDodo Payments is a global Merchant-of-Record platform that lets AI, SaaS and digital businesses sell in 150+ countries without touching tax, fraud, or compliance. A single, developer-friendly API powers checkout, billing, and payouts so you can launch worldwide in minutes.\n\nGet support on Dodo Payments' Discord\n\nThis plugin is maintained by the Dodo Payments team.\nHave questions? Our team is available on Discord to assist you anytime.\n\nFeatures\nAutomatic customer creation on sign-up\nType-safe checkout flows with product slug mapping\nSelf-service customer portal\nReal-time webhook event processing with signature verification\nGet started with Dodo Payments\n\nYou need a Dodo Payments account and API keys to use this integration.\n\nInstallation\n\nRun the following command in your project root:\n\nnpm install @dodopayments/better-auth dodopayments better-auth zod\n\nAdd these to your .env file:\n\nDODO_PAYMENTS_API_KEY=your_api_key_here\nDODO_PAYMENTS_WEBHOOK_SECRET=your_webhook_secret_here\n\nCreate or update src/lib/auth.ts:\n\nimport { betterAuth } from \"better-auth\";\nimport {\n  dodopayments,\n  checkout,\n  portal,\n  webhooks,\n} from \"@dodopayments/better-auth\";\nimport DodoPayments from \"dodopayments\";\nexport const dodoPayments = new DodoPayments({\n  bearerToken: process.env.DODO_PAYMENTS_API_KEY!,\n  environment: \"test_mode\"\n});\nexport const auth = betterAuth({\n  plugins: [\n    dodopayments({\n      client: dodoPayments,\n      createCustomerOnSignUp: true,\n      use: [\n        checkout({\n          products: [\n            {\n              productId: \"pdt_xxxxxxxxxxxxxxxxxxxxx\",\n              slug: \"premium-plan\",\n            },\n          ],\n          successUrl: \"/dashboard/success\",\n          authenticatedUsersOnly: true,\n        }),\n        portal(),\n        webhooks({\n          webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_SECRET!,\n          onPayload: async (payload) => {\n            console.log(\"Received webhook:\", payload.event_type);\n          },\n        }),\n      ],\n    }),\n  ],\n});\n\nSet environment to live_mode for production.\n\nCreate or update src/lib/auth-client.ts:\n\nimport { dodopaymentsClient } from \"@dodopayments/better-auth\";\nexport const authClient = createAuthClient({\n  baseURL: process.env.BETTER_AUTH_URL || \"http://localhost:3000\",\n  plugins: [dodopaymentsClient()],\n});\nUsage\nCreating a Checkout Session\nconst { data: checkout, error } = await authClient.dodopayments.checkout({\n  slug: \"premium-plan\",\n  customer: {\n    email: \"customer@example.com\",\n    name: \"John Doe\",\n  },\n  billing: {\n    city: \"San Francisco\",\n    country: \"US\",\n    state: \"CA\",\n    street: \"123 Market St\",\n    zipcode: \"94103\",\n  },\n  referenceId: \"order_123\",\n});\nif (checkout) {\n  window.location.href = checkout.url;\n}\nAccessing the Customer Portal\nconst { data: customerPortal, error } = await authClient.dodopayments.customer.portal();\nif (customerPortal && customerPortal.redirect) {\n  window.location.href = customerPortal.url;\n}\nListing Customer Data\n// Get subscriptions\nconst { data: subscriptions, error } =\n  await authClient.dodopayments.customer.subscriptions.list({\n    query: {\n      limit: 10,\n      page: 1,\n      active: true,\n    },\n  });\n// Get payment history\nconst { data: payments, error } = await authClient.dodopayments.customer.payments.list({\n  query: {\n    limit: 10,\n    page: 1,\n    status: \"succeeded\",\n  },\n});\nWebhooks\n\nThe webhooks plugin processes real-time payment events from Dodo Payments with secure signature verification. The default endpoint is /api/auth/dodopayments/webhooks.\n\nGenerate a webhook secret for your endpoint URL (e.g., https://your-domain.com/api/auth/dodopayments/webhooks) in the Dodo Payments Dashboard and set it in your .env file:\n\nDODO_PAYMENTS_WEBHOOK_SECRET=your_webhook_secret_here\n\nExample handler:\n\nwebhooks({\n  webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_SECRET!,\n  onPayload: async (payload) => {\n    console.log(\"Received webhook:\", payload.event_type);\n  },\n});\nConfiguration Reference\nPlugin Options\nclient (required): DodoPayments client instance\ncreateCustomerOnSignUp (optional): Auto-create customers on user signup\nuse (required): Array of plugins to enable (checkout, portal, webhooks)\nCheckout Plugin Options\nproducts: Array of products or async function returning products\nsuccessUrl: URL to redirect after successful payment\nauthenticatedUsersOnly: Require user authentication (default: false)\n\nIf you encounter any issues, please refer to the Dodo Payments documentation for troubleshooting steps.\n\nEdit on GitHub\n\nPrevious Page\n\nAutumn Billing\n\nNext Page\n\nDub"
  },
  {
    "title": "Autumn Billing | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/autumn",
    "html": "Autumn Billing\nCopy Markdown\nOpen in\n\nAutumn is open source infrastructure to run SaaS pricing plans. It sits between your app and Stripe, and acts as the database for your customers' subscription status, usage metering and feature permissions.\n\nGet help on Autumn's Discord\n\nWe're online to help you with any questions you have.\n\nFeatures\nOne function for all checkout, subscription and payment flows\nNo webhooks required: query Autumn for the data you need\nManages your application's free and paid plans\nUsage tracking for usage billing and periodic limits\nCustom plans and pricing changes through Autumn's dashboard\nSetup Autumn Account\n\nFirst, create your pricing plans in Autumn's dashboard, where you define what each plan and product gets access to and how it should be billed. In this example, we're handling the free and pro plans for an AI chatbot, which comes with a number of messages per month.\n\nInstall Autumn SDK\nnpm\npnpm\nyarn\nbun\nnpm install autumn-js\n\nIf you're using a separate client and server setup, make sure to install the plugin in both parts of your project.\n\nAdd AUTUMN_SECRET_KEY to your environment variables\n\nYou can find it in Autumn's dashboard under \"Developer\".\n\n.env\nAUTUMN_SECRET_KEY=am_sk_xxxxxxxxxx\nAdd the Autumn plugin to your auth config\nUser\nOrganization\nUser & Organization\nCustom\nauth.ts\nimport { autumn } from \"autumn-js/better-auth\";\nexport const auth = betterAuth({\n  // ...\n  plugins: [autumn()],\n});\n\nAutumn will auto-create your customers when they sign up, and assign them any default plans you created (eg your Free plan). You can choose who becomes a customer: individual users, organizations, both, or something custom like workspaces.\n\nAdd <AutumnProvider />\n\nClient side, wrap your application with the AutumnProvider component, and pass in the baseUrl that you define within better-auth's authClient.\n\napp/layout.tsx\nimport { AutumnProvider } from \"autumn-js/react\";\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html>\n      <body>\n        {/* or meta.env.BETTER_AUTH_URL for vite */}\n        <AutumnProvider betterAuthUrl={process.env.NEXT_PUBLIC_BETTER_AUTH_URL}>\n          {children}\n        </AutumnProvider>\n      </body>\n    </html>\n  );\n}\nUsage\nHandle payments\n\nCall attach to redirect the customer to a Stripe checkout page when they want to purchase the Pro plan.\n\nIf their payment method is already on file, AttachDialog will open instead to let the customer confirm their new subscription or purchase, and handle the payment.\n\nMake sure you've pasted in your Stripe test secret key in the Autumn dashboard.\n\nimport { useCustomer, AttachDialog } from \"autumn-js/react\";\nexport default function PurchaseButton() {\n  const { attach } = useCustomer();\n  return (\n    <button\n      onClick={async () => {\n        await attach({\n          productId: \"pro\",\n          dialog: AttachDialog,\n        });\n      }}\n    >\n      Upgrade to Pro\n    </button>\n  );\n}\n\nThe AttachDialog component can be used directly from the autumn-js/react library (as shown in the example above), or downloaded as a shadcn/ui component to customize.\n\nIntegrate Pricing Logic\n\nIntegrate your client and server pricing tiers logic with the following functions:\n\ncheck to see if the customer is allowed to send a message.\ntrack a usage event in Autumn (typically done server-side)\ncustomer to display any relevant billing data in your UI (subscriptions, feature balances)\n\nServer-side, you can access Autumn's functions through the auth object.\n\nClient\nServer\nimport { useCustomer } from \"autumn-js/react\";\nexport default function SendChatMessage() {\n  const { customer, allowed, refetch } = useCustomer();\n  return (\n    <>\n      <button\n        onClick={async () => {\n          if (allowed({ featureId: \"messages\" })) {\n            //... send chatbot message server-side, then\n            await refetch(); // refetch customer usage data\n            alert(\n              \"Remaining messages: \" + customer?.features.messages?.balance\n            );\n          } else {\n            alert(\"You're out of messages\");\n          }\n        }}\n      >\n        Send Message\n      </button>\n    </>\n  );\n}\nAdditional Functions\nopenBillingPortal()\n\nOpens a billing portal where the customer can update their payment method or cancel their plan.\n\nimport { useCustomer } from \"autumn-js/react\";\nexport default function BillingSettings() {\n  const { openBillingPortal } = useCustomer();\n  return (\n    <button\n      onClick={async () => {\n        await openBillingPortal({\n          returnUrl: \"/settings/billing\",\n        });\n      }}\n    >\n      Manage Billing\n    </button>\n  );\n}\ncancel()\n\nCancel a product or subscription.\n\nimport { useCustomer } from \"autumn-js/react\";\nexport default function CancelSubscription() {\n  const { cancel } = useCustomer();\n  return (\n    <button\n      onClick={async () => {\n        await cancel({ productId: \"pro\" });\n      }}\n    >\n      Cancel Subscription\n    </button>\n  );\n}\nGet invoice history\n\nPass in an expand param into useCustomer to get additional information. You can expand invoices, trials_used, payment_method, or rewards.\n\nimport { useCustomer } from \"autumn-js/react\";\nexport default function CustomerProfile() {\n  const { customer } = useCustomer({ expand: [\"invoices\"] });\n  return (\n    <div>\n      <h2>Customer Profile</h2>\n      <p>Name: {customer?.name}</p>\n      <p>Email: {customer?.email}</p>\n      <p>Balance: {customer?.features.chat_messages?.balance}</p>\n    </div>\n  );\n}\nEdit on GitHub\n\nPrevious Page\n\nPolar\n\nNext Page\n\nDodo Payments"
  },
  {
    "title": "Dub | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/dub",
    "html": "Dub\nCopy Markdown\nOpen in\n\nDub is an open source modern link management platform for entrepreneurs, creators, and growth teams.\n\nThis plugins allows you to track leads when a user signs up using a Dub link. It also adds OAuth linking support to allow you to build integrations extending Dub's linking management infrastructure.\n\nInstallation\nInstall the plugin\n\nFirst, install the plugin:\n\nnpm\npnpm\nyarn\nbun\nnpm install @dub/better-auth\nInstall the Dub SDK\n\nNext, install the Dub SDK on your server:\n\nnpm\npnpm\nyarn\nbun\nnpm install dub\nConfigure the plugin\n\nAdd the plugin to your auth config:\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { dubAnalytics } from \"@dub/better-auth\"\nimport { dub } from \"dub\"\nexport const auth = betterAuth({\n    plugins: [\n        dubAnalytics({\n            dubClient: new Dub()\n        })\n    ]\n})\nUsage\nLead Tracking\n\nBy default, the plugin will track sign up events as leads. You can disable this by setting disableLeadTracking to true.\n\nimport { dubAnalytics } from \"@dub/better-auth\";\nimport { betterAuth } from \"better-auth\";\nimport { Dub } from \"dub\";\nconst dub = new Dub();\nconst betterAuth = betterAuth({\n  plugins: [\n    dubAnalytics({\n      dubClient: dub,\n      disableLeadTracking: true, // Disable lead tracking\n    }),\n  ],\n});\nOAuth Linking\n\nThe plugin supports OAuth for account linking.\n\nFirst, you need to setup OAuth app in Dub. Dub supports OAuth 2.0 authentication, which is recommended if you build integrations extending Dubâ€™s functionality Learn more about OAuth.\n\nOnce you get the client ID and client secret, you can configure the plugin.\n\ndubAnalytics({\n  dubClient: dub,\n  oauth: {\n    clientId: \"your-client-id\",\n    clientSecret: \"your-client-secret\",\n  },\n});\n\nAnd in the client, you need to use the dubAnalyticsClient plugin.\n\nimport { createAuthClient } from \"better-auth/client\";\nimport { dubAnalyticsClient } from \"@dub/better-auth/client\";\nconst authClient = createAuthClient({\n  plugins: [dubAnalyticsClient()],\n});\n\nTo link account with Dub, you need to use the dub.link.\n\nClient\nServer\nPOST\n/dub/link\nconst { data, error } = await authClient.dub.link({\n    callbackURL: \"/dashboard\", // required\n});\nProp\tDescription\tType\ncallbackURL\t\nURL to redirect to after linking\n\tstring\nOptions\n\nYou can pass the following options to the plugin:\n\ndubClient\n\nThe Dub client instance.\n\ndisableLeadTracking\n\nDisable lead tracking for sign up events.\n\nleadEventName\n\nEvent name for sign up leads.\n\ncustomLeadTrack\n\nCustom lead track function.\n\noauth\n\nDub OAuth configuration.\n\noauth.clientId\n\nClient ID for Dub OAuth.\n\noauth.clientSecret\n\nClient secret for Dub OAuth.\n\noauth.pkce\n\nEnable PKCE for Dub OAuth.\n\nEdit on GitHub\n\nPrevious Page\n\nDodo Payments\n\nNext Page\n\nCommunity Plugins"
  },
  {
    "title": "Community Plugins | Better Auth",
    "url": "https://www.better-auth.com/docs/plugins/community-plugins",
    "html": "Community Plugins\nCopy Markdown\nOpen in\n\nThis page showcases a list of recommended community made plugins.\n\nWe encourage you to create custom plugins and maybe get added to the list!\n\nTo create your own custom plugin, get started by reading our plugins documentation. And if you want to share your plugin with the community, please open a pull request to add it to this list.\n\nPlugin\n\tDescription\t\nAuthor\n\n@dymo-api/better-auth\tSign Up Protection and validation of disposable emails (the world's largest database with nearly 14 million entries).\t TPEOficial\nbetter-auth-harmony\tEmail & phone normalization and additional validation, blocking over 55,000 temporary email domains.\t GeKorm\nvalidation-better-auth\tValidate API request using any validation library (e.g., Zod, Yup)\t Daanish2003\nbetter-auth-localization\tLocalize and customize better-auth messages with easy translation and message override support.\t marcellosso\nbetter-auth-attio-plugin\tSync your products Better Auth users & workspaces with Attio\t tobimori\nbetter-auth-cloudflare\tSeamlessly integrate with Cloudflare Workers, D1, Hyperdrive, KV, R2, and geolocation services. Includes CLI for project generation, automated resource provisioning on Cloudflare, and database migrations. Supports Next.js, Hono, and more!\t zpg6\nexpo-better-auth-passkey\tBetter-auth client plugin for using passkeys on mobile platforms in expo apps. Supports iOS, macOS, Android (and web!) by wrapping the existing better-auth passkey client plugin.\t kevcube\nbetter-auth-credentials-plugin\tLDAP authentication plugin for Better Auth.\t erickweil\nbetter-auth-opaque\tProvides database-breach resistant authentication using the zero-knowledge OPAQUE protocol.\t TheUntraceable\nEdit on GitHub\n\nPrevious Page\n\nDub\n\nNext Page\n\nGuides"
  },
  {
    "title": "Astro Integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/astro",
    "html": "Astro Integration\nCopy Markdown\nOpen in\n\nBetter Auth comes with first class support for Astro. This guide will show you how to integrate Better Auth with Astro.\n\nBefore you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the installation.\n\nMount the handler\n\nTo enable Better Auth to handle requests, we need to mount the handler to a catch all API route. Create a file inside /pages/api/auth called [...all].ts and add the following code:\n\npages/api/auth/[...all].ts\nimport { auth } from \"~/auth\";\nimport type { APIRoute } from \"astro\";\nexport const ALL: APIRoute = async (ctx) => {\n\t// If you want to use rate limiting, make sure to set the 'x-forwarded-for' header to the request headers from the context\n\t// ctx.request.headers.set(\"x-forwarded-for\", ctx.clientAddress);\n\treturn auth.handler(ctx.request);\n};\n\nYou can change the path on your better-auth configuration but it's recommended to keep it as /api/auth/[...all]\n\nCreate a client\n\nAstro supports multiple frontend frameworks, so you can easily import your client based on the framework you're using.\n\nIf you're not using a frontend framework, you can still import the vanilla client.\n\nvanilla\nreact\nvue\nsvelte\nsolid\nlib/auth-client.ts\nimport { createAuthClient } from \"better-auth/react\"\nexport const authClient =  createAuthClient()\nAuth Middleware\nAstro Locals types\n\nTo have types for your Astro locals, you need to set it inside the env.d.ts file.\n\nenv.d.ts\n/// <reference path=\"../.astro/types.d.ts\" />\ndeclare namespace App {\n    // Note: 'import {} from \"\"' syntax does not work in .d.ts files.\n    interface Locals {\n        user: import(\"better-auth\").User | null;\n        session: import(\"better-auth\").Session | null;\n    }\n}\nMiddleware\n\nTo protect your routes, you can check if the user is authenticated using the getSession method in middleware and set the user and session data using the Astro locals with the types we set before. Start by creating a middleware.ts file in the root of your project and follow the example below:\n\nmiddleware.ts\nimport { auth } from \"@/auth\";\nimport { defineMiddleware } from \"astro:middleware\";\nexport const onRequest = defineMiddleware(async (context, next) => {\n    const isAuthed = await auth.api\n        .getSession({\n            headers: context.request.headers,\n        })\n    if (isAuthed) {\n        context.locals.user = isAuthed.user;\n        context.locals.session = isAuthed.session;\n    } else {\n        context.locals.user = null;\n        context.locals.session = null;\n    }\n    return next();\n});\nGetting session on the server inside .astro file\n\nYou can use Astro.locals to check if the user has session and get the user data from the server side. Here is an example of how you can get the session inside an .astro file:\n\n---\nimport { UserCard } from \"@/components/user-card\";\nconst session = () => {\n    if (Astro.locals.session) {\n        return Astro.locals.session;\n    } else {\n        // Redirect to login page if the user is not authenticated\n        return Astro.redirect(\"/login\");\n    }\n}\n---\n<UserCard initialSession={session} />\nEdit on GitHub\n\nPrevious Page\n\nFull Stack\n\nNext Page\n\nRemix"
  },
  {
    "title": "Remix Integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/remix",
    "html": "Remix Integration\nCopy Markdown\nOpen in\n\nBetter Auth can be easily integrated with Remix. This guide will show you how to integrate Better Auth with Remix.\n\nYou can follow the steps from installation to get started or you can follow this guide to make it the Remix-way.\n\nIf you have followed the installation steps, you can skip the first step.\n\nCreate auth instance\n\nCreate a file named auth.server.ts in one of these locations:\n\nProject root\nlib/ folder\nutils/ folder\n\nYou can also nest any of these folders under app/ folder. (e.g. app/lib/auth.server.ts)\n\nAnd in this file, import Better Auth and create your instance.\n\nMake sure to export the auth instance with the variable name auth or as a default export.\n\napp/lib/auth.server.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    database: {\n        provider: \"postgres\", //change this to your database provider\n        url: process.env.DATABASE_URL, // path to your database or connection string\n    }\n})\nCreate API Route\n\nWe need to mount the handler to a API route. Create a resource route file api.auth.$.ts inside app/routes/ directory. And add the following code:\n\napp/routes/api.auth.$.ts\nimport { auth } from '~/lib/auth.server' // Adjust the path as necessary\nimport type { LoaderFunctionArgs, ActionFunctionArgs } from \"@remix-run/node\"\nexport async function loader({ request }: LoaderFunctionArgs) {\n    return auth.handler(request)\n}\nexport async function action({ request }: ActionFunctionArgs) {\n    return auth.handler(request)\n}\n\nYou can change the path on your better-auth configuration but it's recommended to keep it as routes/api.auth.$.ts\n\nCreate a client\n\nCreate a client instance. Here we are creating auth-client.ts file inside the lib/ directory.\n\napp/lib/auth-client.ts\nimport { createAuthClient } from \"better-auth/react\" // make sure to import from better-auth/react\nexport const authClient = createAuthClient({\n    //you can pass client configuration here\n})\n\nOnce you have created the client, you can use it to sign up, sign in, and perform other actions.\n\nExample usage\nSign Up\napp/routes/signup.tsx\nimport { Form } from \"@remix-run/react\"\nimport { useState } from \"react\"\nimport { authClient } from \"~/lib/auth-client\"\nexport default function SignUp() {\n  const [email, setEmail] = useState(\"\")\n  const [name, setName] = useState(\"\")\n  const [password, setPassword] = useState(\"\")\n  const signUp = async () => {\n    await authClient.signUp.email(\n      {\n        email,\n        password,\n        name,\n      },\n      {\n        onRequest: (ctx) => {\n          // show loading state\n        },\n        onSuccess: (ctx) => {\n          // redirect to home\n        },\n        onError: (ctx) => {\n          alert(ctx.error)\n        },\n      },\n    )\n  }\n  return (\n    <div>\n      <h2>\n        Sign Up\n      </h2>\n      <Form\n        onSubmit={signUp}\n      >\n        <input\n          type=\"text\"\n          value={name}\n          onChange={(e) => setName(e.target.value)}\n          placeholder=\"Name\"\n        />\n        <input\n          type=\"email\"\n          value={email}\n          onChange={(e) => setEmail(e.target.value)}\n          placeholder=\"Email\"\n        />\n        <input\n          type=\"password\"\n          value={password}\n          onChange={(e) => setPassword(e.target.value)}\n          placeholder=\"Password\"\n        />\n        <button\n          type=\"submit\"\n        >\n          Sign Up\n        </button>\n      </Form>\n    </div>\n  )\n}\nSign In\napp/routes/signin.tsx\nimport { Form } from \"@remix-run/react\"\nimport { useState } from \"react\"\nimport { authClient } from \"~/services/auth-client\"\nexport default function SignIn() {\n  const [email, setEmail] = useState(\"\")\n  const [password, setPassword] = useState(\"\")\n  const signIn = async () => {\n    await authClient.signIn.email(\n      {\n        email,\n        password,\n      },\n      {\n        onRequest: (ctx) => {\n          // show loading state\n        },\n        onSuccess: (ctx) => {\n          // redirect to home\n        },\n        onError: (ctx) => {\n          alert(ctx.error)\n        },\n      },\n    )\n  }\n  return (\n    <div>\n      <h2>\n        Sign In\n      </h2>\n      <Form onSubmit={signIn}>\n        <input\n          type=\"email\"\n          value={email}\n          onChange={(e) => setEmail(e.target.value)}\n        />\n        <input\n          type=\"password\"\n          value={password}\n          onChange={(e) => setPassword(e.target.value)}\n        />\n        <button\n          type=\"submit\"\n        >\n          Sign In\n        </button>\n      </Form>\n    </div>\n  )\n}\nEdit on GitHub\n\nPrevious Page\n\nAstro\n\nNext Page\n\nNext"
  },
  {
    "title": "Nuxt Integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/nuxt",
    "html": "Nuxt Integration\nCopy Markdown\nOpen in\n\nBefore you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the installation.\n\nCreate API Route\n\nWe need to mount the handler to an API route. Create a file inside /server/api/auth called [...all].ts and add the following code:\n\nserver/api/auth/[...all].ts\nimport { auth } from \"~/lib/auth\"; // import your auth config\nexport default defineEventHandler((event) => {\n\treturn auth.handler(toWebRequest(event));\n});\n\nYou can change the path on your better-auth configuration but it's recommended to keep it as /api/auth/[...all]\n\nMigrate the database\n\nRun the following command to create the necessary tables in your database:\n\nnpx @better-auth/cli migrate\nCreate a client\n\nCreate a client instance. You can name the file anything you want. Here we are creating client.ts file inside the lib/ directory.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/vue\" // make sure to import from better-auth/vue\nexport const authClient = createAuthClient({\n    //you can pass client configuration here\n})\n\nOnce you have created the client, you can use it to sign up, sign in, and perform other actions. Some of the actions are reactive.\n\nExample usage\nindex.vue\n<script setup lang=\"ts\">\nimport { authClient } from \"~/lib/client\"\nconst session = authClient.useSession()\n</script>\n<template>\n    <div>\n        <button v-if=\"!session?.data\" @click=\"() => authClient.signIn.social({\n            provider: 'github'\n        })\">\n            Continue with GitHub\n        </button>\n        <div>\n            <pre>{{ session.data }}</pre>\n            <button v-if=\"session.data\" @click=\"authClient.signOut()\">\n                Sign out\n            </button>\n        </div>\n    </div>\n</template>\nServer Usage\n\nThe api object exported from the auth instance contains all the actions that you can perform on the server. Every endpoint made inside Better Auth is a invocable as a function. Including plugins endpoints.\n\nExample: Getting Session on a server API route\n\nserver/api/example.ts\nimport { auth } from \"~/lib/auth\";\nexport default defineEventHandler((event) => {\n    const session = await auth.api.getSession({\n      headers: event.headers\n    });\n   if(session) {\n     // access the session.session && session.user\n   }\n});\nSSR Usage\n\nIf you are using Nuxt with SSR, you can use the useSession function in the setup function of your page component and pass useFetch to make it work with SSR.\n\nindex.vue\n<script setup lang=\"ts\">\nimport { authClient } from \"~/lib/auth-client\";\nconst { data: session } = await authClient.useSession(useFetch);\n</script>\n<template>\n    <p>\n        {{ session }}\n    </p>\n</template>\nMiddleware\n\nTo add middleware to your Nuxt project, you can use the useSession method from the client.\n\nmiddleware/auth.global.ts\nimport { authClient } from \"~/lib/auth-client\";\nexport default defineNuxtRouteMiddleware(async (to, from) => {\n\tconst { data: session } = await authClient.useSession(useFetch); \n\tif (!session.value) {\n\t\tif (to.path === \"/dashboard\") {\n\t\t\treturn navigateTo(\"/\");\n\t\t}\n\t}\n});\nResources & Examples\nNuxt and Nuxt Hub example on GitHub.\nNuxtZzle is Nuxt,Drizzle ORM example on GitHub preview\nNuxt example on StackBlitz.\nNuxSaaS (Github) is a full-stack SaaS Starter Kit that leverages Better Auth for secure and efficient user authentication. Demo\nNuxtOne (Github) is a Nuxt-based starter template for building AIaaS (AI-as-a-Service) applications preview\nEdit on GitHub\n\nPrevious Page\n\nNext\n\nNext Page\n\nSvelteKit"
  },
  {
    "title": "SvelteKit Integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/svelte-kit",
    "html": "SvelteKit Integration\nCopy Markdown\nOpen in\n\nBefore you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the installation.\n\nMount the handler\n\nWe need to mount the handler to SvelteKit server hook.\n\nhooks.server.ts\nimport { auth } from \"$lib/auth\";\nimport { svelteKitHandler } from \"better-auth/svelte-kit\";\nimport { building } from \"$app/environment\";\nexport async function handle({ event, resolve }) {\n  return svelteKitHandler({ event, resolve, auth, building });\n}\nPopulate session data in the event (event.locals)\n\nThe svelteKitHandler does not automatically populate event.locals.user or event.locals.session. If you want to access the current session in your server code (e.g., in +layout.server.ts, actions, or endpoints), populate event.locals in your handle hook:\n\nhooks.server.ts\nimport { auth } from \"$lib/auth\";\nimport { svelteKitHandler } from \"better-auth/svelte-kit\";\nimport { building } from \"$app/environment\";\nexport async function handle({ event, resolve }) {\n  // Fetch current session from Better Auth\n  const session = await auth.api.getSession({\n    headers: event.request.headers,\n  });\n  // Make session and user available on server\n  if (session) {\n    event.locals.session = session.session;\n    event.locals.user = session.user;\n  }\n  return svelteKitHandler({ event, resolve, auth, building });\n}\nServer Action Cookies\n\nTo ensure cookies are properly set when you call functions like signInEmail or signUpEmail in a server action, you should use the sveltekitCookies plugin. This plugin will automatically handle setting cookies for you in SvelteKit.\n\nYou need to add it as a plugin to your Better Auth instance.\n\nThe getRequestEvent function is available in SvelteKit 2.20.0 and later. Make sure you are using a compatible version.\n\nlib/auth.ts\nimport { betterAuth } from \"better-auth\";\nimport { sveltekitCookies } from \"better-auth/svelte-kit\";\nimport { getRequestEvent } from \"$app/server\";\nexport const auth = betterAuth({\n  // ... your config\n  plugins: [sveltekitCookies(getRequestEvent)], // make sure this is the last plugin in the array\n});\nCreate a client\n\nCreate a client instance. You can name the file anything you want. Here we are creating client.ts file inside the lib/ directory.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/svelte\"; // make sure to import from better-auth/svelte\nexport const authClient = createAuthClient({\n  // you can pass client configuration here\n});\n\nOnce you have created the client, you can use it to sign up, sign in, and perform other actions. Some of the actions are reactive. The client use nano-store to store the state and reflect changes when there is a change like a user signing in or out affecting the session state.\n\nExample usage\n<script lang=\"ts\">\n  import { authClient } from \"$lib/client\";\n  const session = authClient.useSession();\n</script>\n    <div>\n      {#if $session.data}\n        <div>\n          <p>\n            {$session.data.user.name}\n          </p>\n          <button\n            on:click={async () => {\n              await authClient.signOut();\n            }}\n          >\n            Sign Out\n          </button>\n        </div>\n      {:else}\n        <button\n          on:click={async () => {\n            await authClient.signIn.social({\n              provider: \"github\",\n            });\n          }}\n        >\n          Continue with GitHub\n        </button>\n      {/if}\n    </div>\nEdit on GitHub\n\nPrevious Page\n\nNuxt\n\nNext Page\n\nSolidStart"
  },
  {
    "title": "SolidStart Integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/solid-start",
    "html": "SolidStart Integration\nCopy Markdown\nOpen in\n\nBefore you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the installation.\n\nMount the handler\n\nWe need to mount the handler to SolidStart server. Put the following code in your *auth.ts file inside /routes/api/auth folder.\n\n*auth.ts\nimport { auth } from \"~/lib/auth\";\nimport { toSolidStartHandler } from \"better-auth/solid-start\";\nexport const { GET, POST } = toSolidStartHandler(auth);\nEdit on GitHub\n\nPrevious Page\n\nSvelteKit\n\nNext Page\n\nTanStack Start"
  },
  {
    "title": "TanStack Start Integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/tanstack",
    "html": "TanStack Start Integration\nCopy Markdown\nOpen in\n\nThis integration guide is assuming you are using TanStack Start.\n\nBefore you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the installation.\n\nMount the handler\n\nWe need to mount the handler to a TanStack API endpoint/Server Route. Create a new file: /src/routes/api/auth/$.ts\n\nsrc/routes/api/auth/$.ts\nimport { auth } from '@/lib/auth'\nimport { createFileRoute } from '@tanstack/react-router'\nexport const Route = createFileRoute('/api/auth/$')({\n  server: {\n    handlers: {\n      GET: ({ request }) => {\n        return auth.handler(request)\n      },\n      POST: ({ request }) => {\n        return auth.handler(request)\n      },\n    },\n  },\n})\nUsage tips\nWe recommend using the client SDK or authClient to handle authentication, rather than server actions with auth.api.\nWhen you call functions that need to set cookies (like signInEmail or signUpEmail), you'll need to handle cookie setting for TanStack Start. Better Auth provides a reactStartCookies plugin to automatically handle this for you.\nsrc/lib/auth.ts\nimport { betterAuth } from \"better-auth\";\nimport { reactStartCookies } from \"better-auth/react-start\";\nexport const auth = betterAuth({\n    //...your config\n    plugins: [reactStartCookies()] // make sure this is the last plugin in the array\n})\n\nNow, when you call functions that set cookies, they will be automatically set using TanStack Start's cookie handling system.\n\nimport { auth } from \"@/lib/auth\"\nconst signIn = async () => {\n    await auth.api.signInEmail({\n        body: {\n            email: \"user@email.com\",\n            password: \"password\",\n        }\n    })\n}\nEdit on GitHub\n\nPrevious Page\n\nSolidStart\n\nNext Page\n\nBackend"
  },
  {
    "title": "Hono Integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/hono",
    "html": "Hono Integration\nCopy Markdown\nOpen in\n\nBefore you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the installation.\n\nMount the handler\n\nWe need to mount the handler to Hono endpoint.\n\nimport { Hono } from \"hono\";\nimport { auth } from \"./auth\";\nimport { serve } from \"@hono/node-server\";\nconst app = new Hono();\napp.on([\"POST\", \"GET\"], \"/api/auth/*\", (c) => {\n\treturn auth.handler(c.req.raw);\n});\nserve(app);\nCors\n\nTo configure cors, you need to use the cors plugin from hono/cors.\n\nimport { Hono } from \"hono\";\nimport { auth } from \"./auth\";\nimport { serve } from \"@hono/node-server\";\nimport { cors } from \"hono/cors\";\n \nconst app = new Hono();\napp.use(\n\t\"/api/auth/*\", // or replace with \"*\" to enable cors for all routes\n\tcors({\n\t\torigin: \"http://localhost:3001\", // replace with your origin\n\t\tallowHeaders: [\"Content-Type\", \"Authorization\"],\n\t\tallowMethods: [\"POST\", \"GET\", \"OPTIONS\"],\n\t\texposeHeaders: [\"Content-Length\"],\n\t\tmaxAge: 600,\n\t\tcredentials: true,\n\t}),\n);\napp.on([\"POST\", \"GET\"], \"/api/auth/*\", (c) => {\n\treturn auth.handler(c.req.raw);\n});\nserve(app);\n\nImportant: CORS middleware must be registered before your routes. This ensures that cross-origin requests are properly handled before they reach your authentication endpoints.\n\nMiddleware\n\nYou can add a middleware to save the session and user in a context and also add validations for every route.\n\nimport { Hono } from \"hono\";\nimport { auth } from \"./auth\";\nimport { serve } from \"@hono/node-server\";\nimport { cors } from \"hono/cors\";\n \nconst app = new Hono<{\n\tVariables: {\n\t\tuser: typeof auth.$Infer.Session.user | null;\n\t\tsession: typeof auth.$Infer.Session.session | null\n\t}\n}>();\napp.use(\"*\", async (c, next) => {\n\tconst session = await auth.api.getSession({ headers: c.req.raw.headers });\n  \tif (!session) {\n    \tc.set(\"user\", null);\n    \tc.set(\"session\", null);\n    \tawait next();\n        return;\n  \t}\n  \tc.set(\"user\", session.user);\n  \tc.set(\"session\", session.session);\n  \tawait next();\n});\napp.on([\"POST\", \"GET\"], \"/api/auth/*\", (c) => {\n\treturn auth.handler(c.req.raw);\n});\nserve(app);\n\nThis will allow you to access the user and session object in all of your routes.\n\napp.get(\"/session\", (c) => {\n\tconst session = c.get(\"session\")\n\tconst user = c.get(\"user\")\n\t\n\tif(!user) return c.body(null, 401);\n  \treturn c.json({\n\t  session,\n\t  user\n\t});\n});\nCross-Domain Cookies\n\nBy default, all Better Auth cookies are set with SameSite=Lax. If you need to use cookies across different domains, youâ€™ll need to set SameSite=None and Secure=true. However, we recommend using subdomains whenever possible, as this allows you to keep SameSite=Lax. To enable cross-subdomain cookies, simply turn on crossSubDomainCookies in your auth config.\n\nauth.ts\nexport const auth = createAuth({\n  advanced: {\n    crossSubDomainCookies: {\n      enabled: true\n    }\n  }\n})\n\nIf you still need to set SameSite=None and Secure=true, you can adjust these attributes globally through cookieOptions in the createAuth configuration.\n\nauth.ts\nexport const auth = createAuth({\n  advanced: {\n    defaultCookieAttributes: {\n      sameSite: \"none\",\n      secure: true,\n      partitioned: true // New browser standards will mandate this for foreign cookies\n    }\n  }\n})\n\nYou can also customize cookie attributes individually by setting them within cookies in your auth config.\n\nauth.ts\nexport const auth = createAuth({\n  advanced: {\n    cookies: {\n      sessionToken: {\n        attributes: {\n          sameSite: \"none\",\n          secure: true,\n          partitioned: true // New browser standards will mandate this for foreign cookies\n        }\n      }\n    }\n  }\n})\nClient-Side Configuration\n\nWhen using the Hono client (@hono/client) to make requests to your Better Auth-protected endpoints, you need to configure it to send credentials (cookies) with cross-origin requests.\n\napi.ts\nimport { hc } from \"hono/client\";\nimport type { AppType } from \"./server\"; // Your Hono app type\nconst client = hc<AppType>(\"http://localhost:8787/\", {\n  init: {\n    credentials: \"include\", // Required for sending cookies cross-origin\n  },\n});\n// Now your client requests will include credentials\nconst response = await client.someProtectedEndpoint.$get();\n\nThis configuration is necessary when:\n\nYour client and server are on different domains/ports during development\nYou're making cross-origin requests in production\nYou need to send authentication cookies with your requests\n\nThe credentials: \"include\" option tells the fetch client to send cookies even for cross-origin requests. This works in conjunction with the CORS configuration on your server that has credentials: true.\n\nNote: Make sure your CORS configuration on the server matches your client's domain, and that credentials: true is set in both the server's CORS config and the client's fetch config.\n\nEdit on GitHub\n\nPrevious Page\n\nBackend\n\nNext Page\n\nFastify"
  },
  {
    "title": "Express Integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/express",
    "html": "Express Integration\nCopy Markdown\nOpen in\n\nThis guide will show you how to integrate Better Auth with express.js.\n\nBefore you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the installation.\n\nNote that CommonJS (cjs) isn't supported. Use ECMAScript Modules (ESM) by setting \"type\": \"module\" in your package.json or configuring your tsconfig.json to use ES modules.\n\nMount the handler\n\nTo enable Better Auth to handle requests, we need to mount the handler to an API route. Create a catch-all route to manage all requests to /api/auth/* in case of ExpressJS v4 or /api/auth/*splat in case of ExpressJS v5 (or any other path specified in your Better Auth options).\n\nDonâ€™t use express.json() before the Better Auth handler. Use it only for other routes, or the client API will get stuck on \"pending\".\n\nserver.ts\nimport express from \"express\";\nimport { toNodeHandler } from \"better-auth/node\";\nimport { auth } from \"./auth\";\nconst app = express();\nconst port = 3005;\napp.all(\"/api/auth/*\", toNodeHandler(auth)); // For ExpressJS v4\n// app.all(\"/api/auth/*splat\", toNodeHandler(auth)); For ExpressJS v5 \n// Mount express json middleware after Better Auth handler\n// or only apply it to routes that don't interact with Better Auth\napp.use(express.json());\napp.listen(port, () => {\n\tconsole.log(`Example app listening on port ${port}`);\n});\n\nAfter completing the setup, start your server. Better Auth will be ready to use. You can send a GET request to the /ok endpoint (/api/auth/ok) to verify that the server is running.\n\nCors Configuration\n\nTo add CORS (Cross-Origin Resource Sharing) support to your Express server when integrating Better Auth, you can use the cors middleware. Below is an updated example showing how to configure CORS for your server:\n\nimport express from \"express\";\nimport cors from \"cors\"; // Import the CORS middleware\nimport { toNodeHandler, fromNodeHeaders } from \"better-auth/node\";\nimport { auth } from \"./auth\";\nconst app = express();\nconst port = 3005;\n// Configure CORS middleware\napp.use(\n  cors({\n    origin: \"http://your-frontend-domain.com\", // Replace with your frontend's origin\n    methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"], // Specify allowed HTTP methods\n    credentials: true, // Allow credentials (cookies, authorization headers, etc.)\n  })\n);\nGetting the User Session\n\nTo retrieve the user's session, you can use the getSession method provided by the auth object. This method requires the request headers to be passed in a specific format. To simplify this process, Better Auth provides a fromNodeHeaders helper function that converts Node.js request headers to the format expected by Better Auth (a Headers object).\n\nHere's an example of how to use getSession in an Express route:\n\nserver.ts\nimport { fromNodeHeaders } from \"better-auth/node\";\nimport { auth } from \"./auth\"; // Your Better Auth instance\napp.get(\"/api/me\", async (req, res) => {\n \tconst session = await auth.api.getSession({\n      headers: fromNodeHeaders(req.headers),\n    });\n\treturn res.json(session);\n});\nEdit on GitHub\n\nPrevious Page\n\nFastify\n\nNext Page\n\nElysia"
  },
  {
    "title": "Elysia Integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/elysia",
    "html": "Elysia Integration\nCopy Markdown\nOpen in\n\nThis integration guide is assuming you are using Elysia with bun server.\n\nBefore you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the installation.\n\nMount the handler\n\nWe need to mount the handler to Elysia endpoint.\n\nimport { Elysia } from \"elysia\";\nimport { auth } from \"./auth\";\nconst app = new Elysia().mount(auth.handler).listen(3000);\nconsole.log(\n  `ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`,\n);\nCORS\n\nTo configure cors, you can use the cors plugin from @elysiajs/cors.\n\nimport { Elysia } from \"elysia\";\nimport { cors } from \"@elysiajs/cors\";\nimport { auth } from \"./auth\";\nconst app = new Elysia()\n  .use(\n    cors({\n      origin: \"http://localhost:3001\",\n      methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"],\n      credentials: true,\n      allowedHeaders: [\"Content-Type\", \"Authorization\"],\n    }),\n  )\n  .mount(auth.handler)\n  .listen(3000);\nconsole.log(\n  `ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`,\n);\nMacro\n\nYou can use macro with resolve to provide session and user information before pass to view.\n\nimport { Elysia } from \"elysia\";\nimport { auth } from \"./auth\";\n// user middleware (compute user and session and pass to routes)\nconst betterAuth = new Elysia({ name: \"better-auth\" })\n  .mount(auth.handler)\n  .macro({\n    auth: {\n      async resolve({ status, request: { headers } }) {\n        const session = await auth.api.getSession({\n          headers,\n        });\n        if (!session) return status(401);\n        return {\n          user: session.user,\n          session: session.session,\n        };\n      },\n    },\n  });\nconst app = new Elysia()\n  .use(betterAuth)\n  .get(\"/user\", ({ user }) => user, {\n    auth: true,\n  })\n  .listen(3000);\nconsole.log(\n  `ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`,\n);\n\nThis will allow you to access the user and session object in all of your routes.\n\nEdit on GitHub\n\nPrevious Page\n\nExpress\n\nNext Page\n\nNitro"
  },
  {
    "title": "NestJS Integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/nestjs",
    "html": "NestJS Integration\nCopy Markdown\nOpen in\n\nThis guide will show you how to integrate Better Auth with NestJS.\n\nBefore you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the installation.\n\nThe NestJS integration is community maintained. If you encounter any issues, please open them at nestjs-better-auth.\n\nInstallation\n\nInstall the NestJS integration library:\n\nnpm\npnpm\nyarn\nbun\nnpm install @thallesp/nestjs-better-auth\nBasic Setup\n\nCurrently the library has beta support for Fastify, if you experience any issues with it, please open an issue at nestjs-better-auth.\n\n1. Disable Body Parser\n\nDisable NestJS's built-in body parser to allow Better Auth to handle the raw request body:\n\nmain.ts\nimport { NestFactory } from \"@nestjs/core\";\nimport { AppModule } from \"./app.module\";\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule, {\n    bodyParser: false, // Required for Better Auth\n  });\n  await app.listen(process.env.PORT ?? 3000);\n}\nbootstrap();\n2. Import AuthModule\n\nImport the AuthModule in your root module:\n\napp.module.ts\nimport { Module } from '@nestjs/common';\nimport { AuthModule } from '@thallesp/nestjs-better-auth';\nimport { auth } from \"./auth\"; // Your Better Auth instance\n@Module({\n  imports: [\n    AuthModule.forRoot({ auth }),\n  ],\n})\nexport class AppModule {}\n3. Route Protection\n\nGlobal by default: An AuthGuard is registered globally by this module. All routes are protected unless you explicitly allow access.\n\nUse the Session decorator to access the user session:\n\nuser.controller.ts\nimport { Controller, Get } from '@nestjs/common';\nimport { Session, UserSession, AllowAnonymous, OptionalAuth } from '@thallesp/nestjs-better-auth';\n@Controller('users')\nexport class UserController {\n  @Get('me')\n  async getProfile(@Session() session: UserSession) {\n    return { user: session.user };\n  }\n  @Get('public')\n  @AllowAnonymous() // Allow anonymous access\n  async getPublic() {\n    return { message: 'Public route' };\n  }\n  @Get('optional')\n  @OptionalAuth() // Authentication is optional\n  async getOptional(@Session() session: UserSession) {\n    return { authenticated: !!session };\n  }\n}\nFull Documentation\n\nFor comprehensive documentation including decorators, hooks, global guards, and advanced configuration, visit the NestJS Better Auth repository.\n\nEdit on GitHub\n\nPrevious Page\n\nNitro\n\nNext Page\n\nConvex"
  },
  {
    "title": "Nitro Integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/nitro",
    "html": "Nitro Integration\nCopy Markdown\nOpen in\n\nBetter Auth can be integrated with your Nitro Application (an open source framework to build web servers).\n\nThis guide aims to help you integrate Better Auth with your Nitro application in a few simple steps.\n\nCreate a new Nitro Application\n\nStart by scaffolding a new Nitro application using the following command:\n\nTerminal\nnpx giget@latest nitro nitro-app --install\n\nThis will create the nitro-app directory and install all the dependencies. You can now open the nitro-app directory in your code editor.\n\nPrisma Adapter Setup\n\nThis guide assumes that you have a basic understanding of Prisma. If you are new to Prisma, you can check out the Prisma documentation.\n\nThe sqlite database used in this guide will not work in a production environment. You should replace it with a production-ready database like PostgreSQL.\n\nFor this guide, we will be using the Prisma adapter. You can install prisma client by running the following command:\n\nnpm\npnpm\nyarn\nbun\nnpm install @prisma/client\n\nprisma can be installed as a dev dependency using the following command:\n\nnpm\npnpm\nyarn\nbun\nnpm install -D prisma\n\nGenerate a schema.prisma file in the prisma directory by running the following command:\n\nTerminal\nnpx prisma init\n\nYou can now replace the contents of the schema.prisma file with the following:\n\nprisma/schema.prisma\ngenerator client {\n  provider = \"prisma-client-js\"\n}\ndatasource db {\n  provider = \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n// Will be deleted. Just need it to generate the prisma client\nmodel Test {\n  id   Int    @id @default(autoincrement())\n  name String\n}\n\nEnsure that you update the DATABASE_URL in your .env file to point to the location of your database.\n\n.env\nDATABASE_URL=\"file:./dev.db\"\n\nRun the following command to generate the Prisma client & sync the database:\n\nTerminal\nnpx prisma db push\nInstall & Configure Better Auth\n\nFollow steps 1 & 2 from the installation guide to install Better Auth in your Nitro application & set up the environment variables.\n\nOnce that is done, create your Better Auth instance within the server/utils/auth.ts file.\n\nserver/utils/auth.ts\nimport { betterAuth } from \"better-auth\";\nimport { prismaAdapter } from \"better-auth/adapters/prisma\";\nimport { PrismaClient } from \"@prisma/client\";\nconst prisma = new PrismaClient();\nexport const auth = betterAuth({\n  database: prismaAdapter(prisma, { provider: \"sqlite\" }),\n  emailAndPassword: { enabled: true },\n});\nUpdate Prisma Schema\n\nUse the Better Auth CLI to update your Prisma schema with the required models by running the following command:\n\nTerminal\nnpx @better-auth/cli generate --config server/utils/auth.ts\n\nThe --config flag is used to specify the path to the file where you have created your Better Auth instance.\n\nHead over to the prisma/schema.prisma file & save the file to trigger the format on save.\n\nAfter saving the file, you can run the npx prisma db push command to update the database schema.\n\nMount The Handler\n\nYou can now mount the Better Auth handler in your Nitro application. You can do this by adding the following code to your server/routes/api/auth/[...all].ts file:\n\nserver/routes/api/auth/[...all].ts\nexport default defineEventHandler((event) => {\n  return auth.handler(toWebRequest(event));\n});\n\nThis is a catch-all route that will handle all requests to /api/auth/*.\n\nCORS\n\nYou can configure CORS for your Nitro app by creating a plugin.\n\nStart by installing the cors package:\n\nnpm\npnpm\nyarn\nbun\nnpm install cors\n\nYou can now create a new file server/plugins/cors.ts and add the following code:\n\nserver/plugins/cors.ts\nimport cors from \"cors\";\nexport default defineNitroPlugin((plugin) => {\n  plugin.h3App.use(\n    fromNodeMiddleware(\n      cors({\n        origin: \"*\",\n      }),\n    ),\n  );\n});\n\nThis will enable CORS for all routes. You can customize the origin property to allow requests from specific domains. Ensure that the config is in sync with your frontend application.\n\nAuth Guard/Middleware\n\nYou can add an auth guard to your Nitro application to protect routes that require authentication. You can do this by creating a new file server/utils/require-auth.ts and adding the following code:\n\nserver/utils/require-auth.ts\nimport { EventHandler, H3Event } from \"h3\";\nimport { fromNodeHeaders } from \"better-auth/node\";\n/**\n * Middleware used to require authentication for a route.\n *\n * Can be extended to check for specific roles or permissions.\n */\nexport const requireAuth: EventHandler = async (event: H3Event) => {\n  const headers = event.headers;\n  const session = await auth.api.getSession({\n    headers: headers,\n  });\n  if (!session)\n    throw createError({\n      statusCode: 401,\n      statusMessage: \"Unauthorized\",\n    });\n  // You can save the session to the event context for later use\n  event.context.auth = session;\n};\n\nYou can now use this event handler/middleware in your routes to protect them:\n\nserver/routes/api/secret.get.ts\n// Object syntax of the route handler\nexport default defineEventHandler({\n  // The user has to be logged in to access this route\n  onRequest: [requireAuth],\n  handler: async (event) => {\n    setResponseStatus(event, 201, \"Secret data\");\n    return { message: \"Secret data\" };\n  },\n});\nExample\n\nYou can find an example of a Nitro application integrated with Better Auth & Prisma here.\n\nEdit on GitHub\n\nPrevious Page\n\nElysia\n\nNext Page\n\nNestJS"
  },
  {
    "title": "Convex Integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/convex",
    "html": "Convex Integration\nCopy Markdown\nOpen in\n\nThis documentation comes from the Convex documentation, for more information, please refer to their documentation.\n\nPrerequisites\nCreate a Convex project\n\nTo use Convex + Better Auth, you'll first need a Convex project. If you don't have one, run the following command to get started.\n\nnpm\npnpm\nyarn\nbun\nnpm create convex@latest\n\nCheck out the Convex docs to learn more about Convex.\n\nRun convex dev\n\nRunning the CLI during setup will initialize your Convex deployment if it doesn't already exist, and keeps generated types current through the process. Keep it running.\n\nnpm\npnpm\nyarn\nbun\nnpx convex dev\nInstallation of Convex + Better Auth\n\nThe following documentation assumes you're using Next.js.\n\nIf you're not using Next.js, support for other frameworks is documented in the installation guide by Convex.\n\nFor a complete example, check out Convex + Better Auth example with Next.js on GitHub.\n\nInstallation\nInstall packages\n\nInstall the component, a pinned version of Better Auth, and ensure the latest version of Convex.\n\nThis component requires Convex 1.25.0 or later.\n\nnpm\npnpm\nyarn\nbun\nnpm install better-auth@1.3.27 --save-exact\nnpm install convex@latest @convex-dev/better-auth\nRegister the component\n\nRegister the Better Auth component in your Convex project.\n\nconvex/convex.config.ts\nimport { defineApp } from \"convex/server\";\nimport betterAuth from \"@convex-dev/better-auth/convex.config\";\nconst app = defineApp();\napp.use(betterAuth);\nexport default app;\nAdd Convex auth config\n\nAdd a convex/auth.config.ts file to configure Better Auth as an authentication provider.\n\nconvex/auth.config.ts\nexport default {\n    providers: [\n        {\n            domain: process.env.CONVEX_SITE_URL,\n            applicationID: \"convex\",\n        },\n    ],\n};\nSet environment variables\n\nGenerate a secret for encryption and generating hashes. Use the command below if you have openssl installed, or generate your own however you like.\n\nnpm\npnpm\nyarn\nbun\nnpx convex env set BETTER_AUTH_SECRET=$(openssl rand -base64 32)\n\nAdd your site URL to your Convex deployment.\n\nnpm\npnpm\nyarn\nbun\nnpx convex env set SITE_URL http://localhost:3000\n\nAdd environment variables to the .env.local file created by npx convex dev. It will be picked up by your framework dev server.\n\nCloud\nSelf hosted\n.env.local\n# Deployment used by \\`npx convex dev\\`\nCONVEX_DEPLOYMENT=dev:adjective-animal-123 # team: team-name, project: project-name\nNEXT_PUBLIC_CONVEX_URL=https://adjective-animal-123.convex.cloud\n# Same as NEXT_PUBLIC_CONVEX_URL but ends in .site\nNEXT_PUBLIC_CONVEX_SITE_URL=https://adjective-animal-123.convex.site\n# Your local site URL\nSITE_URL=http://localhost:3000\nCreate a Better Auth instance\n\nCreate a Better Auth instance and initialize the component.\n\nSome TypeScript errors will show until you save the file.\nconvex/auth.ts\nimport { createClient, type GenericCtx } from \"@convex-dev/better-auth\";\nimport { convex } from \"@convex-dev/better-auth/plugins\";\nimport { components } from \"./_generated/api\";\nimport { DataModel } from \"./_generated/dataModel\";\nimport { query } from \"./_generated/server\";\nimport { betterAuth } from \"better-auth\";\nconst siteUrl = process.env.SITE_URL!;\n// The component client has methods needed for integrating Convex with Better Auth,\n// as well as helper methods for general use.\nexport const authComponent = createClient<DataModel>(components.betterAuth);\nexport const createAuth = (\n    ctx: GenericCtx<DataModel>,\n    { optionsOnly } = { optionsOnly: false },\n) => {\n    return betterAuth({\n        // disable logging when createAuth is called just to generate options.\n        // this is not required, but there's a lot of noise in logs without it.\n        logger: {\n            disabled: optionsOnly,\n        },\n        baseURL: siteUrl,\n        database: authComponent.adapter(ctx),\n        // Configure simple, non-verified email/password to get started\n        emailAndPassword: {\n            enabled: true,\n            requireEmailVerification: false,\n        },\n        plugins: [\n            // The Convex plugin is required for Convex compatibility\n            convex(),\n        ],\n    });\n};\n// Example function for getting the current user\n// Feel free to edit, omit, etc.\nexport const getCurrentUser = query({\n    args: {},\n    handler: async (ctx) => {\n        return authComponent.getAuthUser(ctx);\n    },\n});\nCreate a Better Auth client instance\n\nCreate a Better Auth client instance for interacting with the Better Auth server from your client.\n\nsrc/lib/auth-client.ts\nimport { createAuthClient } from \"better-auth/react\";\nimport { convexClient } from \"@convex-dev/better-auth/client/plugins\";\nexport const authClient = createAuthClient({\n    plugins: [convexClient()],\n});\nMount handlers\n\nRegister Better Auth route handlers on your Convex deployment.\n\nconvex/http.ts\nimport { httpRouter } from \"convex/server\";\nimport { authComponent, createAuth } from \"./auth\";\nconst http = httpRouter();\nauthComponent.registerRoutes(http, createAuth);\nexport default http;\n\nSet up route handlers to proxy auth requests from your framework server to your Convex deployment.\n\napp/api/auth/[...all]/route.ts\nimport { nextJsHandler } from \"@convex-dev/better-auth/nextjs\";\nexport const { GET, POST } = nextJsHandler();\nSet up Convex client provider\n\nWrap your app with the ConvexBetterAuthProvider component.\n\napp/ConvexClientProvider.tsx\n\"use client\";\nimport { ReactNode } from \"react\";\nimport { ConvexReactClient } from \"convex/react\";\nimport { authClient } from \"@/lib/auth-client\"; \nimport { ConvexBetterAuthProvider } from \"@convex-dev/better-auth/react\"; \nconst convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!, {\n  // Optionally pause queries until the user is authenticated\n  expectAuth: true, \n});\nexport function ConvexClientProvider({ children }: { children: ReactNode }) {\n  return (\n    <ConvexBetterAuthProvider client={convex} authClient={authClient}>\n      {children}\n    </ConvexBetterAuthProvider>\n  );\n}\nYou're done!\n\nYou're now ready to start using Better Auth with Convex.\n\nUsage\nUsing Better Auth from the server\n\nTo use Better Auth's server methods in server rendering, server functions, or any other Next.js server code, use Convex functions and call the function from your server code.\n\nFirst, a token helper for calling Convex functions from your server code.\n\nsrc/lib/auth-server.ts\nimport { createAuth } from \"@/convex/auth\";\nimport { getToken as getTokenNextjs } from \"@convex-dev/better-auth/nextjs\";\nexport const getToken = () => {\n  return getTokenNextjs(createAuth);\n};\n\nHere's an example Convex function that uses Better Auth's server methods, and a server action that calls the Convex function.\n\nconvex/users.ts\nimport { mutation } from \"./_generated/server\";\nimport { v } from \"convex/values\";\nimport { createAuth, authComponent } from \"./auth\";\nexport const updateUserPassword = mutation({\n  args: {\n    currentPassword: v.string(),\n    newPassword: v.string(),\n  },\n  handler: async (ctx, args) => {\n    const { auth, headers } = await authComponent.getAuth(createAuth, ctx);\n    await auth.api.changePassword({\n      body: {\n        currentPassword: args.currentPassword,\n        newPassword: args.newPassword,\n      },\n      headers,\n    });\n  },\n});\napp/actions.ts\n\"use server\";\nimport { fetchMutation } from \"convex/nextjs\";\nimport { api } from \"../convex/_generated/api\";\nimport { getToken } from \"../lib/auth-server\";\n// Authenticated mutation via server function\nexport async function updatePassword({\n  currentPassword,\n  newPassword,\n}: {\n  currentPassword: string;\n  newPassword: string;\n}) {\n  const token = await getToken();\n  await fetchMutation(\n    api.users.updatePassword,\n    { currentPassword, newPassword },\n    { token }\n  );\n}\n\nThis documentation comes from the Convex documentation, for more information, please refer to their documentation.\n\nEdit on GitHub\n\nPrevious Page\n\nNestJS\n\nNext Page\n\nMobile & Desktop"
  },
  {
    "title": "Expo Integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/expo",
    "html": "Expo Integration\nCopy Markdown\nOpen in\n\nExpo is a popular framework for building cross-platform apps with React Native. Better Auth supports both Expo native and web apps.\n\nInstallation\nConfigure A Better Auth Backend\n\nBefore using Better Auth with Expo, make sure you have a Better Auth backend set up. You can either use a separate server or leverage Expo's new API Routes feature to host your Better Auth instance.\n\nTo get started, check out our installation guide for setting up Better Auth on your server. If you prefer to check out the full example, you can find it here.\n\nTo use the new API routes feature in Expo to host your Better Auth instance you can create a new API route in your Expo app and mount the Better Auth handler.\n\napp/api/auth/[...auth]+api.ts\nimport { auth } from \"@/lib/auth\"; // import Better Auth handler\nconst handler = auth.handler;\nexport { handler as GET, handler as POST }; // export handler for both GET and POST requests\nInstall Server Dependencies\n\nInstall both the Better Auth package and Expo plugin into your server application.\n\nnpm\npnpm\nyarn\nbun\nnpm install better-auth @better-auth/expo\nInstall Client Dependencies\n\nYou also need to install both the Better Auth package and Expo plugin into your Expo application.\n\nnpm\npnpm\nyarn\nbun\nnpm install better-auth @better-auth/expo \n\nIf you plan on using our social integrations (Google, Apple etc.) then there are a few more dependencies that are required in your Expo app. In the default Expo template these are already installed so you may be able to skip this step if you have these dependencies already.\n\nnpm\npnpm\nyarn\nbun\nnpm install expo-linking expo-web-browser expo-constants\nAdd the Expo Plugin on Your Server\n\nAdd the Expo plugin to your Better Auth server.\n\nlib/auth.ts\nimport { betterAuth } from \"better-auth\";\nimport { expo } from \"@better-auth/expo\";\nexport const auth = betterAuth({\n    plugins: [expo()],\n    emailAndPassword: { \n        enabled: true, // Enable authentication using email and password.\n      }, \n});\nInitialize Better Auth Client\n\nTo initialize Better Auth in your Expo app, you need to call createAuthClient with the base URL of your Better Auth backend. Make sure to import the client from /react.\n\nMake sure you install the expo-secure-store package into your Expo app. This is used to store the session data and cookies securely.\n\nnpm\npnpm\nyarn\nbun\nnpm install expo-secure-store\n\nYou need to also import client plugin from @better-auth/expo/client and pass it to the plugins array when initializing the auth client.\n\nThis is important because:\n\nSocial Authentication Support: enables social auth flows by handling authorization URLs and callbacks within the Expo web browser.\nSecure Cookie Management: stores cookies securely and automatically adds them to the headers of your auth requests.\nlib/auth-client.ts\nimport { createAuthClient } from \"better-auth/react\";\nimport { expoClient } from \"@better-auth/expo/client\";\nimport * as SecureStore from \"expo-secure-store\";\nexport const authClient = createAuthClient({\n    baseURL: \"http://localhost:8081\", // Base URL of your Better Auth backend.\n    plugins: [\n        expoClient({\n            scheme: \"myapp\",\n            storagePrefix: \"myapp\",\n            storage: SecureStore,\n        })\n    ]\n});\n\nBe sure to include the full URL, including the path, if you've changed the default path from /api/auth.\n\nScheme and Trusted Origins\n\nBetter Auth uses deep links to redirect users back to your app after authentication. To enable this, you need to add your app's scheme to the trustedOrigins list in your Better Auth config.\n\nFirst, make sure you have a scheme defined in your app.json file.\n\napp.json\n{\n    \"expo\": {\n        \"scheme\": \"myapp\"\n    }\n}\n\nThen, update your Better Auth config to include the scheme in the trustedOrigins list.\n\nauth.ts\nexport const auth = betterAuth({\n    trustedOrigins: [\"myapp://\"]\n})\n\nIf you have multiple schemes or need to support deep linking with various paths, you can use specific patterns or wildcards:\n\nauth.ts\nexport const auth = betterAuth({\n    trustedOrigins: [\n        // Basic scheme\n        \"myapp://\", \n        \n        // Production & staging schemes\n        \"myapp-prod://\",\n        \"myapp-staging://\",\n        \n        // Wildcard support for all paths following the scheme\n        \"myapp://*\"\n    ]\n})\n\nThe wildcard pattern can be particularly useful if your app uses different URL formats for deep linking based on features or screens.\n\nConfigure Metro Bundler\n\nTo resolve Better Auth exports you'll need to enable unstable_enablePackageExports in your metro config.\n\nmetro.config.js\nconst { getDefaultConfig } = require(\"expo/metro-config\");\nconst config = getDefaultConfig(__dirname)\nconfig.resolver.unstable_enablePackageExports = true; \nmodule.exports = config;\nIn case you don't have a metro.config.js file in your project run npx expo customize metro.config.js.\n\nIf you can't enable unstable_enablePackageExports option, you can use babel-plugin-module-resolver to manually resolve the paths.\n\nbabel.config.js\nmodule.exports = function (api) {\n    api.cache(true);\n    return {\n        presets: [\"babel-preset-expo\"],\n        plugins: [\n            [\n                \"module-resolver\",\n                {\n                    alias: {\n                        \"better-auth/react\": \"./node_modules/better-auth/dist/client/react/index.cjs\",\n                        \"better-auth/client/plugins\": \"./node_modules/better-auth/dist/client/plugins/index.cjs\",\n                        \"@better-auth/expo/client\": \"./node_modules/@better-auth/expo/dist/client.cjs\",\n                    },\n                },\n            ],\n        ],\n    }\n}\nIn case you don't have a babel.config.js file in your project run npx expo customize babel.config.js.\n\nDon't forget to clear the cache after making changes.\n\nnpx expo start --clear\nUsage\nAuthenticating Users\n\nWith Better Auth initialized, you can now use the authClient to authenticate users in your Expo app.\n\nsign-in\nsign-up\napp/sign-in.tsx\nimport { useState } from \"react\"; \nimport { View, TextInput, Button } from \"react-native\";\nimport { authClient } from \"@/lib/auth-client\";\nexport default function SignIn() {\n    const [email, setEmail] = useState(\"\");\n    const [password, setPassword] = useState(\"\");\n    const handleLogin = async () => {\n        await authClient.signIn.email({\n            email,\n            password,\n        })\n    };\n    return (\n        <View>\n            <TextInput\n                placeholder=\"Email\"\n                value={email}\n                onChangeText={setEmail}\n            />\n            <TextInput\n                placeholder=\"Password\"\n                value={password}\n                onChangeText={setPassword}\n            />\n            <Button title=\"Login\" onPress={handleLogin} />\n        </View>\n    );\n}\nSocial Sign-In\n\nFor social sign-in, you can use the authClient.signIn.social method with the provider name and a callback URL.\n\napp/social-sign-in.tsx\nimport { Button } from \"react-native\";\nexport default function SocialSignIn() {\n    const handleLogin = async () => {\n        await authClient.signIn.social({\n            provider: \"google\",\n            callbackURL: \"/dashboard\" // this will be converted to a deep link (eg. `myapp://dashboard`) on native\n        })\n    };\n    return <Button title=\"Login with Google\" onPress={handleLogin} />;\n}\nIdToken Sign-In\n\nIf you want to make provider request on the mobile device and then verify the ID token on the server, you can use the authClient.signIn.social method with the idToken option.\n\napp/social-sign-in.tsx\nimport { Button } from \"react-native\";\nexport default function SocialSignIn() {\n    const handleLogin = async () => {\n        await authClient.signIn.social({\n            provider: \"google\", // only google, apple and facebook are supported for idToken signIn\n            idToken: {\n                token: \"...\", // ID token from provider\n                nonce: \"...\", // nonce from provider (optional)\n            }\n            callbackURL: \"/dashboard\" // this will be converted to a deep link (eg. `myapp://dashboard`) on native\n        })\n    };\n    return <Button title=\"Login with Google\" onPress={handleLogin} />;\n}\nSession\n\nBetter Auth provides a useSession hook to access the current user's session in your app.\n\napp/index.tsx\nimport { Text } from \"react-native\";\nimport { authClient } from \"@/lib/auth-client\";\nexport default function Index() {\n    const { data: session } = authClient.useSession();\n    return <Text>Welcome, {session?.user.name}</Text>;\n}\n\nOn native, the session data will be cached in SecureStore. This will allow you to remove the need for a loading spinner when the app is reloaded. You can disable this behavior by passing the disableCache option to the client.\n\nMaking Authenticated Requests to Your Server\n\nTo make authenticated requests to your server that require the user's session, you have to retrieve the session cookie from SecureStore and manually add it to your request headers.\n\nimport { authClient } from \"@/lib/auth-client\";\nconst makeAuthenticatedRequest = async () => {\n  const cookies = authClient.getCookie(); \n  const headers = {\n    \"Cookie\": cookies, \n  };\n  const response = await fetch(\"http://localhost:8081/api/secure-endpoint\", { \n    headers,\n    // 'include' can interfere with the cookies we just set manually in the headers\n    credentials: \"omit\"\n  });\n  const data = await response.json();\n  return data;\n};\n\nExample: Usage With TRPC\n\nlib/trpc-provider.tsx\n//...other imports\nimport { authClient } from \"@/lib/auth-client\"; \nexport const api = createTRPCReact<AppRouter>();\nexport function TRPCProvider(props: { children: React.ReactNode }) {\n  const [queryClient] = useState(() => new QueryClient());\n  const [trpcClient] = useState(() =>\n    api.createClient({\n      links: [\n        httpBatchLink({\n          //...your other options\n          headers() {\n            const headers = new Map<string, string>(); \n            const cookies = authClient.getCookie(); \n            if (cookies) { \n              headers.set(\"Cookie\", cookies); \n            } \n            return Object.fromEntries(headers); \n          },\n        }),\n      ],\n    }),\n  );\n  return (\n    <api.Provider client={trpcClient} queryClient={queryClient}>\n      <QueryClientProvider client={queryClient}>\n        {props.children}\n      </QueryClientProvider>\n    </api.Provider>\n  );\n}\nOptions\nExpo Client\n\nstorage: the storage mechanism used to cache the session data and cookies.\n\nlib/auth-client.ts\nimport { createAuthClient } from \"better-auth/react\";\nimport SecureStorage from \"expo-secure-store\";\nconst authClient = createAuthClient({\n    baseURL: \"http://localhost:8081\",\n    storage: SecureStorage\n});\n\nscheme: scheme is used to deep link back to your app after a user has authenticated using oAuth providers. By default, Better Auth tries to read the scheme from the app.json file. If you need to override this, you can pass the scheme option to the client.\n\nlib/auth-client.ts\nimport { createAuthClient } from \"better-auth/react\";\nconst authClient = createAuthClient({\n    baseURL: \"http://localhost:8081\",\n    scheme: \"myapp\"\n});\n\ndisableCache: By default, the client will cache the session data in SecureStore. You can disable this behavior by passing the disableCache option to the client.\n\nlib/auth-client.ts\nimport { createAuthClient } from \"better-auth/react\";\nconst authClient = createAuthClient({\n    baseURL: \"http://localhost:8081\",\n    disableCache: true\n});\nExpo Servers\n\nServer plugin options:\n\noverrideOrigin: Override the origin for Expo API routes (default: false). Enable this if you're facing cors origin issues with Expo API routes.\n\nEdit on GitHub\n\nPrevious Page\n\nMobile & Desktop\n\nNext Page\n\nLynx"
  },
  {
    "title": "Lynx Integration | Better Auth",
    "url": "https://www.better-auth.com/docs/integrations/lynx",
    "html": "Lynx Integration\nCopy Markdown\nOpen in\n\nThis integration guide is for using Better Auth with Lynx, a cross-platform rendering framework that enables developers to build applications for Android, iOS, and Web platforms with native rendering performance.\n\nBefore you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the installation.\n\nInstallation\n\nInstall Better Auth and the Lynx React dependency:\n\nnpm\npnpm\nyarn\nbun\nnpm install better-auth @lynx-js/react\nCreate Client Instance\n\nImport createAuthClient from better-auth/lynx to create your client instance:\n\nlib/auth-client.ts\nimport { createAuthClient } from \"better-auth/lynx\"\nexport const authClient = createAuthClient({\n    baseURL: \"http://localhost:3000\" // The base URL of your auth server\n})\nUsage\n\nThe Lynx client provides the same API as other Better Auth clients, with optimized integration for Lynx's reactive system.\n\nAuthentication Methods\nimport { authClient } from \"./lib/auth-client\"\n// Sign in with email and password\nawait authClient.signIn.email({\n    email: \"test@user.com\",\n    password: \"password1234\"\n})\n// Sign up\nawait authClient.signUp.email({\n    email: \"test@user.com\", \n    password: \"password1234\",\n    name: \"John Doe\"\n})\n// Sign out\nawait authClient.signOut()\nHooks\n\nThe Lynx client includes reactive hooks that integrate seamlessly with Lynx's component system:\n\nuseSession\ncomponents/user.tsx\nimport { authClient } from \"../lib/auth-client\"\nexport function User() {\n    const {\n        data: session,\n        isPending, // loading state\n        error // error object \n    } = authClient.useSession()\n    if (isPending) return <div>Loading...</div>\n    if (error) return <div>Error: {error.message}</div>\n    return (\n        <div>\n            {session ? (\n                <div>\n                    <p>Welcome, {session.user.name}!</p>\n                    <button onClick={() => authClient.signOut()}>\n                        Sign Out\n                    </button>\n                </div>\n            ) : (\n                <button onClick={() => authClient.signIn.social({\n                    provider: 'github'\n                })}>\n                    Sign In with GitHub\n                </button>\n            )}\n        </div>\n    )\n}\nStore Integration\n\nThe Lynx client uses nanostores for state management and provides a useStore hook for accessing reactive state:\n\ncomponents/session-info.tsx\nimport { useStore } from \"better-auth/lynx\"\nimport { authClient } from \"../lib/auth-client\"\nexport function SessionInfo() {\n    // Access the session store directly\n    const session = useStore(authClient.$store.session)\n    \n    return (\n        <div>\n            {session && (\n                <pre>{JSON.stringify(session, null, 2)}</pre>\n            )}\n        </div>\n    )\n}\nAdvanced Store Usage\n\nYou can use the store with selective key watching for optimized re-renders:\n\ncomponents/optimized-user.tsx\nimport { useStore } from \"better-auth/lynx\"\nimport { authClient } from \"../lib/auth-client\"\nexport function OptimizedUser() {\n    // Only re-render when specific keys change\n    const session = useStore(authClient.$store.session, {\n        keys: ['user.name', 'user.email'] // Only watch these specific keys\n    })\n    \n    return (\n        <div>\n            {session?.user && (\n                <div>\n                    <h2>{session.user.name}</h2>\n                    <p>{session.user.email}</p>\n                </div>\n            )}\n        </div>\n    )\n}\nPlugin Support\n\nThe Lynx client supports all Better Auth plugins:\n\nlib/auth-client.ts\nimport { createAuthClient } from \"better-auth/lynx\"\nimport { magicLinkClient } from \"better-auth/client/plugins\"\nconst authClient = createAuthClient({\n    plugins: [\n        magicLinkClient()\n    ]\n})\n// Use plugin methods\nawait authClient.signIn.magicLink({\n    email: \"test@email.com\"\n})\nError Handling\n\nError handling works the same as other Better Auth clients:\n\ncomponents/login-form.tsx\nimport { authClient } from \"../lib/auth-client\"\nexport function LoginForm() {\n    const signIn = async (email: string, password: string) => {\n        const { data, error } = await authClient.signIn.email({\n            email,\n            password\n        })\n        \n        if (error) {\n            console.error('Login failed:', error.message)\n            return\n        }\n        \n        console.log('Login successful:', data)\n    }\n    \n    return (\n        <form onSubmit={(e) => {\n            e.preventDefault()\n            const formData = new FormData(e.target)\n            signIn(formData.get('email'), formData.get('password'))\n        }}>\n            <input name=\"email\" type=\"email\" placeholder=\"Email\" />\n            <input name=\"password\" type=\"password\" placeholder=\"Password\" />\n            <button type=\"submit\">Sign In</button>\n        </form>\n    )\n}\nFeatures\n\nThe Lynx client provides:\n\nCross-Platform Support: Works across Android, iOS, and Web platforms\nOptimized Performance: Built specifically for Lynx's reactive system\nNanostores Integration: Uses nanostores for efficient state management\nSelective Re-rendering: Watch specific store keys to minimize unnecessary updates\nFull API Compatibility: All Better Auth methods and plugins work seamlessly\nTypeScript Support: Full type safety with TypeScript inference\n\nThe Lynx integration maintains all the features and benefits of Better Auth while providing optimal performance and developer experience within Lynx's cross-platform ecosystem.\n\nEdit on GitHub\n\nPrevious Page\n\nExpo\n\nNext Page\n\nAuthentication"
  },
  {
    "title": "Optimizing for Performance | Better Auth",
    "url": "https://www.better-auth.com/docs/guides/optimizing-for-performance",
    "html": "Optimizing for Performance\nCopy Markdown\nOpen in\n\nIn this guide, weâ€™ll go over some of the ways you can optimize your application for a more performant Better Auth app.\n\nCaching\n\nCaching is a powerful technique that can significantly improve the performance of your Better Auth application by reducing the number of database queries and speeding up response times.\n\nCookie Cache\n\nCalling your database every time useSession or getSession is invoked isnâ€™t ideal, especially if sessions donâ€™t change frequently. Cookie caching handles this by storing session data in a short-lived, signed cookie similar to how JWT access tokens are used with refresh tokens.\n\nTo turn on cookie caching, just set session.cookieCache in your auth config:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  session: {\n    cookieCache: {\n      enabled: true,\n      maxAge: 5 * 60, // Cache duration in seconds\n    },\n  },\n});\n\nRead more about cookie caching.\n\nFramework Caching\n\nHere are examples of how you can do caching in different frameworks and environments:\n\nNext\nRemix\nSolidStart\nReact Query\n\nSince Next v15, we can use the \"use cache\" directive to cache the response of a server function.\n\nexport async function getUsers() {\n    'use cache'\n    const { users } = await auth.api.listUsers();\n    return users\n}\n\nLearn more about NextJS use cache directive here.\n\nSSR Optimizations\n\nIf you're using a framework that supports server-side rendering, it's usually best to pre-fetch the user session on the server and use it as a fallback on the client.\n\nconst session = await auth.api.getSession({\n  headers: await headers(),\n});\n//then pass the session to the client\nDatabase optimizations\n\nOptimizing database performance is essential to get the best out of Better Auth.\n\nRecommended fields to index\nTable\tFields\tPlugin\nusers\temail\t\naccounts\tuserId\t\nsessions\tuserId, token\t\nverifications\tidentifier\t\ninvitations\temail, organizationId\torganization\nmembers\tuserId, organizationId\torganization\norganizations\tslug\torganization\npasskey\tuserId\tpasskey\ntwoFactor\tsecret\ttwoFactor\n\nWe intend to add indexing support in our schema generation tool in the future.\n\nEdit on GitHub\n\nPrevious Page\n\nSAML SSO with Okta\n\nNext Page\n\nOptions"
  },
  {
    "title": "Other Social Providers | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/other-social-providers",
    "html": "Other Social Providers\nCopy Markdown\nOpen in\n\nBetter Auth provides out of the box support for a Generic OAuth Plugin which allows you to use any social provider that implements the OAuth2 protocol or OpenID Connect (OIDC) flows.\n\nTo use a provider that is not supported out of the box, you can use the Generic OAuth Plugin.\n\nInstallation\nAdd the plugin to your auth config\n\nTo use the Generic OAuth plugin, add it to your auth config.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { genericOAuth } from \"better-auth/plugins\"\nexport const auth = betterAuth({\n    // ... other config options\n    plugins: [\n        genericOAuth({ \n            config: [ \n                { \n                    providerId: \"provider-id\", \n                    clientId: \"test-client-id\", \n                    clientSecret: \"test-client-secret\", \n                    discoveryUrl: \"https://auth.example.com/.well-known/openid-configuration\", \n                    // ... other config options\n                }, \n                // Add more providers as needed\n            ] \n        }) \n    ]\n})\nAdd the client plugin\n\nInclude the Generic OAuth client plugin in your authentication client instance.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nimport { genericOAuthClient } from \"better-auth/client/plugins\"\nconst authClient = createAuthClient({\n    plugins: [\n        genericOAuthClient()\n    ]\n})\n\nRead more about installation and usage of the Generic Oauth plugin here.\n\nExample usage\nInstagram Example\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { genericOAuth } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n  // ... other config options\n  plugins: [\n    genericOAuth({\n      config: [\n        {\n          providerId: \"instagram\",\n          clientId: process.env.INSTAGRAM_CLIENT_ID as string,\n          clientSecret: process.env.INSTAGRAM_CLIENT_SECRET as string,\n          authorizationUrl: \"https://api.instagram.com/oauth/authorize\",\n          tokenUrl: \"https://api.instagram.com/oauth/access_token\",\n          scopes: [\"user_profile\", \"user_media\"],\n        },\n      ],\n    }),\n  ],\n});\nsign-in.ts\nconst response = await authClient.signIn.oauth2({\n  providerId: \"instagram\",\n  callbackURL: \"/dashboard\", // the path to redirect to after the user is authenticated\n});\nCoinbase Example\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { genericOAuth } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n  // ... other config options\n  plugins: [\n    genericOAuth({\n      config: [\n        {\n          providerId: \"coinbase\",\n          clientId: process.env.COINBASE_CLIENT_ID as string,\n          clientSecret: process.env.COINBASE_CLIENT_SECRET as string,\n          authorizationUrl: \"https://www.coinbase.com/oauth/authorize\",\n          tokenUrl: \"https://api.coinbase.com/oauth/token\",\n          scopes: [\"wallet:user:read\"], // and more...\n        },\n      ],\n    }),\n  ],\n});\nsign-in.ts\nconst response = await authClient.signIn.oauth2({\n  providerId: \"coinbase\",\n  callbackURL: \"/dashboard\", // the path to redirect to after the user is authenticated\n});\nEdit on GitHub\n\nPrevious Page\n\nOthers\n\nNext Page\n\nMySQL"
  },
  {
    "title": "Email & Password | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/email-password#forget-password",
    "html": "Email & Password\nCopy Markdown\nOpen in\n\nEmail and password authentication is a common method used by many applications. Better Auth provides a built-in email and password authenticator that you can easily integrate into your project.\n\nIf you prefer username-based authentication, check out the username plugin. It extends the email and password authenticator with username support.\n\nEnable Email and Password\n\nTo enable email and password authentication, you need to set the emailAndPassword.enabled option to true in the auth configuration.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  emailAndPassword: { \n    enabled: true, \n  }, \n});\n\nIf it's not enabled, it'll not allow you to sign in or sign up with email and password.\n\nUsage\nSign Up\n\nTo sign a user up, you can use the signUp.email function provided by the client.\n\nClient\nServer\nPOST\n/sign-up/email\nconst { data, error } = await authClient.signUp.email({\n    name: \"John Doe\", // required\n    email: \"john.doe@example.com\", // required\n    password: \"password1234\", // required\n    image: \"https://example.com/image.png\",\n    callbackURL: \"https://example.com/callback\",\n});\nProp\tDescription\tType\nname\t\nThe name of the user.\n\tstring\nemail\t\nThe email address of the user.\n\tstring\npassword\t\nThe password of the user. It should be at least 8 characters long and max 128 by default.\n\tstring\nimage?\t\nAn optional profile image of the user.\n\tstring\ncallbackURL?\t\nAn optional URL to redirect to after the user signs up.\n\tstring\n\nThese are the default properties for the sign up email endpoint, however it's possible that with additional fields or special plugins you can pass more properties to the endpoint.\n\nSign In\n\nTo sign a user in, you can use the signIn.email function provided by the client.\n\nClient\nServer\nPOST\n/sign-in/email\nconst { data, error } = await authClient.signIn.email({\n    email: \"john.doe@example.com\", // required\n    password: \"password1234\", // required\n    rememberMe: true,\n    callbackURL: \"https://example.com/callback\",\n});\nProp\tDescription\tType\nemail\t\nThe email address of the user.\n\tstring\npassword\t\nThe password of the user. It should be at least 8 characters long and max 128 by default.\n\tstring\nrememberMe?\t\nIf false, the user will be signed out when the browser is closed. (optional) (default: true)\n\tboolean\ncallbackURL?\t\nAn optional URL to redirect to after the user signs in. (optional)\n\tstring\n\nThese are the default properties for the sign in email endpoint, however it's possible that with additional fields or special plugins you can pass different properties to the endpoint.\n\nSign Out\n\nTo sign a user out, you can use the signOut function provided by the client.\n\nClient\nServer\nPOST\n/sign-out\nawait authClient.signOut();\n\nyou can pass fetchOptions to redirect onSuccess\n\nauth-client.ts\nawait authClient.signOut({\n  fetchOptions: {\n    onSuccess: () => {\n      router.push(\"/login\"); // redirect to login page\n    },\n  },\n});\nEmail Verification\n\nTo enable email verification, you need to pass a function that sends a verification email with a link. The sendVerificationEmail function takes a data object with the following properties:\n\nuser: The user object.\nurl: The URL to send to the user which contains the token.\ntoken: A verification token used to complete the email verification.\n\nand a request object as the second parameter.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { sendEmail } from \"./email\"; // your email sending function\nexport const auth = betterAuth({\n  emailVerification: {\n    sendVerificationEmail: async ( { user, url, token }, request) => {\n      await sendEmail({\n        to: user.email,\n        subject: \"Verify your email address\",\n        text: `Click the link to verify your email: ${url}`,\n      });\n    },\n  },\n});\n\nOn the client side you can use sendVerificationEmail function to send verification link to user. This will trigger the sendVerificationEmail function you provided in the auth configuration.\n\nOnce the user clicks on the link in the email, if the token is valid, the user will be redirected to the URL provided in the callbackURL parameter. If the token is invalid, the user will be redirected to the URL provided in the callbackURL parameter with an error message in the query string ?error=invalid_token.\n\nRequire Email Verification\n\nIf you enable require email verification, users must verify their email before they can log in. And every time a user tries to sign in, sendVerificationEmail is called.\n\nThis only works if you have sendVerificationEmail implemented and if the user is trying to sign in with email and password.\n\nauth.ts\nexport const auth = betterAuth({\n  emailAndPassword: {\n    requireEmailVerification: true,\n  },\n});\n\nIf a user tries to sign in without verifying their email, you can handle the error and show a message to the user.\n\nauth-client.ts\nawait authClient.signIn.email(\n  {\n    email: \"email@example.com\",\n    password: \"password\",\n  },\n  {\n    onError: (ctx) => {\n      // Handle the error\n      if (ctx.error.status === 403) {\n        alert(\"Please verify your email address\");\n      }\n      //you can also show the original error message\n      alert(ctx.error.message);\n    },\n  }\n);\nTriggering manually Email Verification\n\nYou can trigger the email verification manually by calling the sendVerificationEmail function.\n\nawait authClient.sendVerificationEmail({\n  email: \"user@email.com\",\n  callbackURL: \"/\", // The redirect URL after verification\n});\nRequest Password Reset\n\nTo allow users to reset a password first you need to provide sendResetPassword function to the email and password authenticator. The sendResetPassword function takes a data object with the following properties:\n\nuser: The user object.\nurl: The URL to send to the user which contains the token.\ntoken: A verification token used to complete the password reset.\n\nand a request object as the second parameter.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport { sendEmail } from \"./email\"; // your email sending function\nexport const auth = betterAuth({\n  emailAndPassword: {\n    enabled: true,\n    sendResetPassword: async ({user, url, token}, request) => {\n      await sendEmail({\n        to: user.email,\n        subject: \"Reset your password\",\n        text: `Click the link to reset your password: ${url}`,\n      });\n    },\n    onPasswordReset: async ({ user }, request) => {\n      // your logic here\n      console.log(`Password for user ${user.email} has been reset.`);\n    },\n  },\n});\n\nAdditionally, you can provide an onPasswordReset callback to execute logic after a password has been successfully reset.\n\nOnce you configured your server you can call requestPasswordReset function to send reset password link to user. If the user exists, it will trigger the sendResetPassword function you provided in the auth config.\n\nClient\nServer\nPOST\n/request-password-reset\nconst { data, error } = await authClient.requestPasswordReset({\n    email: \"john.doe@example.com\", // required\n    redirectTo: \"https://example.com/reset-password\",\n});\nProp\tDescription\tType\nemail\t\nThe email address of the user to send a password reset email to\n\tstring\nredirectTo?\t\nThe URL to redirect the user to reset their password. If the token isn't valid or expired, it'll be redirected with a query parameter ?error=INVALID_TOKEN. If the token is valid, it'll be redirected with a query parameter `?token=VALID_TOKEN\n\tstring\n\nWhen a user clicks on the link in the email, they will be redirected to the reset password page. You can add the reset password page to your app. Then you can use resetPassword function to reset the password. It takes an object with the following properties:\n\nnewPassword: The new password of the user.\nauth-client.ts\nconst { data, error } = await authClient.resetPassword({\n  newPassword: \"password1234\",\n  token,\n});\nClient\nServer\nPOST\n/reset-password\nconst token = new URLSearchParams(window.location.search).get(\"token\");\nif (!token) {\n  // Handle the error\n}\nconst { data, error } = await authClient.resetPassword({\n    newPassword: \"password1234\", // required\n    token, // required\n});\nProp\tDescription\tType\nnewPassword\t\nThe new password to set\n\tstring\ntoken\t\nThe token to reset the password\n\tstring\nUpdate password\n\nA user's password isn't stored in the user table. Instead, it's stored in the account table. To change the password of a user, you can use one of the following approaches:\n\nClient\nServer\nPOST\n/change-password\nconst { data, error } = await authClient.changePassword({\n    newPassword: \"newpassword1234\", // required\n    currentPassword: \"oldpassword1234\", // required\n    revokeOtherSessions: true,\n});\nProp\tDescription\tType\nnewPassword\t\nThe new password to set\n\tstring\ncurrentPassword\t\nThe current user password\n\tstring\nrevokeOtherSessions?\t\nWhen set to true, all other active sessions for this user will be invalidated\n\tboolean\nConfiguration\n\nPassword\n\nBetter Auth stores passwords inside the account table with providerId set to credential.\n\nPassword Hashing: Better Auth uses scrypt to hash passwords. The scrypt algorithm is designed to be slow and memory-intensive to make it difficult for attackers to brute force passwords. OWASP recommends using scrypt if argon2id is not available. We decided to use scrypt because it's natively supported by Node.js.\n\nYou can pass custom password hashing algorithm by setting passwordHasher option in the auth configuration.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nimport { scrypt } from \"scrypt\"\nexport const auth = betterAuth({\n    //...rest of the options\n    emailAndPassword: {\n        password: {\n            hash: // your custom password hashing function\n            verify: // your custom password verification function\n        }\n    }\n})\n\nProp\n\nType\n\nenabled?\nboolean\ndisableSignUp?\nboolean\nminPasswordLength?\nnumber\nmaxPasswordLength?\nnumber\nsendResetPassword?\nfunction\nonPasswordReset?\nfunction\nresetPasswordTokenExpiresIn?\nnumber\npassword?\nobject\nEdit on GitHub\n\nPrevious Page\n\nUsers & Accounts\n\nNext Page\n\nSocial Sign-On"
  },
  {
    "title": "SAML SSO with Okta | Better Auth",
    "url": "https://www.better-auth.com/docs/guides/saml-sso-with-okta",
    "html": "SAML SSO with Okta\nCopy Markdown\nOpen in\n\nThis guide walks you through setting up SAML Single Sign-On (SSO) with your Identity Provider (IdP), using Okta as an example. For advanced configuration details and the full API reference, check out the SSO Plugin Documentation.\n\nWhat is SAML?\n\nSAML (Security Assertion Markup Language) is an XML-based standard for exchanging authentication and authorization data between an Identity Provider (IdP) (e.g., Okta, Azure AD, OneLogin) and a Service Provider (SP) (in this case, Better Auth).\n\nIn this setup:\n\nIdP (Okta): Authenticates users and sends assertions about their identity.\nSP (Better Auth): Validates assertions and logs the user in.up.\nStep 1: Create a SAML Application in Okta\n\nLog in to your Okta Admin Console\n\nNavigate to Applications > Applications\n\nClick \"Create App Integration\"\n\nSelect \"SAML 2.0\" as the Sign-in method\n\nConfigure the following settings:\n\nSingle Sign-on URL: Your Better Auth ACS endpoint (e.g., http://localhost:3000/api/auth/sso/saml2/sp/acs/sso). while sso being your providerId\nAudience URI (SP Entity ID): Your Better Auth metadata URL (e.g., http://localhost:3000/api/auth/sso/saml2/sp/metadata)\nName ID format: Email Address or any of your choice.\n\nDownload the IdP metadata XML file and certificate\n\nStep 2: Configure Better Auth\n\nHereâ€™s an example configuration for Okta in a dev environment:\n\nconst ssoConfig = {\n  defaultSSO: [{\n    domain: \"localhost:3000\", // Your domain\n    providerId: \"sso\",\n    samlConfig: {\n      // SP Configuration\n      issuer: \"http://localhost:3000/api/auth/sso/saml2/sp/metadata\",\n      entryPoint: \"https://trial-1076874.okta.com/app/trial-1076874_samltest_1/exktofb0a62hqLAUL697/sso/saml\",\n      callbackUrl: \"/dashboard\", // Redirect after successful authentication\n      \n      // IdP Configuration\n      idpMetadata: {\n        entityID: \"https://trial-1076874.okta.com/app/exktofb0a62hqLAUL697/sso/saml/metadata\",\n        singleSignOnService: [{\n          Binding: \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect\",\n          Location: \"https://trial-1076874.okta.com/app/trial-1076874_samltest_1/exktofb0a62hqLAUL697/sso/saml\"\n        }],\n        cert: `-----BEGIN CERTIFICATE-----\nMIIDqjCCApKgAwIBAgIGAZhVGMeUMA0GCSqGSIb3DQEBCwUAMIGVMQswCQYDVQQGEwJVUzETMBEG\n...\n[Your Okta Certificate]\n...\n-----END CERTIFICATE-----`\n      },\n      \n      // SP Metadata\n      spMetadata: {\n        metadata: `<md:EntityDescriptor xmlns:md=\"urn:oasis:names:tc:SAML:2.0:metadata\" \n          entityID=\"http://localhost:3000/api/sso/saml2/sp/metadata\">\n          ...\n          [Your SP Metadata XML]\n          ...\n        </md:EntityDescriptor>`\n      }\n    }\n  }]\n}\nStep 3: Multiple Default Providers (Optional)\n\nYou can configure multiple SAML providers for different domains:\n\nconst ssoConfig = {\n  defaultSSO: [\n    {\n      domain: \"company.com\",\n      providerId: \"company-okta\",\n      samlConfig: {\n        // Okta SAML configuration for company.com\n      }\n    },\n    {\n      domain: \"partner.com\", \n      providerId: \"partner-adfs\",\n      samlConfig: {\n        // ADFS SAML configuration for partner.com\n      }\n    },\n    {\n      domain: \"contractor.org\",\n      providerId: \"contractor-azure\",\n      samlConfig: {\n        // Azure AD SAML configuration for contractor.org\n      }\n    }\n  ]\n}\n\nExplicit: Pass providerId directly when signing in. Domain fallback: Matches based on the userâ€™s email domain. e.g. user@company.com â†’ matches company-okta provider.\n\nStep 4: Initiating Sign-In\n\nYou can start an SSO flow in three ways:\n\n1. Explicitly by providerId (recommended):\n\n// Explicitly specify which provider to use\nawait authClient.signIn.sso({\n  providerId: \"company-okta\",\n  callbackURL: \"/dashboard\"\n});\n\n2. By email domain matching:\n\n// Automatically matches provider based on email domain\nawait authClient.signIn.sso({\n  email: \"user@company.com\",\n  callbackURL: \"/dashboard\"\n});\n\n3. By specifying domain:\n\n// Explicitly specify domain for matching\nawait authClient.signIn.sso({\n  domain: \"partner.com\",\n  callbackURL: \"/dashboard\"\n});\n\nImportant Notes:\n\nDummyIDP should ONLY be used for development and testing\nNever use these certificates in production\nThe example uses localhost:3000 - adjust URLs for your environment\nFor production, always use proper IdP providers like Okta, Azure AD, or OneLogin\nStep 5: Dynamically Registering SAML Providers\n\nFor dynamic registration, you should register SAML providers using the API. See the SSO Plugin Documentation for detailed registration instructions.\n\nExample registration:\n\nawait authClient.sso.register({\n  providerId: \"okta-prod\",\n  issuer: \"https://your-domain.com\",\n  domain: \"your-domain.com\",\n  samlConfig: {\n    // Your production SAML configuration\n  }\n});\nAdditional Resources\nSSO Plugin Documentation\nOkta SAML Documentation\nSAML 2.0 Specification\nEdit on GitHub\n\nPrevious Page\n\nBrowser Extension Guide\n\nNext Page\n\nOptimize for Performance"
  },
  {
    "title": "Migrating from NextAuth.js to Better Auth | Better Auth",
    "url": "https://www.better-auth.com/docs/guides/next-auth-migration-guide",
    "html": "Migrating from NextAuth.js to Better Auth\nCopy Markdown\nOpen in\n\nIn this guide, weâ€™ll walk through the steps to migrate a project from NextAuth.js to Better Auth, ensuring no loss of data or functionality. While this guide focuses on Next.js, it can be adapted for other frameworks as well.\n\nBefore You Begin\n\nBefore starting the migration process, set up Better Auth in your project. Follow the installation guide to get started.\n\nMapping Existing Columns\n\nInstead of altering your existing database column names, you can map them to match Better Auth's expected structure. This allows you to retain your current database schema.\n\nUser Schema\n\nMap the following fields in the user schema:\n\n(next-auth v4) emailVerified: datetime â†’ boolean\nSession Schema\n\nMap the following fields in the session schema:\n\nexpires â†’ expiresAt\nsessionToken â†’ token\n(next-auth v4) add createdAt with datetime type\n(next-auth v4) add updatedAt with datetime type\nauth.ts\nexport const auth = betterAuth({\n    // Other configs\n    session: {\n        fields: {\n            expiresAt: \"expires\", // Map your existing `expires` field to Better Auth's `expiresAt`\n            token: \"sessionToken\" // Map your existing `sessionToken` field to Better Auth's `token`\n        }\n    },\n});\n\nMake sure to have createdAt and updatedAt fields on your session schema.\n\nAccount Schema\n\nMap these fields in the account schema:\n\n(next-auth v4) provider â†’ providerId\nproviderAccountId â†’ accountId\nrefresh_token â†’ refreshToken\naccess_token â†’ accessToken\n(next-auth v3) access_token_expires â†’ accessTokenExpiresAt and int â†’ datetime\n(next-auth v4) expires_at â†’ accessTokenExpiresAt and int â†’ datetime\nid_token â†’ idToken\n(next-auth v4) add createdAt with datetime type\n(next-auth v4) add updatedAt with datetime type\n\nRemove the session_state, type, and token_type fields, as they are not required by Better Auth.\n\nauth.ts\nexport const auth = betterAuth({\n    // Other configs\n    account: {\n        fields: {\n            accountId: \"providerAccountId\",\n            refreshToken: \"refresh_token\",\n            accessToken: \"access_token\",\n            accessTokenExpiresAt: \"access_token_expires\",\n            idToken: \"id_token\",\n        }\n    },\n});\n\nNote: If you use ORM adapters, you can map these fields in your schema file.\n\nExample with Prisma:\n\nschema.prisma\nmodel Session {\n    id          String   @id @default(cuid())\n    expiresAt   DateTime @map(\"expires\") // Map your existing `expires` field to Better Auth's `expiresAt`\n    token       String   @map(\"sessionToken\") // Map your existing `sessionToken` field to Better Auth's `token`\n    userId      String\n    user        User     @relation(fields: [userId], references: [id])\n}\n\nMake sure to have createdAt and updatedAt fields on your account schema.\n\nUpdate the Route Handler\n\nIn the app/api/auth folder, rename the [...nextauth] file to [...all] to avoid confusion. Then, update the route.ts file as follows:\n\napp/api/auth/[...all]/route.ts\nimport { toNextJsHandler } from \"better-auth/next-js\";\nimport { auth } from \"~/server/auth\";\nexport const { POST, GET } = toNextJsHandler(auth);\nUpdate the Client\n\nCreate a file named auth-client.ts in the lib folder. Add the following code:\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/react\";\nexport const authClient = createAuthClient({\n    baseURL: process.env.BASE_URL! // Optional if the API base URL matches the frontend\n});\nexport const { signIn, signOut, useSession } = authClient;\nSocial Login Functions\n\nUpdate your social login functions to use Better Auth. For example, for Discord:\n\nimport { signIn } from \"~/lib/auth-client\";\nexport const signInDiscord = async () => {\n    const data = await signIn.social({\n        provider: \"discord\"\n    });\n    return data;\n};\nUpdate useSession Calls\n\nReplace useSession calls with Better Authâ€™s version. Example:\n\nProfile.tsx\nimport { useSession } from \"~/lib/auth-client\";\nexport const Profile = () => {\n    const { data } = useSession();\n    return (\n        <div>\n            <pre>\n                {JSON.stringify(data, null, 2)}\n            </pre>\n        </div>\n    );\n};\nServer-Side Session Handling\n\nUse the auth instance to get session data on the server:\n\nactions.ts\n\"use server\";\nimport { auth } from \"~/server/auth\";\nimport { headers } from \"next/headers\";\nexport const protectedAction = async () => {\n    const session = await auth.api.getSession({\n        headers: await headers(),\n    });\n};\nMiddleware\n\nTo protect routes with middleware, refer to the Next.js middleware guide.\n\nWrapping Up\n\nCongratulations! Youâ€™ve successfully migrated from NextAuth.js to Better Auth. For a complete implementation with multiple authentication methods, check out the demo repository.\n\nBetter Auth offers greater flexibility and more featuresâ€”be sure to explore the documentation to unlock its full potential.\n\nEdit on GitHub\n\nPrevious Page\n\nGuides\n\nNext Page\n\nSupabase Migration Guide"
  },
  {
    "title": "Migrating from Supabase Auth to Better Auth | Better Auth",
    "url": "https://www.better-auth.com/docs/guides/supabase-migration-guide",
    "html": "Migrating from Supabase Auth to Better Auth\nCopy Markdown\nOpen in\n\nIn this guide, we'll walk through the steps to migrate a project from Supabase Auth to Better Auth.\n\nThis migration will invalidate all active sessions. While this guide doesn't currently cover migrating two-factor (2FA) or Row Level Security (RLS) configurations, both should be possible with additional steps.\n\nBefore You Begin\n\nBefore starting the migration process, set up Better Auth in your project. Follow the installation guide to get started.\n\nConnect to your database\n\nYou'll need to connect to your database to migrate the users and accounts. Copy your DATABASE_URL from your Supabase project and use it to connect to your database. And for this example, we'll need to install pg to connect to the database.\n\nnpm\npnpm\nyarn\nbun\nnpm install pg\n\nAnd then you can use the following code to connect to your database.\n\nauth.ts\nimport { Pool } from \"pg\";\nexport const auth = betterAuth({\n    database: new Pool({ \n        connectionString: process.env.DATABASE_URL \n    }),\n})\nEnable Email and Password (Optional)\n\nEnable the email and password in your auth config.\n\nauth.ts\nimport { admin, anonymous } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n    database: new Pool({ \n        connectionString: process.env.DATABASE_URL \n    }),\n\temailVerification: {\n\t\tsendEmailVerification: async(user)=>{\n\t\t\t// send email verification email\n\t\t\t// implement your own logic here\n\t\t}\n\t},\n    emailAndPassword: { \n        enabled: true, \n    } \n})\nSetup Social Providers (Optional)\n\nAdd social providers you have enabled in your Supabase project in your auth config.\n\nauth.ts\nimport { admin, anonymous } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n    database: new Pool({ \n        connectionString: process.env.DATABASE_URL \n    }),\n    emailAndPassword: { \n        enabled: true,\n    },\n    socialProviders: { \n        github: { \n            clientId: process.env.GITHUB_CLIENT_ID, \n            clientSecret: process.env.GITHUB_CLIENT_SECRET, \n        } \n    } \n})\nAdd admin and anonymous plugins (Optional)\n\nAdd the admin and anonymous plugins to your auth config.\n\nauth.ts\nimport { admin, anonymous } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n    database: new Pool({ \n        connectionString: process.env.DATABASE_URL \n    }),\n    emailAndPassword: { \n        enabled: true,\n    },\n    socialProviders: {\n        github: {\n            clientId: process.env.GITHUB_CLIENT_ID!,\n            clientSecret: process.env.GITHUB_CLIENT_SECRET!,\n        }\n    },\n    plugins: [admin(), anonymous()], \n})\nRun the migration\n\nRun the migration to create the necessary tables in your database.\n\nTerminal\nnpx @better-auth/cli migrate\n\nThis will create the following tables in your database:\n\nuser\naccount\nsession\nverification\n\nThis tables will be created on the public schema.\n\nCopy the migration script\n\nNow that we have the necessary tables in our database, we can run the migration script to migrate the users and accounts from Supabase to Better Auth.\n\nStart by creating a .ts file in your project.\n\nTerminal\ntouch migration.ts\n\nAnd then copy and paste the following code into the file.\n\nmigration.ts\nimport { Pool } from \"pg\";\nimport { auth } from \"./auth\";\nimport { User as SupabaseUser } from \"@supabase/supabase-js\";\ntype User = SupabaseUser & {\n\tis_super_admin: boolean;\n\traw_user_meta_data: {\n\t\tavatar_url: string;\n\t};\n\tencrypted_password: string;\n\temail_confirmed_at: string;\n\tcreated_at: string;\n\tupdated_at: string;\n\tis_anonymous: boolean;\n\tidentities: {\n\t\tprovider: string;\n\t\tidentity_data: {\n\t\t\tsub: string;\n\t\t\temail: string;\n\t\t};\n\t\tcreated_at: string;\n\t\tupdated_at: string;\n\t};\n};\nconst migrateFromSupabase = async () => {\n\tconst ctx = await auth.$context;\n\tconst db = ctx.options.database as Pool;\n\tconst users = await db\n\t\t.query(`\n\t\t\tSELECT \n\t\t\t\tu.*,\n\t\t\t\tCOALESCE(\n\t\t\t\t\tjson_agg(\n\t\t\t\t\t\ti.* ORDER BY i.id\n\t\t\t\t\t) FILTER (WHERE i.id IS NOT NULL),\n\t\t\t\t\t'[]'::json\n\t\t\t\t) as identities\n\t\t\tFROM auth.users u\n\t\t\tLEFT JOIN auth.identities i ON u.id = i.user_id\n\t\t\tGROUP BY u.id\n\t\t`)\n\t\t.then((res) => res.rows as User[]);\n\tfor (const user of users) {\n\t\tif (!user.email) {\n\t\t\tcontinue;\n\t\t}\n\t\tawait ctx.adapter\n\t\t\t.create({\n\t\t\t\tmodel: \"user\",\n\t\t\t\tdata: {\n\t\t\t\t\tid: user.id,\n\t\t\t\t\temail: user.email,\n\t\t\t\t\tname: user.email,\n\t\t\t\t\trole: user.is_super_admin ? \"admin\" : user.role,\n\t\t\t\t\temailVerified: !!user.email_confirmed_at,\n\t\t\t\t\timage: user.raw_user_meta_data.avatar_url,\n\t\t\t\t\tcreatedAt: new Date(user.created_at),\n\t\t\t\t\tupdatedAt: new Date(user.updated_at),\n\t\t\t\t\tisAnonymous: user.is_anonymous,\n\t\t\t\t},\n\t\t\t})\n\t\t\t.catch(() => {});\n\t\tfor (const identity of user.identities) {\n\t\t\tconst existingAccounts = await ctx.internalAdapter.findAccounts(user.id);\n\t\t\tif (identity.provider === \"email\") {\n\t\t\t\tconst hasCredential = existingAccounts.find(\n\t\t\t\t\t(account) => account.providerId === \"credential\",\n\t\t\t\t);\n\t\t\t\tif (!hasCredential) {\n\t\t\t\t\tawait ctx.adapter\n\t\t\t\t\t\t.create({\n\t\t\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\tuserId: user.id,\n\t\t\t\t\t\t\t\tproviderId: \"credential\",\n\t\t\t\t\t\t\t\taccountId: user.id,\n\t\t\t\t\t\t\t\tpassword: user.encrypted_password,\n\t\t\t\t\t\t\t\tcreatedAt: new Date(user.created_at),\n\t\t\t\t\t\t\t\tupdatedAt: new Date(user.updated_at),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(() => {});\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst supportedProviders = Object.keys(ctx.options.socialProviders || {})\n\t\t\tif (supportedProviders.includes(identity.provider)) {\n\t\t\t\tconst hasAccount = existingAccounts.find(\n\t\t\t\t\t(account) => account.providerId === identity.provider,\n\t\t\t\t);\n\t\t\t\tif (!hasAccount) {\n\t\t\t\t\tawait ctx.adapter.create({\n\t\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tuserId: user.id,\n\t\t\t\t\t\t\tproviderId: identity.provider,\n\t\t\t\t\t\t\taccountId: identity.identity_data?.sub,\n\t\t\t\t\t\t\tcreatedAt: new Date(identity.created_at ?? user.created_at),\n\t\t\t\t\t\t\tupdatedAt: new Date(identity.updated_at ?? user.updated_at),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nmigrateFromSupabase();\nCustomize the migration script (Optional)\nname: the migration script will use the user's email as the name. You might want to customize it if you have the user display name in your database.\nsocialProviderList: the migration script will use the social providers you have enabled in your auth config. You might want to customize it if you have additional social providers that you haven't enabled in your auth config.\nrole: remove role if you're not using the admin plugin\nisAnonymous: remove isAnonymous if you're not using the anonymous plugin.\nupdate other tables that reference the users table to use the id field.\nRun the migration script\n\nRun the migration script to migrate the users and accounts from Supabase to Better Auth.\n\nTerminal\nbun migration.ts # or use node, ts-node, etc.\nChange password hashing algorithm\n\nBy default, Better Auth uses the scrypt algorithm to hash passwords. Since Supabase uses bcrypt, you'll need to configure Better Auth to use bcrypt for password verification.\n\nFirst, install bcrypt:\n\nnpm install bcrypt\nnpm install -D @types/bcrypt\n\nThen update your auth configuration:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport bcrypt from \"bcrypt\";\nexport const auth = betterAuth({\n   emailAndPassword: {\n       password: {\n           hash: async (password) => {\n               return await bcrypt.hash(password, 10);\n           },\n           verify: async ({ hash, password }) => {\n               return await bcrypt.compare(password, hash);\n           }\n       }\n   }\n})\nUpdate your code\n\nUpdate your codebase from Supabase auth calls to Better Auth API.\n\nHere's a list of the Supabase auth API calls and their Better Auth counterparts.\n\nsupabase.auth.signUp -> authClient.signUp.email\nsupabase.auth.signInWithPassword -> authClient.signIn.email\nsupabase.auth.signInWithOAuth -> authClient.signIn.social\nsupabase.auth.signInAnonymously -> authClient.signIn.anonymous\nsupabase.auth.signOut -> authClient.signOut\nsupabase.auth.getSession -> authClient.getSession - you can also use authClient.useSession for reactive state\n\nLearn more:\n\nBasic Usage: Learn how to use the auth client to sign up, sign in, and sign out.\nEmail and Password: Learn how to add email and password authentication to your project.\nAnonymous: Learn how to add anonymous authentication to your project.\nAdmin: Learn how to add admin authentication to your project.\nEmail OTP: Learn how to add email OTP authentication to your project.\nHooks: Learn how to use the hooks to listen for events.\nNext.js: Learn how to use the auth client in a Next.js project.\nMiddleware\n\nTo protect routes with middleware, refer to the Next.js middleware guide or your framework's documentation.\n\nWrapping Up\n\nCongratulations! You've successfully migrated from Supabase Auth to Better Auth.\n\nBetter Auth offers greater flexibility and more featuresâ€”be sure to explore the documentation to unlock its full potential.\n\nEdit on GitHub\n\nPrevious Page\n\nNext Auth Migration Guide\n\nNext Page\n\nClerk Migration Guide"
  },
  {
    "title": "Migrating from Clerk to Better Auth | Better Auth",
    "url": "https://www.better-auth.com/docs/guides/clerk-migration-guide",
    "html": "Migrating from Clerk to Better Auth\nCopy Markdown\nOpen in\n\nIn this guide, we'll walk through the steps to migrate a project from Clerk to Better Auth â€” including email/password with proper hashing, social/external accounts, phone number, two-factor data, and more.\n\nThis migration will invalidate all active sessions. This guide doesn't currently show you how to migrate Organization but it should be possible with additional steps and the Organization Plugin.\n\nBefore You Begin\n\nBefore starting the migration process, set up Better Auth in your project. Follow the installation guide to get started. And go to\n\nConnect to your database\n\nYou'll need to connect to your database to migrate the users and accounts. You can use any database you want, but for this example, we'll use PostgreSQL.\n\nnpm\npnpm\nyarn\nbun\nnpm install pg\n\nAnd then you can use the following code to connect to your database.\n\nauth.ts\nimport { Pool } from \"pg\";\nexport const auth = betterAuth({\n    database: new Pool({ \n        connectionString: process.env.DATABASE_URL \n    }),\n})\nEnable Email and Password (Optional)\n\nEnable the email and password in your auth config and implement your own logic for sending verification emails, reset password emails, etc.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    database: new Pool({ \n        connectionString: process.env.DATABASE_URL \n    }),\n    emailAndPassword: { \n        enabled: true, \n    }, \n    emailVerification: {\n      sendVerificationEmail: async({ user, url })=>{\n        // implement your logic here to send email verification\n      }\n\t},\n})\n\nSee Email and Password for more configuration options.\n\nSetup Social Providers (Optional)\n\nAdd social providers you have enabled in your Clerk project in your auth config.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    database: new Pool({ \n        connectionString: process.env.DATABASE_URL \n    }),\n    emailAndPassword: { \n        enabled: true,\n    },\n    socialProviders: { \n        github: { \n            clientId: process.env.GITHUB_CLIENT_ID, \n            clientSecret: process.env.GITHUB_CLIENT_SECRET, \n        } \n    } \n})\nAdd Plugins (Optional)\n\nYou can add the following plugins to your auth config based on your needs.\n\nAdmin Plugin will allow you to manage users, user impersonations and app level roles and permissions.\n\nTwo Factor Plugin will allow you to add two-factor authentication to your application.\n\nPhone Number Plugin will allow you to add phone number authentication to your application.\n\nUsername Plugin will allow you to add username authentication to your application.\n\nauth.ts\nimport { Pool } from \"pg\";\nimport { betterAuth } from \"better-auth\";\nimport { admin, twoFactor, phoneNumber, username } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n    database: new Pool({ \n        connectionString: process.env.DATABASE_URL \n    }),\n    emailAndPassword: { \n        enabled: true,\n    },\n    socialProviders: {\n        github: {\n            clientId: process.env.GITHUB_CLIENT_ID!,\n            clientSecret: process.env.GITHUB_CLIENT_SECRET!,\n        }\n    },\n    plugins: [admin(), twoFactor(), phoneNumber(), username()], \n})\nGenerate Schema\n\nIf you're using a custom database adapter, generate the schema:\n\nnpx @better-auth/cli generate\n\nor if you're using the default adapter, you can use the following command:\n\nnpx @better-auth/cli migrate\nExport Clerk Users\n\nGo to the Clerk dashboard and export the users. Check how to do it here. It will download a CSV file with the users data. You need to save it as exported_users.csv and put it in the root of your project.\n\nCreate the migration script\n\nCreate a new file called migrate-clerk.ts in the scripts folder and add the following code:\n\nscripts/migrate-clerk.ts\nimport { generateRandomString, symmetricEncrypt } from \"better-auth/crypto\";\nimport { auth } from \"@/lib/auth\"; // import your auth instance\nfunction getCSVData(csv: string) {\n  const lines = csv.split('\\n').filter(line => line.trim());\n  const headers = lines[0]?.split(',').map(header => header.trim()) || [];\n  const jsonData = lines.slice(1).map(line => {\n      const values = line.split(',').map(value => value.trim());\n      return headers.reduce((obj, header, index) => {\n          obj[header] = values[index] || '';\n          return obj;\n      }, {} as Record<string, string>);\n  });\n  return jsonData as Array<{\n      id: string;\n      first_name: string;\n      last_name: string;\n      username: string;\n      primary_email_address: string;\n      primary_phone_number: string;\n      verified_email_addresses: string;\n      unverified_email_addresses: string;\n      verified_phone_numbers: string;\n      unverified_phone_numbers: string;\n      totp_secret: string;\n      password_digest: string;\n      password_hasher: string;\n  }>;\n}\nconst exportedUserCSV = await Bun.file(\"exported_users.csv\").text(); // this is the file you downloaded from Clerk\nasync function getClerkUsers(totalUsers: number) {\n  const clerkUsers: {\n      id: string;\n      first_name: string;\n      last_name: string;\n      username: string;\n      image_url: string;\n      password_enabled: boolean;\n      two_factor_enabled: boolean;\n      totp_enabled: boolean;\n      backup_code_enabled: boolean;\n      banned: boolean;\n      locked: boolean;\n      lockout_expires_in_seconds: number;\n      created_at: number;\n      updated_at: number;\n      external_accounts: {\n          id: string;\n          provider: string;\n          identification_id: string;\n          provider_user_id: string;\n          approved_scopes: string;\n          email_address: string;\n          first_name: string;\n          last_name: string;\n          image_url: string;\n          created_at: number;\n          updated_at: number;\n      }[]\n  }[] = [];\n  for (let i = 0; i < totalUsers; i += 500) {\n      const response = await fetch(`https://api.clerk.com/v1/users?offset=${i}&limit=${500}`, {\n          headers: {\n              'Authorization': `Bearer ${process.env.CLERK_SECRET_KEY}`\n          }\n      });\n      if (!response.ok) {\n          throw new Error(`Failed to fetch users: ${response.statusText}`);\n      }\n      const clerkUsersData = await response.json();\n      // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n      clerkUsers.push(...clerkUsersData as any);\n  }\n  return clerkUsers;\n}\nexport async function generateBackupCodes(\n  secret: string,\n) {\n  const key = secret;\n  const backupCodes = Array.from({ length: 10 })\n      .fill(null)\n      .map(() => generateRandomString(10, \"a-z\", \"0-9\", \"A-Z\"))\n      .map((code) => `${code.slice(0, 5)}-${code.slice(5)}`);\n  const encCodes = await symmetricEncrypt({\n      data: JSON.stringify(backupCodes),\n      key: key,\n  });\n  return encCodes\n}\n// Helper function to safely convert timestamp to Date\nfunction safeDateConversion(timestamp?: number): Date {\n  if (!timestamp) return new Date();\n  // Convert seconds to milliseconds\n  const date = new Date(timestamp * 1000);\n  // Check if the date is valid\n  if (isNaN(date.getTime())) {\n      console.warn(`Invalid timestamp: ${timestamp}, falling back to current date`);\n      return new Date();\n  }\n  // Check for unreasonable dates (before 2000 or after 2100)\n  const year = date.getFullYear();\n  if (year < 2000 || year > 2100) {\n      console.warn(`Suspicious date year: ${year}, falling back to current date`);\n      return new Date();\n  }\n  return date;\n}\nasync function migrateFromClerk() {\n  const jsonData = getCSVData(exportedUserCSV);\n  const clerkUsers = await getClerkUsers(jsonData.length);\n  const ctx = await auth.$context\n  const isAdminEnabled = ctx.options?.plugins?.find(plugin => plugin.id === \"admin\");\n  const isTwoFactorEnabled = ctx.options?.plugins?.find(plugin => plugin.id === \"two-factor\");\n  const isUsernameEnabled = ctx.options?.plugins?.find(plugin => plugin.id === \"username\");\n  const isPhoneNumberEnabled = ctx.options?.plugins?.find(plugin => plugin.id === \"phone-number\");\n  for (const user of jsonData) {\n      const { id, first_name, last_name, username, primary_email_address, primary_phone_number, verified_email_addresses, unverified_email_addresses, verified_phone_numbers, unverified_phone_numbers, totp_secret, password_digest, password_hasher } = user;\n      const clerkUser = clerkUsers.find(clerkUser => clerkUser?.id === id);\n      // create user\n      const createdUser = await ctx.adapter.create<{\n          id: string;\n      }>({\n          model: \"user\",\n          data: {\n              id,\n              email: primary_email_address,\n              emailVerified: verified_email_addresses.length > 0,\n              name: `${first_name} ${last_name}`,\n              image: clerkUser?.image_url,\n              createdAt: safeDateConversion(clerkUser?.created_at),\n              updatedAt: safeDateConversion(clerkUser?.updated_at),\n              // # Two Factor (if you enabled two factor plugin)\n              ...(isTwoFactorEnabled ? {\n                  twoFactorEnabled: clerkUser?.two_factor_enabled\n              } : {}),\n              // # Admin (if you enabled admin plugin)\n              ...(isAdminEnabled ? {\n                  banned: clerkUser?.banned,\n                  banExpiresAt: clerkUser?.lockout_expires_in_seconds,\n                  role: \"user\"\n              } : {}),\n              // # Username (if you enabled username plugin)\n              ...(isUsernameEnabled ? {\n                  username: username,\n              } : {}),\n              // # Phone Number (if you enabled phone number plugin)  \n              ...(isPhoneNumberEnabled ? {\n                  phoneNumber: primary_phone_number,\n                  phoneNumberVerified: verified_phone_numbers.length > 0,\n              } : {}),\n          },\n          forceAllowId: true\n      }).catch(async e => {\n          return await ctx.adapter.findOne<{\n              id: string;\n          }>({\n              model: \"user\",\n              where: [{\n                  field: \"id\",\n                  value: id\n              }]\n          })\n      })\n      // create external account\n      const externalAccounts = clerkUser?.external_accounts;\n      if (externalAccounts) {\n          for (const externalAccount of externalAccounts) {\n              const { id, provider, identification_id, provider_user_id, approved_scopes, email_address, first_name, last_name, image_url, created_at, updated_at } = externalAccount;\n              if (externalAccount.provider === \"credential\") {\n                  await ctx.adapter.create({\n                      model: \"account\",\n                      data: {\n                          id,\n                          providerId: provider,\n                          accountId: externalAccount.provider_user_id,\n                          scope: approved_scopes,\n                          userId: createdUser?.id,\n                          createdAt: safeDateConversion(created_at),\n                          updatedAt: safeDateConversion(updated_at),\n                          password: password_digest,\n                      }\n                  })\n              } else {\n                  await ctx.adapter.create({\n                      model: \"account\",\n                      data: {\n                          id,\n                          providerId: provider.replace(\"oauth_\", \"\"),\n                          accountId: externalAccount.provider_user_id,\n                          scope: approved_scopes,\n                          userId: createdUser?.id,\n                          createdAt: safeDateConversion(created_at),\n                          updatedAt: safeDateConversion(updated_at),\n                      },\n                      forceAllowId: true\n                  })\n              }\n          }\n      }\n      //two factor\n      if (isTwoFactorEnabled) {\n          await ctx.adapter.create({\n              model: \"twoFactor\",\n              data: {\n                  userId: createdUser?.id,\n                  secret: totp_secret,\n                  backupCodes: await generateBackupCodes(totp_secret)\n              }\n          })\n      }\n  }\n}\nmigrateFromClerk()\n  .then(() => {\n      console.log('Migration completed');\n      process.exit(0);\n  })\n  .catch((error) => {\n      console.error('Migration failed:', error);\n      process.exit(1);\n  });\n\nMake sure to replace the process.env.CLERK_SECRET_KEY with your own Clerk secret key. Feel free to customize the script to your needs.\n\nRun the migration\n\nRun the migration:\n\nbun run script/migrate-clerk.ts # you can use any thing you like to run the script\n\nMake sure to:\n\nTest the migration in a development environment first\nMonitor the migration process for any errors\nVerify the migrated data in Better Auth before proceeding\nKeep Clerk installed and configured until the migration is complete\nVerify the migration\n\nAfter running the migration, verify that all users have been properly migrated by checking the database.\n\nUpdate your components\n\nNow that the data is migrated, you can start updating your components to use Better Auth. Here's an example for the sign-in component:\n\ncomponents/auth/sign-in.tsx\nimport { authClient } from \"better-auth/client\";\nexport const SignIn = () => {\n  const handleSignIn = async () => {\n    const { data, error } = await authClient.signIn.email({\n      email: \"user@example.com\",\n      password: \"password\",\n    });\n    \n    if (error) {\n      console.error(error);\n      return;\n    }\n    // Handle successful sign in\n  };\n  return (\n    <form onSubmit={handleSignIn}>\n      <button type=\"submit\">Sign in</button>\n    </form>\n  );\n};\nUpdate the middleware\n\nReplace your Clerk middleware with Better Auth's middleware:\n\nmiddleware.ts\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { getSessionCookie } from \"better-auth/cookies\";\nexport async function middleware(request: NextRequest) {\n  const sessionCookie = getSessionCookie(request);\n  const { pathname } = request.nextUrl;\n  if (sessionCookie && [\"/login\", \"/signup\"].includes(pathname)) {\n    return NextResponse.redirect(new URL(\"/dashboard\", request.url));\n  }\n  if (!sessionCookie && pathname.startsWith(\"/dashboard\")) {\n    return NextResponse.redirect(new URL(\"/login\", request.url));\n  }\n  return NextResponse.next();\n}\nexport const config = {\n  matcher: [\"/dashboard\", \"/login\", \"/signup\"],\n};\nRemove Clerk Dependencies\n\nOnce you've verified that everything is working correctly with Better Auth, you can remove Clerk:\n\nRemove Clerk\npnpm remove @clerk/nextjs @clerk/themes @clerk/types\nAdditional Resources\n\nGoodbye Clerk, Hello Better Auth â€“ Full Migration Guide!\n\nWrapping Up\n\nCongratulations! You've successfully migrated from Clerk to Better Auth.\n\nBetter Auth offers greater flexibility and more featuresâ€”be sure to explore the documentation to unlock its full potential.\n\nEdit on GitHub\n\nPrevious Page\n\nSupabase Migration Guide\n\nNext Page\n\nAuth0 Migration Guide"
  },
  {
    "title": "Migrating from Auth0 to Better Auth | Better Auth",
    "url": "https://www.better-auth.com/docs/guides/auth0-migration-guide",
    "html": "Migrating from Auth0 to Better Auth\nCopy Markdown\nOpen in\n\nIn this guide, we'll walk through the steps to migrate a project from Auth0 to Better Auth â€” including email/password with proper hashing, social/external accounts, two-factor authentication, and more.\n\nThis migration will invalidate all active sessions. This guide doesn't currently show you how to migrate Organizations but it should be possible with additional steps and the Organization Plugin.\n\nBefore You Begin\n\nBefore starting the migration process, set up Better Auth in your project. Follow the installation guide to get started.\n\nConnect to your database\n\nYou'll need to connect to your database to migrate the users and accounts. You can use any database you want, but for this example, we'll use PostgreSQL.\n\nnpm\npnpm\nyarn\nbun\nnpm install pg\n\nAnd then you can use the following code to connect to your database.\n\nauth.ts\nimport { Pool } from \"pg\";\nexport const auth = betterAuth({\n    database: new Pool({ \n        connectionString: process.env.DATABASE_URL \n    }),\n})\nEnable Email and Password (Optional)\n\nEnable the email and password in your auth config and implement your own logic for sending verification emails, reset password emails, etc.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    database: new Pool({ \n        connectionString: process.env.DATABASE_URL \n    }),\n    emailAndPassword: { \n        enabled: true, \n    }, \n    emailVerification: {\n      sendVerificationEmail: async({ user, url })=>{\n        // implement your logic here to send email verification\n      }\n    },\n})\n\nSee Email and Password for more configuration options.\n\nSetup Social Providers (Optional)\n\nAdd social providers you have enabled in your Auth0 project in your auth config.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n    database: new Pool({ \n        connectionString: process.env.DATABASE_URL \n    }),\n    emailAndPassword: { \n        enabled: true,\n    },\n    socialProviders: { \n        google: { \n            clientId: process.env.GOOGLE_CLIENT_ID, \n            clientSecret: process.env.GOOGLE_CLIENT_SECRET, \n        }, \n        github: { \n            clientId: process.env.GITHUB_CLIENT_ID, \n            clientSecret: process.env.GITHUB_CLIENT_SECRET, \n        } \n    } \n})\nAdd Plugins (Optional)\n\nYou can add the following plugins to your auth config based on your needs.\n\nAdmin Plugin will allow you to manage users, user impersonations and app level roles and permissions.\n\nTwo Factor Plugin will allow you to add two-factor authentication to your application.\n\nUsername Plugin will allow you to add username authentication to your application.\n\nauth.ts\nimport { Pool } from \"pg\";\nimport { betterAuth } from \"better-auth\";\nimport { admin, twoFactor, username } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n    database: new Pool({ \n        connectionString: process.env.DATABASE_URL \n    }),\n    emailAndPassword: { \n        enabled: true,\n        password: {\n            verify: (data) => {\n                // this for an edgecase that you might run in to on verifying the password\n            }\n        }\n    },\n    socialProviders: {\n        google: {\n            clientId: process.env.GOOGLE_CLIENT_ID!,\n            clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n        },\n        github: {\n            clientId: process.env.GITHUB_CLIENT_ID!,\n            clientSecret: process.env.GITHUB_CLIENT_SECRET!,\n        }\n    },\n    plugins: [admin(), twoFactor(), username()], \n})\nGenerate Schema\n\nIf you're using a custom database adapter, generate the schema:\n\nnpx @better-auth/cli generate\n\nor if you're using the default adapter, you can use the following command:\n\nnpx @better-auth/cli migrate\nInstall Dependencies\n\nInstall the required dependencies for the migration:\n\nnpm install auth0\nCreate the migration script\n\nCreate a new file called migrate-auth0.ts in the scripts folder and add the following code:\n\nInstead of using the Management API, you can use Auth0's bulk user export functionality and pass the exported JSON data directly to the auth0Users array. This is especially useful if you need to migrate password hashes and complete user data, which are not available through the Management API.\n\nImportant Notes:\n\nPassword hashes export is only available for Auth0 Enterprise users\nFree plan users cannot export password hashes and will need to request a support ticket\nFor detailed information about bulk user exports, see the Auth0 Bulk User Export Documentation\nFor password hash export details, refer to Exporting Password Hashes\n\nExample:\n\n// Replace this with your exported users JSON data\nconst auth0Users = [\n  {\n    \"email\": \"helloworld@gmail.com\",\n    \"email_verified\": false,\n    \"name\": \"Hello world\",\n    // Note: password_hash is only available for Enterprise users\n    \"password_hash\": \"$2b$10$w4kfaZVjrcQ6ZOMiG.M8JeNvnVQkPKZV03pbDUHbxy9Ug0h/McDXi\",\n    // ... other user data\n  }\n];\nscripts/migrate-auth0.ts\nimport { ManagementClient } from 'auth0';\nimport { generateRandomString, symmetricEncrypt } from \"better-auth/crypto\";\nimport { auth } from '@/lib/auth';\nconst auth0Client = new ManagementClient({\n    domain: process.env.AUTH0_DOMAIN!,\n    clientId: process.env.AUTH0_CLIENT_ID!,\n    clientSecret: process.env.AUTH0_SECRET!,\n});\nfunction safeDateConversion(timestamp?: string | number): Date {\n    if (!timestamp) return new Date();\n    const numericTimestamp = typeof timestamp === 'string' ? Date.parse(timestamp) : timestamp;\n    const milliseconds = numericTimestamp < 1000000000000 ? numericTimestamp * 1000 : numericTimestamp;\n    const date = new Date(milliseconds);\n    if (isNaN(date.getTime())) {\n        console.warn(`Invalid timestamp: ${timestamp}, falling back to current date`);\n        return new Date();\n    }\n    // Check for unreasonable dates (before 2000 or after 2100)\n    const year = date.getFullYear();\n    if (year < 2000 || year > 2100) {\n        console.warn(`Suspicious date year: ${year}, falling back to current date`);\n        return new Date();\n    }\n    return date;\n}\n// Helper function to generate backup codes for 2FA\nasync function generateBackupCodes(secret: string) {\n    const key = secret;\n    const backupCodes = Array.from({ length: 10 })\n        .fill(null)\n        .map(() => generateRandomString(10, \"a-z\", \"0-9\", \"A-Z\"))\n        .map((code) => `${code.slice(0, 5)}-${code.slice(5)}`);\n    const encCodes = await symmetricEncrypt({\n        data: JSON.stringify(backupCodes),\n        key: key,\n    });\n    return encCodes;\n}\nfunction mapAuth0RoleToBetterAuthRole(auth0Roles: string[]) {\n    if (typeof auth0Roles === 'string') return auth0Roles;\n    if (Array.isArray(auth0Roles)) return auth0Roles.join(',');\n}\n// helper function to migrate password from auth0 to better auth for custom hashes and algs\nasync function migratePassword(auth0User: any) {\n    if (auth0User.password_hash) {\n        if (auth0User.password_hash.startsWith('$2a$') || auth0User.password_hash.startsWith('$2b$')) {\n            return auth0User.password_hash;\n        }\n    }\n    if (auth0User.custom_password_hash) {\n        const customHash = auth0User.custom_password_hash;\n        if (customHash.algorithm === 'bcrypt') {\n            const hash = customHash.hash.value;\n            if (hash.startsWith('$2a$') || hash.startsWith('$2b$')) {\n                return hash;\n            }\n        }\n        return JSON.stringify({\n            algorithm: customHash.algorithm,\n            hash: {\n                value: customHash.hash.value,\n                encoding: customHash.hash.encoding || 'utf8',\n                ...(customHash.hash.digest && { digest: customHash.hash.digest }),\n                ...(customHash.hash.key && {\n                    key: {\n                        value: customHash.hash.key.value,\n                        encoding: customHash.hash.key.encoding || 'utf8'\n                    }\n                })\n            },\n            ...(customHash.salt && {\n                salt: {\n                    value: customHash.salt.value,\n                    encoding: customHash.salt.encoding || 'utf8',\n                    position: customHash.salt.position || 'prefix'\n                }\n            }),\n            ...(customHash.password && {\n                password: {\n                    encoding: customHash.password.encoding || 'utf8'\n                }\n            }),\n            ...(customHash.algorithm === 'scrypt' && {\n                keylen: customHash.keylen,\n                cost: customHash.cost || 16384,\n                blockSize: customHash.blockSize || 8,\n                parallelization: customHash.parallelization || 1\n            })\n        });\n    }\n    return null;\n}\nasync function migrateMFAFactors(auth0User: any, userId: string | undefined, ctx: any) {\n    if (!userId || !auth0User.mfa_factors || !Array.isArray(auth0User.mfa_factors)) {\n        return;\n    }\n    for (const factor of auth0User.mfa_factors) {\n        try {\n            if (factor.totp && factor.totp.secret) {\n                await ctx.adapter.create({\n                    model: \"twoFactor\",\n                    data: {\n                        userId: userId,\n                        secret: factor.totp.secret,\n                        backupCodes: await generateBackupCodes(factor.totp.secret)\n                    }\n                });\n            }\n        } catch (error) {\n            console.error(`Failed to migrate MFA factor for user ${userId}:`, error);\n        }\n    }\n}\nasync function migrateOAuthAccounts(auth0User: any, userId: string | undefined, ctx: any) {\n    if (!userId || !auth0User.identities || !Array.isArray(auth0User.identities)) {\n        return;\n    }\n    for (const identity of auth0User.identities) {\n        try {\n            const providerId = identity.provider === 'auth0' ? \"credential\" : identity.provider.split(\"-\")[0];\n            await ctx.adapter.create({\n                model: \"account\",\n                data: {\n                    id: `${auth0User.user_id}|${identity.provider}|${identity.user_id}`,\n                    userId: userId,\n                    password: await migratePassword(auth0User),\n                    providerId: providerId || identity.provider,\n                    accountId: identity.user_id,\n                    accessToken: identity.access_token,\n                    tokenType: identity.token_type,\n                    refreshToken: identity.refresh_token,\n                    accessTokenExpiresAt: identity.expires_in ? new Date(Date.now() + identity.expires_in * 1000) : undefined,\n                    // if you are enterprise user, you can get the refresh tokens or all the tokensets - auth0Client.users.getAllTokensets \n                    refreshTokenExpiresAt: identity.refresh_token_expires_in ? new Date(Date.now() + identity.refresh_token_expires_in * 1000) : undefined,\n                    scope: identity.scope,\n                    idToken: identity.id_token,\n                    createdAt: safeDateConversion(auth0User.created_at),\n                    updatedAt: safeDateConversion(auth0User.updated_at)\n                },\n                forceAllowId: true\n            }).catch((error: Error) => {\n                console.error(`Failed to create OAuth account for user ${userId} with provider ${providerId}:`, error);\n                return ctx.adapter.create({\n                    // Try creating without optional fields if the first attempt failed\n                    model: \"account\",\n                    data: {\n                        id: `${auth0User.user_id}|${identity.provider}|${identity.user_id}`,\n                        userId: userId,\n                        password: migratePassword(auth0User),\n                        providerId: providerId,\n                        accountId: identity.user_id,\n                        accessToken: identity.access_token,\n                        tokenType: identity.token_type,\n                        refreshToken: identity.refresh_token,\n                        accessTokenExpiresAt: identity.expires_in ? new Date(Date.now() + identity.expires_in * 1000) : undefined,\n                        refreshTokenExpiresAt: identity.refresh_token_expires_in ? new Date(Date.now() + identity.refresh_token_expires_in * 1000) : undefined,\n                        scope: identity.scope,\n                        idToken: identity.id_token,\n                        createdAt: safeDateConversion(auth0User.created_at),\n                        updatedAt: safeDateConversion(auth0User.updated_at)\n                    },\n                    forceAllowId: true\n                });\n            });\n            console.log(`Successfully migrated OAuth account for user ${userId} with provider ${providerId}`);\n        } catch (error) {\n            console.error(`Failed to migrate OAuth account for user ${userId}:`, error);\n        }\n    }\n}\nasync function migrateOrganizations(ctx: any) {\n    try {\n        const organizations = await auth0Client.organizations.getAll();\n        for (const org of organizations.data || []) {\n            try {\n                await ctx.adapter.create({\n                    model: \"organization\",\n                    data: {\n                        id: org.id,\n                        name: org.display_name || org.id,\n                        slug: (org.display_name || org.id).toLowerCase().replace(/[^a-z0-9]/g, '-'),\n                        logo: org.branding?.logo_url,\n                        metadata: JSON.stringify(org.metadata || {}),\n                        createdAt: safeDateConversion(org.created_at),\n                    },\n                    forceAllowId: true\n                });\n                const members = await auth0Client.organizations.getMembers({ id: org.id });\n                for (const member of members.data || []) {\n                    try {\n                        const userRoles = await auth0Client.organizations.getMemberRoles({\n                            id: org.id,\n                            user_id: member.user_id\n                        });\n                        const role = mapAuth0RoleToBetterAuthRole(userRoles.data?.map(r => r.name) || []);\n                        await ctx.adapter.create({\n                            model: \"member\",\n                            data: {\n                                id: `${org.id}|${member.user_id}`,\n                                organizationId: org.id,\n                                userId: member.user_id,\n                                role: role,\n                                createdAt: new Date()\n                            },\n                            forceAllowId: true\n                        });\n                        console.log(`Successfully migrated member ${member.user_id} for organization ${org.display_name || org.id}`);\n                    } catch (error) {\n                        console.error(`Failed to migrate member ${member.user_id} for organization ${org.display_name || org.id}:`, error);\n                    }\n                }\n                console.log(`Successfully migrated organization: ${org.display_name || org.id}`);\n            } catch (error) {\n                console.error(`Failed to migrate organization ${org.display_name || org.id}:`, error);\n            }\n        }\n        console.log('Organization migration completed');\n    } catch (error) {\n        console.error('Failed to migrate organizations:', error);\n    }\n}\nasync function migrateFromAuth0() {\n    try {\n        const ctx = await auth.$context;\n        const isAdminEnabled = ctx.options?.plugins?.find(plugin => plugin.id === \"admin\");\n        const isUsernameEnabled = ctx.options?.plugins?.find(plugin => plugin.id === \"username\");\n        const isOrganizationEnabled = ctx.options?.plugins?.find(plugin => plugin.id === \"organization\");\n        const perPage = 100;\n        const auth0Users: any[] = [];\n        let pageNumber = 0;\n        while (true) {\n            try {\n                const params = {\n                    per_page: perPage,\n                    page: pageNumber,\n                    include_totals: true,\n                };\n                const response = (await auth0Client.users.getAll(params)).data as any;\n                const users = response.users || [];\n                if (users.length === 0) break;\n                auth0Users.push(...users);\n                pageNumber++;\n                if (users.length < perPage) break;\n            } catch (error) {\n                console.error('Error fetching users:', error);\n                break;\n            }\n        }\n        console.log(`Found ${auth0Users.length} users to migrate`);\n        for (const auth0User of auth0Users) {\n            try {\n                // Determine if this is a password-based or OAuth user\n                const isOAuthUser = auth0User.identities?.some((identity: any) => identity.provider !== 'auth0');\n                // Base user data that's common for both types\n                const baseUserData = {\n                    id: auth0User.user_id,\n                    email: auth0User.email,\n                    emailVerified: auth0User.email_verified || false,\n                    name: auth0User.name || auth0User.nickname,\n                    image: auth0User.picture,\n                    createdAt: safeDateConversion(auth0User.created_at),\n                    updatedAt: safeDateConversion(auth0User.updated_at),\n                    ...(isAdminEnabled ? {\n                        banned: auth0User.blocked || false,\n                        role: mapAuth0RoleToBetterAuthRole(auth0User.roles || []),\n                    } : {}),\n                    ...(isUsernameEnabled ? {\n                        username: auth0User.username || auth0User.nickname,\n                    } : {}),\n                };\n                const createdUser = await ctx.adapter.create({\n                    model: \"user\",\n                    data: {\n                        ...baseUserData,\n                    },\n                    forceAllowId: true\n                });\n                if (!createdUser?.id) {\n                    throw new Error('Failed to create user');\n                }\n                await migrateOAuthAccounts(auth0User, createdUser.id, ctx)\n                console.log(`Successfully migrated user: ${auth0User.email}`);\n            } catch (error) {\n                console.error(`Failed to migrate user ${auth0User.email}:`, error);\n            }\n        }\n        if (isOrganizationEnabled) {\n            await migrateOrganizations(ctx);\n        }\n        // the reset of migration will be here.\n        console.log('Migration completed successfully');\n    } catch (error) {\n        console.error('Migration failed:', error);\n        throw error;\n    }\n}\nmigrateFromAuth0()\n    .then(() => {\n        console.log('Migration completed');\n        process.exit(0);\n    })\n    .catch((error) => {\n        console.error('Migration failed:', error);\n        process.exit(1);\n    }); \n\nMake sure to replace the Auth0 environment variables with your own values:\n\nAUTH0_DOMAIN\nAUTH0_CLIENT_ID\nAUTH0_SECRET\nRun the migration\n\nRun the migration script:\n\nbun run scripts/migrate-auth0.ts # or use your preferred runtime\n\nImportant considerations:\n\nTest the migration in a development environment first\nMonitor the migration process for any errors\nVerify the migrated data in Better Auth before proceeding\nKeep Auth0 installed and configured until the migration is complete\nThe script handles bcrypt password hashes by default. For custom password hashing algorithms, you'll need to modify the migratePassword function\nChange password hashing algorithm\n\nBy default, Better Auth uses the scrypt algorithm to hash passwords. Since Auth0 uses bcrypt, you'll need to configure Better Auth to use bcrypt for password verification.\n\nFirst, install bcrypt:\n\nnpm install bcrypt\nnpm install -D @types/bcrypt\n\nThen update your auth configuration:\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nimport bcrypt from \"bcrypt\";\nexport const auth = betterAuth({\n   emailAndPassword: {\n       password: {\n           hash: async (password) => {\n               return await bcrypt.hash(password, 10);\n           },\n           verify: async ({ hash, password }) => {\n               return await bcrypt.compare(password, hash);\n           }\n       }\n   }\n})\nVerify the migration\n\nAfter running the migration, verify that:\n\nAll users have been properly migrated\nSocial connections are working\nPassword-based authentication is working\nTwo-factor authentication settings are preserved (if enabled)\nUser roles and permissions are correctly mapped\nUpdate your components\n\nNow that the data is migrated, update your components to use Better Auth. Here's an example for the sign-in component:\n\ncomponents/auth/sign-in.tsx\nimport { authClient } from \"better-auth/client\";\nexport const SignIn = () => {\n  const handleSignIn = async () => {\n    const { data, error } = await authClient.signIn.email({\n      email: \"helloworld@gmail.com\",\n      password: \"helloworld\",\n    });\n    \n    if (error) {\n      console.error(error);\n      return;\n    }\n    // Handle successful sign in\n  };\n  return (\n    <form onSubmit={handleSignIn}>\n      <button type=\"submit\">Sign in</button>\n    </form>\n  );\n};\nUpdate the middleware\n\nReplace your Auth0 middleware with Better Auth's middleware:\n\nmiddleware.ts\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { getSessionCookie } from \"better-auth/cookies\";\nexport async function middleware(request: NextRequest) {\n  const sessionCookie = getSessionCookie(request);\n  const { pathname } = request.nextUrl;\n  if (sessionCookie && [\"/login\", \"/signup\"].includes(pathname)) {\n    return NextResponse.redirect(new URL(\"/dashboard\", request.url));\n  }\n  if (!sessionCookie && pathname.startsWith(\"/dashboard\")) {\n    return NextResponse.redirect(new URL(\"/login\", request.url));\n  }\n  return NextResponse.next();\n}\nexport const config = {\n  matcher: [\"/dashboard\", \"/login\", \"/signup\"],\n};\nRemove Auth0 Dependencies\n\nOnce you've verified everything is working correctly with Better Auth, remove Auth0:\n\nnpm remove @auth0/auth0-react @auth0/auth0-spa-js @auth0/nextjs-auth0\nAdditional Considerations\nPassword Migration\n\nThe migration script handles bcrypt password hashes by default. If you're using custom password hashing algorithms in Auth0, you'll need to modify the migratePassword function in the migration script to handle your specific case.\n\nRole Mapping\n\nThe script includes a basic role mapping function (mapAuth0RoleToBetterAuthRole). Customize this function based on your Auth0 roles and Better Auth role requirements.\n\nRate Limiting\n\nThe migration script includes pagination to handle large numbers of users. Adjust the perPage value based on your needs and Auth0's rate limits.\n\nWrapping Up\n\nNow! You've successfully migrated from Auth0 to Better Auth.\n\nBetter Auth offers greater flexibility and more featuresâ€”be sure to explore the documentation to unlock its full potential.\n\nEdit on GitHub\n\nPrevious Page\n\nClerk Migration Guide\n\nNext Page\n\nCreate Your First Plugin"
  },
  {
    "title": "Create your first plugin | Better Auth",
    "url": "https://www.better-auth.com/docs/guides/your-first-plugin",
    "html": "Create your first plugin\nCopy Markdown\nOpen in\n\nIn this guide, weâ€™ll walk you through the steps of creating your first Better Auth plugin.\n\nThis guide assumes you have setup the basics of Better Auth and are ready to create your first plugin.\n\nPlan your idea\n\nBefore beginning, you must know what plugin you intend to create.\n\nIn this guide, weâ€™ll create a birthday plugin to keep track of user birth dates.\n\nServer plugin first\n\nBetter Auth plugins operate as a pair: a server plugin and a client plugin. The server plugin forms the foundation of your authentication system, while the client plugin provides convenient frontend APIs to interact with your server implementation.\n\nYou can read more about server/client plugins in our documentation.\n\nCreating the server plugin\n\nGo ahead and find a suitable location to create your birthday plugin folder, with an index.ts file within.\n\nbirthday-plugin\nindex.ts\n\nIn the index.ts file, weâ€™ll export a function that represents our server plugin. This will be what we will later add to our plugin list in the auth.ts file.\n\nindex.ts\nimport { createAuthClient } from \"better-auth/client\";\nimport type { BetterAuthPlugin } from \"better-auth\";\nexport const birthdayPlugin = () =>\n  ({\n    id: \"birthdayPlugin\",\n  } satisfies BetterAuthPlugin);\n\nAlthough this does nothing, you have technically just made yourself your first plugin, congratulations! ðŸŽ‰\n\nDefining a schema\n\nIn order to save each userâ€™s birthday data, we must create a schema on top of the user model.\n\nBy creating a schema here, this also allows Better Authâ€™s CLI to generate the schemas required to update your database.\n\nYou can learn more about plugin schemas here.\n\nindex.ts\n//...\nexport const birthdayPlugin = () =>\n  ({\n    id: \"birthdayPlugin\",\n    schema: {\n      user: {\n        fields: {\n          birthday: {\n            type: \"date\", // string, number, boolean, date\n            required: true, // if the field should be required on a new record. (default: false)\n            unique: false, // if the field should be unique. (default: false)\n            references: null // if the field is a reference to another table. (default: null)\n          },\n        },\n      },\n    },\n  } satisfies BetterAuthPlugin);\nAuthorization logic\n\nFor this example guide, weâ€™ll set up authentication logic to check and ensure that the user who signs-up is older than 5. But the same concept could be applied for something like verifying users agreeing to the TOS or anything alike.\n\nTo do this, weâ€™ll utilize Hooks, which allows us to run code before or after an action is performed.\n\nindex.ts\nexport const birthdayPlugin = () => ({\n    //...\n    // In our case, we want to write authorization logic,\n    // meaning we want to intercept it `before` hand.\n    hooks: {\n      before: [\n        {\n          matcher: (context) => /* ... */,\n          handler: createAuthMiddleware(async (ctx) => {\n            //...\n          }),\n        },\n      ],\n    },\n} satisfies BetterAuthPlugin)\n\nIn our case we want to match any requests going to the signup path:\n\nBefore hook\n{\n  matcher: (context) => context.path.startsWith(\"/sign-up/email\"),\n  //...\n}\n\nAnd for our logic, weâ€™ll write the following code to check the if userâ€™s birthday makes them above 5 years old.\n\nImports\nimport { APIError } from \"better-auth/api\";\nimport { createAuthMiddleware } from \"better-auth/plugins\";\nBefore hook\n{\n  //...\n  handler: createAuthMiddleware(async (ctx) => {\n    const { birthday } = ctx.body;\n    if(!(birthday instanceof Date)) {\n      throw new APIError(\"BAD_REQUEST\", { message: \"Birthday must be of type Date.\" });\n    }\n    const today = new Date();\n    const fiveYearsAgo = new Date(today.setFullYear(today.getFullYear() - 5));\n    if(birthday >= fiveYearsAgo) {\n      throw new APIError(\"BAD_REQUEST\", { message: \"User must be above 5 years old.\" });\n    }\n    return { context: ctx };\n  }),\n}\n\nAuthorized! ðŸ”’\n\nWeâ€™ve now successfully written code to ensure authorization for users above 5!\n\nClient Plugin\n\nWeâ€™re close to the finish line! ðŸ\n\nNow that we have created our server plugin, the next step is to develop our client plugin. Since there isnâ€™t much frontend APIs going on for this plugin, there isnâ€™t much to do!\n\nFirst, letâ€™s create our client.ts file first:\n\nbirthday-plugin\nindex.ts\nclient.ts\n\nThen, add the following code:\n\nclient.ts\nimport { BetterAuthClientPlugin } from \"better-auth\";\nimport type { birthdayPlugin } from \"./index\"; // make sure to import the server plugin as a type\ntype BirthdayPlugin = typeof birthdayPlugin;\nexport const birthdayClientPlugin = () => {\n  return {\n    id: \"birthdayPlugin\",\n    $InferServerPlugin: {} as ReturnType<BirthdayPlugin>,\n  } satisfies BetterAuthClientPlugin;\n};\n\nWhat weâ€™ve done is allow the client plugin to infer the types defined by our schema from the server plugin.\n\nAnd thatâ€™s it! This is all it takes for the birthday client plugin. ðŸŽ‚\n\nInitiate your plugin!\n\nBoth the client and server plugins are now ready, the last step is to import them to both your auth-client.ts and your server.ts files respectively to initiate the plugin.\n\nServer initiation\nserver.ts\nimport { betterAuth } from \"better-auth\";\nimport { birthdayPlugin } from \"./birthday-plugin\";\n \nexport const auth = betterAuth({\n    plugins: [\n      birthdayPlugin(),\n    ]\n});\nClient initiation\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nimport { birthdayClientPlugin } from \"./birthday-plugin/client\";\n \nconst authClient = createAuthClient({\n    plugins: [\n      birthdayClientPlugin()\n    ]\n});\nOh yeah, the schemas!\n\nDonâ€™t forget to add your birthday field to your user table model!\n\nOr, use the generate CLI command:\n\nnpx @better-auth/cli@latest generate\nWrapping Up\n\nCongratulations! Youâ€™ve successfully created your first ever Better Auth plugin. We highly recommend you visit our plugins documentation to learn more information.\n\nIf you have a plugin youâ€™d like to share with the community, feel free to let us know through our Discord server, or through a pull-request and we may add it to the community-plugins list!\n\nEdit on GitHub\n\nPrevious Page\n\nAuth0 Migration Guide\n\nNext Page\n\nCreate a Database Adapter"
  },
  {
    "title": "Create a Database Adapter | Better Auth",
    "url": "https://www.better-auth.com/docs/guides/create-a-db-adapter",
    "html": "Create a Database Adapter\nCopy Markdown\nOpen in\n\nLearn how to create a custom database adapter for Better-Auth using createAdapter.\n\nOur createAdapter function is designed to be very flexible, and we've done our best to make it easy to understand and use. Our hope is to allow you to focus on writing database logic, and not have to worry about how the adapter is working with Better-Auth.\n\nAnything from custom schema configurations, custom ID generation, safe JSON parsing, and more is handled by the createAdapter function. All you need to do is provide the database logic, and the createAdapter function will handle the rest.\n\nQuick Start\nGet things ready\nImport createAdapter.\nCreate CustomAdapterConfig interface that represents your adapter config options.\nCreate the adapter!\nimport { createAdapter, type DBAdapterDebugLogOption } from \"better-auth/adapters\";\n// Your custom adapter config options\ninterface CustomAdapterConfig {\n  /**\n   * Helps you debug issues with the adapter.\n   */\n  debugLogs?: DBAdapterDebugLogOption;\n  /**\n   * If the table names in the schema are plural.\n   */\n  usePlural?: boolean;\n}\nexport const myAdapter = (config: CustomAdapterConfig = {}) =>\n  createAdapter({\n    // ...\n  });\nConfigure the adapter\n\nThe config object is mostly used to provide information about the adapter to Better-Auth. We try to minimize the amount of code you need to write in your adapter functions, and these config options are used to help us do that.\n\n// ...\nexport const myAdapter = (config: CustomAdapterConfig = {}) =>\n  createAdapter({\n    config: {\n      adapterId: \"custom-adapter\", // A unique identifier for the adapter.\n      adapterName: \"Custom Adapter\", // The name of the adapter.\n      usePlural: config.usePlural ?? false, // Whether the table names in the schema are plural.\n      debugLogs: config.debugLogs ?? false, // Whether to enable debug logs.\n      supportsJSON: false, // Whether the database supports JSON. (Default: false)\n      supportsDates: true, // Whether the database supports dates. (Default: true)\n      supportsBooleans: true, // Whether the database supports booleans. (Default: true)\n      supportsNumericIds: true, // Whether the database supports auto-incrementing numeric IDs. (Default: true)\n    },\n    // ...\n  });\nCreate the adapter\n\nThe adapter function is where you write the code that interacts with your database.\n\n// ...\nexport const myAdapter = (config: CustomAdapterConfig = {}) =>\n  createAdapter({\n    config: {\n      // ...\n    },\n    adapter: ({}) => {\n      return {\n        create: async ({ data, model, select }) => {\n          // ...\n        },\n        update: async ({ data, model, select }) => {\n          // ...\n        },\n        updateMany: async ({ data, model, select }) => {\n          // ...\n        },\n        delete: async ({ data, model, select }) => {\n          // ...\n        },\n        // ...\n      };\n    },\n  });\n\nLearn more about the adapter here here.\n\nAdapter\n\nThe adapter function is where you write the code that interacts with your database.\n\nIf you haven't already, check out the options object in the config section, as it can be useful for your adapter.\n\nBefore we get into the adapter function, let's go over the parameters that are available to you.\n\noptions: The Better Auth options.\nschema: The schema from the user's Better Auth instance.\ndebugLog: The debug log function.\ngetField: The get field function.\ngetDefaultModelName: The get default model name function.\ngetDefaultFieldName: The get default field name function.\ngetFieldAttributes: The get field attributes function.\nExample\nadapter: ({\n  options,\n  schema,\n  debugLog,\n  getField,\n  getDefaultModelName,\n  getDefaultFieldName,\n}) => {\n  return {\n    // ...\n  };\n};\nAdapter Methods\nAll model values are already transformed into the correct model name for the database based on the end-user's schema configuration.\nThis also means that if you need access to the schema version of a given model, you can't use this exact model value, you'll need to use the getDefaultModelName function provided in the options to convert the model to the schema version.\nWe will automatically fill in any missing fields you return based on the user's schema configuration.\nAny method that includes a select parameter, is only for the purpose of getting data from your database more efficiently. You do not need to worry about only returning what the select parameter states, as we will handle that for you.\ncreate method\n\nThe create method is used to create a new record in the database.\n\nNote: If the user has enabled the useNumberId option, or if generateId is false in the user's Better Auth config, then it's expected that the id is provided in the data object. Otherwise, the id will be automatically generated.\n\nAdditionally, it's possible to pass forceAllowId as a parameter to the create method, which allows id to be provided in the data object. We handle forceAllowId internally, so you don't need to worry about it.\n\nparameters:\n\nmodel: The model/table name that new data will be inserted into.\ndata: The data to insert into the database.\nselect: An array of fields to return from the database.\n\nMake sure to return the data that is inserted into the database.\n\nExample\ncreate: async ({ model, data, select }) => {\n  // Example of inserting data into the database.\n  return await db.insert(model).values(data);\n};\nupdate method\n\nThe update method is used to update a record in the database.\n\nparameters:\n\nmodel: The model/table name that the record will be updated in.\nwhere: The where clause to update the record by.\nupdate: The data to update the record with.\n\nMake sure to return the data in the row which is updated. This includes any fields that were not updated.\n\nExample\nupdate: async ({ model, where, update }) => {\n  // Example of updating data in the database.\n  return await db.update(model).set(update).where(where);\n};\nupdateMany method\n\nThe updateMany method is used to update multiple records in the database.\n\nparameters:\n\nmodel: The model/table name that the records will be updated in.\nwhere: The where clause to update the records by.\nupdate: The data to update the records with.\nMake sure to return the number of records that were updated.\nExample\nupdateMany: async ({ model, where, update }) => {\n  // Example of updating multiple records in the database.\n  return await db.update(model).set(update).where(where);\n};\ndelete method\n\nThe delete method is used to delete a record from the database.\n\nparameters:\n\nmodel: The model/table name that the record will be deleted from.\nwhere: The where clause to delete the record by.\nExample\ndelete: async ({ model, where }) => {\n  // Example of deleting a record from the database.\n  await db.delete(model).where(where);\n}\ndeleteMany method\n\nThe deleteMany method is used to delete multiple records from the database.\n\nparameters:\n\nmodel: The model/table name that the records will be deleted from.\nwhere: The where clause to delete the records by.\nMake sure to return the number of records that were deleted.\nExample\ndeleteMany: async ({ model, where }) => {\n  // Example of deleting multiple records from the database.\n  return await db.delete(model).where(where);\n};\nfindOne method\n\nThe findOne method is used to find a single record in the database.\n\nparameters:\n\nmodel: The model/table name that the record will be found in.\nwhere: The where clause to find the record by.\nselect: The select clause to return.\nMake sure to return the data that is found in the database.\nExample\nfindOne: async ({ model, where, select }) => {\n  // Example of finding a single record in the database.\n  return await db.select().from(model).where(where).limit(1);\n};\nfindMany method\n\nThe findMany method is used to find multiple records in the database.\n\nparameters:\n\nmodel: The model/table name that the records will be found in.\nwhere: The where clause to find the records by.\nlimit: The limit of records to return.\nsortBy: The sortBy clause to sort the records by.\noffset: The offset of records to return.\n\nMake sure to return the array of data that is found in the database.\n\nExample\nfindMany: async ({ model, where, limit, sortBy, offset }) => {\n  // Example of finding multiple records in the database.\n  return await db\n    .select()\n    .from(model)\n    .where(where)\n    .limit(limit)\n    .offset(offset)\n    .orderBy(sortBy);\n};\ncount method\n\nThe count method is used to count the number of records in the database.\n\nparameters:\n\nmodel: The model/table name that the records will be counted in.\nwhere: The where clause to count the records by.\nMake sure to return the number of records that were counted.\nExample\ncount: async ({ model, where }) => {\n  // Example of counting the number of records in the database.\n  return await db.select().from(model).where(where).count();\n};\noptions (optional)\n\nThe options object is for any potential config that you got from your custom adapter options.\n\nExample\nconst myAdapter = (config: CustomAdapterConfig) =>\n  createAdapter({\n    config: {\n      // ...\n    },\n    adapter: ({ options }) => {\n      return {\n        options: config,\n      };\n    },\n  });\ncreateSchema (optional)\n\nThe createSchema method allows the Better Auth CLI to generate a schema for the database.\n\nparameters:\n\ntables: The tables from the user's Better-Auth instance schema; which is expected to be generated into the schema file.\nfile: The file the user may have passed in to the generate command as the expected schema file output path.\nExample\ncreateSchema: async ({ file, tables }) => {\n  // ... Custom logic to create a schema for the database.\n};\nTest your adapter\n\nWe've provided a test suite that you can use to test your adapter. It requires you to use vitest.\n\nmy-adapter.test.ts\nimport { expect, test, describe } from \"vitest\";\nimport { runAdapterTest } from \"better-auth/adapters/test\";\nimport { myAdapter } from \"./my-adapter\";\ndescribe(\"My Adapter Tests\", async () => {\n  afterAll(async () => {\n    // Run DB cleanup here...\n  });\n  const adapter = myAdapter({\n    debugLogs: {\n      // If your adapter config allows passing in debug logs, then pass this here.\n      isRunningAdapterTests: true, // This is our super secret flag to let us know to only log debug logs if a test fails.\n    },\n  });\n  await runAdapterTest({\n    getAdapter: async (betterAuthOptions = {}) => {\n      return adapter(betterAuthOptions);\n    },\n  });\n});\nNumeric ID tests\n\nIf your database supports numeric IDs, then you should run this test as well:\n\nmy-adapter.number-id.test.ts\nimport { expect, test, describe } from \"vitest\";\nimport { runNumberIdAdapterTest } from \"better-auth/adapters/test\";\nimport { myAdapter } from \"./my-adapter\";\ndescribe(\"My Adapter Numeric ID Tests\", async () => {\n  afterAll(async () => {\n    // Run DB cleanup here...\n  });\n  const adapter = myAdapter({\n    debugLogs: {\n      // If your adapter config allows passing in debug logs, then pass this here.\n      isRunningAdapterTests: true, // This is our super secret flag to let us know to only log debug logs if a test fails.\n    },\n  });\n  await runNumberIdAdapterTest({\n    getAdapter: async (betterAuthOptions = {}) => {\n      return adapter(betterAuthOptions);\n    },\n  });\n});\nConfig\n\nThe config object is used to provide information about the adapter to Better-Auth.\n\nWe highly recommend going through and reading each provided option below, as it will help you understand how to properly configure your adapter.\n\nRequired Config\nadapterId\n\nA unique identifier for the adapter.\n\nadapterName\n\nThe name of the adapter.\n\nOptional Config\nsupportsNumericIds\n\nWhether the database supports numeric IDs. If this is set to false and the user's config has enabled useNumberId, then we will throw an error.\n\nsupportsJSON\n\nWhether the database supports JSON. If the database doesn't support JSON, we will use a string to save the JSON data.And when we retrieve the data, we will safely parse the string back into a JSON object.\n\nsupportsDates\n\nWhether the database supports dates. If the database doesn't support dates, we will use a string to save the date. (ISO string) When we retrieve the data, we will safely parse the string back into a Date object.\n\nsupportsBooleans\n\nWhether the database supports booleans. If the database doesn't support booleans, we will use a 0 or 1 to save the boolean value. When we retrieve the data, we will safely parse the 0 or 1 back into a boolean value.\n\nusePlural\n\nWhether the table names in the schema are plural. This is often defined by the user, and passed down through your custom adapter options. If you do not intend to allow the user to customize the table names, you can ignore this option, or set this to false.\n\nExample\nconst adapter = myAdapter({\n  // This value then gets passed into the `usePlural`\n  // option in the createAdapter `config` object.\n  usePlural: true,\n});\ntransaction\n\nWhether the adapter supports transactions. If false, operations run sequentially; otherwise provide a function that executes a callback with a TransactionAdapter.\n\nIf your database does not support transactions, the error handling and rollback will not be as robust. We recommend using a database that supports transactions for better data integrity.\n\ndebugLogs\n\nUsed to enable debug logs for the adapter. You can pass in a boolean, or an object with the following keys: create, update, updateMany, findOne, findMany, delete, deleteMany, count. If any of the keys are true, the debug logs will be enabled for that method.\n\nExample\n// Will log debug logs for all methods.\nconst adapter = myAdapter({\n  debugLogs: true,\n});\nExample\n// Will only log debug logs for the `create` and `update` methods.\nconst adapter = myAdapter({\n  debugLogs: {\n    create: true,\n    update: true,\n  },\n});\ndisableIdGeneration\n\nWhether to disable ID generation. If this is set to true, then the user's generateId option will be ignored.\n\ncustomIdGenerator\n\nIf your database only supports a specific custom ID generation, then you can use this option to generate your own IDs.\n\nmapKeysTransformInput\n\nIf your database uses a different key name for a given situation, you can use this option to map the keys. This is useful for databases that expect a different key name for a given situation. For example, MongoDB uses _id while in Better-Auth we use id.\n\nEach key in the returned object represents the old key to replace. The value represents the new key.\n\nThis can be a partial object that only transforms some keys.\n\nExample\nmapKeysTransformInput: () => {\n  return {\n    id: \"_id\", // We want to replace `id` to `_id` to save into MongoDB\n  };\n},\nmapKeysTransformOutput\n\nIf your database uses a different key name for a given situation, you can use this option to map the keys. This is useful for databases that use a different key name for a given situation. For example, MongoDB uses _id while in Better-Auth we use id.\n\nEach key in the returned object represents the old key to replace. The value represents the new key.\n\nThis can be a partial object that only transforms some keys.\n\nExample\nmapKeysTransformOutput: () => {\n  return {\n    _id: \"id\", // We want to replace `_id` (from MongoDB) to `id` (for Better-Auth)\n  };\n},\ncustomTransformInput\n\nIf you need to transform the input data before it is saved to the database, you can use this option to transform the data.\n\nIf you're using supportsJSON, supportsDates, or supportsBooleans, then the transformations will be applied before your customTransformInput function is called.\n\nThe customTransformInput function receives the following arguments:\n\ndata: The data to transform.\nfield: The field that is being transformed.\nfieldAttributes: The field attributes of the field that is being transformed.\nselect: The select values which the query expects to return.\nmodel: The model that is being transformed.\nschema: The schema that is being transformed.\noptions: Better Auth options.\n\nThe customTransformInput function runs at every key in the data object of a given action.\n\nExample\ncustomTransformInput: ({ field, data }) => {\n  if (field === \"id\") {\n    return \"123\"; // Force the ID to be \"123\"\n  }\n  return data;\n};\ncustomTransformOutput\n\nIf you need to transform the output data before it is returned to the user, you can use this option to transform the data. The customTransformOutput function is used to transform the output data. Similar to the customTransformInput function, it runs at every key in the data object of a given action, but it runs after the data is retrieved from the database.\n\nExample\ncustomTransformOutput: ({ field, data }) => {\n  if (field === \"name\") {\n    return \"Bob\"; // Force the name to be \"Bob\"\n  }\n  return data;\n};\nconst some_data = await adapter.create({\n  model: \"user\",\n  data: {\n    name: \"John\",\n  },\n});\n// The name will be \"Bob\"\nconsole.log(some_data.name);\nEdit on GitHub\n\nPrevious Page\n\nCreate Your First Plugin\n\nNext Page\n\nBrowser Extension Guide"
  },
  {
    "title": "Browser Extension Guide | Better Auth",
    "url": "https://www.better-auth.com/docs/guides/browser-extension-guide",
    "html": "Browser Extension Guide\nCopy Markdown\nOpen in\n\nIn this guide, we'll walk you through the steps of creating a browser extension using Plasmo with Better Auth for authentication.\n\nIf you would like to view a completed example, you can check out the browser extension example.\n\nThe Plasmo framework does not provide a backend for the browser extension. This guide assumes you have a backend setup of Better Auth and are ready to create a browser extension to connect to it.\n\nSetup & Installations\n\nInitialize a new Plasmo project with TailwindCSS and a src directory.\n\npnpm create plasmo --with-tailwindcss --with-src\n\nThen, install the Better Auth package.\n\npnpm add better-auth\n\nTo start the Plasmo development server, run the following command.\n\npnpm dev\nConfigure tsconfig\n\nConfigure the tsconfig.json file to include strict mode.\n\nFor this demo, we have also changed the import alias from ~ to @ and set it to the src directory.\n\ntsconfig.json\n{\n    \"compilerOptions\": {\n        \"paths\": {\n            \"@/_\": [\n                \"./src/_\"\n            ]\n        },\n        \"strict\": true,\n        \"baseUrl\": \".\"\n    }\n}\nCreate the client auth instance\n\nCreate a new file at src/auth/auth-client.ts and add the following code.\n\nsrc\nauth\nauth-client.ts\nauth-client.ts\nimport { createAuthClient } from \"better-auth/react\"\nexport const authClient = createAuthClient({\n    baseURL: \"http://localhost:3000\" /* Base URL of your Better Auth backend. */,\n    plugins: [],\n});\nConfigure the manifest\n\nWe must ensure the extension knows the URL to the Better Auth backend.\n\nHead to your package.json file, and add the following code.\n\npackage.json\n{\n    //...\n    \"manifest\": {\n        \"host_permissions\": [\n            \"https://URL_TO_YOUR_BACKEND\" // localhost works too (e.g. http://localhost:3000)\n        ]\n    }\n}\nYou're now ready!\n\nYou have now set up Better Auth for your browser extension.\n\nAdd your desired UI and create your dream extension!\n\nTo learn more about the client Better Auth API, check out the client documentation.\n\nHere's a quick example ðŸ˜Ž\n\nsrc/popup.tsx\nimport { authClient } from \"./auth/auth-client\"\nfunction IndexPopup() {\n    const {data, isPending, error} = authClient.useSession();\n    if(isPending){\n        return <>Loading...</>\n    }\n    if(error){\n        return <>Error: {error.message}</>\n    }\n    if(data){\n        return <>Signed in as {data.user.name}</>\n    }\n}\nexport default IndexPopup;\nBundle your extension\n\nTo get a production build, run the following command.\n\npnpm build\n\nHead over to chrome://extensions and enable developer mode.\n\nClick on \"Load Unpacked\" and navigate to your extension's build/chrome-mv3-dev (or build/chrome-mv3-prod) directory.\n\nTo see your popup, click on the puzzle piece icon on the Chrome toolbar, and click on your extension.\n\nLearn more about bundling your extension here.\n\nConfigure the server auth instance\n\nFirst, we will need your extension URL.\n\nAn extension URL formed like this: chrome-extension://YOUR_EXTENSION_ID.\n\nYou can find your extension ID at chrome://extensions.\n\nHead to your server's auth file, and make sure that your extension's URL is added to the trustedOrigins list.\n\nserver.ts\nimport { betterAuth } from \"better-auth\"\nimport { auth } from \"@/auth/auth\"\nexport const auth = betterAuth({\n    trustedOrigins: [\"chrome-extension://YOUR_EXTENSION_ID\"],\n})\n\nIf you're developing multiple extensions or need to support different browser extensions with different IDs, you can use wildcard patterns:\n\nserver.ts\nexport const auth = betterAuth({\n    trustedOrigins: [\n        // Support a specific extension ID\n        \"chrome-extension://YOUR_EXTENSION_ID\",\n        \n        // Or support multiple extensions with wildcard (less secure)\n        \"chrome-extension://*\"\n    ],\n})\n\nUsing wildcards for extension origins (chrome-extension://*) reduces security by trusting all extensions. It's safer to explicitly list each extension ID you trust. Only use wildcards for development and testing.\n\nThat's it!\n\nEverything is set up! You can now start developing your extension. ðŸŽ‰\n\nWrapping Up\n\nCongratulations! You've successfully created a browser extension using Better Auth and Plasmo. We highly recommend you visit the Plasmo documentation to learn more about the framework.\n\nIf you would like to view a completed example, you can check out the browser extension example.\n\nIf you have any questions, feel free to open an issue on our GitHub repo, or join our Discord server for support.\n\nEdit on GitHub\n\nPrevious Page\n\nCreate a Database Adapter\n\nNext Page\n\nSAML SSO with Okta"
  },
  {
    "title": "Options | Better Auth",
    "url": "https://www.better-auth.com/docs/reference/options",
    "html": "Options\nCopy Markdown\nOpen in\n\nList of all the available options for configuring Better Auth. See Better Auth Options.\n\nappName\n\nThe name of the application.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tappName: \"My App\",\n})\nbaseURL\n\nBase URL for Better Auth. This is typically the root URL where your application server is hosted. Note: If you include a path in the baseURL, it will take precedence over the default path.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tbaseURL: \"https://example.com\",\n})\n\nIf not explicitly set, the system will check for the environment variable process.env.BETTER_AUTH_URL\n\nbasePath\n\nBase path for Better Auth. This is typically the path where the Better Auth routes are mounted. It will be overridden if there is a path component within baseURL.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tbasePath: \"/api/auth\",\n})\n\nDefault: /api/auth\n\ntrustedOrigins\n\nList of trusted origins. You can provide a static array of origins, a function that returns origins dynamically, or use wildcard patterns to match multiple domains.\n\nStatic Origins\n\nYou can provide a static array of origins:\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\ttrustedOrigins: [\"http://localhost:3000\", \"https://example.com\"],\n})\nDynamic Origins\n\nYou can provide a function that returns origins dynamically:\n\nexport const auth = betterAuth({\n\ttrustedOrigins: async (request: Request) => {\n\t\t// Return an array of trusted origins based on the request\n\t\treturn [\"https://dynamic-origin.com\"];\n\t}\n})\nWildcard Support\n\nYou can use wildcard patterns in trusted origins:\n\nexport const auth = betterAuth({\n\ttrustedOrigins: [\n\t\t\"*.example.com\",             // Trust all subdomains of example.com\n\t\t\"https://*.example.com\",     // Trust only HTTPS subdomains\n\t\t\"http://*.dev.example.com\"   // Trust HTTP subdomains of dev.example.com\n\t]\n})\nsecret\n\nThe secret used for encryption, signing, and hashing.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tsecret: \"your-secret-key\",\n})\n\nBy default, Better Auth will look for the following environment variables:\n\nprocess.env.BETTER_AUTH_SECRET\nprocess.env.AUTH_SECRET\n\nIf none of these environment variables are set, it will default to \"better-auth-secret-123456789\". In production, if it's not set, it will throw an error.\n\nYou can generate a good secret using the following command:\n\nopenssl rand -base64 32\ndatabase\n\nDatabase configuration for Better Auth.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tdatabase: {\n\t\tdialect: \"postgres\",\n\t\ttype: \"postgres\",\n\t\tcasing: \"camel\"\n\t},\n})\n\nBetter Auth supports various database configurations including PostgreSQL, MySQL, and SQLite.\n\nRead more about databases here.\n\nsecondaryStorage\n\nSecondary storage configuration used to store session and rate limit data.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\t// ... other options\n    secondaryStorage: {\n    \t// Your implementation here\n    },\n})\n\nRead more about secondary storage here.\n\nemailVerification\n\nEmail verification configuration.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\temailVerification: {\n\t\tsendVerificationEmail: async ({ user, url, token }) => {\n\t\t\t// Send verification email to user\n\t\t},\n\t\tsendOnSignUp: true,\n\t\tautoSignInAfterVerification: true,\n\t\texpiresIn: 3600 // 1 hour\n\t},\n})\nsendVerificationEmail: Function to send verification email\nsendOnSignUp: Send verification email automatically after sign up (default: false)\nsendOnSignIn: Send verification email automatically on sign in when the user's email is not verified (default: false)\nautoSignInAfterVerification: Auto sign in the user after they verify their email\nexpiresIn: Number of seconds the verification token is valid for (default: 3600 seconds)\nemailAndPassword\n\nEmail and password authentication configuration.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\temailAndPassword: {\n\t\tenabled: true,\n\t\tdisableSignUp: false,\n\t\trequireEmailVerification: true,\n\t\tminPasswordLength: 8,\n\t\tmaxPasswordLength: 128,\n\t\tautoSignIn: true,\n\t\tsendResetPassword: async ({ user, url, token }) => {\n\t\t\t// Send reset password email\n\t\t},\n\t\tresetPasswordTokenExpiresIn: 3600, // 1 hour\n\t\tpassword: {\n\t\t\thash: async (password) => {\n\t\t\t\t// Custom password hashing\n\t\t\t\treturn hashedPassword;\n\t\t\t},\n\t\t\tverify: async ({ hash, password }) => {\n\t\t\t\t// Custom password verification\n\t\t\t\treturn isValid;\n\t\t\t}\n\t\t}\n\t},\n})\nenabled: Enable email and password authentication (default: false)\ndisableSignUp: Disable email and password sign up (default: false)\nrequireEmailVerification: Require email verification before a session can be created\nminPasswordLength: Minimum password length (default: 8)\nmaxPasswordLength: Maximum password length (default: 128)\nautoSignIn: Automatically sign in the user after sign up\nsendResetPassword: Function to send reset password email\nresetPasswordTokenExpiresIn: Number of seconds the reset password token is valid for (default: 3600 seconds)\npassword: Custom password hashing and verification functions\nsocialProviders\n\nConfigure social login providers.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tsocialProviders: {\n\t\tgoogle: {\n\t\t\tclientId: \"your-client-id\",\n\t\t\tclientSecret: \"your-client-secret\",\n\t\t\tredirectURI: \"https://example.com/api/auth/callback/google\"\n\t\t},\n\t\tgithub: {\n\t\t\tclientId: \"your-client-id\",\n\t\t\tclientSecret: \"your-client-secret\",\n\t\t\tredirectURI: \"https://example.com/api/auth/callback/github\"\n\t\t}\n\t},\n})\nplugins\n\nList of Better Auth plugins.\n\nimport { betterAuth } from \"better-auth\";\nimport { emailOTP } from \"better-auth/plugins\";\nexport const auth = betterAuth({\n\tplugins: [\n\t\temailOTP({\n\t\t\tsendVerificationOTP: async ({ email, otp, type }) => {\n\t\t\t\t// Send OTP to user's email\n\t\t\t}\n\t\t})\n\t],\n})\nuser\n\nUser configuration options.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tuser: {\n\t\tmodelName: \"users\",\n\t\tfields: {\n\t\t\temail: \"emailAddress\",\n\t\t\tname: \"fullName\"\n\t\t},\n\t\tadditionalFields: {\n\t\t\tcustomField: {\n\t\t\t\ttype: \"string\",\n\t\t\t}\n\t\t},\n\t\tchangeEmail: {\n\t\t\tenabled: true,\n\t\t\tsendChangeEmailVerification: async ({ user, newEmail, url, token }) => {\n\t\t\t\t// Send change email verification\n\t\t\t}\n\t\t},\n\t\tdeleteUser: {\n\t\t\tenabled: true,\n\t\t\tsendDeleteAccountVerification: async ({ user, url, token }) => {\n\t\t\t\t// Send delete account verification\n\t\t\t},\n\t\t\tbeforeDelete: async (user) => {\n\t\t\t\t// Perform actions before user deletion\n\t\t\t},\n\t\t\tafterDelete: async (user) => {\n\t\t\t\t// Perform cleanup after user deletion\n\t\t\t}\n\t\t}\n\t},\n})\nmodelName: The model name for the user (default: \"user\")\nfields: Map fields to different column names\nadditionalFields: Additional fields for the user table\nchangeEmail: Configuration for changing email\ndeleteUser: Configuration for user deletion\nsession\n\nSession configuration options.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tsession: {\n\t\tmodelName: \"sessions\",\n\t\tfields: {\n\t\t\tuserId: \"user_id\"\n\t\t},\n\t\texpiresIn: 604800, // 7 days\n\t\tupdateAge: 86400, // 1 day\n\t\tdisableSessionRefresh: true, // Disable session refresh so that the session is not updated regardless of the `updateAge` option. (default: `false`)\n\t\tadditionalFields: { // Additional fields for the session table\n\t\t\tcustomField: {\n\t\t\t\ttype: \"string\",\n\t\t\t}\n\t\t},\n\t\tstoreSessionInDatabase: true, // Store session in database when secondary storage is provided (default: `false`)\n\t\tpreserveSessionInDatabase: false, // Preserve session records in database when deleted from secondary storage (default: `false`)\n\t\tcookieCache: {\n\t\t\tenabled: true, // Enable caching session in cookie (default: `false`)\t\n\t\t\tmaxAge: 300 // 5 minutes\n\t\t}\n\t},\n})\nmodelName: The model name for the session (default: \"session\")\nfields: Map fields to different column names\nexpiresIn: Expiration time for the session token in seconds (default: 604800 - 7 days)\nupdateAge: How often the session should be refreshed in seconds (default: 86400 - 1 day)\nadditionalFields: Additional fields for the session table\nstoreSessionInDatabase: Store session in database when secondary storage is provided (default: false)\npreserveSessionInDatabase: Preserve session records in database when deleted from secondary storage (default: false)\ncookieCache: Enable caching session in cookie\naccount\n\nAccount configuration options.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\taccount: {\n\t\tmodelName: \"accounts\",\n\t\tfields: {\n\t\t\tuserId: \"user_id\"\n\t\t},\n\t\tencryptOAuthTokens: true, // Encrypt OAuth tokens before storing them in the database\n\t\taccountLinking: {\n\t\t\tenabled: true,\n\t\t\ttrustedProviders: [\"google\", \"github\", \"email-password\"],\n\t\t\tallowDifferentEmails: false\n\t\t}\n\t},\n})\nmodelName: The model name for the account\nfields: Map fields to different column names\nencryptOAuthTokens\n\nEncrypt OAuth tokens before storing them in the database. Default: false.\n\nupdateAccountOnSignIn\n\nIf enabled (true), the user account data (accessToken, idToken, refreshToken, etc.) will be updated on sign in with the latest data from the provider.\n\naccountLinking\n\nConfiguration for account linking.\n\nenabled: Enable account linking (default: false)\ntrustedProviders: List of trusted providers\nallowDifferentEmails: Allow users to link accounts with different email addresses\nallowUnlinkingAll: Allow users to unlink all accounts\nverification\n\nVerification configuration options.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tverification: {\n\t\tmodelName: \"verifications\",\n\t\tfields: {\n\t\t\tuserId: \"user_id\"\n\t\t},\n\t\tdisableCleanup: false\n\t},\n})\nmodelName: The model name for the verification table\nfields: Map fields to different column names\ndisableCleanup: Disable cleaning up expired values when a verification value is fetched\nrateLimit\n\nRate limiting configuration.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\trateLimit: {\n\t\tenabled: true,\n\t\twindow: 10,\n\t\tmax: 100,\n\t\tcustomRules: {\n\t\t\t\"/example/path\": {\n\t\t\t\twindow: 10,\n\t\t\t\tmax: 100\n\t\t\t}\n\t\t},\n\t\tstorage: \"memory\",\n\t\tmodelName: \"rateLimit\"\n\t}\n})\nenabled: Enable rate limiting (defaults: true in production, false in development)\nwindow: Time window to use for rate limiting. The value should be in seconds. (default: 10)\nmax: The default maximum number of requests allowed within the window. (default: 100)\ncustomRules: Custom rate limit rules to apply to specific paths.\nstorage: Storage configuration. If you passed a secondary storage, rate limiting will be stored in the secondary storage. (options: \"memory\", \"database\", \"secondary-storage\", default: \"memory\")\nmodelName: The name of the table to use for rate limiting if database is used as storage. (default: \"rateLimit\")\nadvanced\n\nAdvanced configuration options.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tadvanced: {\n\t\tipAddress: {\n\t\t\tipAddressHeaders: [\"x-client-ip\", \"x-forwarded-for\"],\n\t\t\tdisableIpTracking: false\n\t\t},\n\t\tuseSecureCookies: true,\n\t\tdisableCSRFCheck: false,\n\t\tcrossSubDomainCookies: {\n\t\t\tenabled: true,\n\t\t\tadditionalCookies: [\"custom_cookie\"],\n\t\t\tdomain: \"example.com\"\n\t\t},\n\t\tcookies: {\n\t\t\tsession_token: {\n\t\t\t\tname: \"custom_session_token\",\n\t\t\t\tattributes: {\n\t\t\t\t\thttpOnly: true,\n\t\t\t\t\tsecure: true\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdefaultCookieAttributes: {\n\t\t\thttpOnly: true,\n\t\t\tsecure: true\n\t\t},\n\t\tcookiePrefix: \"myapp\",\n\t\tdatabase: {\n\t\t\t// If your DB is using auto-incrementing IDs, set this to true.\n\t\t\tuseNumberId: false,\n\t\t\t// Use your own custom ID generator, or disable generating IDs as a whole.\n\t\t\tgenerateId: (((options: {\n\t\t\t\tmodel: LiteralUnion<Models, string>;\n\t\t\t\tsize?: number;\n\t\t\t}) => {\n\t\t\t\treturn \"my-super-unique-id\";\n\t\t\t})) | false,\n\t\t\tdefaultFindManyLimit: 100,\n\t\t}\n\t},\n})\nipAddress: IP address configuration for rate limiting and session tracking\nuseSecureCookies: Use secure cookies (default: false)\ndisableCSRFCheck: Disable trusted origins check (âš ï¸ security risk)\ncrossSubDomainCookies: Configure cookies to be shared across subdomains\ncookies: Customize cookie names and attributes\ndefaultCookieAttributes: Default attributes for all cookies\ncookiePrefix: Prefix for cookies\ngenerateId: Function to generate a unique ID for a model\nlogger\n\nLogger configuration for Better Auth.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tlogger: {\n\t\tdisabled: false,\n\t\tdisableColors: false,\n\t\tlevel: \"error\",\n\t\tlog: (level, message, ...args) => {\n\t\t\t// Custom logging implementation\n\t\t\tconsole.log(`[${level}] ${message}`, ...args);\n\t\t}\n\t}\n})\n\nThe logger configuration allows you to customize how Better Auth handles logging. It supports the following options:\n\ndisabled: Disable all logging when set to true (default: false)\ndisableColors: Disable colors in the default logger implementation (default: determined by the terminal's color support)\nlevel: Set the minimum log level to display. Available levels are:\n\"info\": Show all logs\n\"warn\": Show warnings and errors\n\"error\": Show only errors\n\"debug\": Show all logs including debug information\nlog: Custom logging function that receives:\nlevel: The log level (\"info\", \"warn\", \"error\", or \"debug\")\nmessage: The log message\n...args: Additional arguments passed to the logger\n\nExample with custom logging:\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tlogger: {\n\t\tlevel: \"info\",\n\t\tlog: (level, message, ...args) => {\n\t\t\t// Send logs to a custom logging service\n\t\t\tmyLoggingService.log({\n\t\t\t\tlevel,\n\t\t\t\tmessage,\n\t\t\t\tmetadata: args,\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t});\n\t\t}\n\t}\n})\ndatabaseHooks\n\nDatabase lifecycle hooks for core operations.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tdatabaseHooks: {\n\t\tuser: {\n\t\t\tcreate: {\n\t\t\t\tbefore: async (user) => {\n\t\t\t\t\t// Modify user data before creation\n\t\t\t\t\treturn { data: { ...user, customField: \"value\" } };\n\t\t\t\t},\n\t\t\t\tafter: async (user) => {\n\t\t\t\t\t// Perform actions after user creation\n\t\t\t\t}\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tbefore: async (userData) => {\n\t\t\t\t\t// Modify user data before update\n\t\t\t\t\treturn { data: { ...userData, updatedAt: new Date() } };\n\t\t\t\t},\n\t\t\t\tafter: async (user) => {\n\t\t\t\t\t// Perform actions after user update\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsession: {\n\t\t\t// Session hooks\n\t\t},\n\t\taccount: {\n\t\t\t// Account hooks\n\t\t},\n\t\tverification: {\n\t\t\t// Verification hooks\n\t\t}\n\t},\n})\nonAPIError\n\nAPI error handling configuration.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tonAPIError: {\n\t\tthrow: true,\n\t\tonError: (error, ctx) => {\n\t\t\t// Custom error handling\n\t\t\tconsole.error(\"Auth error:\", error);\n\t\t},\n\t\terrorURL: \"/auth/error\"\n\t},\n})\nthrow: Throw an error on API error (default: false)\nonError: Custom error handler\nerrorURL: URL to redirect to on error (default: /api/auth/error)\nhooks\n\nRequest lifecycle hooks.\n\nimport { betterAuth } from \"better-auth\";\nimport { createAuthMiddleware } from \"better-auth/api\";\nexport const auth = betterAuth({\n\thooks: {\n\t\tbefore: createAuthMiddleware(async (ctx) => {\n\t\t\t// Execute before processing the request\n\t\t\tconsole.log(\"Request path:\", ctx.path);\n\t\t}),\n\t\tafter: createAuthMiddleware(async (ctx) => {\n\t\t\t// Execute after processing the request\n\t\t\tconsole.log(\"Response:\", ctx.context.returned);\n\t\t})\n\t},\n})\n\nFor more details and examples, see the Hooks documentation.\n\ndisabledPaths\n\nDisable specific auth paths.\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n\tdisabledPaths: [\"/sign-up/email\", \"/sign-in/email\"],\n})\ntelemetry\n\nEnable or disable Better Auth's telemetry collection. (default: false)\n\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  telemetry: {\n    enabled: false,\n  }\n})\nEdit on GitHub\n\nPrevious Page\n\nOptimize for Performance\n\nNext Page\n\nContributing"
  },
  {
    "title": "Atlassian | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/atlassian",
    "html": "Atlassian\nCopy Markdown\nOpen in\nGet your Credentials\nSign in to your Atlassian account and go to the Atlassian Developer Console\nClick \"Create new app\"\nFill out the app details\nConfigure your redirect URI (e.g., https://yourdomain.com/api/auth/callback/atlassian)\nNote your Client ID and Client Secret\nThe default scope is read:jira-user and offline_access. For additional scopes, refer to the Atlassian OAuth documentation.\n\nMake sure to set the redirect URI to match your application's callback URL. If you change the base path of the auth routes, you should update the redirect URI accordingly.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        atlassian: { \n            clientId: process.env.ATLASSIAN_CLIENT_ID as string, \n            clientSecret: process.env.ATLASSIAN_CLIENT_SECRET as string, \n        }, \n    },\n})\nSign In with Atlassian\n\nTo sign in with Atlassian, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to atlassian.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"atlassian\"\n    })\n}\n\nFor more information about Atlassian's OAuth scopes and API capabilities, refer to the official Atlassian OAuth 2.0 (3LO) apps documentation.\n\nEdit on GitHub\n\nPrevious Page\n\nApple\n\nNext Page\n\nCognito"
  },
  {
    "title": "Apple | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/apple",
    "html": "Apple\nCopy Markdown\nOpen in\nGet your OAuth credentials\n\nTo use Apple sign in, you need a client ID and client secret. You can get them from the Apple Developer Portal.\n\nYou will need an active Apple Developer account to access the developer portal and generate these credentials.\n\nFollow these steps to set up your App ID, Service ID, and generate the key needed for your client secret:\n\nNavigate to Certificates, Identifiers & Profiles: In the Apple Developer Portal, go to the \"Certificates, Identifiers & Profiles\" section.\n\nCreate an App ID:\n\nGo to the Identifiers tab.\nClick the + icon next to Identifiers.\nSelect App IDs, then click Continue.\nSelect App as the type, then click Continue.\nDescription: Enter a name for your app (e.g., \"My Awesome App\"). This name may be displayed to users when they sign in.\nBundle ID: Set a bundle ID. The recommended format is a reverse domain name (e.g., com.yourcompany.yourapp). Using a suffix like .ai (for app identifier) can help with organization but is not required (e.g., com.yourcompany.yourapp.ai).\nScroll down to Capabilities. Select the checkbox for Sign In with Apple.\nClick Continue, then Register.\n\nCreate a Service ID:\n\nGo back to the Identifiers tab.\nClick the + icon.\nSelect Service IDs, then click Continue.\nDescription: Enter a description for this service (e.g., your app name again).\nIdentifier: Set a unique identifier for the service. Use a reverse domain format, distinct from your App ID (e.g., com.yourcompany.yourapp.si, where .si indicates service identifier - this is for your organization and not required). This Service ID will be your clientId.\nClick Continue, then Register.\n\nConfigure the Service ID:\n\nFind the Service ID you just created in the Identifiers list and click on it.\nCheck the Sign In with Apple capability, then click Configure.\nUnder Primary App ID, select the App ID you created earlier (e.g., com.yourcompany.yourapp.ai).\nUnder Domains and Subdomains, list all the root domains you will use for Sign In with Apple (e.g., example.com, anotherdomain.com).\nUnder Return URLs, enter the callback URL. https://yourdomain.com/api/auth/callback/apple. Add all necessary return URLs.\nClick Next, then Done.\nClick Continue, then Save.\n\nCreate a Client Secret Key:\n\nGo to the Keys tab.\nClick the + icon to create a new key.\nKey Name: Enter a name for the key (e.g., \"Sign In with Apple Key\").\nScroll down and select the checkbox for Sign In with Apple.\nClick the Configure button next to Sign In with Apple.\nSelect the Primary App ID you created earlier.\nClick Save, then Continue, then Register.\nDownload the Key: Immediately download the .p8 key file. This file is only available for download once. Note the Key ID (available on the Keys page after creation) and your Team ID (available in your Apple Developer Account settings).\n\nGenerate the Client Secret (JWT): Apple requires a JSON Web Token (JWT) to be generated dynamically using the downloaded .p8 key, the Key ID, and your Team ID. This JWT serves as your clientSecret.\n\nYou can use the guide below from Apple's documentation to understand how to generate this client secret. You can also use our built in generator below to generate the client secret JWT required for 'Sign in with Apple'.\n\nNote: Apple allows a maximum expiration of 6 months (180 days) for the client secret JWT. You will need to regenerate the client secret before it expires to maintain uninterrupted authentication.\n\nConfigure the provider\n\nTo configure the provider, you need to add it to the socialProviders option of the auth instance.\n\nYou also need to add https://appleid.apple.com to the trustedOrigins array in your auth instance configuration to allow communication with Apple's authentication servers.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        apple: { \n            clientId: process.env.APPLE_CLIENT_ID as string, \n            clientSecret: process.env.APPLE_CLIENT_SECRET as string, \n            // Optional\n            appBundleIdentifier: process.env.APPLE_APP_BUNDLE_IDENTIFIER as string, \n        }, \n    },\n    // Add appleid.apple.com to trustedOrigins for Sign In with Apple flows\n    trustedOrigins: [\"https://appleid.apple.com\"], \n})\n\nOn native iOS, it doesn't use the service ID but the app ID (bundle ID) as client ID, so if using the service ID as clientId in signIn.social with idToken, it throws an error: JWTClaimValidationFailed: unexpected \"aud\" claim value. So you need to provide the appBundleIdentifier when you want to sign in with Apple using the ID Token.\n\nUsage\nSign In with Apple\n\nTo sign in with Apple, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to apple.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"apple\"\n    })\n}\nSign In with Apple With ID Token\n\nTo sign in with Apple using the ID Token, you can use the signIn.social function to pass the ID Token.\n\nThis is useful when you have the ID Token from Apple on the client-side and want to use it to sign in on the server.\n\nIf ID token is provided no redirection will happen, and the user will be signed in directly.\n\nauth-client.ts\nawait authClient.signIn.social({\n    provider: \"apple\",\n    idToken: {\n        token: // Apple ID Token,\n        nonce: // Nonce (optional)\n        accessToken: // Access Token (optional)\n    }\n})\nGenerate Apple Client Secret (JWT)\nApple Team ID\nClient ID (Service ID)\n\nThe identifier for the service you created in Apple Developer.\n\nKey ID\n\nThe ID associated with your private key (.p8 file).\n\nPrivate Key Content (.p8 file content)\n\nPaste the entire content of your .p8 private key file here. Ensure it's in PKCS#8 format.\n\nGenerate Apple Client Secret (JWT)\nEdit on GitHub\n\nPrevious Page\n\nSocial Sign-On\n\nNext Page\n\nAtlassian"
  },
  {
    "title": "Cognito | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/cognito",
    "html": "Cognito\nCopy Markdown\nOpen in\nGet your Cognito Credentials\n\nTo integrate with Cognito, you need to set up a User Pool and an App client in the Amazon Cognito Console.\n\nFollow these steps:\n\nGo to the Cognito Console and create a User Pool.\nUnder App clients, create a new App client (note the Client ID and Client Secret if enabled).\nGo to Domain and set a Cognito Hosted UI domain (e.g., your-app.auth.us-east-1.amazoncognito.com).\nIn App client settings, enable:\nAllowed OAuth flows: Authorization code grant\nAllowed OAuth scopes: openid, profile, email\nAdd your callback URL (e.g., http://localhost:3000/api/auth/callback/cognito).\nUser Pool is required for Cognito authentication.\nMake sure the callback URL matches exactly what you configure in Cognito.\nConfigure the provider\n\nConfigure the cognito key in socialProviders key of your auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  socialProviders: {\n    cognito: {\n      clientId: process.env.COGNITO_CLIENT_ID as string, \n      clientSecret: process.env.COGNITO_CLIENT_SECRET as string, \n      domain: process.env.COGNITO_DOMAIN as string, // e.g. \"your-app.auth.us-east-1.amazoncognito.com\"\n      region: process.env.COGNITO_REGION as string, // e.g. \"us-east-1\"\n      userPoolId: process.env.COGNITO_USERPOOL_ID as string, \n    },\n  },\n})\nSign In with Cognito\n\nTo sign in with Cognito, use the signIn.social function from the client.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient = createAuthClient()\nconst signIn = async () => {\n  const data = await authClient.signIn.social({\n    provider: \"cognito\"\n  })\n}\nAdditional Options:\nscope: Additional OAuth2 scopes to request (combined with default permissions).\nDefault: \"openid\" \"profile\" \"email\"\nCommon Cognito scopes:\nopenid: Required for OpenID Connect authentication\nprofile: Access to basic profile info\nemail: Access to userâ€™s email\nphone: Access to userâ€™s phone number\naws.cognito.signin.user.admin: Grants access to Cognito-specific APIs\nNote: You must configure the scopes in your Cognito App Client settings. available scopes\ngetUserInfo: Custom function to retrieve user information from the Cognito UserInfo endpoint.\n\nFor more information about Amazon Cognito's scopes and API capabilities, refer to the official documentation.\n\nEdit on GitHub\n\nPrevious Page\n\nAtlassian\n\nNext Page\n\nDiscord"
  },
  {
    "title": "Discord | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/discord",
    "html": "Discord\nCopy Markdown\nOpen in\nGet your Discord credentials\n\nTo use Discord sign in, you need a client ID and client secret. You can get them from the Discord Developer Portal.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/discord for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({ \n    socialProviders: {\n        discord: { \n            clientId: process.env.DISCORD_CLIENT_ID as string, \n            clientSecret: process.env.DISCORD_CLIENT_SECRET as string, \n        }, \n    },\n})\nUsage\nSign In with Discord\n\nTo sign in with Discord, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to discord.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"discord\"\n    })\n}\nOptions\n\nFor the full list of options supported by all social providers, check the Provider Options.\n\nBot Permissions (Optional)\n\nIf you're using the bot scope with Discord OAuth, you can specify bot permissions using the permissions option. It can either be a bitwise value (e.g 2048 | 16384 for Send Messages and Embed Links) or a specific permission value (e.g 16384 for Embed Links).\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({ \n    socialProviders: {\n        discord: {\n            clientId: process.env.DISCORD_CLIENT_ID as string,\n            clientSecret: process.env.DISCORD_CLIENT_SECRET as string,\n            permissions: 2048 | 16384, // Send Messages + Embed Links\n        }, \n    },\n})\n\nNote: The permissions parameter only works when the bot scope is included in your OAuth2 scopes. Read more about Discord bot permissions.\n\nEdit on GitHub\n\nPrevious Page\n\nCognito\n\nNext Page\n\nFacebook"
  },
  {
    "title": "Figma | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/figma",
    "html": "Figma\nCopy Markdown\nOpen in\nGet your Credentials\nSign in to your Figma account and go to the Developer Apps page\nClick \"Create new app\"\nFill out the app details (name, description, etc.)\nConfigure your redirect URI (e.g., https://yourdomain.com/api/auth/callback/figma)\nNote your Client ID and Client Secret\nThe default scope is file_read. For additional scopes like file_write, refer to the Figma OAuth documentation.\n\nMake sure to set the redirect URI to match your application's callback URL. If you change the base path of the auth routes, you should update the redirect URI accordingly.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        figma: { \n            clientId: process.env.FIGMA_CLIENT_ID as string, \n            clientSecret: process.env.FIGMA_CLIENT_SECRET as string, \n            clientKey: process.env.FIGMA_CLIENT_KEY as string, \n        }, \n    },\n})\nSign In with Figma\n\nTo sign in with Figma, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to figma.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"figma\"\n    })\n}\n\nFor more information about Figma's OAuth scopes and API capabilities, refer to the official Figma API documentation.\n\nEdit on GitHub\n\nPrevious Page\n\nFacebook\n\nNext Page\n\nGitHub"
  },
  {
    "title": "Facebook | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/facebook",
    "html": "Facebook\nCopy Markdown\nOpen in\nGet your Facebook credentials\n\nTo use Facebook sign in, you need a client ID and client Secret. You can get them from the Facebook Developer Portal. Select your app, navigate to App Settings > Basic, locate the following:\n\nApp ID: This is your clientId\nApp Secret: This is your clientSecret.\n\nAvoid exposing the clientSecret in client-side code (e.g., frontend apps) because itâ€™s sensitive information.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/facebook for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        facebook: { \n            clientId: process.env.FACEBOOK_CLIENT_ID as string, \n            clientSecret: process.env.FACEBOOK_CLIENT_SECRET as string, \n        }, \n    },\n})\n\nBetterAuth also supports Facebook Login for Business, all you need to do is provide the configId as listed in Facebook Login For Business > Configurations alongside your clientId and clientSecret. Note that the app must be a Business app and, since BetterAuth expects to have an email address and account id, the configuration must be of the \"User access token\" type. \"System-user access token\" is not supported.\n\nSign In with Facebook\n\nTo sign in with Facebook, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to facebook.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/auth-client\"\nconst authClient = createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"facebook\"\n    })\n}\nAdditional Configuration\nScopes\n\nBy default, Facebook provides basic user information. If you need additional permissions, you can specify scopes in your auth configuration:\n\nauth.ts\nexport const auth = betterAuth({\n    socialProviders: {\n        facebook: {\n            clientId: process.env.FACEBOOK_CLIENT_ID as string,\n            clientSecret: process.env.FACEBOOK_CLIENT_SECRET as string,\n            scopes: [\"email\", \"public_profile\", \"user_friends\"], // Overwrites permissions\n            fields: [\"user_friends\"], // Extending list of fields\n        },\n    },\n})\n\nAdditional options:\n\nscopes: Access basic account information (overwrites).\nDefault: \"email\", \"public_profile\"\nfields: Extend list of fields to retrieve from the Facebook user profile (assignment).\nDefault: \"id\", \"name\", \"email\", \"picture\"\nSign In with Facebook With ID or Access Token\n\nTo sign in with Facebook using the ID Token, you can use the signIn.social function to pass the ID Token.\n\nThis is useful when you have the ID Token from Facebook on the client-side and want to use it to sign in on the server.\n\nIf ID token is provided no redirection will happen, and the user will be signed in directly.\n\nFor limited login, you need to pass idToken.token, for only accessToken you need to pass idToken.accessToken and idToken.token together because of (#1183)[https://github.com/better-auth/better-auth/issues/1183].\n\nauth-client.ts\nconst data = await authClient.signIn.social({\n    provider: \"facebook\",\n    idToken: {  \n        ...(platform === 'ios' ?\n            { token: idToken }  \n            : { token: accessToken, accessToken: accessToken }), \n    },\n})\n\nFor a complete list of available permissions, refer to the Permissions Reference.\n\nEdit on GitHub\n\nPrevious Page\n\nDiscord\n\nNext Page\n\nFigma"
  },
  {
    "title": "GitHub | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/github",
    "html": "GitHub\nCopy Markdown\nOpen in\nGet your GitHub credentials\n\nTo use GitHub sign in, you need a client ID and client secret. You can get them from the GitHub Developer Portal.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/github for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nImportant: You MUST include the user:email scope in your GitHub app. See details below.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        github: { \n            clientId: process.env.GITHUB_CLIENT_ID as string, \n            clientSecret: process.env.GITHUB_CLIENT_SECRET as string, \n        }, \n    },\n})\nSign In with GitHub\n\nTo sign in with GitHub, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to github.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"github\"\n    })\n}\nUsage\nSetting up your Github app\n\nGithub has two types of apps: Github apps and OAuth apps.\n\nFor OAuth apps, you don't have to do anything special (just follow the steps above). For Github apps, you DO have to add one more thing, which is enable it to read the user's email:\n\nAfter creating your app, go to Permissions and Events > Account Permissions > Email Addresses and select \"Read-Only\"\n\nSave changes.\n\nThat's all! Now you can copy the Client ID and Client Secret of your app!\n\nIf you get \"email_not_found\" error, it's because you selected a Github app & did not configure this part!\n\nWhy don't I have a refresh token?\n\nGithub doesn't issue refresh tokens for OAuth apps. For regular OAuth apps, GitHub issues access tokens that remain valid indefinitely unless the user revokes them, the app revokes them, or they go unused for a year. There's no need for a refresh token because the access token doesn't expire on a short interval like Google or Discord.\n\nEdit on GitHub\n\nPrevious Page\n\nFigma\n\nNext Page\n\nGoogle"
  },
  {
    "title": "Google | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/google",
    "html": "Google\nCopy Markdown\nOpen in\nGet your Google credentials\n\nTo use Google as a social provider, you need to get your Google credentials. You can get them by creating a new project in the Google Cloud Console.\n\nIn the Google Cloud Console > Credentials > Authorized redirect URIs, make sure to set the redirect URL to http://localhost:3000/api/auth/callback/google for local development. For production, make sure to set the redirect URL as your application domain, e.g. https://example.com/api/auth/callback/google. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nConfigure the provider\n\nTo configure the provider, you need to pass the clientId and clientSecret to socialProviders.google in your auth configuration.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        google: { \n            clientId: process.env.GOOGLE_CLIENT_ID as string, \n            clientSecret: process.env.GOOGLE_CLIENT_SECRET as string, \n        }, \n    },\n})\nUsage\nSign In with Google\n\nTo sign in with Google, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to google.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nconst authClient = createAuthClient();\nconst signIn = async () => {\n  const data = await authClient.signIn.social({\n    provider: \"google\",\n  });\n};\nSign In with Google With ID Token\n\nTo sign in with Google using the ID Token, you can use the signIn.social function to pass the ID Token.\n\nThis is useful when you have the ID Token from Google on the client-side and want to use it to sign in on the server.\n\nIf ID token is provided no redirection will happen, and the user will be signed in directly.\n\nauth-client.ts\nconst data = await authClient.signIn.social({\n    provider: \"google\",\n    idToken: {\n        token: // Google ID Token,\n        accessToken: // Google Access Token\n    }\n})\n\nIf you want to use google one tap, you can use the One Tap Plugin guide.\n\nAlways ask to select an account\n\nIf you want to always ask the user to select an account, you pass the prompt parameter to the provider, setting it to select_account.\n\nsocialProviders: {\n    google: {\n        prompt: \"select_account\", \n        clientId: process.env.GOOGLE_CLIENT_ID as string,\n        clientSecret: process.env.GOOGLE_CLIENT_SECRET as string,\n    },\n}\nRequesting Additional Google Scopes\n\nIf your application needs additional Google scopes after the user has already signed up (e.g., for Google Drive, Gmail, or other Google services), you can request them using the linkSocial method with the same Google provider.\n\nauth-client.ts\nconst requestGoogleDriveAccess = async () => {\n  await authClient.linkSocial({\n    provider: \"google\",\n    scopes: [\"https://www.googleapis.com/auth/drive.file\"],\n  });\n};\n// Example usage in a React component\nreturn (\n  <button onClick={requestGoogleDriveAccess}>\n    Add Google Drive Permissions\n  </button>\n);\n\nThis will trigger a new OAuth flow that requests the additional scopes. After completion, your account will have the new scope in the database, and the access token will give you access to the requested Google APIs.\n\nEnsure you're using Better Auth version 1.2.7 or later to avoid \"Social account already linked\" errors when requesting additional scopes from the same provider.\n\nAlways get refresh token\n\nGoogle only issues a refresh token the first time a user consents to your app. If the user has already authorized your app, subsequent OAuth flows will only return an access token, not a refresh token.\n\nTo always get a refresh token, you can set the accessType to offline, and prompt to select_account consent in the provider options.\n\nsocialProviders: {\n    google: {\n        clientId: process.env.GOOGLE_CLIENT_ID as string,\n        clientSecret: process.env.GOOGLE_CLIENT_SECRET as string,\n        accessType: \"offline\", \n        prompt: \"select_account consent\", \n    },\n}\n\nRevoking Access: If you want to get a new refresh token for a user who has already authorized your app, you must have them revoke your app's access in their Google account settings, then re-authorize.\n\nEdit on GitHub\n\nPrevious Page\n\nGitHub\n\nNext Page\n\nLINE"
  },
  {
    "title": "LINE | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/line",
    "html": "LINE\nCopy Markdown\nOpen in\nGet your LINE credentials\nCreate a channel in the LINE Developers Console.\nNote your Channel ID (client_id) and Channel secret (client_secret).\nIn the channel settings, add your Redirect URI, e.g. http://localhost:3000/api/auth/callback/line for local development.\nEnable required scopes (at least openid; add profile, email if you need name, avatar, email).\n\nSee LINE Login v2.1 reference for details: [https://developers.line.biz/en/reference/line-login/#issue-access-token]\n\nConfigure the provider\n\nAdd your LINE credentials to socialProviders.line in your auth configuration.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  socialProviders: {\n    line: {\n      clientId: process.env.LINE_CLIENT_ID as string,\n      clientSecret: process.env.LINE_CLIENT_SECRET as string,\n      // Optional: override redirect if needed\n      // redirectURI: \"https://your.app/api/auth/callback/line\",\n      // scopes are prefilled: [\"openid\",\"profile\",\"email\"]. Append if needed\n    },\n  },\n});\nUsage\nSign In with LINE\n\nUse the client signIn.social with provider: \"line\".\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nconst authClient = createAuthClient();\nasync function signInWithLINE() {\n  const res = await authClient.signIn.social({ provider: \"line\" });\n}\nSign In with LINE using ID Token (optional)\n\nIf you obtain the LINE ID token on the client, you can sign in directly without redirection.\n\nauth-client.ts\nawait authClient.signIn.social({\n  provider: \"line\",\n  idToken: {\n    token: \"<LINE_ID_TOKEN>\",\n    accessToken: \"<LINE_ACCESS_TOKEN>\",\n  },\n});\nNotes\nDefault scopes include openid profile email. Adjust as needed via provider options.\nVerify redirect URI exactly matches the value configured in LINE Developers Console.\nLINE ID token verification uses the official endpoint and checks audience and optional nonce per spec.\n\nDesigning a login button? Follow LINE's button guidelines.\n\nEdit on GitHub\n\nPrevious Page\n\nGoogle\n\nNext Page\n\nHugging Face"
  },
  {
    "title": "Hugging Face | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/huggingface",
    "html": "Hugging Face\nCopy Markdown\nOpen in\nGet your Hugging Face credentials\n\nTo use Hugging Face sign in, you need a client ID and client secret. Hugging Face OAuth documentation. Make sure the created oauth app on Hugging Face has the \"email\" scope.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/huggingface for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        huggingface: { \n            clientId: process.env.HUGGINGFACE_CLIENT_ID as string, \n            clientSecret: process.env.HUGGINGFACE_CLIENT_SECRET as string, \n        }, \n    },\n})\nSign In with Hugging Face\n\nTo sign in with Hugging Face, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to huggingface.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"huggingface\"\n    })\n}\nEdit on GitHub\n\nPrevious Page\n\nLINE\n\nNext Page\n\nKakao"
  },
  {
    "title": "Kakao | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/kakao",
    "html": "Kakao\nCopy Markdown\nOpen in\nGet your Kakao Credentials\n\nTo use Kakao sign in, you need a client ID and client secret. You can get them from the Kakao Developer Portal.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/kakao for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        kakao: { \n            clientId: process.env.KAKAO_CLIENT_ID as string, \n            clientSecret: process.env.KAKAO_CLIENT_SECRET as string, \n        }, \n    }\n})\nSign In with Kakao\n\nTo sign in with Kakao, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to kakao.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"kakao\"\n    })\n}\nEdit on GitHub\n\nPrevious Page\n\nHugging Face\n\nNext Page\n\nKick"
  },
  {
    "title": "Kick | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/kick",
    "html": "Kick\nCopy Markdown\nOpen in\nGet your Kick Credentials\n\nTo use Kick sign in, you need a client ID and client secret. You can get them from the Kick Developer Portal.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/kick for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        kick: { \n            clientId: process.env.KICK_CLIENT_ID as string, \n            clientSecret: process.env.KICK_CLIENT_SECRET as string, \n        }, \n    }\n})\nSign In with Kick\n\nTo sign in with Kick, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to kick.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"kick\"\n    })\n}\nEdit on GitHub\n\nPrevious Page\n\nKakao\n\nNext Page\n\nMicrosoft"
  },
  {
    "title": "Microsoft | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/microsoft",
    "html": "Microsoft\nCopy Markdown\nOpen in\n\nEnabling OAuth with Microsoft Azure Entra ID (formerly Active Directory) allows your users to sign in and sign up to your application with their Microsoft account.\n\nGet your Microsoft credentials\n\nTo use Microsoft as a social provider, you need to get your Microsoft credentials. Which involves generating your own Client ID and Client Secret using your Microsoft Entra ID dashboard account.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/microsoft for local development. For production, you should change it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nsee the Microsoft Entra ID documentation for more information.\n\nConfigure the provider\n\nTo configure the provider, you need to pass the clientId and clientSecret to socialProviders.microsoft in your auth configuration.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        microsoft: { \n            clientId: process.env.MICROSOFT_CLIENT_ID as string, \n            clientSecret: process.env.MICROSOFT_CLIENT_SECRET as string, \n            // Optional\n            tenantId: 'common', \n            authority: \"https://login.microsoftonline.com\", // Authentication authority URL\n            prompt: \"select_account\", // Forces account selection\n        }, \n    },\n})\n\nAuthority URL: Use the default https://login.microsoftonline.com for standard Entra ID scenarios or https://<tenant-id>.ciamlogin.com for CIAM (Customer Identity and Access Management) scenarios.\n\nSign In with Microsoft\n\nTo sign in with Microsoft, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to microsoft.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nconst authClient = createAuthClient();\nconst signIn = async () => {\n  const data = await authClient.signIn.social({\n    provider: \"microsoft\",\n    callbackURL: \"/dashboard\", // The URL to redirect to after the sign in\n  });\n};\nEdit on GitHub\n\nPrevious Page\n\nKick\n\nNext Page\n\nPayPal"
  },
  {
    "title": "PayPal | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/paypal",
    "html": "PayPal\nCopy Markdown\nOpen in\nGet your PayPal Credentials\n\nTo integrate with PayPal, you need to obtain API credentials by creating an application in the PayPal Developer Portal.\n\nFollow these steps:\n\nCreate an account on the PayPal Developer Portal\nCreate a new application, official docs\nConfigure Log in with PayPal under \"Other features\"\nSet up your Return URL (redirect URL)\nConfigure user information permissions\nNote your Client ID and Client Secret\nPayPal has two environments: Sandbox (for testing) and Live (for production)\nFor testing, create sandbox test accounts in the Developer Dashboard under \"Sandbox\" â†’ \"Accounts\"\nYou cannot use your real PayPal account to test in sandbox mode - you must use the generated test accounts\nThe Return URL in your PayPal app settings must exactly match your redirect URI\nThe PayPal API does not work with localhost. You need to use a public domain for the redirect URL and HTTPS for local testing. You can use NGROK or another similar tool for this.\n\nMake sure to configure \"Log in with PayPal\" in your app settings:\n\nGo to your app in the Developer Dashboard\nUnder \"Other features\", check \"Log in with PayPal\"\nClick \"Advanced Settings\"\nEnter your Return URL\nSelect the user information you want to access (email, name, etc.)\nEnter Privacy Policy and User Agreement URLs\nPayPal doesn't use traditional OAuth2 scopes in the authorization URL. Instead, you configure permissions directly in the Developer Dashboard\nFor live apps, PayPal must review and approve your application before it can go live, which typically takes a few weeks\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        paypal: { \n            clientId: process.env.PAYPAL_CLIENT_ID as string, \n            clientSecret: process.env.PAYPAL_CLIENT_SECRET as string, \n            environment: \"sandbox\", // or \"live\" for production //,\n        }, \n    },\n})\nOptions\n\nThe PayPal provider accepts the following options:\n\nenvironment: 'sandbox' | 'live' - PayPal environment to use (default: 'sandbox')\nrequestShippingAddress: boolean - Whether to request shipping address information (default: false)\nauth.ts\nexport const auth = betterAuth({\n    socialProviders: {\n        paypal: {\n            clientId: process.env.PAYPAL_CLIENT_ID as string,\n            clientSecret: process.env.PAYPAL_CLIENT_SECRET as string,\n            environment: \"live\", // Use \"live\" for production\n            requestShippingAddress: true, // Request address info\n        },\n    },\n})\nSign In with PayPal\n\nTo sign in with PayPal, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to paypal.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"paypal\"\n    })\n}\nAdditional Options:\nenvironment: PayPal environment to use.\nDefault: \"sandbox\"\nOptions: \"sandbox\" | \"live\"\nrequestShippingAddress: Whether to request shipping address information.\nDefault: false\nscope: Additional scopes to request (combined with default permissions).\nDefault: Configured in PayPal Developer Dashboard\nNote: PayPal doesn't use traditional OAuth2 scopes - permissions are set in the Dashboard For more details refer to the Scopes Reference\nmapProfileToUser: Custom function to map PayPal profile data to user object.\ngetUserInfo: Custom function to retrieve user information. For more details refer to the User Reference\nverifyIdToken: Custom ID token verification function.\nEdit on GitHub\n\nPrevious Page\n\nMicrosoft\n\nNext Page\n\nSalesforce"
  },
  {
    "title": "Salesforce | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/salesforce",
    "html": "Salesforce\nCopy Markdown\nOpen in\nGet your Salesforce Credentials\nLog into your Salesforce org (Production or Developer Edition)\nNavigate to Setup > App Manager\nClick New Connected App\nFill in the basic information:\nConnected App Name: Your app name\nAPI Name: Auto-generated from app name\nContact Email: Your email address\nEnable OAuth Settings:\nCheck Enable OAuth Settings\nSet Callback URL to your redirect URI (e.g., http://localhost:3000/api/auth/callback/salesforce for development)\nSelect Required OAuth Scopes:\nAccess your basic information (id)\nAccess your identity URL service (openid)\nAccess your email address (email)\nPerform requests on your behalf at any time (refresh_token, offline_access)\nEnable Require Proof Key for Code Exchange (PKCE) (required)\nSave and note your Consumer Key (Client ID) and Consumer Secret (Client Secret)\nFor development, you can use http://localhost:3000 URLs, but production requires HTTPS\nThe callback URL must exactly match what's configured in Better Auth\nPKCE (Proof Key for Code Exchange) is required by Salesforce and is automatically handled by the provider\n\nFor sandbox testing, you can create the Connected App in your sandbox org, or use the same Connected App but specify environment: \"sandbox\" in the provider configuration.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        salesforce: { \n            clientId: process.env.SALESFORCE_CLIENT_ID as string, \n            clientSecret: process.env.SALESFORCE_CLIENT_SECRET as string, \n            environment: \"production\", // or \"sandbox\"\n        }, \n    },\n})\nConfiguration Options\nclientId: Your Connected App's Consumer Key\nclientSecret: Your Connected App's Consumer Secret\nenvironment: \"production\" (default) or \"sandbox\"\nloginUrl: Custom My Domain URL (without https://) - overrides environment setting\nredirectURI: Override the auto-generated redirect URI if needed\nAdvanced Configuration\nauth.ts\nexport const auth = betterAuth({\n    socialProviders: {\n        salesforce: {\n            clientId: process.env.SALESFORCE_CLIENT_ID as string,\n            clientSecret: process.env.SALESFORCE_CLIENT_SECRET as string,\n            environment: \"sandbox\", \n            loginUrl: \"mycompany.my.salesforce.com\", // Custom My Domain\n            redirectURI: \"http://localhost:3000/api/auth/callback/salesforce\", // Override if needed\n        },\n    },\n})\nUse environment: \"sandbox\" for testing with Salesforce sandbox orgs\nThe loginUrl option is useful for organizations with My Domain enabled\nThe redirectURI option helps resolve redirect URI mismatch errors\nEnvironment Variables\n\nAdd the following environment variables to your .env.local file:\n\n.env.local\nSALESFORCE_CLIENT_ID=your_consumer_key_here\nSALESFORCE_CLIENT_SECRET=your_consumer_secret_here\nBETTER_AUTH_URL=http://localhost:3000 # Important for redirect URI generation\n\nFor production:\n\n.env\nSALESFORCE_CLIENT_ID=your_consumer_key_here\nSALESFORCE_CLIENT_SECRET=your_consumer_secret_here\nBETTER_AUTH_URL=https://yourdomain.com\nSign In with Salesforce\n\nTo sign in with Salesforce, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to salesforce.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient = createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"salesforce\"\n    })\n}\nTroubleshooting\nRedirect URI Mismatch Error\n\nIf you encounter a redirect_uri_mismatch error:\n\nCheck Callback URL: Ensure the Callback URL in your Salesforce Connected App exactly matches your Better Auth callback URL\nProtocol: Make sure you're using the same protocol (http:// vs https://)\nPort: Verify the port number matches (e.g., :3000)\nOverride if needed: Use the redirectURI option to explicitly set the redirect URI\nsalesforce: {\n    clientId: process.env.SALESFORCE_CLIENT_ID as string,\n    clientSecret: process.env.SALESFORCE_CLIENT_SECRET as string,\n    redirectURI: \"http://localhost:3000/api/auth/callback/salesforce\", \n}\nEnvironment Issues\nProduction: Use environment: \"production\" (default) with login.salesforce.com\nSandbox: Use environment: \"sandbox\" with test.salesforce.com\nMy Domain: Use loginUrl: \"yourcompany.my.salesforce.com\" for custom domains\nPKCE Requirements\n\nSalesforce requires PKCE (Proof Key for Code Exchange) which is automatically handled by this provider. Make sure PKCE is enabled in your Connected App settings.\n\nThe default scopes requested are openid, email, and profile. The provider will automatically include the id scope for accessing basic user information.\n\nEdit on GitHub\n\nPrevious Page\n\nPayPal\n\nNext Page\n\nSlack"
  },
  {
    "title": "Slack | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/slack",
    "html": "Slack\nCopy Markdown\nOpen in\nGet your Slack credentials\n\nTo use Slack as a social provider, you need to create a Slack app and get your credentials.\n\nGo to Your Apps on Slack API and click \"Create New App\"\nChoose \"From scratch\" and give your app a name and select a development workspace\nIn your app settings, navigate to \"OAuth & Permissions\"\nUnder \"Redirect URLs\", add your redirect URL:\nFor local development: http://localhost:3000/api/auth/callback/slack\nFor production: https://yourdomain.com/api/auth/callback/slack\nCopy your Client ID and Client Secret from the \"Basic Information\" page\n\nSlack requires HTTPS for redirect URLs in production. For local development, you can use tools like ngrok to create a secure tunnel.\n\nConfigure the provider\n\nTo configure the provider, you need to pass the clientId and clientSecret to socialProviders.slack in your auth configuration.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        slack: { \n            clientId: process.env.SLACK_CLIENT_ID as string, \n            clientSecret: process.env.SLACK_CLIENT_SECRET as string, \n        }, \n    },\n})\nUsage\nSign In with Slack\n\nTo sign in with Slack, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to slack.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nconst authClient = createAuthClient();\nconst signIn = async () => {\n  const data = await authClient.signIn.social({ provider: \"slack\" });\n};\nRequesting Additional Scopes\n\nBy default, Slack uses OpenID Connect scopes: openid, profile, and email. You can request additional Slack scopes during sign-in:\n\nauth-client.ts\nconst signInWithSlack = async () => {\n  await authClient.signIn.social({\n    provider: \"slack\",\n    scopes: [\"channels:read\", \"chat:write\"], // Additional Slack API scopes\n  });\n};\nWorkspace-Specific Sign In\n\nIf you want to restrict sign-in to a specific Slack workspace, you can pass the team parameter:\n\nauth.ts\nsocialProviders: {\n    slack: {\n        clientId: process.env.SLACK_CLIENT_ID as string,\n        clientSecret: process.env.SLACK_CLIENT_SECRET as string,\n        team: \"T1234567890\", // Your Slack workspace ID\n    },\n}\nUsing Slack API After Sign In\n\nAfter successful authentication, you can access the user's Slack information through the session. The access token can be used to make requests to the Slack API:\n\nconst session = await authClient.getSession();\nif (session?.user) {\n  // Access Slack-specific data\n  const slackUserId = session.user.id; // This is the Slack user ID\n  // The access token is stored securely on the server\n}\n\nThe Slack provider uses OpenID Connect by default, which provides basic user information. If you need to access other Slack APIs, make sure to request the appropriate scopes during sign-in.\n\nEdit on GitHub\n\nPrevious Page\n\nSalesforce\n\nNext Page\n\nNotion"
  },
  {
    "title": "Notion | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/notion",
    "html": "Notion\nCopy Markdown\nOpen in\nGet your Notion credentials\n\nTo use Notion as a social provider, you need to get your Notion OAuth credentials. You can get them by creating a new integration in the Notion Developers Portal.\n\nIn the Notion integration settings > OAuth Domain & URIs, make sure to set the redirect URL to http://localhost:3000/api/auth/callback/notion for local development. For production, make sure to set the redirect URL as your application domain, e.g. https://example.com/api/auth/callback/notion. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nMake sure your Notion integration has the appropriate capabilities enabled. For user authentication, you'll need the \"Read user information including email addresses\" capability.\n\nConfigure the provider\n\nTo configure the provider, you need to pass the clientId and clientSecret to socialProviders.notion in your auth configuration.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        notion: { \n            clientId: process.env.NOTION_CLIENT_ID as string, \n            clientSecret: process.env.NOTION_CLIENT_SECRET as string, \n        }, \n    },\n})\nUsage\nSign In with Notion\n\nTo sign in with Notion, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to notion.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"notion\"\n    })\n}\nNotion Integration Types\n\nNotion supports different integration types. When creating your integration, you can choose between:\n\nPublic integrations: Can be installed by any Notion workspace\nInternal integrations: Limited to your own workspace\n\nFor most authentication use cases, you'll want to create a public integration to allow users from different workspaces to sign in.\n\nRequesting Additional Notion Scopes\n\nIf your application needs additional Notion capabilities after the user has already signed up, you can request them using the linkSocial method with the same Notion provider and additional scopes.\n\nauth-client.ts\nconst requestNotionAccess = async () => {\n    await authClient.linkSocial({\n        provider: \"notion\",\n        // Notion automatically provides access based on integration capabilities\n    });\n};\n// Example usage in a React component\nreturn <button onClick={requestNotionAccess}>Connect Notion Workspace</button>;\n\nAfter authentication, you can use the access token to interact with the Notion API to read and write pages, databases, and other content that the user has granted access to.\n\nEdit on GitHub\n\nPrevious Page\n\nSlack\n\nNext Page\n\nNaver"
  },
  {
    "title": "Naver | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/naver",
    "html": "Naver\nCopy Markdown\nOpen in\nGet your Naver Credentials\n\nTo use Naver sign in, you need a client ID and client secret. You can get them from the Naver Developers.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/naver for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        naver: { \n            clientId: process.env.NAVER_CLIENT_ID as string, \n            clientSecret: process.env.NAVER_CLIENT_SECRET as string, \n        }, \n    }\n})\nSign In with Naver\n\nTo sign in with Naver, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to naver.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"naver\"\n    })\n}\nEdit on GitHub\n\nPrevious Page\n\nNotion\n\nNext Page\n\nTiktok"
  },
  {
    "title": "TikTok | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/tiktok",
    "html": "TikTok\nCopy Markdown\nOpen in\nGet your TikTok Credentials\n\nTo integrate with TikTok, you need to obtain API credentials by creating an application in the TikTok Developer Portal.\n\nFollow these steps:\n\nCreate an account on the TikTok Developer Portal\nCreate a new application\nSet up a sandbox environment for testing\nConfigure your redirect URL (must be HTTPS)\nNote your Client Secret and Client Key\nThe TikTok API does not work with localhost. You need to use a public domain for the redirect URL and HTTPS for local testing. You can use NGROK or another similar tool for this.\nFor testing, you will need to use the Sandbox mode, which you can enable in the TikTok Developer Portal.\nThe default scope is user.info.profile. For additional scopes, refer to the Available Scopes documentation.\n\nMake sure to set the redirect URL to a valid HTTPS domain for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nThe TikTok API does not provide email addresses. As a workaround, this implementation uses the user's username value for the email field, which is why it requires the user.info.profile scope instead of just user.info.basic.\nFor production use, you will need to request approval from TikTok for the scopes you intend to use.\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        tiktok: { \n            clientSecret: process.env.TIKTOK_CLIENT_SECRET as string, \n            clientKey: process.env.TIKTOK_CLIENT_KEY as string, \n        }, \n    },\n})\nSign In with TikTok\n\nTo sign in with TikTok, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to tiktok.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"tiktok\"\n    })\n}\nEdit on GitHub\n\nPrevious Page\n\nNaver\n\nNext Page\n\nTwitch"
  },
  {
    "title": "Twitch | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/twitch",
    "html": "Twitch\nCopy Markdown\nOpen in\nGet your Twitch Credentials\n\nTo use Twitch sign in, you need a client ID and client secret. You can get them from the Twitch Developer Portal.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/twitch for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        twitch: { \n            clientId: process.env.TWITCH_CLIENT_ID as string, \n            clientSecret: process.env.TWITCH_CLIENT_SECRET as string, \n        }, \n    }\n})\nSign In with Twitch\n\nTo sign in with Twitch, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to twitch.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"twitch\"\n    })\n}\nEdit on GitHub\n\nPrevious Page\n\nTiktok\n\nNext Page\n\nTwitter (X)"
  },
  {
    "title": "Twitter (X) | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/twitter",
    "html": "Twitter (X)\nCopy Markdown\nOpen in\nGet your Twitter Credentials\n\nGet your Twitter credentials from the Twitter Developer Portal.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/twitter for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nTwitter API v2 now supports email address retrieval. Make sure to request the user.email scope when configuring your Twitter app to enable this feature.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\" \nexport const auth = betterAuth({\n    socialProviders: {\n        twitter: { \n            clientId: process.env.TWITTER_CLIENT_ID as string, \n            clientSecret: process.env.TWITTER_CLIENT_SECRET as string, \n        }, \n    },\n})\nSign In with Twitter\n\nTo sign in with Twitter, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to twitter.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"twitter\"\n    })\n}\nEdit on GitHub\n\nPrevious Page\n\nTwitch\n\nNext Page\n\nDropbox"
  },
  {
    "title": "Dropbox | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/dropbox",
    "html": "Dropbox\nCopy Markdown\nOpen in\nGet your Dropbox credentials\n\nTo use Dropbox sign in, you need a client ID and client secret. You can get them from the Dropbox Developer Portal. You can Allow \"Implicit Grant & PKCE\" for the application in the App Console.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/dropbox for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nIf you need deeper dive into Dropbox Authentication, you can check out the official documentation.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        dropbox: { \n            clientId: process.env.DROPBOX_CLIENT_ID as string, \n            clientSecret: process.env.DROPBOX_CLIENT_SECRET as string, \n        }, \n    },\n})\nSign In with Dropbox\n\nTo sign in with Dropbox, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to dropbox.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"dropbox\"\n    })\n}\nEdit on GitHub\n\nPrevious Page\n\nTwitter (X)\n\nNext Page\n\nLinear"
  },
  {
    "title": "Linear | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/linear",
    "html": "Linear\nCopy Markdown\nOpen in\nGet your Linear credentials\n\nTo use Linear sign in, you need a client ID and client secret. You can get them from the Linear Developer Portal.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/linear for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nWhen creating your OAuth application in Linear, you'll need to specify the required scopes. The default scope is read, but you can also request additional scopes like write if needed.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        linear: { \n            clientId: process.env.LINEAR_CLIENT_ID as string, \n            clientSecret: process.env.LINEAR_CLIENT_SECRET as string, \n        }, \n    },\n})\nSign In with Linear\n\nTo sign in with Linear, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to linear.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient = createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"linear\"\n    })\n}\nAvailable scopes\n\nLinear OAuth supports the following scopes:\n\nread (default): Read access for the user's account\nwrite: Write access for the user's account\nissues:create: Allows creating new issues and their attachments\ncomments:create: Allows creating new issue comments\ntimeSchedule:write: Allows creating and modifying time schedules\nadmin: Full access to admin level endpoints (use with caution)\n\nYou can specify additional scopes when configuring the provider:\n\nauth.ts\nexport const auth = betterAuth({\n    socialProviders: {\n        linear: {\n            clientId: process.env.LINEAR_CLIENT_ID as string,\n            clientSecret: process.env.LINEAR_CLIENT_SECRET as string,\n            scope: [\"read\", \"write\"] \n        },\n    },\n})\nEdit on GitHub\n\nPrevious Page\n\nDropbox\n\nNext Page\n\nLinkedIn"
  },
  {
    "title": "LinkedIn | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/linkedin",
    "html": "LinkedIn\nCopy Markdown\nOpen in\nGet your LinkedIn credentials\n\nTo use LinkedIn sign in, you need a client ID and client secret. You can get them from the LinkedIn Developer Portal.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/linkedin for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nIn the LinkedIn portal under products you need the Sign In with LinkedIn using OpenID Connect product.\n\nThere are some different Guides here: Authorization Code Flow (3-legged OAuth) (Outdated) Sign In with LinkedIn using OpenID Connect\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        linkedin: { \n            clientId: process.env.LINKEDIN_CLIENT_ID as string, \n            clientSecret: process.env.LINKEDIN_CLIENT_SECRET as string, \n        }, \n    },\n})\nSign In with LinkedIn\n\nTo sign in with LinkedIn, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to linkedin.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"linkedin\"\n    })\n}\nEdit on GitHub\n\nPrevious Page\n\nLinear\n\nNext Page\n\nGitLab"
  },
  {
    "title": "GitLab | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/gitlab",
    "html": "GitLab\nCopy Markdown\nOpen in\nGet your GitLab credentials\n\nTo use GitLab sign in, you need a client ID and client secret. GitLab OAuth documentation.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/gitlab for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        gitlab: { \n            clientId: process.env.GITLAB_CLIENT_ID as string, \n            clientSecret: process.env.GITLAB_CLIENT_SECRET as string, \n            issuer: process.env.GITLAB_ISSUER as string, \n        }, \n    },\n})\nConfiguration Options\nclientId: Your GitLab application's Client ID\nclientSecret: Your GitLab application's Client Secret\nissuer: (Optional) The URL of your GitLab instance. Use this for self-hosted GitLab servers.\nDefault: \"https://gitlab.com\" (GitLab.com)\nExample: \"https://gitlab.company.com\"\n\nThe issuer option is useful when using a self-hosted GitLab instance. If you're using GitLab.com, you can omit this option as it defaults to https://gitlab.com.\n\nExample with self-hosted GitLab\nauth.ts\nexport const auth = betterAuth({\n    socialProviders: {\n        gitlab: {\n            clientId: process.env.GITLAB_CLIENT_ID as string,\n            clientSecret: process.env.GITLAB_CLIENT_SECRET as string,\n            issuer: \"https://gitlab.company.com\", // Your self-hosted GitLab URL\n        },\n    },\n})\nSign In with GitLab\n\nTo sign in with GitLab, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to gitlab.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"gitlab\"\n    })\n}\nEdit on GitHub\n\nPrevious Page\n\nLinkedIn\n\nNext Page\n\nReddit"
  },
  {
    "title": "Reddit | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/reddit",
    "html": "Reddit\nCopy Markdown\nOpen in\nGet your Reddit Credentials\n\nTo use Reddit sign in, you need a client ID and client secret. You can get them from the Reddit Developer Portal.\n\nClick \"Create App\" or \"Create Another App\"\nSelect \"web app\" as the application type\nSet the redirect URL to http://localhost:3000/api/auth/callback/reddit for local development\nFor production, set it to your application's domain (e.g. https://example.com/api/auth/callback/reddit)\nAfter creating the app, you'll get the client ID (under the app name) and client secret\n\nIf you change the base path of the auth routes, make sure to update the redirect URL accordingly.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n    socialProviders: {\n        reddit: {\n            clientId: process.env.REDDIT_CLIENT_ID as string,\n            clientSecret: process.env.REDDIT_CLIENT_SECRET as string,\n        },\n    },\n})\nSign In with Reddit\n\nTo sign in with Reddit, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to reddit.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient = createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"reddit\"\n    })\n}\nAdditional Configuration\nScopes\n\nBy default, Reddit provides basic user information. If you need additional permissions, you can specify scopes in your auth configuration:\n\nauth.ts\nexport const auth = betterAuth({\n    socialProviders: {\n        reddit: {\n            clientId: process.env.REDDIT_CLIENT_ID as string,\n            clientSecret: process.env.REDDIT_CLIENT_SECRET as string,\n            duration: \"permanent\",\n            scope: [\"read\", \"submit\"] // Add required scopes\n        },\n    },\n})\n\nCommon Reddit scopes include:\n\nidentity: Access basic account information\nread: Access posts and comments\nsubmit: Submit posts and comments\nsubscribe: Manage subreddit subscriptions\nhistory: Access voting history\n\nFor a complete list of available scopes, refer to the Reddit OAuth2 documentation.\n\nEdit on GitHub\n\nPrevious Page\n\nGitLab\n\nNext Page\n\nRoblox"
  },
  {
    "title": "Spotify | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/spotify",
    "html": "Spotify\nCopy Markdown\nOpen in\nGet your Spotify Credentials\n\nTo use Spotify sign in, you need a client ID and client secret. You can get them from the Spotify Developer Portal.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/spotify for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n   \n    socialProviders: {\n        spotify: { \n            clientId: process.env.SPOTIFY_CLIENT_ID as string, \n            clientSecret: process.env.SPOTIFY_CLIENT_SECRET as string, \n        }, \n    },\n})\nSign In with Spotify\n\nTo sign in with Spotify, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to spotify.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"spotify\"\n    })\n}\nEdit on GitHub\n\nPrevious Page\n\nRoblox\n\nNext Page\n\nVK"
  },
  {
    "title": "Roblox | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/roblox",
    "html": "Roblox\nCopy Markdown\nOpen in\nGet your Roblox Credentials\n\nGet your Roblox credentials from the Roblox Creator Hub.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/roblox for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nThe Roblox API does not provide email addresses. As a workaround, the user's email field uses the preferred_username value instead.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\" \nexport const auth = betterAuth({\n    socialProviders: {\n        roblox: { \n            clientId: process.env.ROBLOX_CLIENT_ID as string, \n            clientSecret: process.env.ROBLOX_CLIENT_SECRET as string, \n        }, \n    },\n})\nSign In with Roblox\n\nTo sign in with Roblox, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to roblox.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n    const data = await authClient.signIn.social({\n        provider: \"roblox\"\n    })\n}\nEdit on GitHub\n\nPrevious Page\n\nReddit\n\nNext Page\n\nSpotify"
  },
  {
    "title": "Zoom | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/zoom",
    "html": "Zoom\nCopy Markdown\nOpen in\nCreate a Zoom App from Marketplace\n\nVisit Zoom Marketplace.\n\nHover on the Develop button and select Build App\n\nSelect General App and click Create\n\nConfigure your Zoom App\n\nEnsure that you are in the Basic Information of your app settings.\n\nUnder Select how the app is managed, choose User-managed\n\nUnder App Credentials, copy your Client ID and Client Secret and store them in a safe location\n\nUnder OAuth Information -> OAuth Redirect URL, add your Callback URL. For example,\n\nhttp://localhost:3000/api/auth/callback/zoom\n\nFor production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nSkip to the Scopes section, then\n\nClick the Add Scopes button\nSearch for user:read:user (View a user) and select it\nAdd any other scopes your applications needs and click Done\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\"\nexport const auth = betterAuth({\n  socialProviders: {\n    zoom: { \n      clientId: process.env.ZOOM_CLIENT_ID as string, \n      clientSecret: process.env.ZOOM_CLIENT_SECRET as string, \n    }, \n  },\n})\nSign In with Zoom\n\nTo sign in with Zoom, you can use the signIn.social function provided by the client. You will need to specify zoom as the provider.\n\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\"\nconst authClient =  createAuthClient()\nconst signIn = async () => {\n  const data = await authClient.signIn.social({\n    provider: \"zoom\"\n  })\n}\nEdit on GitHub\n\nPrevious Page\n\nVK\n\nNext Page\n\nOthers"
  },
  {
    "title": "VK | Better Auth",
    "url": "https://www.better-auth.com/docs/authentication/vk",
    "html": "VK\nCopy Markdown\nOpen in\nGet your VK ID credentials\n\nTo use VK ID sign in, you need a client ID and client secret. You can get them from the VK ID Developer Portal.\n\nMake sure to set the redirect URL to http://localhost:3000/api/auth/callback/vk for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.\n\nConfigure the provider\n\nTo configure the provider, you need to import the provider and pass it to the socialProviders option of the auth instance.\n\nauth.ts\nimport { betterAuth } from \"better-auth\";\nexport const auth = betterAuth({\n  socialProviders: {\n    vk: { \n      clientId: process.env.VK_CLIENT_ID as string, \n      clientSecret: process.env.VK_CLIENT_SECRET as string, \n    },\n  },\n});\nSign In with VK\n\nTo sign in with VK, you can use the signIn.social function provided by the client. The signIn function takes an object with the following properties:\n\nprovider: The provider to use. It should be set to vk.\nauth-client.ts\nimport { createAuthClient } from \"better-auth/client\";\nconst authClient = createAuthClient();\nconst signIn = async () => {\n  const data = await authClient.signIn.social({\n    provider: \"vk\",\n  });\n};\nEdit on GitHub\n\nPrevious Page\n\nSpotify\n\nNext Page\n\nZoom"
  },
  {
    "title": "Contributing to BetterAuth | Better Auth",
    "url": "https://www.better-auth.com/docs/reference/contributing",
    "html": "Contributing to BetterAuth\nCopy Markdown\nOpen in\n\nThank you for your interest in contributing to Better Auth! This guide is a concise guide to contributing to Better Auth.\n\nGetting Started\n\nBefore diving in, here are a few important resources:\n\nTake a look at our existing issues and pull requests\nJoin our community discussions in Discord\nDevelopment Setup\n\nTo get started with development:\n\nMake sure you have Node.JS installed, preferably on LTS.\n\n1. Fork the repository\n\nVisit https://github.com/better-auth/better-auth\n\nClick the \"Fork\" button in the top right.\n\n2. Clone your fork\n# Replace YOUR-USERNAME with your GitHub username\ngit clone https://github.com/YOUR-USERNAME/better-auth.git\ncd better-auth\n3. Install dependencies\n\nMake sure you have pnpm installed!\n\npnpm install\n4. Prepare ENV files\n\nCopy the example env file to create your new .env file.\n\ncp -n ./docs/.env.example ./docs/.env\nMaking changes\n\nOnce you have an idea of what you want to contribute, you can start making changes. Here are some steps to get started:\n\n1. Create a new branch\n# Make sure you're on main\ngit checkout main\n# Pull latest changes\ngit pull upstream main\n# Create and switch to a new branch\ngit checkout -b feature/your-feature-name\n2. Start development server\n\nStart the development server:\n\npnpm dev\n\nTo start the docs server:\n\npnpm -F docs dev\n3. Make Your Changes\n\nMake your changes to the codebase.\n\nWrite tests if needed. (Read more about testing here)\n\nUpdate documentation. (Read more about documenting here)\n\nIssues and Bug Fixes\nCheck our GitHub issues for tasks labeled good first issue\nWhen reporting bugs, include steps to reproduce and expected behavior\nComment on issues you'd like to work on to avoid duplicate efforts\nFramework Integrations\n\nWe welcome contributions to support more frameworks:\n\nFocus on framework-agnostic solutions where possible\nKeep integrations minimal and maintainable\nAll integrations currently live in the main package\nPlugin Development\nFor core plugins: Open an issue first to discuss your idea\nFor community plugins: Feel free to develop independently\nFollow our plugin architecture guidelines\nDocumentation\nFix typos and errors\nAdd examples and clarify existing content\nEnsure documentation is up to date with code changes\nTesting\n\nWe use Vitest for testing. Place test files next to the source files they test:\n\nimport { describe, it, expect } from \"vitest\";\nimport { getTestInstance } from \"./test-utils/test-instance\";\ndescribe(\"Feature\", () => {\n    it(\"should work as expected\", async () => {\n        const { client } = await getTestInstance();\n        // Test code here\n        expect(result).toBeDefined();\n    });\n});\nUsing the Test Instance Helper\n\nThe test instance helper now includes improved async context support for managing user sessions:\n\nconst { client, runWithUser, signInWithTestUser } = await getTestInstance();\n// Run tests with a specific user context\nawait runWithUser(\"user@example.com\", \"password\", async (headers) => {\n    // All client calls within this block will use the user's session\n    const response = await client.getSession();\n    // headers are automatically applied\n});\n// Or use the test user with async context\nconst { runWithDefaultUser } = await signInWithTestUser();\nawait runWithDefaultUser(async (headers) => {\n    // Code here runs with the test user's session context\n});\nTesting Best Practices\nWrite clear commit messages\nUpdate documentation to reflect your changes\nAdd tests for new features\nFollow our coding standards\nKeep pull requests focused on a single change\nNeed Help?\n\nDon't hesitate to ask for help! You can:\n\nOpen an issue with questions\nJoin our community discussions\nReach out to project maintainers\n\nThank you for contributing to Better Auth!\n\nEdit on GitHub\n\nPrevious Page\n\nOptions\n\nNext Page\n\nResources"
  },
  {
    "title": "Resources | Better Auth",
    "url": "https://www.better-auth.com/docs/reference/resources",
    "html": "Resources\nCopy Markdown\nOpen in\n\nA curated collection of resources to help you learn and master Better Auth. From blog posts to video tutorials, find everything you need to get started.\n\nVideo tutorials\nAll\ntrends\nshowcase\nreview\nimplementation\nnextjs\ncomparison\ntutorial\ntanstack\nmigration\nclerk\nThe State of Authentication\n\nTheo(t3.gg) explores the current landscape of authentication, discussing trends, challenges, and where the industry is heading.\n\ntrends\nshowcase\nreview\nLast Authentication You Will Ever Need\n\nA comprehensive tutorial demonstrating why Better Auth could be the final authentication solution you'll need for your projects.\n\nimplementation\nshowcase\nThis Might Be My New Favourite Auth Library\n\ndevelopedbyed explores the features and capabilities of Better Auth, explaining why it stands out among authentication libraries.\n\nreview\nshowcase\n8 Reasons To Try Better Auth\n\nCJ presents 8 compelling reasons why Better Auth is the BEST auth framework he's ever used, demonstrating its superior features and ease of implementation.\n\nreview\nshowcase\nimplementation\nBetter Auth is so good that I almost switched programming languages\n\nDreams of Code reviews Better Auth's features that nearly made them switch languages.\n\nreview\nshowcase\nimplementation\nBest authentication framework for next.js\n\nA detailed comparison of authentication frameworks for Next.js, highlighting why Better Auth might be your best choice.\n\nnextjs\ncomparison\nBetter-Auth: A First Look\n\nAn introductory overview and demonstration of Better Auth's core features and capabilities.\n\nimplementation\nshowcase\nStripe was never so easy (with better auth)\n\nA tutorial on how to integrate Stripe with Better Auth.\n\nimplementation\nNextjs 15 Authentication Made EASY with Better Auth\n\nA practical guide showing how to seamlessly integrate Better Auth with Next.js 15 for robust authentication.\n\nnextjs\nimplementation\ntutorial\nBetter Auth: Headless Authentication for Your TanStack Start App\n\nJack demonstrates how to implement headless authentication in your TanStack Start application using Better Auth, providing a modern approach to auth.\n\ntanstack\nimplementation\nGoodbye Clerk, Hello Better Auth â€“ Full Migration Guide!\n\nA comprehensive guide showing how to migrate your authentication from Clerk to Better Auth, with step-by-step instructions and best practices.\n\nmigration\nclerk\ntutorial\nBlog posts\nAll\ntypescript\nreact\nbun\nvite\norganizations\nintegration\npayments\nastro\ntutorial\nmulti-tenant\nzenstack\narchitecture\nBetter Auth with Hono, Bun, TypeScript, React and Vite\n\nYou'll learn how to implement authentication with Better Auth in a client - server architecture, where the frontend is separate from the backend.\n\ntypescript\nreact\nbun\nvite\nPolar.sh + BetterAuth for Organizations\n\nPolar.sh is a platform for building payment integrations. This article will show you how to use Better Auth to authenticate your users.\n\norganizations\nintegration\npayments\nAuthenticating users in Astro with Better Auth\n\nStep by step guide on how to authenticate users in Astro with Better Auth.\n\nastro\nintegration\ntutorial\nBuilding Multi-Tenant Apps With Better-Auth and ZenStack\n\nLearn how to build multi-tenant apps with Better-Auth and ZenStack.\n\nmulti-tenant\nzenstack\narchitecture\nEdit on GitHub\n\nPrevious Page\n\nContributing\n\nNext Page\n\nSecurity"
  },
  {
    "title": "Security | Better Auth",
    "url": "https://www.better-auth.com/docs/reference/security",
    "html": "Security\nCopy Markdown\nOpen in\n\nThis page contains information about security features of Better Auth.\n\nPassword Hashing\n\nBetter Auth uses the scrypt algorithm to hash passwords by default. This algorithm is designed to be memory-hard and CPU-intensive, making it resistant to brute-force attacks. You can customize the password hashing function by setting the password option in the configuration. This option should include a hash function to hash passwords and a verify function to verify them.\n\nSession Management\nSession Expiration\n\nBetter Auth uses secure session management to protect user data. Sessions are stored in the database or a secondary storage, if configured, to prevent unauthorized access. By default, sessions expire after 7 days, but you can customize this value in the configuration. Additionally, each time a session is used, if it reaches the updateAge threshold, the expiration date is extended, which by default is set to 1 day.\n\nSession Revocation\n\nBetter Auth allows you to revoke sessions to enhance security. When a session is revoked, the user is logged out and can no longer access the application. A logged in user can also revoke their own sessions to log out from different devices or browsers.\n\nSee the session management for more details.\n\nCSRF Protection\n\nBetter Auth includes multiple safeguards to prevent Cross-Site Request Forgery (CSRF) attacks:\n\nNon-Simple Headers POST requests must either have a non-simple header or a Content-Type header of application/json. Non-simple headers are headers that are not included in the simple headers list.\n\nOrigin Validation Each requestâ€™s Origin header is verified to confirm it comes from your application or another explicitly trusted source. Requests from untrusted origins are rejected. By default, Better Auth trusts the base URL of your app, but you can specify additional trusted origins via the trustedOrigins configuration option.\n\nSecure Cookie Settings Session cookies use the SameSite=Lax attribute by default, preventing browsers from sending cookies with most cross-site requests. You can override this behavior using the defaultCookieAttributes option.\n\nNo Mutations on GET Requests (with additional safeguards) GET requests are assumed to be read-only and should not alter the applicationâ€™s state. In cases where a GET request must perform a mutationâ€”such as during OAuth callbacks - Better Auth applies extra security measures, including validating nonce and state parameters to ensure the requestâ€™s authenticity.\n\nYou can skip the CSRF check for all requests by setting the disableCSRFCheck option to true in the configuration.\n\n{\n  advanced: {\n    disableCSRFCheck: true\n  }\n}\n\nYou can skip the origin check for all requests by setting the disableOriginCheck option to true in the configuration.\n\n{\n  advanced: {\n    disableOriginCheck: true\n  }\n}\n\nSkipping csrf check will open your application to CSRF attacks. And skipping origin check may open up your application to other security vulnerabilities including open redirects.\n\nOAuth State and PKCE\n\nTo secure OAuth flows, Better Auth stores the OAuth state and PKCE (Proof Key for Code Exchange) in the database. The state helps prevent CSRF attacks, while PKCE protects against code injection threats. Once the OAuth process completes, these values are removed from the database.\n\nCookies\n\nBetter Auth assigns secure cookies by default when the base URL uses https. These secure cookies are encrypted and only sent over secure connections, adding an extra layer of protection. They are also set with the sameSite attribute to lax by default to prevent cross-site request forgery attacks. And the httpOnly attribute is enabled to prevent client-side JavaScript from accessing the cookie.\n\nFor Cross-Subdomain Cookies, you can set the crossSubDomainCookies option in the configuration. This option allows cookies to be shared across subdomains, enabling seamless authentication across multiple subdomains.\n\nCustomizing Cookies\n\nYou can customize cookie names to minimize the risk of fingerprinting attacks and set specific cookie options as needed for additional control. For more information, refer to the cookie options.\n\nPlugins can also set custom cookie options to align with specific security needs. If you're using Better Auth in non-browser environments, plugins offer ways to manage cookies securely in those contexts as well.\n\nRate Limiting\n\nBetter Auth includes built-in rate limiting to safeguard against brute-force attacks. Rate limits are applied across all routes by default, with specific routes subject to stricter limits based on potential risk.\n\nIP Address Headers\n\nBetter Auth uses client IP addresses for rate limiting and security monitoring. By default, it reads the IP address from the standard X-Forwarded-For header. However, you can configure a specific trusted header to ensure accurate IP address detection and prevent IP spoofing attacks.\n\nYou can configure the IP address header in your Better Auth configuration:\n\n{\n  advanced: {\n    ipAddress: {\n      ipAddressHeaders: ['cf-connecting-ip'] // or any other custom header\n    }\n  }\n}\n\nThis ensures that Better Auth only accepts IP addresses from your trusted proxy's header, making it more difficult for attackers to bypass rate limiting or other IP-based security measures by spoofing headers.\n\nImportant: When setting a custom IP address header, ensure that your proxy or load balancer is properly configured to set this header, and that it cannot be set by end users directly.\n\nTrusted Origins\n\nTrusted origins prevent CSRF attacks and block open redirects. You can set a list of trusted origins in the trustedOrigins configuration option. Requests from origins not on this list are automatically blocked.\n\nBasic Usage\n\nThe most basic usage is to specify exact origins:\n\n{\n  trustedOrigins: [\n    \"https://example.com\",\n    \"https://app.example.com\",\n    \"http://localhost:3000\"\n  ]\n}\nWildcard Domains\n\nBetter Auth supports wildcard patterns in trusted origins, which allows you to trust multiple subdomains with a single entry:\n\n{\n  trustedOrigins: [\n    \"*.example.com\",             // Trust all subdomains of example.com (any protocol)\n    \"https://*.example.com\",     // Trust only HTTPS subdomains of example.com\n    \"http://*.dev.example.com\"   // Trust all HTTP subdomains of dev.example.com\n  ]\n}\nProtocol-specific wildcards\n\nWhen using a wildcard pattern with a protocol prefix (like https://):\n\nThe protocol must match exactly\nThe domain can have any subdomain in place of the *\nRequests using a different protocol will be rejected, even if the domain matches\nProtocol-agnostic wildcards\n\nWhen using a wildcard pattern without a protocol prefix (like *.example.com):\n\nAny protocol (http, https, etc.) will be accepted\nThe domain must match the wildcard pattern\nCustom Schemes\n\nTrusted origins also support custom schemes for mobile apps and browser extensions:\n\n{\n  trustedOrigins: [\n    \"myapp://\",                               // Mobile app scheme\n    \"chrome-extension://YOUR_EXTENSION_ID\"    // Browser extension\n  ]\n}\nReporting Vulnerabilities\n\nIf you discover a security vulnerability in Better Auth, please report it to us at security@better-auth.com. We address all reports promptly, and credits will be given for validated discoveries.\n\nEdit on GitHub\n\nPrevious Page\n\nResources\n\nNext Page\n\nTelemetry"
  },
  {
    "title": "Telemetry | Better Auth",
    "url": "https://www.better-auth.com/docs/reference/telemetry",
    "html": "Telemetry\nCopy Markdown\nOpen in\n\nBetter Auth collects anonymous usage data to help us improve the project. This is optional, transparent, and disabled by default.\n\nWhy is telemetry collected?\n\nSince v1.3.5, Better Auth collects anonymous telemetry data about general usage if enabled.\n\nTelemetry data helps us understand how Better Auth is being used across different environments so we can improve performance, prioritize features, and fix issues more effectively. It guides our decisions on performance optimizations, feature development, and bug fixes. All data is collected completely anonymously and with privacy in mind, and users can opt out at any time. We strive to keep what we collect as transparent as possible.\n\nWhat is being collected?\n\nThe following data points may be reported. Everything is anonymous and intended for aggregate insights only.\n\nAnonymous identifier: A non-reversible hash derived from your project (package.json name and optionally baseURL). This lets us deâ€‘duplicate events per project without knowing who you are.\nRuntime: { name: \"node\" | \"bun\" | \"deno\", version }.\nEnvironment: one of development, production, test, or ci.\nFramework (if detected): { name, version } for frameworks like Next.js, Nuxt, Remix, Astro, SvelteKit, etc.\nDatabase (if detected): { name, version } for integrations like PostgreSQL, MySQL, SQLite, Prisma, Drizzle, MongoDB, etc.\nSystem info: platform, OS release, architecture, CPU count/model/speed, total memory, and flags like isDocker, isWSL, isTTY.\nPackage manager: { name, version } derived from the npm user agent.\nRedacted auth config snapshot: A minimized, privacyâ€‘preserving view of your betterAuth options produced by getTelemetryAuthConfig.\n\nWe also collect anonymous telemetry from the CLI:\n\nCLI generate (cli_generate): outcome generated | overwritten | appended | no_changes | aborted plus redacted config.\nCLI migrate (cli_migrate): outcome migrated | no_changes | aborted | unsupported_adapter plus adapter id (when relevant) and redacted config.\n\nYou can audit telemetry locally by setting the BETTER_AUTH_TELEMETRY_DEBUG=1 environment variable when running your project or by setting telemetry: { debug: true } in your auth config. In this debug mode, telemetry events are logged only to the console.\n\nauth.ts\nexport const auth = betterAuth({\n  telemetry: { \n    debug: true\n  } \n});\nHow is my data protected?\n\nAll collected data is fully anonymous and only useful in aggregate. It cannot be traced back to any individual source and is accessible only to a small group of core Better Auth maintainers to guide roadmap decisions.\n\nNo PII or secrets: We do not collect emails, usernames, tokens, secrets, client IDs, client secrets, or database URLs.\nNo full config: We never send your full betterAuth configuration. Instead we send a reduced, redacted snapshot of nonâ€‘sensitive toggles and counts.\nRedaction by design: See detect-auth-config.ts in the Better Auth source for the exact shape of what is included. It purposely converts sensitive values to booleans, counts, or generic identifiers.\nHow can I enable it?\n\nYou can enable telemetry collection in your auth config or by setting an environment variable.\n\nVia your auth config.\n\nauth.ts\nexport const auth = betterAuth({\n  telemetry: { \n    enabled: true\n  } \n});\n\nVia an environment variable.\n\n.env\n# Enable telemetry\nBETTER_AUTH_TELEMETRY=1\n# Disable telemetry\nBETTER_AUTH_TELEMETRY=0\nWhen is telemetry sent?\nOn betterAuth initialization (type: \"init\").\nOn CLI actions: generate and migrate as described above.\n\nTelemetry is disabled automatically in tests (NODE_ENV=test) unless explicitly overridden by internal tooling.\n\nEdit on GitHub\n\nPrevious Page\n\nSecurity\n\nNext Page\n\nFAQ"
  },
  {
    "title": "FAQ | Better Auth",
    "url": "https://www.better-auth.com/docs/reference/faq",
    "html": "FAQ\nCopy Markdown\nOpen in\n\nThis page contains frequently asked questions, common issues, and other helpful information about Better Auth.\n\nAuth client not working\ngetSession not working\nAdding custom fields to the users table\nDifference between getSession and useSession\nCommon TypeScript Errors\nCan I remove `name`, `image`, or `email` fields from the user table?\nEdit on GitHub\n\nPrevious Page\n\nTelemetry"
  }
]
[
  {
    "title": "API Reference: Directives | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/directives",
    "html": "App Router\nAPI Reference\nDirectives\nCopy page\nDirectives\n\nThe following directives are available:\n\nuse cache\nLearn how to use the use cache directive to cache data in your Next.js application.\nuse cache: private\nLearn how to use the `\"use cache: private\"` directive to enable runtime prefetching of personalized content in your Next.js application.\nuse cache: remote\nLearn how to use the `\"use cache: remote\"` directive to enable caching in dynamic contexts in your Next.js application.\nuse client\nLearn how to use the use client directive to render a component on the client.\nuse server\nLearn how to use the use server directive to execute code on the server.\nPrevious\nAPI Reference\nNext\nuse cache\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "App Router: API Reference | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference",
    "html": "Next.js Docs\nApp Router\nAPI Reference\nCopy page\nAPI Reference\nDirectives\nDirectives are used to modify the behavior of your Next.js application.\nComponents\nAPI Reference for Next.js built-in components.\nFile-system conventions\nAPI Reference for Next.js file-system conventions.\nFunctions\nAPI Reference for Next.js Functions and Hooks.\nConfiguration\nLearn how to configure Next.js applications.\nCLI\nAPI Reference for the Next.js Command Line Interface (CLI) tools.\nEdge Runtime\nAPI Reference for the Edge Runtime.\nTurbopack\nTurbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js.\nPrevious\nVideos\nNext\nDirectives\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Directives: use cache | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/directives/use-cache",
    "html": "API Reference\nDirectives\nuse cache\nCopy page\nuse cache\n\nThe use cache directive allows you to mark a route, React component, or a function as cacheable. It can be used at the top of a file to indicate that all exports in the file should be cached, or inline at the top of function or component to cache the return value.\n\nGood to know: For caching user-specific content that requires access to cookies or headers, see 'use cache: private'.\n\nUsage\n\nuse cache is a Cache Components feature. To enable it, add the cacheComponents option to your next.config.ts file:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  cacheComponents: true,\n}\n \nexport default nextConfig\n\nThen, add use cache at the file, component, or function level:\n\n// File level\n'use cache'\n \nexport default async function Page() {\n  // ...\n}\n \n// Component level\nexport async function MyComponent() {\n  'use cache'\n  return <></>\n}\n \n// Function level\nexport async function getData() {\n  'use cache'\n  const data = await fetch('/api/data')\n  return data\n}\nHow use cache works\nCache keys\n\nA cache entry's key is generated using a serialized version of its inputs, which includes:\n\nBuild ID (generated for each build)\nFunction ID (a secure identifier unique to the function)\nThe serializable\n function arguments (or props).\n\nThe arguments passed to the cached function, as well as any values it reads from the parent scope automatically become a part of the key. This means, the same cache entry will be reused as long as its inputs are the same.\n\nNon-serializable arguments\n\nAny non-serializable arguments, props, or closed-over values will turn into references inside the cached function, and can be only passed through and not inspected nor modified. These non-serializable values will be filled in at the request time and won't become a part of the cache key.\n\nFor example, a cached function can take in JSX as a children prop and return <div>{children}</div>, but it won't be able to introspect the actual children object. This allows you to nest uncached content inside a cached component.\n\napp/ui/cached-component.tsx\nTypeScript\nJavaScript\nTypeScript\nfunction CachedComponent({ children }: { children: ReactNode }) {\n  'use cache'\n  return <div>{children}</div>\n}\nReturn values\n\nThe return value of the cacheable function must be serializable. This ensures that the cached data can be stored and retrieved correctly.\n\nuse cache at build time\n\nWhen used at the top of a layout or page, the route segment will be prerendered, allowing it to later be revalidated.\n\nThis means use cache cannot be used with runtime data like cookies or headers.\n\nNote: If you need to cache content that depends on cookies, headers, or search params, use 'use cache: private' instead.\n\nuse cache at runtime\n\nOn the server, the cache entries of individual components or functions will be cached in-memory.\n\nThen, on the client, any content returned from the server cache will be stored in the browser's memory for the duration of the session or until revalidated.\n\nDuring revalidation\n\nBy default, use cache has server-side revalidation period of 15 minutes. While this period may be useful for content that doesn't require frequent updates, you can use the cacheLife and cacheTag APIs to configure when the individual cache entries should be revalidated.\n\ncacheLife: Configure the cache entry lifetime.\ncacheTag: Create tags for on-demand revalidation.\n\nBoth of these APIs integrate across the client and server caching layers, meaning you can configure your caching semantics in one place and have them apply everywhere.\n\nSee the cacheLife and cacheTag API docs for more information.\n\nExamples\nCaching an entire route with use cache\n\nTo prerender an entire route, add use cache to the top of both the layout and page files. Each of these segments are treated as separate entry points in your application, and will be cached independently.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\n'use cache'\n \nexport default function Layout({ children }: { children: ReactNode }) {\n  return <div>{children}</div>\n}\n\nAny components imported and nested in page file are part of the cache output associated with the page.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\n'use cache'\n \nasync function Users() {\n  const users = await fetch('/api/users')\n  // loop through users\n}\n \nexport default function Page() {\n  return (\n    <main>\n      <Users />\n    </main>\n  )\n}\n\nGood to know:\n\nIf use cache is added only to the layout or the page, only that route segment and any components imported into it will be cached.\nIf any of the nested children in the route use Dynamic APIs, then the route will opt out of pre-rendering.\nCaching a component's output with use cache\n\nYou can use use cache at the component level to cache any fetches or computations performed within that component. The cache entry will be reused as long as the serialized props produce the same value in each instance.\n\napp/components/bookings.tsx\nTypeScript\nJavaScript\nTypeScript\nexport async function Bookings({ type = 'haircut' }: BookingsProps) {\n  'use cache'\n  async function getBookingsData() {\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)\n    return data\n  }\n  return //...\n}\n \ninterface BookingsProps {\n  type: string\n}\nCaching function output with use cache\n\nSince you can add use cache to any asynchronous function, you aren't limited to caching components or routes only. You might want to cache a network request, a database query, or a slow computation.\n\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function getData() {\n  'use cache'\n \n  const data = await fetch('/api/data')\n  return data\n}\nInterleaving\n\nIn React, composition with children or slots is a well-known pattern for building flexible components. When using use cache, you can continue to compose your UI in this way. Anything included as children, or other compositional slots, in the returned JSX will be passed through the cached component without affecting its cache entry.\n\nAs long as you don't directly reference any of the JSX slots inside the body of the cacheable function itself, their presence in the returned output won't affect the cache entry.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Page() {\n  const uncachedData = await getData()\n  return (\n    // Pass compositional slots as props, e.g. header and children\n    <CacheComponent header={<h1>Home</h1>}>\n      {/* DynamicComponent is provided as the children slot */}\n      <DynamicComponent data={uncachedData} />\n    </CacheComponent>\n  )\n}\n \nasync function CacheComponent({\n  header, // header: a compositional slot, injected as a prop\n  children, // children: another slot for nested composition\n}: {\n  header: ReactNode\n  children: ReactNode\n}) {\n  'use cache'\n  const cachedData = await fetch('/api/cached-data')\n  return (\n    <div>\n      {header}\n      <PrerenderedComponent data={cachedData} />\n      {children}\n    </div>\n  )\n}\n\nYou can also pass Server Actions through cached components to Client Components without invoking them inside the cacheable function.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport ClientComponent from './ClientComponent'\n \nexport default async function Page() {\n  const performUpdate = async () => {\n    'use server'\n    // Perform some server-side update\n    await db.update(...)\n  }\n \n  return <CacheComponent performUpdate={performUpdate} />\n}\n \nasync function CachedComponent({\n  performUpdate,\n}: {\n  performUpdate: () => Promise<void>\n}) {\n  'use cache'\n  // Do not call performUpdate here\n  return <ClientComponent action={performUpdate} />\n}\napp/ClientComponent.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nexport default function ClientComponent({\n  action,\n}: {\n  action: () => Promise<void>\n}) {\n  return <button onClick={action}>Update</button>\n}\nPlatform Support\nDeployment Option\tSupported\nNode.js server\tYes\nDocker container\tYes\nStatic export\tNo\nAdapters\tPlatform-specific\n\nLearn how to configure caching when self-hosting Next.js.\n\nVersion History\nVersion\tChanges\nv16.0.0\t\"use cache\" is enabled with the Cache Components feature.\nv15.0.0\t\"use cache\" is introduced as an experimental feature.\nRelated\nView related API references.\nuse cache: private\nLearn how to use the `\"use cache: private\"` directive to enable runtime prefetching of personalized content in your Next.js application.\ncacheComponents\nLearn how to enable the cacheComponents flag in Next.js.\ncacheLife\nLearn how to set up cacheLife configurations in Next.js.\ncacheTag\nLearn how to use the cacheTag function to manage cache invalidation in your Next.js application.\ncacheLife\nLearn how to use the cacheLife function to set the cache expiration time for a cached function or component.\nrevalidateTag\nAPI Reference for the revalidateTag function.\nPrevious\nDirectives\nNext\nuse cache: private\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Directives: use cache: private | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/directives/use-cache-private",
    "html": "API Reference\nDirectives\nuse cache: private\nCopy page\nuse cache: private\n\nThe 'use cache: private' directive enables runtime prefetching of personalized content that depends on cookies, headers, or search params.\n\nGood to know: 'use cache: private' is a variant of use cache designed specifically for user-specific content that needs to be prefetchable but should never be stored in server-side cache handlers.\n\nUsage\n\nTo use 'use cache: private', enable the cacheComponents flag in your next.config.ts file:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  cacheComponents: true,\n}\n \nexport default nextConfig\n\nThen add 'use cache: private' to your function along with a cacheLife configuration and export unstable_prefetch from your page.\n\nBasic example\napp/product/[id]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Suspense } from 'react'\nimport { cookies } from 'next/headers'\nimport { cacheLife, cacheTag } from 'next/cache'\n \n// REQUIRED: Enable runtime prefetching\nexport const unstable_prefetch = {\n  mode: 'runtime',\n  samples: [\n    { params: { id: '1' }, cookies: [{ name: 'session-id', value: '1' }] },\n  ],\n}\n \nexport default async function ProductPage({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n \n  return (\n    <div>\n      <ProductDetails id={id} />\n      <Suspense fallback={<div>Loading recommendations...</div>}>\n        <Recommendations productId={id} />\n      </Suspense>\n    </div>\n  )\n}\n \nasync function Recommendations({ productId }: { productId: string }) {\n  const recommendations = await getRecommendations(productId)\n \n  return (\n    <div>\n      {recommendations.map((rec) => (\n        <ProductCard key={rec.id} product={rec} />\n      ))}\n    </div>\n  )\n}\n \nasync function getRecommendations(productId: string) {\n  'use cache: private'\n  cacheTag(`recommendations-${productId}`)\n  cacheLife({ stale: 60 }) // Minimum 30 seconds required for runtime prefetch\n \n  // Access cookies within private cache functions\n  const sessionId = (await cookies()).get('session-id')?.value || 'guest'\n \n  return getPersonalizedRecommendations(productId, sessionId)\n}\n\nNote: Private caches require a cacheLife stale time of at least 30 seconds to enable runtime prefetching. Values below 30 seconds are treated as dynamic.\n\nDifference from use cache\n\nWhile regular use cache is designed for static, shared content that can be cached on the server, 'use cache: private' is specifically for dynamic, user-specific content that needs to be:\n\nPersonalized - varies based on cookies, headers, or search params\nPrefetchable - can be loaded before the user navigates to the page\nClient-only - never persisted to server-side cache handlers\nFeature\tuse cache\t'use cache: private'\nAccess to await cookies()\tNo\tYes\nAccess to await headers()\tNo\tYes\nAccess to await searchParams\tNo\tYes\nStored in cache handler\tYes (server-side)\tNo (client-side only)\nRuntime prefetchable\tN/A (already static)\tYes (when configured)\nCache scope\tGlobal (shared)\tPer-user (isolated)\nUse case\tStatic, shared content\tPersonalized, user-specific content\nHow it works\nRuntime prefetching\n\nWhen a user hovers over or views a link to a page with unstable_prefetch = { mode: 'runtime' }:\n\nStatic content is prefetched immediately (layouts, page shell)\nPrivate cache functions are executed with the user's current cookies/headers\nResults are stored in the client-side Resume Data Cache\nNavigation is instant - both static and personalized content are already loaded\n\nGood to know: Without 'use cache: private', personalized content cannot be prefetched and must wait until after navigation completes. Runtime prefetching eliminates this delay by executing cache functions with the user's current request context.\n\nStorage behavior\n\nPrivate caches are never persisted to server-side cache handlers (like Redis, Vercel Data Cache, etc.). They exist only to:\n\nEnable runtime prefetching of personalized content\nStore prefetched data in the client-side cache during the session\nCoordinate cache invalidation with tags and stale times\n\nThis ensures user-specific data is never accidentally shared between users while still enabling fast, prefetched navigation.\n\nStale time requirements\n\nNote: Functions with a cacheLife stale time less than 30 seconds will not be runtime prefetched, even when using 'use cache: private'. This prevents prefetching of rapidly changing data that would likely be stale by navigation time.\n\n// Will be runtime prefetched (stale ≥ 30s)\ncacheLife({ stale: 60 })\n \n// Will be runtime prefetched (stale ≥ 30s)\ncacheLife({ stale: 30 })\n \n// Will NOT be runtime prefetched (stale < 30s)\ncacheLife({ stale: 10 })\nRequest APIs allowed in private caches\n\nThe following request-specific APIs can be used inside 'use cache: private' functions:\n\nAPI\tAllowed in use cache\tAllowed in 'use cache: private'\ncookies()\tNo\tYes\nheaders()\tNo\tYes\nsearchParams\tNo\tYes\nconnection()\tNo\tNo\n\nNote: The connection()\n API is prohibited in both use cache and 'use cache: private' as it provides connection-specific information that cannot be safely cached.\n\nNesting rules\n\nPrivate caches have specific nesting rules to prevent user-specific data from leaking into shared caches:\n\nPrivate caches can be nested inside other private caches\nPrivate caches cannot be nested inside public caches ('use cache', 'use cache: remote')\nPublic caches can be nested inside private caches\n// VALID: Private inside private\nasync function outerPrivate() {\n  'use cache: private'\n  const result = await innerPrivate()\n  return result\n}\n \nasync function innerPrivate() {\n  'use cache: private'\n  return getData()\n}\n \n// INVALID: Private inside public\nasync function outerPublic() {\n  'use cache'\n  const result = await innerPrivate() // Error!\n  return result\n}\n \nasync function innerPrivate() {\n  'use cache: private'\n  return getData()\n}\nExamples\nPersonalized product recommendations\n\nThis example shows how to cache personalized product recommendations based on a user's session cookie. The recommendations are prefetched at runtime when the user hovers over product links.\n\napp/product/[id]/page.tsx\nimport { cookies } from 'next/headers'\nimport { cacheLife, cacheTag } from 'next/cache'\n \nexport const unstable_prefetch = {\n  mode: 'runtime',\n  samples: [\n    { params: { id: '1' }, cookies: [{ name: 'user-id', value: 'user-123' }] },\n  ],\n}\n \nasync function getRecommendations(productId: string) {\n  'use cache: private'\n  cacheTag(`recommendations-${productId}`)\n  cacheLife({ stale: 60 })\n \n  const userId = (await cookies()).get('user-id')?.value\n \n  // Fetch personalized recommendations based on user's browsing history\n  const recommendations = await db.recommendations.findMany({\n    where: { userId, productId },\n  })\n \n  return recommendations\n}\nUser-specific pricing\n\nCache pricing information that varies by user tier, allowing instant navigation to the pricing page with personalized rates already loaded.\n\napp/pricing/page.tsx\nimport { cookies } from 'next/headers'\nimport { cacheLife } from 'next/cache'\n \nexport const unstable_prefetch = {\n  mode: 'runtime',\n  samples: [{ cookies: [{ name: 'user-tier', value: 'premium' }] }],\n}\n \nasync function getPricing() {\n  'use cache: private'\n  cacheLife({ stale: 300 }) // 5 minutes\n \n  const tier = (await cookies()).get('user-tier')?.value || 'free'\n \n  // Return tier-specific pricing\n  return db.pricing.findMany({ where: { tier } })\n}\nLocalized content based on headers\n\nServe localized content based on the user's Accept-Language header, prefetching the correct language variant before navigation.\n\napp/page.tsx\nimport { headers } from 'next/headers'\nimport { cacheLife, cacheTag } from 'next/cache'\n \nexport const unstable_prefetch = {\n  mode: 'runtime',\n  samples: [{ headers: [{ name: 'accept-language', value: 'en-US' }] }],\n}\n \nasync function getLocalizedContent() {\n  'use cache: private'\n  cacheTag('content')\n  cacheLife({ stale: 3600 }) // 1 hour\n \n  const headersList = await headers()\n  const locale = headersList.get('accept-language')?.split(',')[0] || 'en-US'\n \n  return db.content.findMany({ where: { locale } })\n}\nSearch results with user preferences\n\nPrefetch search results that include user-specific preferences, ensuring personalized search results load instantly.\n\napp/search/page.tsx\nimport { cookies } from 'next/headers'\nimport { cacheLife } from 'next/cache'\n \nexport const unstable_prefetch = {\n  mode: 'runtime',\n  samples: [\n    {\n      searchParams: { q: 'laptop' },\n      cookies: [{ name: 'preferences', value: 'compact-view' }],\n    },\n  ],\n}\n \nasync function getSearchResults(query: string) {\n  'use cache: private'\n  cacheLife({ stale: 120 }) // 2 minutes\n \n  const preferences = (await cookies()).get('preferences')?.value\n \n  // Apply user preferences to search results\n  return searchWithPreferences(query, preferences)\n}\n\nGood to know:\n\nPrivate caches are ephemeral and only exist in the client-side cache for the session duration\nPrivate cache results are never written to server-side cache handlers\nThe unstable_prefetch export is required for runtime prefetching to work\nA minimum stale time of 30 seconds is required for private caches to be prefetched\nYou can use cacheTag() and revalidateTag() to invalidate private caches\nEach user gets their own private cache entries based on their cookies/headers\nPlatform Support\nDeployment Option\tSupported\nNode.js server\tYes\nDocker container\tYes\nStatic export\tNo\nAdapters\tYes\nVersion History\nVersion\tChanges\nv16.0.0\t'use cache: private' introduced as an experimental feature.\nRelated\nView related API references.\nuse cache\nLearn how to use the use cache directive to cache data in your Next.js application.\ncacheComponents\nLearn how to enable the cacheComponents flag in Next.js.\ncacheLife\nLearn how to use the cacheLife function to set the cache expiration time for a cached function or component.\ncacheTag\nLearn how to use the cacheTag function to manage cache invalidation in your Next.js application.\nPrefetching\nLearn how to configure prefetching in Next.js\nPrevious\nuse cache\nNext\nuse cache: remote\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Directives: use client | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/directives/use-client",
    "html": "API Reference\nDirectives\nuse client\nCopy page\nuse client\n\nThe 'use client' directive declares an entry point for the components to be rendered on the client side and should be used when creating interactive user interfaces (UI) that require client-side JavaScript capabilities, such as state management, event handling, and access to browser APIs. This is a React feature.\n\nGood to know:\n\nYou do not need to add the 'use client' directive to every file that contains Client Components. You only need to add it to the files whose components you want to render directly within Server Components. The 'use client' directive defines the client-server boundary\n, and the components exported from such a file serve as entry points to the client.\n\nUsage\n\nTo declare an entry point for the Client Components, add the 'use client' directive at the top of the file, before any imports:\n\napp/components/counter.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useState } from 'react'\n \nexport default function Counter() {\n  const [count, setCount] = useState(0)\n \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  )\n}\n\nWhen using the 'use client' directive, the props of the Client Components must be serializable\n. This means the props need to be in a format that React can serialize when sending data from the server to the client.\n\napp/components/counter.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nexport default function Counter({\n  onClick /* ❌ Function is not serializable */,\n}) {\n  return (\n    <div>\n      <button onClick={onClick}>Increment</button>\n    </div>\n  )\n}\nNesting Client Components within Server Components\n\nCombining Server and Client Components allows you to build applications that are both performant and interactive:\n\nServer Components: Use for static content, data fetching, and SEO-friendly elements.\nClient Components: Use for interactive elements that require state, effects, or browser APIs.\nComponent composition: Nest Client Components within Server Components as needed for a clear separation of server and client logic.\n\nIn the following example:\n\nHeader is a Server Component handling static content.\nCounter is a Client Component enabling interactivity within the page.\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Header from './header'\nimport Counter from './counter' // This is a Client Component\n \nexport default function Page() {\n  return (\n    <div>\n      <Header />\n      <Counter />\n    </div>\n  )\n}\nReference\n\nSee the React documentation\n for more information on 'use client'.\n\nPrevious\nuse cache: remote\nNext\nuse server\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Directives: use cache: remote | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/directives/use-cache-remote",
    "html": "API Reference\nDirectives\nuse cache: remote\nCopy page\nuse cache: remote\n\nThe 'use cache: remote' directive enables caching of shared data in dynamic contexts where regular use cache would not work, for example after calling await connection(), await cookies() or await headers().\n\nGood to know:\n\nResults are stored in server-side cache handlers and shared across all users.\nFor user-specific data that depends on await cookies() or await headers(), use 'use cache: private' instead.\nUsage\n\nTo use 'use cache: remote', enable the cacheComponents flag in your next.config.ts file:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  cacheComponents: true,\n}\n \nexport default nextConfig\n\nThen add 'use cache: remote' to your function that needs to cache data in a dynamic context.\n\nBasic example\n\nCache product pricing that needs to be fetched at request time but can be shared across all users. Use cacheLife to set the cache lifetime of the price.\n\napp/product/[id]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Suspense } from 'react'\nimport { connection } from 'next/server'\nimport { cacheTag, cacheLife } from 'next/cache'\n \nexport default async function ProductPage({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n \n  return (\n    <div>\n      <ProductDetails id={id} />\n      <Suspense fallback={<div>Loading price...</div>}>\n        <ProductPrice productId={id} />\n      </Suspense>\n    </div>\n  )\n}\n \nfunction ProductDetails({ id }: { id: string }) {\n  return <div>Product: {id}</div>\n}\n \nasync function ProductPrice({ productId }: { productId: string }) {\n  // Calling connection() makes this component dynamic, preventing\n  // it from being included in the static shell. This ensures the price\n  // is always fetched at request time.\n  await connection()\n \n  // Now we can cache the price in a remote cache handler.\n  // Regular 'use cache' would NOT work here because we're in a dynamic context.\n  const price = await getProductPrice(productId)\n \n  return <div>Price: ${price}</div>\n}\n \nasync function getProductPrice(productId: string) {\n  'use cache: remote'\n  cacheTag(`product-price-${productId}`)\n  cacheLife({ expire: 3600 }) // 1 hour\n \n  // This database query is cached and shared across all users\n  return db.products.getPrice(productId)\n}\n\nNote: Regular use cache will not cache anything when used in a dynamic context (after await connection(), await cookies(), await headers(), etc.). Use 'use cache: remote' to enable runtime caching in these scenarios.\n\nHow use cache: remote differs from use cache and use cache: private\n\nNext.js provides three caching directives, each designed for different use cases:\n\nFeature\tuse cache\t'use cache: remote'\t'use cache: private'\nWorks in dynamic context\tNo (requires static context)\tYes (designed for dynamic contexts)\tYes\nAccess to await cookies()\tNo\tNo\tYes\nAccess to await headers()\tNo\tNo\tYes\nAfter await connection()\tNo (won't cache)\tNo\tNo\nStored in cache handler\tYes (server-side)\tYes (server-side)\tNo (client-side only)\nCache scope\tGlobal (shared)\tGlobal (shared)\tPer-user (isolated)\nSupports runtime prefetching\tN/A (pre-rendered at build)\tNo\tYes (when configured)\nUse case\tStatic, shared content (build-time)\tDynamic, shared content in runtime contexts (per-request)\tPersonalized, user-specific content\n\nNote: While you can't call await cookies() or await headers() inside 'use cache: remote', you can read the values before calling a function that is wrapped by 'use cache: remote' and the arguments will be included in the cache key. Note that this is not recommended as it will dramatically increase the cache size and reduce the cache hit rate.\n\nWhen to use each directive\n\nChoose the right caching directive based on your use case:\n\nUse use cache when:\n\nContent can be prerendered at build time\nContent is shared across all users\nContent doesn't depend on request-specific data\n\nUse 'use cache: remote' when:\n\nYou need caching within dynamic context\nContent is shared across users but must be rendered per-request (after await connection())\nYou want to cache expensive operations in a server-side cache handler\n\nUse 'use cache: private' when:\n\nContent is personalized per-user (depends on cookies, headers)\nYou need runtime prefetching of user-specific content\nContent should never be shared between users\nHow it works\n\nThe 'use cache: remote' directive enables runtime caching of shared data in dynamic contexts by storing results in server-side cache handlers rather than prerendering at build time.\n\nDynamic context detection\n\nWhen Next.js encounters certain APIs like connection(), cookies(), or headers(), the context becomes \"dynamic\". In a dynamic context:\n\nRegular use cache stops working - it won't cache anything\n'use cache: remote' continues to work - it is cached by a remote cache handler.\nResults are stored server-side in a key-value store configured for your deployment\nCached data is shared across requests - reducing database load and origin requests\n\nGood to know: Without 'use cache: remote', functions in dynamic contexts would execute on every request, potentially creating performance bottlenecks. Remote caching eliminates this issue by storing results in server-side cache handlers.\n\nStorage behavior\n\nRemote caches are persisted using server-side cache handlers, which may include:\n\nDistributed key-value stores (in-memory or persistent storage solutions)\nFile system or in-memory storage (often used in development or for custom deployments)\nEnvironment-specific caches (provided by your hosting infrastructure)\nCustom or configured cache handlers (depending on your application's setup)\n\nThis means:\n\nCached data is shared across all users and requests\nCache entries persist beyond a single session\nCache invalidation works via cacheTag and revalidateTag\nCache expiration is controlled by cacheLife configuration\nDynamic context example\nasync function UserDashboard() {\n  // Calling connection() makes the context dynamic\n  await connection()\n \n  // Without any caching directive, this runs on every request\n  const stats = await getStats()\n \n  // With 'use cache: remote', this is cached in the remote handler\n  const analytics = await getAnalytics()\n \n  return (\n    <div>\n      <Stats data={stats} />\n      <Analytics data={analytics} />\n    </div>\n  )\n}\n \nasync function getAnalytics() {\n  'use cache: remote'\n  cacheLife({ expire: 300 }) // 5 minutes\n \n  // This expensive operation is cached and shared across all requests\n  return fetchAnalyticsData()\n}\nRequest APIs and remote caches\n\nWhile 'use cache: remote' technically allows access to request-specific data by calling API's like cookies() and headers() before calling a function that is wrapped by 'use cache: remote', it's generally not recommended to use them together:\n\nAPI\tAllowed in use cache\tAllowed in 'use cache: remote'\tRecommended\ncookies()\tNo\tNo\tUse 'use cache: private' instead\nheaders()\tNo\tNo\tUse 'use cache: private' instead\nconnection()\tNo\tNo\tNo - these cannot ever be cached\nsearchParams\tNo\tNo\tUse 'use cache: private' instead\n\nImportant: If you need to cache based on cookies, headers, or search params, use 'use cache: private' instead. Remote caches are shared across all users, so caching user-specific data in them can lead to incorrect results being served to different users.\n\nNesting rules\n\nRemote caches have specific nesting rules:\n\nRemote caches can be nested inside other remote caches ('use cache: remote')\nRemote caches can be nested inside regular caches ('use cache')\nRemote caches cannot be nested inside private caches ('use cache: private')\nPrivate caches cannot be nested inside remote caches\n// VALID: Remote inside remote\nasync function outerRemote() {\n  'use cache: remote'\n  const result = await innerRemote()\n  return result\n}\n \nasync function innerRemote() {\n  'use cache: remote'\n  return getData()\n}\n \n// VALID: Remote inside regular cache\nasync function outerCache() {\n  'use cache'\n  // If this is in a dynamic context, the inner remote cache will work\n  const result = await innerRemote()\n  return result\n}\n \nasync function innerRemote() {\n  'use cache: remote'\n  return getData()\n}\n \n// INVALID: Remote inside private\nasync function outerPrivate() {\n  'use cache: private'\n  const result = await innerRemote() // Error!\n  return result\n}\n \nasync function innerRemote() {\n  'use cache: remote'\n  return getData()\n}\n \n// INVALID: Private inside remote\nasync function outerRemote() {\n  'use cache: remote'\n  const result = await innerPrivate() // Error!\n  return result\n}\n \nasync function innerPrivate() {\n  'use cache: private'\n  return getData()\n}\nExamples\n\nThe following examples demonstrate common patterns for using 'use cache: remote'. For details about cacheLife parameters (stale, revalidate, expire), see the cacheLife API reference.\n\nPer-request database queries\n\nCache expensive database queries that are accessed in dynamic contexts, reducing load on your database:\n\napp/dashboard/page.tsx\nimport { connection } from 'next/server'\nimport { cacheLife, cacheTag } from 'next/cache'\n \nexport default async function DashboardPage() {\n  // Make context dynamic\n  await connection()\n \n  const stats = await getGlobalStats()\n \n  return <StatsDisplay stats={stats} />\n}\n \nasync function getGlobalStats() {\n  'use cache: remote'\n  cacheTag('global-stats')\n  cacheLife({ expire: 60 }) // 1 minute\n \n  // This expensive database query is cached and shared across all users,\n  // reducing load on your database\n  const stats = await db.analytics.aggregate({\n    total_users: 'count',\n    active_sessions: 'count',\n    revenue: 'sum',\n  })\n \n  return stats\n}\nAPI responses in streaming contexts\n\nCache API responses that are fetched during streaming or after dynamic operations:\n\napp/feed/page.tsx\nimport { Suspense } from 'react'\nimport { connection } from 'next/server'\nimport { cacheLife, cacheTag } from 'next/cache'\n \nexport default async function FeedPage() {\n  return (\n    <div>\n      <Suspense fallback={<Skeleton />}>\n        <FeedItems />\n      </Suspense>\n    </div>\n  )\n}\n \nasync function FeedItems() {\n  // Dynamic context\n  await connection()\n \n  const items = await getFeedItems()\n \n  return items.map((item) => <FeedItem key={item.id} item={item} />)\n}\n \nasync function getFeedItems() {\n  'use cache: remote'\n  cacheTag('feed-items')\n  cacheLife({ expire: 120 }) // 2 minutes\n \n  // This API call is cached, reducing requests to your external service\n  const response = await fetch('https://api.example.com/feed')\n  return response.json()\n}\nComputed data after dynamic checks\n\nCache expensive computations that occur after dynamic security or feature checks:\n\napp/reports/page.tsx\nimport { connection } from 'next/server'\nimport { cacheLife } from 'next/cache'\n \nexport default async function ReportsPage() {\n  // Dynamic security check\n  await connection()\n \n  const report = await generateReport()\n \n  return <ReportViewer report={report} />\n}\n \nasync function generateReport() {\n  'use cache: remote'\n  cacheLife({ expire: 3600 }) // 1 hour\n \n  // This expensive computation is cached and shared across all authorized users,\n  // avoiding repeated calculations\n  const data = await db.transactions.findMany()\n \n  return {\n    totalRevenue: calculateRevenue(data),\n    topProducts: analyzeProducts(data),\n    trends: calculateTrends(data),\n  }\n}\nMixed caching strategies\n\nCombine static, remote, and private caching for optimal performance:\n\napp/product/[id]/page.tsx\nimport { Suspense } from 'react'\nimport { connection } from 'next/server'\nimport { cookies } from 'next/headers'\nimport { cacheLife, cacheTag } from 'next/cache'\n \n// Static product data - prerendered at build time\nasync function getProduct(id: string) {\n  'use cache'\n  cacheTag(`product-${id}`)\n \n  // This is cached at build time and shared across all users\n  return db.products.find({ where: { id } })\n}\n \n// Shared pricing data - cached at runtime in remote handler\nasync function getProductPrice(id: string) {\n  'use cache: remote'\n  cacheTag(`product-price-${id}`)\n  cacheLife({ expire: 300 }) // 5 minutes\n \n  // This is cached at runtime and shared across all users\n  return db.products.getPrice({ where: { id } })\n}\n \n// User-specific recommendations - private cache per user\nasync function getRecommendations(productId: string) {\n  'use cache: private'\n  cacheLife({ expire: 60 }) // 1 minute\n \n  const sessionId = (await cookies()).get('session-id')?.value\n \n  // This is cached per-user and never shared\n  return db.recommendations.findMany({\n    where: { productId, sessionId },\n  })\n}\n \nexport default async function ProductPage({ params }) {\n  const { id } = await params\n \n  // Static product data\n  const product = await getProduct(id)\n \n  return (\n    <div>\n      <ProductDetails product={product} />\n \n      {/* Dynamic shared price */}\n      <Suspense fallback={<PriceSkeleton />}>\n        <ProductPriceComponent productId={id} />\n      </Suspense>\n \n      {/* Dynamic personalized recommendations */}\n      <Suspense fallback={<RecommendationsSkeleton />}>\n        <ProductRecommendations productId={id} />\n      </Suspense>\n    </div>\n  )\n}\n \nfunction ProductDetails({ product }) {\n  return (\n    <div>\n      <h1>{product.name}</h1>\n      <p>{product.description}</p>\n    </div>\n  )\n}\n \nasync function ProductPriceComponent({ productId }) {\n  // Make this component dynamic\n  await connection()\n \n  const price = await getProductPrice(productId)\n  return <div>Price: ${price}</div>\n}\n \nasync function ProductRecommendations({ productId }) {\n  const recommendations = await getRecommendations(productId)\n  return <RecommendationsList items={recommendations} />\n}\n \nfunction PriceSkeleton() {\n  return <div>Loading price...</div>\n}\n \nfunction RecommendationsSkeleton() {\n  return <div>Loading recommendations...</div>\n}\n \nfunction RecommendationsList({ items }) {\n  return (\n    <ul>\n      {items.map((item) => (\n        <li key={item.id}>{item.name}</li>\n      ))}\n    </ul>\n  )\n}\n\nGood to know:\n\nRemote caches are stored in server-side cache handlers and shared across all users\nRemote caches work in dynamic contexts where regular use cache would fail\nUse cacheTag() and revalidateTag() to invalidate remote caches on-demand\nUse cacheLife() to configure cache expiration\nFor user-specific data, use 'use cache: private' instead of 'use cache: remote'\nRemote caches reduce origin load by storing computed or fetched data server-side\nPlatform Support\nDeployment Option\tSupported\nNode.js server\tYes\nDocker container\tYes\nStatic export\tNo\nAdapters\tYes\nVersion History\nVersion\tChanges\nv16.0.0\t'use cache: remote' introduced as an experimental feature.\nRelated\nView related API references.\nuse cache\nLearn how to use the use cache directive to cache data in your Next.js application.\nuse cache: private\nLearn how to use the `\"use cache: private\"` directive to enable runtime prefetching of personalized content in your Next.js application.\ncacheComponents\nLearn how to enable the cacheComponents flag in Next.js.\ncacheLife\nLearn how to use the cacheLife function to set the cache expiration time for a cached function or component.\ncacheTag\nLearn how to use the cacheTag function to manage cache invalidation in your Next.js application.\nconnection\nAPI Reference for the connection function.\nPrevious\nuse cache: private\nNext\nuse client\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Directives: use server | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/directives/use-server",
    "html": "API Reference\nDirectives\nuse server\nCopy page\nuse server\n\nThe use server directive designates a function or file to be executed on the server side. It can be used at the top of a file to indicate that all functions in the file are server-side, or inline at the top of a function to mark the function as a Server Function\n. This is a React feature.\n\nUsing use server at the top of a file\n\nThe following example shows a file with a use server directive at the top. All functions in the file are executed on the server.\n\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\nimport { db } from '@/lib/db' // Your database client\n \nexport async function createUser(data: { name: string; email: string }) {\n  const user = await db.user.create({ data })\n  return user\n}\nUsing Server Functions in a Client Component\n\nTo use Server Functions in Client Components you need to create your Server Functions in a dedicated file using the use server directive at the top of the file. These Server Functions can then be imported into Client and Server Components and executed.\n\nAssuming you have a fetchUsers Server Function in actions.ts:\n\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\nimport { db } from '@/lib/db' // Your database client\n \nexport async function fetchUsers() {\n  const users = await db.user.findMany()\n  return users\n}\n\nThen you can import the fetchUsers Server Function into a Client Component and execute it on the client-side.\n\napp/components/my-button.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\nimport { fetchUsers } from '../actions'\n \nexport default function MyButton() {\n  return <button onClick={() => fetchUsers()}>Fetch Users</button>\n}\nUsing use server inline\n\nIn the following example, use server is used inline at the top of a function to mark it as a Server Function\n:\n\napp/posts/[id]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { EditPost } from './edit-post'\nimport { revalidatePath } from 'next/cache'\n \nexport default async function PostPage({ params }: { params: { id: string } }) {\n  const post = await getPost(params.id)\n \n  async function updatePost(formData: FormData) {\n    'use server'\n    await savePost(params.id, formData)\n    revalidatePath(`/posts/${params.id}`)\n  }\n \n  return <EditPost updatePostAction={updatePost} post={post} />\n}\nSecurity considerations\n\nWhen using the use server directive, it's important to ensure that all server-side logic is secure and that sensitive data remains protected.\n\nAuthentication and authorization\n\nAlways authenticate and authorize users before performing sensitive server-side operations.\n\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { db } from '@/lib/db' // Your database client\nimport { authenticate } from '@/lib/auth' // Your authentication library\n \nexport async function createUser(\n  data: { name: string; email: string },\n  token: string\n) {\n  const user = authenticate(token)\n  if (!user) {\n    throw new Error('Unauthorized')\n  }\n  const newUser = await db.user.create({ data })\n  return newUser\n}\nReference\n\nSee the React documentation\n for more information on use server.\n\nPrevious\nuse client\nNext\nComponents\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "API Reference: Components | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/components",
    "html": "App Router\nAPI Reference\nComponents\nCopy page\nComponents\nFont\nOptimizing loading web fonts with the built-in `next/font` loaders.\nForm Component\nLearn how to use the `<Form>` component to handle form submissions and search params updates with client-side navigation.\nImage Component\nOptimize Images in your Next.js Application using the built-in `next/image` Component.\nLink Component\nEnable fast client-side navigation with the built-in `next/link` component.\nScript Component\nOptimize third-party scripts in your Next.js application using the built-in `next/script` Component.\nPrevious\nuse server\nNext\nFont\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Components: Form Component | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/components/form",
    "html": "API Reference\nComponents\nForm Component\nCopy page\nForm Component\n\nThe <Form> component extends the HTML <form> element to provide prefetching of loading UI, client-side navigation on submission, and progressive enhancement.\n\nIt's useful for forms that update URL search params as it reduces the boilerplate code needed to achieve the above.\n\nBasic usage:\n\n/app/ui/search.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Form from 'next/form'\n \nexport default function Page() {\n  return (\n    <Form action=\"/search\">\n      {/* On submission, the input value will be appended to\n          the URL, e.g. /search?query=abc */}\n      <input name=\"query\" />\n      <button type=\"submit\">Submit</button>\n    </Form>\n  )\n}\nReference\n\nThe behavior of the <Form> component depends on whether the action prop is passed a string or function.\n\nWhen action is a string, the <Form> behaves like a native HTML form that uses a GET method. The form data is encoded into the URL as search params, and when the form is submitted, it navigates to the specified URL. In addition, Next.js:\nPrefetches the path when the form becomes visible, this preloads shared UI (e.g. layout.js and loading.js), resulting in faster navigation.\nPerforms a client-side navigation instead of a full page reload when the form is submitted. This retains shared UI and client-side state.\nWhen action is a function (Server Action), <Form> behaves like a React form\n, executing the action when the form is submitted.\naction (string) Props\n\nWhen action is a string, the <Form> component supports the following props:\n\nProp\tExample\tType\tRequired\naction\taction=\"/search\"\tstring (URL or relative path)\tYes\nreplace\treplace={false}\tboolean\t-\nscroll\tscroll={true}\tboolean\t-\nprefetch\tprefetch={true}\tboolean\t-\naction: The URL or path to navigate to when the form is submitted.\nAn empty string \"\" will navigate to the same route with updated search params.\nreplace: Replaces the current history state instead of pushing a new one to the browser's history\n stack. Default is false.\nscroll: Controls the scroll behavior during navigation. Defaults to true, this means it will scroll to the top of the new route, and maintain the scroll position for backwards and forwards navigation.\nprefetch: Controls whether the path should be prefetched when the form becomes visible in the user's viewport. Defaults to true.\naction (function) Props\n\nWhen action is a function, the <Form> component supports the following prop:\n\nProp\tExample\tType\tRequired\naction\taction={myAction}\tfunction (Server Action)\tYes\naction: The Server Action to be called when the form is submitted. See the React docs\n for more.\n\nGood to know: When action is a function, the replace and scroll props are ignored.\n\nCaveats\nformAction: Can be used in a <button> or <input type=\"submit\"> fields to override the action prop. Next.js will perform a client-side navigation, however, this approach doesn't support prefetching.\nWhen using basePath, you must also include it in the formAction path. e.g. formAction=\"/base-path/search\".\nkey: Passing a key prop to a string action is not supported. If you'd like to trigger a re-render or perform a mutation, consider using a function action instead.\nonSubmit: Can be used to handle form submission logic. However, calling event.preventDefault() will override <Form> behavior such as navigating to the specified URL.\nmethod\n, encType\n, target\n: Are not supported as they override <Form> behavior.\nSimilarly, formMethod, formEncType, and formTarget can be used to override the method, encType, and target props respectively, and using them will fallback to native browser behavior.\nIf you need to use these props, use the HTML <form> element instead.\n<input type=\"file\">: Using this input type when the action is a string will match browser behavior by submitting the filename instead of the file object.\nExamples\nSearch form that leads to a search result page\n\nYou can create a search form that navigates to a search results page by passing the path as an action:\n\n/app/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Form from 'next/form'\n \nexport default function Page() {\n  return (\n    <Form action=\"/search\">\n      <input name=\"query\" />\n      <button type=\"submit\">Submit</button>\n    </Form>\n  )\n}\n\nWhen the user updates the query input field and submits the form, the form data will be encoded into the URL as search params, e.g. /search?query=abc.\n\nGood to know: If you pass an empty string \"\" to action, the form will navigate to the same route with updated search params.\n\nOn the results page, you can access the query using the searchParams page.js prop and use it to fetch data from an external source.\n\n/app/search/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { getSearchResults } from '@/lib/search'\n \nexport default async function SearchPage({\n  searchParams,\n}: {\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  const results = await getSearchResults((await searchParams).query)\n \n  return <div>...</div>\n}\n\nWhen the <Form> becomes visible in the user's viewport, shared UI (such as layout.js and loading.js) on the /search page will be prefetched. On submission, the form will immediately navigate to the new route and show loading UI while the results are being fetched. You can design the fallback UI using loading.js:\n\n/app/search/loading.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Loading() {\n  return <div>Loading...</div>\n}\n\nTo cover cases when shared UI hasn't yet loaded, you can show instant feedback to the user using useFormStatus\n.\n\nFirst, create a component that displays a loading state when the form is pending:\n\n/app/ui/search-button.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\nimport { useFormStatus } from 'react-dom'\n \nexport default function SearchButton() {\n  const status = useFormStatus()\n  return (\n    <button type=\"submit\">{status.pending ? 'Searching...' : 'Search'}</button>\n  )\n}\n\nThen, update the search form page to use the SearchButton component:\n\n/app/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Form from 'next/form'\nimport { SearchButton } from '@/ui/search-button'\n \nexport default function Page() {\n  return (\n    <Form action=\"/search\">\n      <input name=\"query\" />\n      <SearchButton />\n    </Form>\n  )\n}\nMutations with Server Actions\n\nYou can perform mutations by passing a function to the action prop.\n\n/app/posts/create/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Form from 'next/form'\nimport { createPost } from '@/posts/actions'\n \nexport default function Page() {\n  return (\n    <Form action={createPost}>\n      <input name=\"title\" />\n      {/* ... */}\n      <button type=\"submit\">Create Post</button>\n    </Form>\n  )\n}\n\nAfter a mutation, it's common to redirect to the new resource. You can use the redirect function from next/navigation to navigate to the new post page.\n\nGood to know: Since the \"destination\" of the form submission is not known until the action is executed, <Form> cannot automatically prefetch shared UI.\n\n/app/posts/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\nimport { redirect } from 'next/navigation'\n \nexport async function createPost(formData: FormData) {\n  // Create a new post\n  // ...\n \n  // Redirect to the new post\n  redirect(`/posts/${data.id}`)\n}\n\nThen, in the new page, you can fetch data using the params prop:\n\n/app/posts/[id]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { getPost } from '@/posts/data'\n \nexport default async function PostPage({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n  const data = await getPost(id)\n \n  return (\n    <div>\n      <h1>{data.title}</h1>\n      {/* ... */}\n    </div>\n  )\n}\n\nSee the Server Actions docs for more examples.\n\nPrevious\nFont\nNext\nImage Component\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Components: Font | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/components/font",
    "html": "API Reference\nComponents\nFont\nCopy page\nFont Module\n\nnext/font automatically optimizes your fonts (including custom fonts) and removes external network requests for improved privacy and performance.\n\nIt includes built-in automatic self-hosting for any font file. This means you can optimally load web fonts with no layout shift\n.\n\nYou can also conveniently use all Google Fonts\n. CSS and font files are downloaded at build time and self-hosted with the rest of your static assets. No requests are sent to Google by the browser.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Inter } from 'next/font/google'\n \n// If loading a variable font, you don't need to specify the font weight\nconst inter = Inter({\n  subsets: ['latin'],\n  display: 'swap',\n})\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\" className={inter.className}>\n      <body>{children}</body>\n    </html>\n  )\n}\n\n🎥 Watch: Learn more about using next/font → YouTube (6 minutes)\n.\n\nReference\nKey\tfont/google\tfont/local\tType\tRequired\nsrc\t\n\t\n\tString or Array of Objects\tYes\nweight\t\n\t\n\tString or Array\tRequired/Optional\nstyle\t\n\t\n\tString or Array\t-\nsubsets\t\n\t\n\tArray of Strings\t-\naxes\t\n\t\n\tArray of Strings\t-\ndisplay\t\n\t\n\tString\t-\npreload\t\n\t\n\tBoolean\t-\nfallback\t\n\t\n\tArray of Strings\t-\nadjustFontFallback\t\n\t\n\tBoolean or String\t-\nvariable\t\n\t\n\tString\t-\ndeclarations\t\n\t\n\tArray of Objects\t-\nsrc\n\nThe path of the font file as a string or an array of objects (with type Array<{path: string, weight?: string, style?: string}>) relative to the directory where the font loader function is called.\n\nUsed in next/font/local\n\nRequired\n\nExamples:\n\nsrc:'./fonts/my-font.woff2' where my-font.woff2 is placed in a directory named fonts inside the app directory\nsrc:[{path: './inter/Inter-Thin.ttf', weight: '100',},{path: './inter/Inter-Regular.ttf',weight: '400',},{path: './inter/Inter-Bold-Italic.ttf', weight: '700',style: 'italic',},]\nif the font loader function is called in app/page.tsx using src:'../styles/fonts/my-font.ttf', then my-font.ttf is placed in styles/fonts at the root of the project\nweight\n\nThe font weight\n with the following possibilities:\n\nA string with possible values of the weights available for the specific font or a range of values if it's a variable\n font\nAn array of weight values if the font is not a variable google font\n. It applies to next/font/google only.\n\nUsed in next/font/google and next/font/local\n\nRequired if the font being used is not variable\n\nExamples:\n\nweight: '400': A string for a single weight value - for the font Inter\n, the possible values are '100', '200', '300', '400', '500', '600', '700', '800', '900' or 'variable' where 'variable' is the default)\nweight: '100 900': A string for the range between 100 and 900 for a variable font\nweight: ['100','400','900']: An array of 3 possible values for a non variable font\nstyle\n\nThe font style\n with the following possibilities:\n\nA string value\n with default value of 'normal'\nAn array of style values if the font is not a variable google font\n. It applies to next/font/google only.\n\nUsed in next/font/google and next/font/local\n\nOptional\n\nExamples:\n\nstyle: 'italic': A string - it can be normal or italic for next/font/google\nstyle: 'oblique': A string - it can take any value for next/font/local but is expected to come from standard font styles\nstyle: ['italic','normal']: An array of 2 values for next/font/google - the values are from normal and italic\nsubsets\n\nThe font subsets\n defined by an array of string values with the names of each subset you would like to be preloaded. Fonts specified via subsets will have a link preload tag injected into the head when the preload option is true, which is the default.\n\nUsed in next/font/google\n\nOptional\n\nExamples:\n\nsubsets: ['latin']: An array with the subset latin\n\nYou can find a list of all subsets on the Google Fonts page for your font.\n\naxes\n\nSome variable fonts have extra axes that can be included. By default, only the font weight is included to keep the file size down. The possible values of axes depend on the specific font.\n\nUsed in next/font/google\n\nOptional\n\nExamples:\n\naxes: ['slnt']: An array with value slnt for the Inter variable font which has slnt as additional axes as shown here\n. You can find the possible axes values for your font by using the filter on the Google variable fonts page\n and looking for axes other than wght\ndisplay\n\nThe font display\n with possible string values\n of 'auto', 'block', 'swap', 'fallback' or 'optional' with default value of 'swap'.\n\nUsed in next/font/google and next/font/local\n\nOptional\n\nExamples:\n\ndisplay: 'optional': A string assigned to the optional value\npreload\n\nA boolean value that specifies whether the font should be preloaded or not. The default is true.\n\nUsed in next/font/google and next/font/local\n\nOptional\n\nExamples:\n\npreload: false\nfallback\n\nThe fallback font to use if the font cannot be loaded. An array of strings of fallback fonts with no default.\n\nOptional\n\nUsed in next/font/google and next/font/local\n\nExamples:\n\nfallback: ['system-ui', 'arial']: An array setting the fallback fonts to system-ui or arial\nadjustFontFallback\nFor next/font/google: A boolean value that sets whether an automatic fallback font should be used to reduce Cumulative Layout Shift\n. The default is true.\nFor next/font/local: A string or boolean false value that sets whether an automatic fallback font should be used to reduce Cumulative Layout Shift\n. The possible values are 'Arial', 'Times New Roman' or false. The default is 'Arial'.\n\nUsed in next/font/google and next/font/local\n\nOptional\n\nExamples:\n\nadjustFontFallback: false: for next/font/google\nadjustFontFallback: 'Times New Roman': for next/font/local\nvariable\n\nA string value to define the CSS variable name to be used if the style is applied with the CSS variable method.\n\nUsed in next/font/google and next/font/local\n\nOptional\n\nExamples:\n\nvariable: '--my-font': The CSS variable --my-font is declared\ndeclarations\n\nAn array of font face descriptor\n key-value pairs that define the generated @font-face further.\n\nUsed in next/font/local\n\nOptional\n\nExamples:\n\ndeclarations: [{ prop: 'ascent-override', value: '90%' }]\nExamples\nGoogle Fonts\n\nTo use a Google font, import it from next/font/google as a function. We recommend using variable fonts\n for the best performance and flexibility.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Inter } from 'next/font/google'\n \n// If loading a variable font, you don't need to specify the font weight\nconst inter = Inter({\n  subsets: ['latin'],\n  display: 'swap',\n})\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\" className={inter.className}>\n      <body>{children}</body>\n    </html>\n  )\n}\n\nIf you can't use a variable font, you will need to specify a weight:\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Roboto } from 'next/font/google'\n \nconst roboto = Roboto({\n  weight: '400',\n  subsets: ['latin'],\n  display: 'swap',\n})\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\" className={roboto.className}>\n      <body>{children}</body>\n    </html>\n  )\n}\n\nYou can specify multiple weights and/or styles by using an array:\n\napp/layout.js\nconst roboto = Roboto({\n  weight: ['400', '700'],\n  style: ['normal', 'italic'],\n  subsets: ['latin'],\n  display: 'swap',\n})\n\nGood to know: Use an underscore (_) for font names with multiple words. E.g. Roboto Mono should be imported as Roboto_Mono.\n\nSpecifying a subset\n\nGoogle Fonts are automatically subset\n. This reduces the size of the font file and improves performance. You'll need to define which of these subsets you want to preload. Failing to specify any subsets while preload is true will result in a warning.\n\nThis can be done by adding it to the function call:\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nconst inter = Inter({ subsets: ['latin'] })\n\nView the Font API Reference for more information.\n\nUsing Multiple Fonts\n\nYou can import and use multiple fonts in your application. There are two approaches you can take.\n\nThe first approach is to create a utility function that exports a font, imports it, and applies its className where needed. This ensures the font is preloaded only when it's rendered:\n\napp/fonts.ts\nTypeScript\nJavaScript\nTypeScript\nimport { Inter, Roboto_Mono } from 'next/font/google'\n \nexport const inter = Inter({\n  subsets: ['latin'],\n  display: 'swap',\n})\n \nexport const roboto_mono = Roboto_Mono({\n  subsets: ['latin'],\n  display: 'swap',\n})\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { inter } from './fonts'\n \nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\" className={inter.className}>\n      <body>\n        <div>{children}</div>\n      </body>\n    </html>\n  )\n}\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { roboto_mono } from './fonts'\n \nexport default function Page() {\n  return (\n    <>\n      <h1 className={roboto_mono.className}>My page</h1>\n    </>\n  )\n}\n\nIn the example above, Inter will be applied globally, and Roboto Mono can be imported and applied as needed.\n\nAlternatively, you can create a CSS variable and use it with your preferred CSS solution:\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Inter, Roboto_Mono } from 'next/font/google'\nimport styles from './global.css'\n \nconst inter = Inter({\n  subsets: ['latin'],\n  variable: '--font-inter',\n  display: 'swap',\n})\n \nconst roboto_mono = Roboto_Mono({\n  subsets: ['latin'],\n  variable: '--font-roboto-mono',\n  display: 'swap',\n})\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\" className={`${inter.variable} ${roboto_mono.variable}`}>\n      <body>\n        <h1>My App</h1>\n        <div>{children}</div>\n      </body>\n    </html>\n  )\n}\napp/global.css\nhtml {\n  font-family: var(--font-inter);\n}\n \nh1 {\n  font-family: var(--font-roboto-mono);\n}\n\nIn the example above, Inter will be applied globally, and any <h1> tags will be styled with Roboto Mono.\n\nRecommendation: Use multiple fonts conservatively since each new font is an additional resource the client has to download.\n\nLocal Fonts\n\nImport next/font/local and specify the src of your local font file. We recommend using variable fonts\n for the best performance and flexibility.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport localFont from 'next/font/local'\n \n// Font files can be colocated inside of `app`\nconst myFont = localFont({\n  src: './my-font.woff2',\n  display: 'swap',\n})\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\" className={myFont.className}>\n      <body>{children}</body>\n    </html>\n  )\n}\n\nIf you want to use multiple files for a single font family, src can be an array:\n\nconst roboto = localFont({\n  src: [\n    {\n      path: './Roboto-Regular.woff2',\n      weight: '400',\n      style: 'normal',\n    },\n    {\n      path: './Roboto-Italic.woff2',\n      weight: '400',\n      style: 'italic',\n    },\n    {\n      path: './Roboto-Bold.woff2',\n      weight: '700',\n      style: 'normal',\n    },\n    {\n      path: './Roboto-BoldItalic.woff2',\n      weight: '700',\n      style: 'italic',\n    },\n  ],\n})\n\nView the Font API Reference for more information.\n\nWith Tailwind CSS\n\nnext/font integrates seamlessly with Tailwind CSS\n using CSS variables.\n\nIn the example below, we use the Inter and Roboto_Mono fonts from next/font/google (you can use any Google Font or Local Font). Use the variable option to define a CSS variable name, such as inter and roboto_mono for these fonts, respectively. Then, apply inter.variable and roboto_mono.variable to include the CSS variables in your HTML document.\n\nGood to know: You can add these variables to the <html> or <body> tag, depending on your preference, styling needs or project requirements.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Inter, Roboto_Mono } from 'next/font/google'\n \nconst inter = Inter({\n  subsets: ['latin'],\n  display: 'swap',\n  variable: '--font-inter',\n})\n \nconst roboto_mono = Roboto_Mono({\n  subsets: ['latin'],\n  display: 'swap',\n  variable: '--font-roboto-mono',\n})\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html\n      lang=\"en\"\n      className={`${inter.variable} ${roboto_mono.variable} antialiased`}\n    >\n      <body>{children}</body>\n    </html>\n  )\n}\n\nFinally, add the CSS variable to your Tailwind CSS config:\n\nglobal.css\n@import 'tailwindcss';\n \n@theme inline {\n  --font-sans: var(--font-inter);\n  --font-mono: var(--font-roboto-mono);\n}\nTailwind CSS v3\ntailwind.config.js\n/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [\n    './pages/**/*.{js,ts,jsx,tsx}',\n    './components/**/*.{js,ts,jsx,tsx}',\n    './app/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      fontFamily: {\n        sans: ['var(--font-inter)'],\n        mono: ['var(--font-roboto-mono)'],\n      },\n    },\n  },\n  plugins: [],\n}\n\nYou can now use the font-sans and font-mono utility classes to apply the font to your elements.\n\n<p class=\"font-sans ...\">The quick brown fox ...</p>\n<p class=\"font-mono ...\">The quick brown fox ...</p>\nApplying Styles\n\nYou can apply the font styles in three ways:\n\nclassName\nstyle\nCSS Variables\nclassName\n\nReturns a read-only CSS className for the loaded font to be passed to an HTML element.\n\n<p className={inter.className}>Hello, Next.js!</p>\nstyle\n\nReturns a read-only CSS style object for the loaded font to be passed to an HTML element, including style.fontFamily to access the font family name and fallback fonts.\n\n<p style={inter.style}>Hello World</p>\nCSS Variables\n\nIf you would like to set your styles in an external style sheet and specify additional options there, use the CSS variable method.\n\nIn addition to importing the font, also import the CSS file where the CSS variable is defined and set the variable option of the font loader object as follows:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Inter } from 'next/font/google'\nimport styles from '../styles/component.module.css'\n \nconst inter = Inter({\n  variable: '--font-inter',\n})\n\nTo use the font, set the className of the parent container of the text you would like to style to the font loader's variable value and the className of the text to the styles property from the external CSS file.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\n<main className={inter.variable}>\n  <p className={styles.text}>Hello World</p>\n</main>\n\nDefine the text selector class in the component.module.css CSS file as follows:\n\nstyles/component.module.css\n.text {\n  font-family: var(--font-inter);\n  font-weight: 200;\n  font-style: italic;\n}\n\nIn the example above, the text Hello World is styled using the Inter font and the generated font fallback with font-weight: 200 and font-style: italic.\n\nUsing a font definitions file\n\nEvery time you call the localFont or Google font function, that font will be hosted as one instance in your application. Therefore, if you need to use the same font in multiple places, you should load it in one place and import the related font object where you need it. This is done using a font definitions file.\n\nFor example, create a fonts.ts file in a styles folder at the root of your app directory.\n\nThen, specify your font definitions as follows:\n\nstyles/fonts.ts\nTypeScript\nJavaScript\nTypeScript\nimport { Inter, Lora, Source_Sans_3 } from 'next/font/google'\nimport localFont from 'next/font/local'\n \n// define your variable fonts\nconst inter = Inter()\nconst lora = Lora()\n// define 2 weights of a non-variable font\nconst sourceCodePro400 = Source_Sans_3({ weight: '400' })\nconst sourceCodePro700 = Source_Sans_3({ weight: '700' })\n// define a custom local font where GreatVibes-Regular.ttf is stored in the styles folder\nconst greatVibes = localFont({ src: './GreatVibes-Regular.ttf' })\n \nexport { inter, lora, sourceCodePro400, sourceCodePro700, greatVibes }\n\nYou can now use these definitions in your code as follows:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { inter, lora, sourceCodePro700, greatVibes } from '../styles/fonts'\n \nexport default function Page() {\n  return (\n    <div>\n      <p className={inter.className}>Hello world using Inter font</p>\n      <p style={lora.style}>Hello world using Lora font</p>\n      <p className={sourceCodePro700.className}>\n        Hello world using Source_Sans_3 font with weight 700\n      </p>\n      <p className={greatVibes.className}>My title in Great Vibes font</p>\n    </div>\n  )\n}\n\nTo make it easier to access the font definitions in your code, you can define a path alias in your tsconfig.json or jsconfig.json files as follows:\n\ntsconfig.json\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@/fonts\": [\"./styles/fonts\"]\n    }\n  }\n}\n\nYou can now import any font definition as follows:\n\napp/about/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { greatVibes, sourceCodePro400 } from '@/fonts'\nPreloading\n\nWhen a font function is called on a page of your site, it is not globally available and preloaded on all routes. Rather, the font is only preloaded on the related routes based on the type of file where it is used:\n\nIf it's a unique page, it is preloaded on the unique route for that page.\nIf it's a layout, it is preloaded on all the routes wrapped by the layout.\nIf it's the root layout, it is preloaded on all routes.\nVersion Changes\nVersion\tChanges\nv13.2.0\t@next/font renamed to next/font. Installation no longer required.\nv13.0.0\t@next/font was added.\nPrevious\nComponents\nNext\nForm Component\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Components: Image Component | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/components/image",
    "html": "API Reference\nComponents\nImage Component\nCopy page\nImage Component\n\nThe Next.js Image component extends the HTML <img> element for automatic image optimization.\n\napp/page.js\nimport Image from 'next/image'\n \nexport default function Page() {\n  return (\n    <Image\n      src=\"/profile.png\"\n      width={500}\n      height={500}\n      alt=\"Picture of the author\"\n    />\n  )\n}\nReference\nProps\n\nThe following props are available:\n\nProp\tExample\tType\tStatus\nsrc\tsrc=\"/profile.png\"\tString\tRequired\nalt\talt=\"Picture of the author\"\tString\tRequired\nwidth\twidth={500}\tInteger (px)\t-\nheight\theight={500}\tInteger (px)\t-\nfill\tfill={true}\tBoolean\t-\nloader\tloader={imageLoader}\tFunction\t-\nsizes\tsizes=\"(max-width: 768px) 100vw, 33vw\"\tString\t-\nquality\tquality={80}\tInteger (1-100)\t-\npreload\tpreload={true}\tBoolean\t-\nplaceholder\tplaceholder=\"blur\"\tString\t-\nstyle\tstyle={{objectFit: \"contain\"}}\tObject\t-\nonLoadingComplete\tonLoadingComplete={img => done())}\tFunction\tDeprecated\nonLoad\tonLoad={event => done())}\tFunction\t-\nonError\tonError(event => fail()}\tFunction\t-\nloading\tloading=\"lazy\"\tString\t-\nblurDataURL\tblurDataURL=\"data:image/jpeg...\"\tString\t-\nunoptimized\tunoptimized={true}\tBoolean\t-\noverrideSrc\toverrideSrc=\"/seo.png\"\tString\t-\ndecoding\tdecoding=\"async\"\tString\t-\nsrc\n\nThe source of the image. Can be one of the following:\n\nAn internal path string.\n\n<Image src=\"/profile.png\" />\n\nAn absolute external URL (must be configured with remotePatterns).\n\n<Image src=\"https://example.com/profile.png\" />\n\nA static import.\n\nimport profile from './profile.png'\n \nexport default function Page() {\n  return <Image src={profile} />\n}\n\nGood to know: For security reasons, the Image Optimization API using the default loader will not forward headers when fetching the src image. If the src image requires authentication, consider using the unoptimized property to disable Image Optimization.\n\nalt\n\nThe alt property is used to describe the image for screen readers and search engines. It is also the fallback text if images have been disabled or an error occurs while loading the image.\n\nIt should contain text that could replace the image without changing the meaning of the page\n. It is not meant to supplement the image and should not repeat information that is already provided in the captions above or below the image.\n\nIf the image is purely decorative\n or not intended for the user\n, the alt property should be an empty string (alt=\"\").\n\nLearn more about image accessibility guidelines\n.\n\nwidth and height\n\nThe width and height properties represent the intrinsic\n image size in pixels. This property is used to infer the correct aspect ratio used by browsers to reserve space for the image and avoid layout shift during loading. It does not determine the rendered size of the image, which is controlled by CSS.\n\n<Image src=\"/profile.png\" width={500} height={500} />\n\nYou must set both width and height properties unless:\n\nThe image is statically imported.\nThe image has the fill property\n\nIf the height and width are unknown, we recommend using the fill property.\n\nfill\n\nA boolean that causes the image to expand to the size of the parent element.\n\n<Image src=\"/profile.png\" fill={true} />\n\nPositioning:\n\nThe parent element must assign position: \"relative\", \"fixed\", \"absolute\".\nBy default, the <img> element uses position: \"absolute\".\n\nObject Fit:\n\nIf no styles are applied to the image, the image will stretch to fit the container. You can use objectFit to control cropping and scaling.\n\n\"contain\": The image will be scaled down to fit the container and preserve aspect ratio.\n\"cover\": The image will fill the container and be cropped.\n\nLearn more about position\n and object-fit\n.\n\nloader\n\nA custom function used to generate the image URL. The function receives the following parameters, and returns a URL string for the image:\n\nsrc\nwidth\nquality\n'use client'\n \nimport Image from 'next/image'\n \nconst imageLoader = ({ src, width, quality }) => {\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\n}\n \nexport default function Page() {\n  return (\n    <Image\n      loader={imageLoader}\n      src=\"me.png\"\n      alt=\"Picture of the author\"\n      width={500}\n      height={500}\n    />\n  )\n}\n\nGood to know: Using props like onLoad, which accept a function, requires using Client Components\n to serialize the provided function.\n\nAlternatively, you can use the loaderFile configuration in next.config.js to configure every instance of next/image in your application, without passing a prop.\n\nsizes\n\nDefine the sizes of the image at different breakpoints. Used by the browser to choose the most appropriate size from the generated srcset.\n\nimport Image from 'next/image'\n \nexport default function Page() {\n  return (\n    <div className=\"grid-element\">\n      <Image\n        fill\n        src=\"/example.png\"\n        sizes=\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\"\n      />\n    </div>\n  )\n}\n\nsizes should be used when:\n\nThe image is using the fill prop\nCSS is used to make the image responsive\n\nIf sizes is missing, the browser assumes the image will be as wide as the viewport (100vw). This can cause unnecessarily large images to be downloaded.\n\nIn addition, sizes affects how srcset is generated:\n\nWithout sizes: Next.js generates a limited srcset (e.g. 1x, 2x), suitable for fixed-size images.\nWith sizes: Next.js generates a full srcset (e.g. 640w, 750w, etc.), optimized for responsive layouts.\n\nLearn more about srcset and sizes on web.dev\n and mdn\n.\n\nquality\n\nAn integer between 1 and 100 that sets the quality of the optimized image. Higher values increase file size and visual fidelity. Lower values reduce file size but may affect sharpness.\n\n// Default quality is 75\n<Image quality={75} />\n\nIf you’ve configured qualities in next.config.js, the value must match one of the allowed entries.\n\nGood to know: If the original image is already low quality, setting a high quality value will increase the file size without improving appearance.\n\nstyle\n\nAllows passing CSS styles to the underlying image element.\n\nconst imageStyle = {\n  borderRadius: '50%',\n  border: '1px solid #fff',\n  width: '100px',\n  height: 'auto',\n}\n \nexport default function ProfileImage() {\n  return <Image src=\"...\" style={imageStyle} />\n}\n\nGood to know: If you’re using the style prop to set a custom width, be sure to also set height: 'auto' to preserve the image’s aspect ratio.\n\npreload\n\nA boolean that indicates if the image should be preloaded.\n\n// Default preload is false\n<Image preload={false} />\ntrue: Preloads\n the image by inserting a <link> in the <head>.\nfalse: Does not preload the image.\n\nWhen to use it:\n\nThe image is the Largest Contentful Paint (LCP)\n element.\nThe image is above the fold, typically the hero image.\nYou want to begin loading the image in the <head>, before its discovered later in the <body>.\n\nWhen not to use it:\n\nWhen you have multiple images that could be considered the Largest Contentful Paint (LCP)\n element depending on the viewport.\nWhen the loading property is used.\nWhen the fetchPriority property is used.\n\nIn most cases, you should use loading=\"eager\" or fetchPriority=\"high\" instead of preload.\n\npriority\n\nStarting with Next.js 16, the priority property has been deprecated in favor of the preload property in order to make the behavior clear.\n\nloading\n\nControls when the image should start loading.\n\n// Defaults to lazy\n<Image loading=\"lazy\" />\nlazy: Defer loading the image until it reaches a calculated distance from the viewport.\neager: Load the image immediately, regardless of its position in the page.\n\nUse eager only when you want to ensure the image is loaded immediately.\n\nLearn more about the loading attribute\n.\n\nplaceholder\n\nSpecifies a placeholder to use while the image is loading, improving the perceived loading performance.\n\n// defaults to empty\n<Image placeholder=\"empty\" />\nempty: No placeholder while the image is loading.\nblur: Use a blurred version of the image as a placeholder. Must be used with the blurDataURL property.\ndata:image/...: Uses the Data URL\n as the placeholder.\n\nExamples:\n\nblur placeholder\nShimmer effect with data URL placeholder prop\nColor effect with blurDataURL prop\n\nLearn more about the placeholder attribute\n.\n\nblurDataURL\n\nA Data URL\n to be used as a placeholder image before the image successfully loads. Can be automatically set or used with the placeholder=\"blur\" property.\n\n<Image placeholder=\"blur\" blurDataURL=\"...\" />\n\nThe image is automatically enlarged and blurred, so a very small image (10px or less) is recommended.\n\nAutomatic\n\nIf src is a static import of a jpg, png, webp, or avif file, blurDataURL is added automatically—unless the image is animated.\n\nManually set\n\nIf the image is dynamic or remote, you must provide blurDataURL yourself. To generate one, you can use:\n\nA online tool like png-pixel.com\nA library like Plaiceholder\n\nA large blurDataURL may hurt performance. Keep it small and simple.\n\nExamples:\n\nDefault blurDataURL prop\nColor effect with blurDataURL prop\nonLoad\n\nA callback function that is invoked once the image is completely loaded and the placeholder has been removed.\n\n<Image onLoad={(e) => console.log(e.target.naturalWidth)} />\n\nThe callback function will be called with one argument, the event which has a target that references the underlying <img> element.\n\nGood to know: Using props like onLoad, which accept a function, requires using Client Components\n to serialize the provided function.\n\nonError\n\nA callback function that is invoked if the image fails to load.\n\n<Image onError={(e) => console.error(e.target.id)} />\n\nGood to know: Using props like onError, which accept a function, requires using Client Components\n to serialize the provided function.\n\nunoptimized\n\nA boolean that indicates if the image should be optimized. This is useful for images that do not benefit from optimization such as small images (less than 1KB), vector images (SVG), or animated images (GIF).\n\nimport Image from 'next/image'\n \nconst UnoptimizedImage = (props) => {\n  // Default is false\n  return <Image {...props} unoptimized />\n}\ntrue: The source image will be served as-is from the src instead of changing quality, size, or format.\nfalse: The source image will be optimized.\n\nSince Next.js 12.3.0, this prop can be assigned to all images by updating next.config.js with the following configuration:\n\nnext.config.js\nmodule.exports = {\n  images: {\n    unoptimized: true,\n  },\n}\noverrideSrc\n\nWhen providing the src prop to the <Image> component, both the srcset and src attributes are generated automatically for the resulting <img>.\n\ninput.js\n<Image src=\"/profile.jpg\" />\noutput.html\n<img\n  srcset=\"\n    /_next/image?url=%2Fprofile.jpg&w=640&q=75 1x,\n    /_next/image?url=%2Fprofile.jpg&w=828&q=75 2x\n  \"\n  src=\"/_next/image?url=%2Fprofile.jpg&w=828&q=75\"\n/>\n\nIn some cases, it is not desirable to have the src attribute generated and you may wish to override it using the overrideSrc prop.\n\nFor example, when upgrading an existing website from <img> to <Image>, you may wish to maintain the same src attribute for SEO purposes such as image ranking or avoiding recrawl.\n\ninput.js\n<Image src=\"/profile.jpg\" overrideSrc=\"/override.jpg\" />\noutput.html\n<img\n  srcset=\"\n    /_next/image?url=%2Fprofile.jpg&w=640&q=75 1x,\n    /_next/image?url=%2Fprofile.jpg&w=828&q=75 2x\n  \"\n  src=\"/override.jpg\"\n/>\ndecoding\n\nA hint to the browser indicating if it should wait for the image to be decoded before presenting other content updates or not.\n\n// Default is async\n<Image decoding=\"async\" />\nasync: Asynchronously decode the image and allow other content to be rendered before it completes.\nsync: Synchronously decode the image for atomic presentation with other content.\nauto: No preference. The browser chooses the best approach.\n\nLearn more about the decoding attribute\n.\n\nOther Props\n\nOther properties on the <Image /> component will be passed to the underlying img element with the exception of the following:\n\nsrcSet: Use Device Sizes instead.\nDeprecated props\nonLoadingComplete\n\nWarning: Deprecated in Next.js 14, use onLoad instead.\n\nA callback function that is invoked once the image is completely loaded and the placeholder has been removed.\n\nThe callback function will be called with one argument, a reference to the underlying <img> element.\n\n'use client'\n \n<Image onLoadingComplete={(img) => console.log(img.naturalWidth)} />\n\nGood to know: Using props like onLoadingComplete, which accept a function, requires using Client Components\n to serialize the provided function.\n\nConfiguration options\n\nYou can configure the Image Component in next.config.js. The following options are available:\n\nlocalPatterns\n\nUse localPatterns in your next.config.js file to allow images from specific local paths to be optimized and block all others.\n\nnext.config.js\nmodule.exports = {\n  images: {\n    localPatterns: [\n      {\n        pathname: '/assets/images/**',\n        search: '',\n      },\n    ],\n  },\n}\n\nThe example above will ensure the src property of next/image must start with /assets/images/ and must not have a query string. Attempting to optimize any other path will respond with 400 Bad Request error.\n\nGood to know: Omitting the search property allows all search parameters which could allow malicious actors to optimize URLs you did not intend. Try using a specific value like search: '?v=2' to ensure an exact match.\n\nremotePatterns\n\nUse remotePatterns in your next.config.js file to allow images from specific external paths and block all others. This ensures that only external images from your account can be served.\n\nnext.config.js\nmodule.exports = {\n  images: {\n    remotePatterns: [new URL('https://example.com/account123/**')],\n  },\n}\n\nYou can also configure remotePatterns using the object:\n\nnext.config.js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 'example.com',\n        port: '',\n        pathname: '/account123/**',\n        search: '',\n      },\n    ],\n  },\n}\n\nThe example above will ensure the src property of next/image must start with https://example.com/account123/ and must not have a query string. Any other protocol, hostname, port, or unmatched path will respond with 400 Bad Request.\n\nWildcard Patterns:\n\nWildcard patterns can be used for both pathname and hostname and have the following syntax:\n\n* match a single path segment or subdomain\n** match any number of path segments at the end or subdomains at the beginning. This syntax does not work in the middle of the pattern.\nnext.config.js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: '**.example.com',\n        port: '',\n        search: '',\n      },\n    ],\n  },\n}\n\nThis allows subdomains like image.example.com. Query strings and custom ports are still blocked.\n\nGood to know: When omitting protocol, port, pathname, or search then the wildcard ** is implied. This is not recommended because it may allow malicious actors to optimize urls you did not intend.\n\nQuery Strings:\n\nYou can also restrict query strings using the search property:\n\nnext.config.js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 'assets.example.com',\n        search: '?v=1727111025337',\n      },\n    ],\n  },\n}\n\nThe example above will ensure the src property of next/image must start with https://assets.example.com and must have the exact query string ?v=1727111025337. Any other protocol or query string will respond with 400 Bad Request.\n\nloaderFile\n\nloaderFiles allows you to use a custom image optimization service instead of Next.js.\n\nnext.config.js\nmodule.exports = {\n  images: {\n    loader: 'custom',\n    loaderFile: './my/image/loader.js',\n  },\n}\n\nThe path must be relative to the project root. The file must export a default function that returns a URL string:\n\nmy/image/loader.js\n'use client'\n \nexport default function myImageLoader({ src, width, quality }) {\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\n}\n\nExample:\n\nCustom Image Loader Configuration\n\nAlternatively, you can use the loader prop to configure each instance of next/image.\n\npath\n\nIf you want to change or prefix the default path for the Image Optimization API, you can do so with the path property. The default value for path is /_next/image.\n\nnext.config.js\nmodule.exports = {\n  images: {\n    path: '/my-prefix/_next/image',\n  },\n}\ndeviceSizes\n\ndeviceSizes allows you to specify a list of device width breakpoints. These widths are used when the next/image component uses sizes prop to ensure the correct image is served for the user's device.\n\nIf no configuration is provided, the default below is used:\n\nnext.config.js\nmodule.exports = {\n  images: {\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n  },\n}\nimageSizes\n\nimageSizes allows you to specify a list of image widths. These widths are concatenated with the array of device sizes to form the full array of sizes used to generate image srcset\n.\n\nIf no configuration is provided, the default below is used:\n\nnext.config.js\nmodule.exports = {\n  images: {\n    imageSizes: [32, 48, 64, 96, 128, 256, 384],\n  },\n}\n\nimageSizes is only used for images which provide a sizes prop, which indicates that the image is less than the full width of the screen. Therefore, the sizes in imageSizes should all be smaller than the smallest size in deviceSizes.\n\nqualities\n\nqualities allows you to specify a list of image quality values.\n\nIf not configuration is provided, the default below is used:\n\nnext.config.js\nmodule.exports = {\n  images: {\n    qualities: [75],\n  },\n}\n\nGood to know: This field is required starting with Next.js 16 because unrestricted access could allow malicious actors to optimize more qualities than you intended.\n\nYou can add more image qualities to the allowlist, such as the following:\n\nnext.config.js\nmodule.exports = {\n  images: {\n    qualities: [25, 50, 75, 100],\n  },\n}\n\nIn the example above, only four qualities are allowed: 25, 50, 75, and 100.\n\nIf the quality prop does not match a value in this array, the closest allowed value will be used.\n\nIf the REST API is visited directly with a quality that does not match a value in this array, the server will return a 400 Bad Request response.\n\nformats\n\nformats allows you to specify a list of image formats to be used.\n\nnext.config.js\nmodule.exports = {\n  images: {\n    // Default\n    formats: ['image/webp'],\n  },\n}\n\nNext.js automatically detects the browser's supported image formats via the request's Accept header in order to determine the best output format.\n\nIf the Accept header matches more than one of the configured formats, the first match in the array is used. Therefore, the array order matters. If there is no match (or the source image is animated), it will use the original image's format.\n\nYou can enable AVIF support, which will fallback to the original format of the src image if the browser does not support AVIF\n:\n\nnext.config.js\nmodule.exports = {\n  images: {\n    formats: ['image/avif'],\n  },\n}\n\nGood to know:\n\nWe still recommend using WebP for most use cases.\nAVIF generally takes 50% longer to encode but it compresses 20% smaller compared to WebP. This means that the first time an image is requested, it will typically be slower, but subsequent requests that are cached will be faster.\nIf you self-host with a Proxy/CDN in front of Next.js, you must configure the Proxy to forward the Accept header.\nminimumCacheTTL\n\nminimumCacheTTL allows you to configure the Time to Live (TTL) in seconds for cached optimized images. In many cases, it's better to use a Static Image Import which will automatically hash the file contents and cache the image forever with a Cache-Control header of immutable.\n\nIf no configuration is provided, the default below is used.\n\nnext.config.js\nmodule.exports = {\n  images: {\n    minimumCacheTTL: 14400, // 4 hours\n  },\n}\n\nYou can increase the TTL to reduce the number of revalidations and potentially lower cost:\n\nnext.config.js\nmodule.exports = {\n  images: {\n    minimumCacheTTL: 2678400, // 31 days\n  },\n}\n\nThe expiration (or rather Max Age) of the optimized image is defined by either the minimumCacheTTL or the upstream image Cache-Control header, whichever is larger.\n\nIf you need to change the caching behavior per image, you can configure headers to set the Cache-Control header on the upstream image (e.g. /some-asset.jpg, not /_next/image itself).\n\nThere is no mechanism to invalidate the cache at this time, so its best to keep minimumCacheTTL low. Otherwise you may need to manually change the src prop or delete the cached file <distDir>/cache/images.\n\ndisableStaticImages\n\ndisableStaticImages allows you to disable static image imports.\n\nThe default behavior allows you to import static files such as import icon from './icon.png' and then pass that to the src property. In some cases, you may wish to disable this feature if it conflicts with other plugins that expect the import to behave differently.\n\nYou can disable static image imports inside your next.config.js:\n\nnext.config.js\nmodule.exports = {\n  images: {\n    disableStaticImages: true,\n  },\n}\nmaximumRedirects\n\nThe default image optimization loader will follow HTTP redirects when fetching remote images up to 3 times.\n\nnext.config.js\nmodule.exports = {\n  images: {\n    maximumRedirects: 3,\n  },\n}\n\nYou can configure the number of redirects to follow when fetching remote images. Setting the value to 0 will disable following redirects.\n\nnext.config.js\nmodule.exports = {\n  images: {\n    maximumRedirects: 0,\n  },\n}\ndangerouslyAllowLocalIP\n\nIn rare cases when self-hosting Next.js on a private network, you may want to allow optimizing images from local IP addresses on the same network. This is not recommended for most users because it could allow malicious users to access content on your internal network.\n\nBy default, the value is false.\n\nnext.config.js\nmodule.exports = {\n  images: {\n    dangerouslyAllowLocalIP: false,\n  },\n}\n\nIf you need to optimize remote images hosted elsewhere in your local network, you can set the value to true.\n\nnext.config.js\nmodule.exports = {\n  images: {\n    dangerouslyAllowLocalIP: true,\n  },\n}\ndangerouslyAllowSVG\n\ndangerouslyAllowSVG allows you to serve SVG images.\n\nnext.config.js\nmodule.exports = {\n  images: {\n    dangerouslyAllowSVG: true,\n  },\n}\n\nBy default, Next.js does not optimize SVG images for a few reasons:\n\nSVG is a vector format meaning it can be resized losslessly.\nSVG has many of the same features as HTML/CSS, which can lead to vulnerabilities without proper Content Security Policy (CSP) headers.\n\nWe recommend using the unoptimized prop when the src prop is known to be SVG. This happens automatically when src ends with \".svg\".\n\n<Image src=\"/my-image.svg\" unoptimized />\n\nIn addition, it is strongly recommended to also set contentDispositionType to force the browser to download the image, as well as contentSecurityPolicy to prevent scripts embedded in the image from executing.\n\nnext.config.js\nmodule.exports = {\n  images: {\n    dangerouslyAllowSVG: true,\n    contentDispositionType: 'attachment',\n    contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\",\n  },\n}\ncontentDispositionType\n\ncontentDispositionType allows you to configure the Content-Disposition\n header.\n\nnext.config.js\nmodule.exports = {\n  images: {\n    contentDispositionType: 'inline',\n  },\n}\ncontentSecurityPolicy\n\ncontentSecurityPolicy allows you to configure the Content-Security-Policy\n header for images. This is particularly important when using dangerouslyAllowSVG to prevent scripts embedded in the image from executing.\n\nnext.config.js\nmodule.exports = {\n  images: {\n    contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\",\n  },\n}\n\nBy default, the loader sets the Content-Disposition\n header to attachment for added protection since the API can serve arbitrary remote images.\n\nThe default value is attachment which forces the browser to download the image when visiting directly. This is particularly important when dangerouslyAllowSVG is true.\n\nYou can optionally configure inline to allow the browser to render the image when visiting directly, without downloading it.\n\nDeprecated configuration options\ndomains\n\nWarning: Deprecated since Next.js 14 in favor of strict remotePatterns in order to protect your application from malicious users.\n\nSimilar to remotePatterns, the domains configuration can be used to provide a list of allowed hostnames for external images. However, the domains configuration does not support wildcard pattern matching and it cannot restrict protocol, port, or pathname.\n\nSince most remote image servers are shared between multiple tenants, it's safer to use remotePatterns to ensure only the intended images are optimized.\n\nBelow is an example of the domains property in the next.config.js file:\n\nnext.config.js\nmodule.exports = {\n  images: {\n    domains: ['assets.acme.com'],\n  },\n}\nFunctions\ngetImageProps\n\nThe getImageProps function can be used to get the props that would be passed to the underlying <img> element, and instead pass them to another component, style, canvas, etc.\n\nimport { getImageProps } from 'next/image'\n \nconst { props } = getImageProps({\n  src: 'https://example.com/image.jpg',\n  alt: 'A scenic mountain view',\n  width: 1200,\n  height: 800,\n})\n \nfunction ImageWithCaption() {\n  return (\n    <figure>\n      <img {...props} />\n      <figcaption>A scenic mountain view</figcaption>\n    </figure>\n  )\n}\n\nThis also avoid calling React useState() so it can lead to better performance, but it cannot be used with the placeholder prop because the placeholder will never be removed.\n\nKnown browser bugs\n\nThis next/image component uses browser native lazy loading\n, which may fallback to eager loading for older browsers before Safari 15.4. When using the blur-up placeholder, older browsers before Safari 12 will fallback to empty placeholder. When using styles with width/height of auto, it is possible to cause Layout Shift\n on older browsers before Safari 15 that don't preserve the aspect ratio\n. For more details, see this MDN video\n.\n\nSafari 15 - 16.3\n display a gray border while loading. Safari 16.4 fixed this issue\n. Possible solutions:\nUse CSS @supports (font: -apple-system-body) and (-webkit-appearance: none) { img[loading=\"lazy\"] { clip-path: inset(0.6px) } }\nUse loading=\"eager\" if the image is above the fold\nFirefox 67+\n displays a white background while loading. Possible solutions:\nEnable AVIF formats\nUse placeholder\nExamples\nStyling images\n\nStyling the Image component is similar to styling a normal <img> element, but there are a few guidelines to keep in mind:\n\nUse className or style, not styled-jsx. In most cases, we recommend using the className prop. This can be an imported CSS Module, a global stylesheet, etc.\n\nimport styles from './styles.module.css'\n \nexport default function MyImage() {\n  return <Image className={styles.image} src=\"/my-image.png\" alt=\"My Image\" />\n}\n\nYou can also use the style prop to assign inline styles.\n\nexport default function MyImage() {\n  return (\n    <Image style={{ borderRadius: '8px' }} src=\"/my-image.png\" alt=\"My Image\" />\n  )\n}\n\nWhen using fill, the parent element must have position: relative or display: block. This is necessary for the proper rendering of the image element in that layout mode.\n\n<div style={{ position: 'relative' }}>\n  <Image fill src=\"/my-image.png\" alt=\"My Image\" />\n</div>\n\nYou cannot use styled-jsx because it's scoped to the current component (unless you mark the style as global).\n\nResponsive images with a static export\n\nWhen you import a static image, Next.js automatically sets its width and height based on the file. You can make the image responsive by setting the style:\n\nimport Image from 'next/image'\nimport mountains from '../public/mountains.jpg'\n \nexport default function Responsive() {\n  return (\n    <div style={{ display: 'flex', flexDirection: 'column' }}>\n      <Image\n        alt=\"Mountains\"\n        // Importing an image will\n        // automatically set the width and height\n        src={mountains}\n        sizes=\"100vw\"\n        // Make the image display full width\n        // and preserve its aspect ratio\n        style={{\n          width: '100%',\n          height: 'auto',\n        }}\n      />\n    </div>\n  )\n}\nResponsive images with a remote URL\n\nIf the source image is a dynamic or a remote URL, you must provide the width and height props so Next.js can calculate the aspect ratio:\n\ncomponents/page.js\nimport Image from 'next/image'\n \nexport default function Page({ photoUrl }) {\n  return (\n    <Image\n      src={photoUrl}\n      alt=\"Picture of the author\"\n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }}\n      width={500}\n      height={300}\n    />\n  )\n}\n\nTry it out:\n\nDemo the image responsive to viewport\nResponsive image with fill\n\nIf you don't know the aspect ratio of the image, you can add the fill prop with the objectFit prop set to cover. This will make the image fill the full width of its parent container.\n\nimport Image from 'next/image'\nimport mountains from '../public/mountains.jpg'\n \nexport default function Fill() {\n  return (\n    <div\n      style={{\n        display: 'grid',\n        gridGap: '8px',\n        gridTemplateColumns: 'repeat(auto-fit, minmax(400px, auto))',\n      }}\n    >\n      <div style={{ position: 'relative', width: '400px' }}>\n        <Image\n          alt=\"Mountains\"\n          src={mountains}\n          fill\n          sizes=\"(min-width: 808px) 50vw, 100vw\"\n          style={{\n            objectFit: 'cover', // cover, contain, none\n          }}\n        />\n      </div>\n      {/* And more images in the grid... */}\n    </div>\n  )\n}\nBackground Image\n\nUse the fill prop to make the image cover the entire screen area:\n\nimport Image from 'next/image'\nimport mountains from '../public/mountains.jpg'\n \nexport default function Background() {\n  return (\n    <Image\n      alt=\"Mountains\"\n      src={mountains}\n      placeholder=\"blur\"\n      quality={100}\n      fill\n      sizes=\"100vw\"\n      style={{\n        objectFit: 'cover',\n      }}\n    />\n  )\n}\n\nFor examples of the Image component used with the various styles, see the Image Component Demo\n.\n\nRemote images\n\nTo use a remote image, the src property should be a URL string.\n\napp/page.js\nimport Image from 'next/image'\n \nexport default function Page() {\n  return (\n    <Image\n      src=\"https://s3.amazonaws.com/my-bucket/profile.png\"\n      alt=\"Picture of the author\"\n      width={500}\n      height={500}\n    />\n  )\n}\n\nSince Next.js does not have access to remote files during the build process, you'll need to provide the width, height and optional blurDataURL props manually.\n\nThe width and height attributes are used to infer the correct aspect ratio of image and avoid layout shift from the image loading in. The width and height do not determine the rendered size of the image file.\n\nTo safely allow optimizing images, define a list of supported URL patterns in next.config.js. Be as specific as possible to prevent malicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket:\n\nnext.config.js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 's3.amazonaws.com',\n        port: '',\n        pathname: '/my-bucket/**',\n        search: '',\n      },\n    ],\n  },\n}\nTheme detection\n\nIf you want to display a different image for light and dark mode, you can create a new component that wraps two <Image> components and reveals the correct one based on a CSS media query.\n\ncomponents/theme-image.module.css\n.imgDark {\n  display: none;\n}\n \n@media (prefers-color-scheme: dark) {\n  .imgLight {\n    display: none;\n  }\n  .imgDark {\n    display: unset;\n  }\n}\ncomponents/theme-image.tsx\nTypeScript\nJavaScript\nTypeScript\nimport styles from './theme-image.module.css'\nimport Image, { ImageProps } from 'next/image'\n \ntype Props = Omit<ImageProps, 'src' | 'preload' | 'loading'> & {\n  srcLight: string\n  srcDark: string\n}\n \nconst ThemeImage = (props: Props) => {\n  const { srcLight, srcDark, ...rest } = props\n \n  return (\n    <>\n      <Image {...rest} src={srcLight} className={styles.imgLight} />\n      <Image {...rest} src={srcDark} className={styles.imgDark} />\n    </>\n  )\n}\n\nGood to know: The default behavior of loading=\"lazy\" ensures that only the correct image is loaded. You cannot use preload or loading=\"eager\" because that would cause both images to load. Instead, you can use fetchPriority=\"high\"\n.\n\nTry it out:\n\nDemo light/dark mode theme detection\nArt direction\n\nIf you want to display a different image for mobile and desktop, sometimes called Art Direction\n, you can provide different src, width, height, and quality props to getImageProps().\n\napp/page.js\nimport { getImageProps } from 'next/image'\n \nexport default function Home() {\n  const common = { alt: 'Art Direction Example', sizes: '100vw' }\n  const {\n    props: { srcSet: desktop },\n  } = getImageProps({\n    ...common,\n    width: 1440,\n    height: 875,\n    quality: 80,\n    src: '/desktop.jpg',\n  })\n  const {\n    props: { srcSet: mobile, ...rest },\n  } = getImageProps({\n    ...common,\n    width: 750,\n    height: 1334,\n    quality: 70,\n    src: '/mobile.jpg',\n  })\n \n  return (\n    <picture>\n      <source media=\"(min-width: 1000px)\" srcSet={desktop} />\n      <source media=\"(min-width: 500px)\" srcSet={mobile} />\n      <img {...rest} style={{ width: '100%', height: 'auto' }} />\n    </picture>\n  )\n}\nBackground CSS\n\nYou can even convert the srcSet string to the image-set()\n CSS function to optimize a background image.\n\napp/page.js\nimport { getImageProps } from 'next/image'\n \nfunction getBackgroundImage(srcSet = '') {\n  const imageSet = srcSet\n    .split(', ')\n    .map((str) => {\n      const [url, dpi] = str.split(' ')\n      return `url(\"${url}\") ${dpi}`\n    })\n    .join(', ')\n  return `image-set(${imageSet})`\n}\n \nexport default function Home() {\n  const {\n    props: { srcSet },\n  } = getImageProps({ alt: '', width: 128, height: 128, src: '/img.png' })\n  const backgroundImage = getBackgroundImage(srcSet)\n  const style = { height: '100vh', width: '100vw', backgroundImage }\n \n  return (\n    <main style={style}>\n      <h1>Hello World</h1>\n    </main>\n  )\n}\nVersion History\nVersion\tChanges\nv16.0.0\tqualities default configuration changed to [75], preload prop added, priority prop deprecated, dangerouslyAllowLocalIP config added, maximumRedirects config added.\nv15.3.0\tremotePatterns added support for array of URL objects.\nv15.0.0\tcontentDispositionType configuration default changed to attachment.\nv14.2.23\tqualities configuration added.\nv14.2.15\tdecoding prop added and localPatterns configuration added.\nv14.2.14\tremotePatterns.search prop added.\nv14.2.0\toverrideSrc prop added.\nv14.1.0\tgetImageProps() is stable.\nv14.0.0\tonLoadingComplete prop and domains config deprecated.\nv13.4.14\tplaceholder prop support for data:/image...\nv13.2.0\tcontentDispositionType configuration added.\nv13.0.6\tref prop added.\nv13.0.0\tThe next/image import was renamed to next/legacy/image. The next/future/image import was renamed to next/image. A codemod is available to safely and automatically rename your imports. <span> wrapper removed. layout, objectFit, objectPosition, lazyBoundary, lazyRoot props removed. alt is required. onLoadingComplete receives reference to img element. Built-in loader config removed.\nv12.3.0\tremotePatterns and unoptimized configuration is stable.\nv12.2.0\tExperimental remotePatterns and experimental unoptimized configuration added. layout=\"raw\" removed.\nv12.1.1\tstyle prop added. Experimental support for layout=\"raw\" added.\nv12.1.0\tdangerouslyAllowSVG and contentSecurityPolicy configuration added.\nv12.0.9\tlazyRoot prop added.\nv12.0.0\tformats configuration added.\nAVIF support added.\nWrapper <div> changed to <span>.\nv11.1.0\tonLoadingComplete and lazyBoundary props added.\nv11.0.0\tsrc prop support for static import.\nplaceholder prop added.\nblurDataURL prop added.\nv10.0.5\tloader prop added.\nv10.0.1\tlayout prop added.\nv10.0.0\tnext/image introduced.\nPrevious\nForm Component\nNext\nLink Component\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Components: Link Component | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/components/link",
    "html": "API Reference\nComponents\nLink Component\nCopy page\nLink Component\n\n<Link> is a React component that extends the HTML <a> element to provide prefetching and client-side navigation between routes. It is the primary way to navigate between routes in Next.js.\n\nBasic usage:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \nexport default function Page() {\n  return <Link href=\"/dashboard\">Dashboard</Link>\n}\nReference\n\nThe following props can be passed to the <Link> component:\n\nProp\tExample\tType\tRequired\nhref\thref=\"/dashboard\"\tString or Object\tYes\nreplace\treplace={false}\tBoolean\t-\nscroll\tscroll={false}\tBoolean\t-\nprefetch\tprefetch={false}\tBoolean or null\t-\nonNavigate\tonNavigate={(e) => {}}\tFunction\t-\n\nGood to know: <a> tag attributes such as className or target=\"_blank\" can be added to <Link> as props and will be passed to the underlying <a> element.\n\nhref (required)\n\nThe path or URL to navigate to.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \n// Navigate to /about?name=test\nexport default function Page() {\n  return (\n    <Link\n      href={{\n        pathname: '/about',\n        query: { name: 'test' },\n      }}\n    >\n      About\n    </Link>\n  )\n}\nreplace\n\nDefaults to false. When true, next/link will replace the current history state instead of adding a new URL into the browser's history\n stack.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \nexport default function Page() {\n  return (\n    <Link href=\"/dashboard\" replace>\n      Dashboard\n    </Link>\n  )\n}\nscroll\n\nDefaults to true. The default scrolling behavior of <Link> in Next.js is to maintain scroll position, similar to how browsers handle back and forwards navigation. When you navigate to a new Page, scroll position will stay the same as long as the Page is visible in the viewport. However, if the Page is not visible in the viewport, Next.js will scroll to the top of the first Page element.\n\nWhen scroll = {false}, Next.js will not attempt to scroll to the first Page element.\n\nGood to know: Next.js checks if scroll: false before managing scroll behavior. If scrolling is enabled, it identifies the relevant DOM node for navigation and inspects each top-level element. All non-scrollable elements and those without rendered HTML are bypassed, this includes sticky or fixed positioned elements, and non-visible elements such as those calculated with getBoundingClientRect. Next.js then continues through siblings until it identifies a scrollable element that is visible in the viewport.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \nexport default function Page() {\n  return (\n    <Link href=\"/dashboard\" scroll={false}>\n      Dashboard\n    </Link>\n  )\n}\nprefetch\n\nPrefetching happens when a <Link /> component enters the user's viewport (initially or through scroll). Next.js prefetches and loads the linked route (denoted by the href) and its data in the background to improve the performance of client-side navigations. If the prefetched data has expired by the time the user hovers over a <Link />, Next.js will attempt to prefetch it again. Prefetching is only enabled in production.\n\nThe following values can be passed to the prefetch prop:\n\n\"auto\" or null (default): Prefetch behavior depends on whether the route is static or dynamic. For static routes, the full route will be prefetched (including all its data). For dynamic routes, the partial route down to the nearest segment with a loading.js boundary will be prefetched.\ntrue: The full route will be prefetched for both static and dynamic routes.\nfalse: Prefetching will never happen both on entering the viewport and on hover.\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \nexport default function Page() {\n  return (\n    <Link href=\"/dashboard\" prefetch={false}>\n      Dashboard\n    </Link>\n  )\n}\nonNavigate\n\nAn event handler called during client-side navigation. The handler receives an event object that includes a preventDefault() method, allowing you to cancel the navigation if needed.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \nexport default function Page() {\n  return (\n    <Link\n      href=\"/dashboard\"\n      onNavigate={(e) => {\n        // Only executes during SPA navigation\n        console.log('Navigating...')\n \n        // Optionally prevent navigation\n        // e.preventDefault()\n      }}\n    >\n      Dashboard\n    </Link>\n  )\n}\n\nGood to know: While onClick and onNavigate may seem similar, they serve different purposes. onClick executes for all click events, while onNavigate only runs during client-side navigation. Some key differences:\n\nWhen using modifier keys (Ctrl/Cmd + Click), onClick executes but onNavigate doesn't since Next.js prevents default navigation for new tabs.\nExternal URLs won't trigger onNavigate since it's only for client-side and same-origin navigations.\nLinks with the download attribute will work with onClick but not onNavigate since the browser will treat the linked URL as a download.\nExamples\n\nThe following examples demonstrate how to use the <Link> component in different scenarios.\n\nLinking to dynamic route segments\n\nWhen linking to dynamic segments, you can use template literals and interpolation\n to generate a list of links. For example, to generate a list of blog posts:\n\napp/blog/post-list.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \ninterface Post {\n  id: number\n  title: string\n  slug: string\n}\n \nexport default function PostList({ posts }: { posts: Post[] }) {\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li key={post.id}>\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\n        </li>\n      ))}\n    </ul>\n  )\n}\nChecking active links\n\nYou can use usePathname() to determine if a link is active. For example, to add a class to the active link, you can check if the current pathname matches the href of the link:\n\napp/ui/nav-links.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { usePathname } from 'next/navigation'\nimport Link from 'next/link'\n \nexport function Links() {\n  const pathname = usePathname()\n \n  return (\n    <nav>\n      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href=\"/\">\n        Home\n      </Link>\n \n      <Link\n        className={`link ${pathname === '/about' ? 'active' : ''}`}\n        href=\"/about\"\n      >\n        About\n      </Link>\n    </nav>\n  )\n}\nScrolling to an id\n\nIf you'd like to scroll to a specific id on navigation, you can append your URL with a # hash link or just pass a hash link to the href prop. This is possible since <Link> renders to an <a> element.\n\n<Link href=\"/dashboard#settings\">Settings</Link>\n \n// Output\n<a href=\"/dashboard#settings\">Settings</a>\n\nGood to know:\n\nNext.js will scroll to the Page if it is not visible in the viewport upon navigation.\nReplace the URL instead of push\n\nThe default behavior of the Link component is to push a new URL into the history stack. You can use the replace prop to prevent adding a new entry, as in the following example:\n\napp/page.js\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \nexport default function Page() {\n  return (\n    <Link href=\"/about\" replace>\n      About us\n    </Link>\n  )\n}\nDisable scrolling to the top of the page\n\nThe default scrolling behavior of <Link> in Next.js is to maintain scroll position, similar to how browsers handle back and forwards navigation. When you navigate to a new Page, scroll position will stay the same as long as the Page is visible in the viewport.\n\nHowever, if the Page is not visible in the viewport, Next.js will scroll to the top of the first Page element. If you'd like to disable this behavior, you can pass scroll={false} to the <Link> component, or scroll: false to router.push() or router.replace().\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \nexport default function Page() {\n  return (\n    <Link href=\"/#hashid\" scroll={false}>\n      Disables scrolling to the top\n    </Link>\n  )\n}\n\nUsing router.push() or router.replace():\n\n// useRouter\nimport { useRouter } from 'next/navigation'\n \nconst router = useRouter()\n \nrouter.push('/dashboard', { scroll: false })\nPrefetching links in Proxy\n\nIt's common to use Proxy for authentication or other purposes that involve rewriting the user to a different page. In order for the <Link /> component to properly prefetch links with rewrites via Proxy, you need to tell Next.js both the URL to display and the URL to prefetch. This is required to avoid un-necessary fetches to proxy to know the correct route to prefetch.\n\nFor example, if you want to serve a /dashboard route that has authenticated and visitor views, you can add the following in your Proxy to redirect the user to the correct page:\n\nproxy.ts\nTypeScript\nJavaScript\nTypeScript\nimport { NextResponse } from 'next/server'\n \nexport function proxy(request: Request) {\n  const nextUrl = request.nextUrl\n  if (nextUrl.pathname === '/dashboard') {\n    if (request.cookies.authToken) {\n      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))\n    } else {\n      return NextResponse.rewrite(new URL('/public/dashboard', request.url))\n    }\n  }\n}\n\nIn this case, you would want to use the following code in your <Link /> component:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport Link from 'next/link'\nimport useIsAuthed from './hooks/useIsAuthed' // Your auth hook\n \nexport default function Page() {\n  const isAuthed = useIsAuthed()\n  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'\n  return (\n    <Link as=\"/dashboard\" href={path}>\n      Dashboard\n    </Link>\n  )\n}\nBlocking navigation\n\nYou can use the onNavigate prop to block navigation when certain conditions are met, such as when a form has unsaved changes. When you need to block navigation across multiple components in your app (like preventing navigation from any link while a form is being edited), React Context provides a clean way to share this blocking state. First, create a context to track the navigation blocking state:\n\napp/contexts/navigation-blocker.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { createContext, useState, useContext } from 'react'\n \ninterface NavigationBlockerContextType {\n  isBlocked: boolean\n  setIsBlocked: (isBlocked: boolean) => void\n}\n \nexport const NavigationBlockerContext =\n  createContext<NavigationBlockerContextType>({\n    isBlocked: false,\n    setIsBlocked: () => {},\n  })\n \nexport function NavigationBlockerProvider({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  const [isBlocked, setIsBlocked] = useState(false)\n \n  return (\n    <NavigationBlockerContext.Provider value={{ isBlocked, setIsBlocked }}>\n      {children}\n    </NavigationBlockerContext.Provider>\n  )\n}\n \nexport function useNavigationBlocker() {\n  return useContext(NavigationBlockerContext)\n}\n\nCreate a form component that uses the context:\n\napp/components/form.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useNavigationBlocker } from '../contexts/navigation-blocker'\n \nexport default function Form() {\n  const { setIsBlocked } = useNavigationBlocker()\n \n  return (\n    <form\n      onSubmit={(e) => {\n        e.preventDefault()\n        setIsBlocked(false)\n      }}\n      onChange={() => setIsBlocked(true)}\n    >\n      <input type=\"text\" name=\"name\" />\n      <button type=\"submit\">Save</button>\n    </form>\n  )\n}\n\nCreate a custom Link component that blocks navigation:\n\napp/components/custom-link.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport Link from 'next/link'\nimport { useNavigationBlocker } from '../contexts/navigation-blocker'\n \ninterface CustomLinkProps extends React.ComponentProps<typeof Link> {\n  children: React.ReactNode\n}\n \nexport function CustomLink({ children, ...props }: CustomLinkProps) {\n  const { isBlocked } = useNavigationBlocker()\n \n  return (\n    <Link\n      onNavigate={(e) => {\n        if (\n          isBlocked &&\n          !window.confirm('You have unsaved changes. Leave anyway?')\n        ) {\n          e.preventDefault()\n        }\n      }}\n      {...props}\n    >\n      {children}\n    </Link>\n  )\n}\n\nCreate a navigation component:\n\napp/components/nav.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { CustomLink as Link } from './custom-link'\n \nexport default function Nav() {\n  return (\n    <nav>\n      <Link href=\"/\">Home</Link>\n      <Link href=\"/about\">About</Link>\n    </nav>\n  )\n}\n\nFinally, wrap your app with the NavigationBlockerProvider in the root layout and use the components in your page:\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { NavigationBlockerProvider } from './contexts/navigation-blocker'\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <NavigationBlockerProvider>{children}</NavigationBlockerProvider>\n      </body>\n    </html>\n  )\n}\n\nThen, use the Nav and Form components in your page:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Nav from './components/nav'\nimport Form from './components/form'\n \nexport default function Page() {\n  return (\n    <div>\n      <Nav />\n      <main>\n        <h1>Welcome to the Dashboard</h1>\n        <Form />\n      </main>\n    </div>\n  )\n}\n\nWhen a user tries to navigate away using CustomLink while the form has unsaved changes, they'll be prompted to confirm before leaving.\n\nVersion history\nVersion\tChanges\nv15.4.0\tAdd auto as an alias to the default prefetch behavior.\nv15.3.0\tAdd onNavigate API\nv13.0.0\tNo longer requires a child <a> tag. A codemod is provided to automatically update your codebase.\nv10.0.0\thref props pointing to a dynamic route are automatically resolved and no longer require an as prop.\nv8.0.0\tImproved prefetching performance.\nv1.0.0\tnext/link introduced.\nPrevious\nImage Component\nNext\nScript Component\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Components: Script Component | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/components/script",
    "html": "API Reference\nComponents\nScript Component\nCopy page\nScript Component\n\nThis API reference will help you understand how to use props available for the Script Component. For features and usage, please see the Optimizing Scripts page.\n\napp/dashboard/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Script from 'next/script'\n \nexport default function Dashboard() {\n  return (\n    <>\n      <Script src=\"https://example.com/script.js\" />\n    </>\n  )\n}\nProps\n\nHere's a summary of the props available for the Script Component:\n\nProp\tExample\tType\tRequired\nsrc\tsrc=\"http://example.com/script\"\tString\tRequired unless inline script is used\nstrategy\tstrategy=\"lazyOnload\"\tString\t-\nonLoad\tonLoad={onLoadFunc}\tFunction\t-\nonReady\tonReady={onReadyFunc}\tFunction\t-\nonError\tonError={onErrorFunc}\tFunction\t-\nRequired Props\n\nThe <Script /> component requires the following properties.\n\nsrc\n\nA path string specifying the URL of an external script. This can be either an absolute external URL or an internal path. The src property is required unless an inline script is used.\n\nOptional Props\n\nThe <Script /> component accepts a number of additional properties beyond those which are required.\n\nstrategy\n\nThe loading strategy of the script. There are four different strategies that can be used:\n\nbeforeInteractive: Load before any Next.js code and before any page hydration occurs.\nafterInteractive: (default) Load early but after some hydration on the page occurs.\nlazyOnload: Load during browser idle time.\nworker: (experimental) Load in a web worker.\nbeforeInteractive\n\nScripts that load with the beforeInteractive strategy are injected into the initial HTML from the server, downloaded before any Next.js module, and executed in the order they are placed.\n\nScripts denoted with this strategy are preloaded and fetched before any first-party code, but their execution does not block page hydration from occurring.\n\nbeforeInteractive scripts must be placed inside the root layout (app/layout.tsx) and are designed to load scripts that are needed by the entire site (i.e. the script will load when any page in the application has been loaded server-side).\n\nThis strategy should only be used for critical scripts that need to be fetched as soon as possible.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Script from 'next/script'\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        {children}\n        <Script\n          src=\"https://example.com/script.js\"\n          strategy=\"beforeInteractive\"\n        />\n      </body>\n    </html>\n  )\n}\n\nGood to know: Scripts with beforeInteractive will always be injected inside the head of the HTML document regardless of where it's placed in the component.\n\nSome examples of scripts that should be fetched as soon as possible with beforeInteractive include:\n\nBot detectors\nCookie consent managers\nafterInteractive\n\nScripts that use the afterInteractive strategy are injected into the HTML client-side and will load after some (or all) hydration occurs on the page. This is the default strategy of the Script component and should be used for any script that needs to load as soon as possible but not before any first-party Next.js code.\n\nafterInteractive scripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is opened in the browser.\n\napp/page.js\nimport Script from 'next/script'\n \nexport default function Page() {\n  return (\n    <>\n      <Script src=\"https://example.com/script.js\" strategy=\"afterInteractive\" />\n    </>\n  )\n}\n\nSome examples of scripts that are good candidates for afterInteractive include:\n\nTag managers\nAnalytics\nlazyOnload\n\nScripts that use the lazyOnload strategy are injected into the HTML client-side during browser idle time and will load after all resources on the page have been fetched. This strategy should be used for any background or low priority scripts that do not need to load early.\n\nlazyOnload scripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is opened in the browser.\n\napp/page.js\nimport Script from 'next/script'\n \nexport default function Page() {\n  return (\n    <>\n      <Script src=\"https://example.com/script.js\" strategy=\"lazyOnload\" />\n    </>\n  )\n}\n\nExamples of scripts that do not need to load immediately and can be fetched with lazyOnload include:\n\nChat support plugins\nSocial media widgets\nworker\n\nWarning: The worker strategy is not yet stable and does not yet work with the App Router. Use with caution.\n\nScripts that use the worker strategy are off-loaded to a web worker in order to free up the main thread and ensure that only critical, first-party resources are processed on it. While this strategy can be used for any script, it is an advanced use case that is not guaranteed to support all third-party scripts.\n\nTo use worker as a strategy, the nextScriptWorkers flag must be enabled in next.config.js:\n\nnext.config.js\nmodule.exports = {\n  experimental: {\n    nextScriptWorkers: true,\n  },\n}\n\nworker scripts can only currently be used in the pages/ directory:\n\npages/home.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Script from 'next/script'\n \nexport default function Home() {\n  return (\n    <>\n      <Script src=\"https://example.com/script.js\" strategy=\"worker\" />\n    </>\n  )\n}\nonLoad\n\nWarning: onLoad does not yet work with Server Components and can only be used in Client Components. Further, onLoad can't be used with beforeInteractive – consider using onReady instead.\n\nSome third-party scripts require users to run JavaScript code once after the script has finished loading in order to instantiate content or call a function. If you are loading a script with either afterInteractive or lazyOnload as a loading strategy, you can execute code after it has loaded using the onLoad property.\n\nHere's an example of executing a lodash method only after the library has been loaded.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport Script from 'next/script'\n \nexport default function Page() {\n  return (\n    <>\n      <Script\n        src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js\"\n        onLoad={() => {\n          console.log(_.sample([1, 2, 3, 4]))\n        }}\n      />\n    </>\n  )\n}\nonReady\n\nWarning: onReady does not yet work with Server Components and can only be used in Client Components.\n\nSome third-party scripts require users to run JavaScript code after the script has finished loading and every time the component is mounted (after a route navigation for example). You can execute code after the script's load event when it first loads and then after every subsequent component re-mount using the onReady property.\n\nHere's an example of how to re-instantiate a Google Maps JS embed every time the component is mounted:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useRef } from 'react'\nimport Script from 'next/script'\n \nexport default function Page() {\n  const mapRef = useRef()\n \n  return (\n    <>\n      <div ref={mapRef}></div>\n      <Script\n        id=\"google-maps\"\n        src=\"https://maps.googleapis.com/maps/api/js\"\n        onReady={() => {\n          new google.maps.Map(mapRef.current, {\n            center: { lat: -34.397, lng: 150.644 },\n            zoom: 8,\n          })\n        }}\n      />\n    </>\n  )\n}\nonError\n\nWarning: onError does not yet work with Server Components and can only be used in Client Components. onError cannot be used with the beforeInteractive loading strategy.\n\nSometimes it is helpful to catch when a script fails to load. These errors can be handled with the onError property:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport Script from 'next/script'\n \nexport default function Page() {\n  return (\n    <>\n      <Script\n        src=\"https://example.com/script.js\"\n        onError={(e: Error) => {\n          console.error('Script failed to load', e)\n        }}\n      />\n    </>\n  )\n}\nVersion History\nVersion\tChanges\nv13.0.0\tbeforeInteractive and afterInteractive is modified to support app.\nv12.2.4\tonReady prop added.\nv12.2.2\tAllow next/script with beforeInteractive to be placed in _document.\nv11.0.0\tnext/script introduced.\nPrevious\nLink Component\nNext\nFile-system conventions\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "API Reference: File-system conventions | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions",
    "html": "App Router\nAPI Reference\nFile-system conventions\nCopy page\nFile-system conventions\ndefault.js\nAPI Reference for the default.js file.\nDynamic Segments\nDynamic Route Segments can be used to programmatically generate route segments from dynamic data.\nerror.js\nAPI reference for the error.js special file.\nforbidden.js\nAPI reference for the forbidden.js special file.\ninstrumentation.js\nAPI reference for the instrumentation.js file.\ninstrumentation-client.js\nLearn how to add client-side instrumentation to track and monitor your Next.js application's frontend performance.\nIntercepting Routes\nUse intercepting routes to load a new route within the current layout while masking the browser URL, useful for advanced routing patterns such as modals.\nlayout.js\nAPI reference for the layout.js file.\nloading.js\nAPI reference for the loading.js file.\nmdx-components.js\nAPI reference for the mdx-components.js file.\nnot-found.js\nAPI reference for the not-found.js file.\npage.js\nAPI reference for the page.js file.\nParallel Routes\nSimultaneously render one or more pages in the same view that can be navigated independently. A pattern for highly dynamic applications.\nproxy.js\nAPI reference for the proxy.js file.\npublic\nNext.js allows you to serve static files, like images, in the public directory. You can learn how it works here.\nroute.js\nAPI reference for the route.js special file.\nRoute Groups\nRoute Groups can be used to partition your Next.js application into different sections.\nRoute Segment Config\nLearn about how to configure options for Next.js route segments.\nsrc\nSave pages under the `src` folder as an alternative to the root `pages` directory.\ntemplate.js\nAPI Reference for the template.js file.\nunauthorized.js\nAPI reference for the unauthorized.js special file.\nMetadata Files\nAPI documentation for the metadata file conventions.\nPrevious\nScript Component\nNext\ndefault.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: Dynamic Segments | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes",
    "html": "API Reference\nFile-system conventions\nDynamic Segments\nCopy page\nDynamic Route Segments\n\nWhen you don't know the exact route segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time.\n\nConvention\n\nA Dynamic Segment can be created by wrapping a folder's name in square brackets: [folderName]. For example, a blog could include the following route app/blog/[slug]/page.js where [slug] is the Dynamic Segment for blog posts.\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  return <div>My Post: {slug}</div>\n}\n\nDynamic Segments are passed as the params prop to layout, page, route, and generateMetadata functions.\n\nRoute\tExample URL\tparams\napp/blog/[slug]/page.js\t/blog/a\t{ slug: 'a' }\napp/blog/[slug]/page.js\t/blog/b\t{ slug: 'b' }\napp/blog/[slug]/page.js\t/blog/c\t{ slug: 'c' }\nIn Client Components\n\nIn a Client Component page, dynamic segments from props can be accessed using the use\n hook.\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\nimport { use } from 'react'\n \nexport default function BlogPostPage({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = use(params)\n \n  return (\n    <div>\n      <p>{slug}</p>\n    </div>\n  )\n}\n\nAlternatively Client Components can use the useParams hook to access the params anywhere in the Client Component tree.\n\nCatch-all Segments\n\nDynamic Segments can be extended to catch-all subsequent segments by adding an ellipsis inside the brackets [...folderName].\n\nFor example, app/shop/[...slug]/page.js will match /shop/clothes, but also /shop/clothes/tops, /shop/clothes/tops/t-shirts, and so on.\n\nRoute\tExample URL\tparams\napp/shop/[...slug]/page.js\t/shop/a\t{ slug: ['a'] }\napp/shop/[...slug]/page.js\t/shop/a/b\t{ slug: ['a', 'b'] }\napp/shop/[...slug]/page.js\t/shop/a/b/c\t{ slug: ['a', 'b', 'c'] }\nOptional Catch-all Segments\n\nCatch-all Segments can be made optional by including the parameter in double square brackets: [[...folderName]].\n\nFor example, app/shop/[[...slug]]/page.js will also match /shop, in addition to /shop/clothes, /shop/clothes/tops, /shop/clothes/tops/t-shirts.\n\nThe difference between catch-all and optional catch-all segments is that with optional, the route without the parameter is also matched (/shop in the example above).\n\nRoute\tExample URL\tparams\napp/shop/[[...slug]]/page.js\t/shop\t{ slug: undefined }\napp/shop/[[...slug]]/page.js\t/shop/a\t{ slug: ['a'] }\napp/shop/[[...slug]]/page.js\t/shop/a/b\t{ slug: ['a', 'b'] }\napp/shop/[[...slug]]/page.js\t/shop/a/b/c\t{ slug: ['a', 'b', 'c'] }\nTypeScript\n\nWhen using TypeScript, you can add types for params depending on your configured route segment — use PageProps<'/route'>, LayoutProps<'/route'>, or RouteContext<'/route'> to type params in page, layout, and route respectively.\n\nRoute params values are typed as string, string[], or undefined (for optional catch-all segments), because their values aren't known until runtime. Users can enter any URL into the address bar, and these broad types help ensure that your application code handles all these possible cases.\n\nRoute\tparams Type Definition\napp/blog/[slug]/page.js\t{ slug: string }\napp/shop/[...slug]/page.js\t{ slug: string[] }\napp/shop/[[...slug]]/page.js\t{ slug?: string[] }\napp/[categoryId]/[itemId]/page.js\t{ categoryId: string, itemId: string }\n\nIf you're working on a route where params can only have a fixed number of valid values, such as a [locale] param with a known set of language codes, you can use runtime validation to handle any invalid params a user may enter, and let the rest of your application work with the narrower type from your known set.\n\n/app/[locale]/page.tsx\nimport { notFound } from 'next/navigation'\nimport type { Locale } from '@i18n/types'\nimport { isValidLocale } from '@i18n/utils'\n \nfunction assertValidLocale(value: string): asserts value is Locale {\n  if (!isValidLocale(value)) notFound()\n}\n \nexport default async function Page(props: PageProps<'/[locale]'>) {\n  const { locale } = await props.params // locale is typed as string\n  assertValidLocale(locale)\n  // locale is now typed as Locale\n}\nBehavior\nSince the params prop is a promise. You must use async/await or React's use function to access the values.\nIn version 14 and earlier, params was a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\nExamples\nWith generateStaticParams\n\nThe generateStaticParams function can be used to statically generate routes at build time instead of on-demand at request time.\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) => res.json())\n \n  return posts.map((post) => ({\n    slug: post.slug,\n  }))\n}\n\nWhen using fetch inside the generateStaticParams function, the requests are automatically deduplicated. This avoids multiple network calls for the same data Layouts, Pages, and other generateStaticParams functions, speeding up build time.\n\nNext Steps\nFor more information on what to do next, we recommend the following sections\ngenerateStaticParams\nAPI reference for the generateStaticParams function.\nPrevious\ndefault.js\nNext\nerror.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: default.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/default",
    "html": "API Reference\nFile-system conventions\ndefault.js\nCopy page\ndefault.js\n\nThe default.js file is used to render a fallback within Parallel Routes when Next.js cannot recover a slot's active state after a full-page load.\n\nDuring soft navigation, Next.js keeps track of the active state (subpage) for each slot. However, for hard navigations (full-page load), Next.js cannot recover the active state. In this case, a default.js file can be rendered for subpages that don't match the current URL.\n\nConsider the following folder structure. The @team slot has a settings page, but @analytics does not.\n\nWhen navigating to /settings, the @team slot will render the settings page while maintaining the currently active page for the @analytics slot.\n\nOn refresh, Next.js will render a default.js for @analytics. If default.js doesn't exist, an error is returned for named slots (@team, @analytics, etc) and requires you to define a default.js in order to continue. If you want to preserve the old behavior of returning a 404 in these situations, you can create a default.js that contains:\n\napp/@team/default.js\nimport { notFound } from 'next/navigation'\n \nexport default function Default() {\n  notFound()\n}\n\nAdditionally, since children is an implicit slot, you also need to create a default.js file to render a fallback for children when Next.js cannot recover the active state of the parent page. If you don't create a default.js for the children slot, it will return a 404 page for the route.\n\nReference\nparams (optional)\n\nA promise that resolves to an object containing the dynamic route parameters from the root segment down to the slot's subpages. For example:\n\napp/[artist]/@sidebar/default.js\nTypeScript\nJavaScript\nTypeScript\nexport default async function Default({\n  params,\n}: {\n  params: Promise<{ artist: string }>\n}) {\n  const { artist } = await params\n}\nExample\tURL\tparams\napp/[artist]/@sidebar/default.js\t/zack\tPromise<{ artist: 'zack' }>\napp/[artist]/[album]/@sidebar/default.js\t/zack/next\tPromise<{ artist: 'zack', album: 'next' }>\nSince the params prop is a promise. You must use async/await or React's use\n function to access the values.\nIn version 14 and earlier, params was a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\nLearn more about Parallel Routes\nParallel Routes\nSimultaneously render one or more pages in the same view that can be navigated independently. A pattern for highly dynamic applications.\nPrevious\nFile-system conventions\nNext\nDynamic Segments\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: error.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/error",
    "html": "API Reference\nFile-system conventions\nerror.js\nCopy page\nerror.js\n\nAn error file allows you to handle unexpected runtime errors and display fallback UI.\n\napp/dashboard/error.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client' // Error boundaries must be Client Components\n \nimport { useEffect } from 'react'\n \nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string }\n  reset: () => void\n}) {\n  useEffect(() => {\n    // Log the error to an error reporting service\n    console.error(error)\n  }, [error])\n \n  return (\n    <div>\n      <h2>Something went wrong!</h2>\n      <button\n        onClick={\n          // Attempt to recover by trying to re-render the segment\n          () => reset()\n        }\n      >\n        Try again\n      </button>\n    </div>\n  )\n}\n\nerror.js wraps a route segment and its nested children in a React Error Boundary\n. When an error throws within the boundary, the error component shows as the fallback UI.\n\nGood to know:\n\nThe React DevTools\n allow you to toggle error boundaries to test error states.\nIf you want errors to bubble up to the parent error boundary, you can throw when rendering the error component.\nReference\nProps\nerror\n\nAn instance of an Error\n object forwarded to the error.js Client Component.\n\nGood to know: During development, the Error object forwarded to the client will be serialized and include the message of the original error for easier debugging. However, this behavior is different in production to avoid leaking potentially sensitive details included in the error to the client.\n\nerror.message\nErrors forwarded from Client Components show the original Error message.\nErrors forwarded from Server Components show a generic message with an identifier. This is to prevent leaking sensitive details. You can use the identifier, under errors.digest, to match the corresponding server-side logs.\nerror.digest\n\nAn automatically generated hash of the error thrown. It can be used to match the corresponding error in server-side logs.\n\nreset\n\nThe cause of an error can sometimes be temporary. In these cases, trying again might resolve the issue.\n\nAn error component can use the reset() function to prompt the user to attempt to recover from the error. When executed, the function will try to re-render the error boundary's contents. If successful, the fallback error component is replaced with the result of the re-render.\n\napp/dashboard/error.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client' // Error boundaries must be Client Components\n \nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string }\n  reset: () => void\n}) {\n  return (\n    <div>\n      <h2>Something went wrong!</h2>\n      <button onClick={() => reset()}>Try again</button>\n    </div>\n  )\n}\nExamples\nGlobal Error\n\nWhile less common, you can handle errors in the root layout or template using global-error.jsx, located in the root app directory, even when leveraging internationalization. Global error UI must define its own <html> and <body> tags, global styles, fonts, or other dependencies that your error page requires. This file replaces the root layout or template when active.\n\nGood to know: Error boundaries must be Client Components, which means that metadata and generateMetadata exports are not supported in global-error.jsx. As an alternative, you can use the React <title>\n component.\n\napp/global-error.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client' // Error boundaries must be Client Components\n \nexport default function GlobalError({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string }\n  reset: () => void\n}) {\n  return (\n    // global-error must include html and body tags\n    <html>\n      <body>\n        <h2>Something went wrong!</h2>\n        <button onClick={() => reset()}>Try again</button>\n      </body>\n    </html>\n  )\n}\nGraceful error recovery with a custom error boundary\n\nWhen rendering fails on the client, it can be useful to show the last known server rendered UI for a better user experience.\n\nThe GracefullyDegradingErrorBoundary is an example of a custom error boundary that captures and preserves the current HTML before an error occurs. If a rendering error happens, it re-renders the captured HTML and displays a persistent notification bar to inform the user.\n\napp/dashboard/error.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport React, { Component, ErrorInfo, ReactNode } from 'react'\n \ninterface ErrorBoundaryProps {\n  children: ReactNode\n  onError?: (error: Error, errorInfo: ErrorInfo) => void\n}\n \ninterface ErrorBoundaryState {\n  hasError: boolean\n}\n \nexport class GracefullyDegradingErrorBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  private contentRef: React.RefObject<HTMLDivElement | null>\n \n  constructor(props: ErrorBoundaryProps) {\n    super(props)\n    this.state = { hasError: false }\n    this.contentRef = React.createRef()\n  }\n \n  static getDerivedStateFromError(_: Error): ErrorBoundaryState {\n    return { hasError: true }\n  }\n \n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    if (this.props.onError) {\n      this.props.onError(error, errorInfo)\n    }\n  }\n \n  render() {\n    if (this.state.hasError) {\n      // Render the current HTML content without hydration\n      return (\n        <>\n          <div\n            ref={this.contentRef}\n            suppressHydrationWarning\n            dangerouslySetInnerHTML={{\n              __html: this.contentRef.current?.innerHTML || '',\n            }}\n          />\n          <div className=\"fixed bottom-0 left-0 right-0 bg-red-600 text-white py-4 px-6 text-center\">\n            <p className=\"font-semibold\">\n              An error occurred during page rendering\n            </p>\n          </div>\n        </>\n      )\n    }\n \n    return <div ref={this.contentRef}>{this.props.children}</div>\n  }\n}\n \nexport default GracefullyDegradingErrorBoundary\nVersion History\nVersion\tChanges\nv15.2.0\tAlso display global-error in development.\nv13.1.0\tglobal-error introduced.\nv13.0.0\terror introduced.\nLearn more about error handling\nError Handling\nLearn how to display expected errors and handle uncaught exceptions.\nPrevious\nDynamic Segments\nNext\nforbidden.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: forbidden.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/forbidden",
    "html": "API Reference\nFile-system conventions\nforbidden.js\nCopy page\nforbidden.js\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nThe forbidden file is used to render UI when the forbidden function is invoked during authentication. Along with allowing you to customize the UI, Next.js will return a 403 status code.\n\napp/forbidden.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \nexport default function Forbidden() {\n  return (\n    <div>\n      <h2>Forbidden</h2>\n      <p>You are not authorized to access this resource.</p>\n      <Link href=\"/\">Return Home</Link>\n    </div>\n  )\n}\nReference\nProps\n\nforbidden.js components do not accept any props.\n\nVersion History\nVersion\tChanges\nv15.1.0\tforbidden.js introduced.\nNext Steps\nforbidden\nAPI Reference for the forbidden function.\nPrevious\nerror.js\nNext\ninstrumentation.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: instrumentation.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/instrumentation",
    "html": "API Reference\nFile-system conventions\ninstrumentation.js\nCopy page\ninstrumentation.js\n\nThe instrumentation.js|ts file is used to integrate observability tools into your application, allowing you to track the performance and behavior, and to debug issues in production.\n\nTo use it, place the file in the root of your application or inside a src folder if using one.\n\nExports\nregister (optional)\n\nThe file exports a register function that is called once when a new Next.js server instance is initiated. register can be an async function.\n\ninstrumentation.ts\nTypeScript\nJavaScript\nTypeScript\nimport { registerOTel } from '@vercel/otel'\n \nexport function register() {\n  registerOTel('next-app')\n}\nonRequestError (optional)\n\nYou can optionally export an onRequestError function to track server errors to any custom observability provider.\n\nIf you're running any async tasks in onRequestError, make sure they're awaited. onRequestError will be triggered when the Next.js server captures the error.\nThe error instance might not be the original error instance thrown, as it may be processed by React if encountered during Server Components rendering. If this happens, you can use digest property on an error to identify the actual error type.\ninstrumentation.ts\nTypeScript\nJavaScript\nTypeScript\nimport { type Instrumentation } from 'next'\n \nexport const onRequestError: Instrumentation.onRequestError = async (\n  err,\n  request,\n  context\n) => {\n  await fetch('https://.../report-error', {\n    method: 'POST',\n    body: JSON.stringify({\n      message: err.message,\n      request,\n      context,\n    }),\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  })\n}\nParameters\n\nThe function accepts three parameters: error, request, and context.\n\nTypes\nexport function onRequestError(\n  error: { digest: string } & Error,\n  request: {\n    path: string // resource path, e.g. /blog?name=foo\n    method: string // request method. e.g. GET, POST, etc\n    headers: { [key: string]: string | string[] }\n  },\n  context: {\n    routerKind: 'Pages Router' | 'App Router' // the router type\n    routePath: string // the route file path, e.g. /app/blog/[dynamic]\n    routeType: 'render' | 'route' | 'action' | 'proxy' // the context in which the error occurred\n    renderSource:\n      | 'react-server-components'\n      | 'react-server-components-payload'\n      | 'server-rendering'\n    revalidateReason: 'on-demand' | 'stale' | undefined // undefined is a normal request without revalidation\n    renderType: 'dynamic' | 'dynamic-resume' // 'dynamic-resume' for PPR\n  }\n): void | Promise<void>\nerror: The caught error itself (type is always Error), and a digest property which is the unique ID of the error.\nrequest: Read-only request information associated with the error.\ncontext: The context in which the error occurred. This can be the type of router (App or Pages Router), and/or (Server Components ('render'), Route Handlers ('route'), Server Actions ('action'), or Proxy ('proxy')).\nSpecifying the runtime\n\nThe instrumentation.js file works in both the Node.js and Edge runtime, however, you can use process.env.NEXT_RUNTIME to target a specific runtime.\n\ninstrumentation.js\nexport function register() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return require('./register.edge')\n  } else {\n    return require('./register.node')\n  }\n}\n \nexport function onRequestError() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return require('./on-request-error.edge')\n  } else {\n    return require('./on-request-error.node')\n  }\n}\nVersion History\nVersion\tChanges\nv15.0.0\tonRequestError introduced, instrumentation stable\nv14.0.4\tTurbopack support for instrumentation\nv13.2.0\tinstrumentation introduced as an experimental feature\nLearn more about Instrumentation\nInstrumentation\nLearn how to use instrumentation to run code at server startup in your Next.js app\nPrevious\nforbidden.js\nNext\ninstrumentation-client.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: instrumentation-client.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/instrumentation-client",
    "html": "API Reference\nFile-system conventions\ninstrumentation-client.js\nCopy page\ninstrumentation-client.js\n\nThe instrumentation-client.js|ts file allows you to add monitoring, analytics code, and other side-effects that run before your application becomes interactive. This is useful for setting up performance tracking, error monitoring, polyfills, or any other client-side observability tools.\n\nTo use it, place the file in the root of your application or inside a src folder.\n\nUsage\n\nUnlike server-side instrumentation, you do not need to export any specific functions. You can write your monitoring code directly in the file:\n\ninstrumentation-client.ts\nTypeScript\nJavaScript\nTypeScript\n// Set up performance monitoring\nperformance.mark('app-init')\n \n// Initialize analytics\nconsole.log('Analytics initialized')\n \n// Set up error tracking\nwindow.addEventListener('error', (event) => {\n  // Send to your error tracking service\n  reportError(event.error)\n})\n\nError handling: Implement try-catch blocks around your instrumentation code to ensure robust monitoring. This prevents individual tracking failures from affecting other instrumentation features.\n\nRouter navigation tracking\n\nYou can export an onRouterTransitionStart function to receive notifications when navigation begins:\n\ninstrumentation-client.ts\nTypeScript\nJavaScript\nTypeScript\nperformance.mark('app-init')\n \nexport function onRouterTransitionStart(\n  url: string,\n  navigationType: 'push' | 'replace' | 'traverse'\n) {\n  console.log(`Navigation started: ${navigationType} to ${url}`)\n  performance.mark(`nav-start-${Date.now()}`)\n}\n\nThe onRouterTransitionStart function receives two parameters:\n\nurl: string - The URL being navigated to\nnavigationType: 'push' | 'replace' | 'traverse' - The type of navigation\nPerformance considerations\n\nKeep instrumentation code lightweight.\n\nNext.js monitors initialization time in development and will log warnings if it takes longer than 16ms, which could impact smooth page loading.\n\nExecution timing\n\nThe instrumentation-client.js file executes at a specific point in the application lifecycle:\n\nAfter the HTML document is loaded\nBefore React hydration begins\nBefore user interactions are possible\n\nThis timing makes it ideal for setting up error tracking, analytics, and performance monitoring that needs to capture early application lifecycle events.\n\nExamples\nError tracking\n\nInitialize error tracking before React starts and add navigation breadcrumbs for better debugging context.\n\ninstrumentation-client.ts\nTypeScript\nJavaScript\nTypeScript\nimport Monitor from './lib/monitoring'\n \nMonitor.initialize()\n \nexport function onRouterTransitionStart(url: string) {\n  Monitor.pushEvent({\n    message: `Navigation to ${url}`,\n    category: 'navigation',\n  })\n}\nAnalytics tracking\n\nInitialize analytics and track navigation events with detailed metadata for user behavior analysis.\n\ninstrumentation-client.ts\nTypeScript\nJavaScript\nTypeScript\nimport { analytics } from './lib/analytics'\n \nanalytics.init()\n \nexport function onRouterTransitionStart(url: string, navigationType: string) {\n  analytics.track('page_navigation', {\n    url,\n    type: navigationType,\n    timestamp: Date.now(),\n  })\n}\nPerformance monitoring\n\nTrack Time to Interactive and navigation performance using the Performance Observer API and performance marks.\n\ninstrumentation-client.ts\nTypeScript\nJavaScript\nTypeScript\nconst startTime = performance.now()\n \nconst observer = new PerformanceObserver(\n  (list: PerformanceObserverEntryList) => {\n    for (const entry of list.getEntries()) {\n      if (entry instanceof PerformanceNavigationTiming) {\n        console.log('Time to Interactive:', entry.loadEventEnd - startTime)\n      }\n    }\n  }\n)\n \nobserver.observe({ entryTypes: ['navigation'] })\n \nexport function onRouterTransitionStart(url: string) {\n  performance.mark(`nav-start-${url}`)\n}\nPolyfills\n\nLoad polyfills before application code runs. Use static imports for immediate loading and dynamic imports for conditional loading based on feature detection.\n\ninstrumentation-client.ts\nTypeScript\nJavaScript\nTypeScript\nimport './lib/polyfills'\n \nif (!window.ResizeObserver) {\n  import('./lib/polyfills/resize-observer').then((mod) => {\n    window.ResizeObserver = mod.default\n  })\n}\nVersion history\nVersion\tChanges\nv15.3\tinstrumentation-client introduced\nPrevious\ninstrumentation.js\nNext\nIntercepting Routes\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: Intercepting Routes | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/intercepting-routes",
    "html": "API Reference\nFile-system conventions\nIntercepting Routes\nCopy page\nIntercepting Routes\n\nIntercepting routes allows you to load a route from another part of your application within the current layout. This routing paradigm can be useful when you want to display the content of a route without the user switching to a different context.\n\nFor example, when clicking on a photo in a feed, you can display the photo in a modal, overlaying the feed. In this case, Next.js intercepts the /photo/123 route, masks the URL, and overlays it over /feed.\n\nHowever, when navigating to the photo by clicking a shareable URL or by refreshing the page, the entire photo page should render instead of the modal. No route interception should occur.\n\nConvention\n\nIntercepting routes can be defined with the (..) convention, which is similar to relative path convention ../ but for route segments.\n\nYou can use:\n\n(.) to match segments on the same level\n(..) to match segments one level above\n(..)(..) to match segments two levels above\n(...) to match segments from the root app directory\n\nFor example, you can intercept the photo segment from within the feed segment by creating a (..)photo directory.\n\nGood to know: The (..) convention is based on route segments, not the file-system. For example, it does not consider @slot folders in Parallel Routes.\n\nExamples\nModals\n\nIntercepting Routes can be used together with Parallel Routes to create modals. This allows you to solve common challenges when building modals, such as:\n\nMaking the modal content shareable through a URL.\nPreserving context when the page is refreshed, instead of closing the modal.\nClosing the modal on backwards navigation rather than going to the previous route.\nReopening the modal on forwards navigation.\n\nConsider the following UI pattern, where a user can open a photo modal from a gallery using client-side navigation, or navigate to the photo page directly from a shareable URL:\n\nIn the above example, the path to the photo segment can use the (..) matcher since @modal is a slot and not a segment. This means that the photo route is only one segment level higher, despite being two file-system levels higher.\n\nSee the Parallel Routes documentation for a step-by-step example, or see our image gallery example\n.\n\nGood to know:\n\nOther examples could include opening a login modal in a top navbar while also having a dedicated /login page, or opening a shopping cart in a side modal.\nNext Steps\nLearn how to create modals with Intercepted and Parallel Routes.\nParallel Routes\nSimultaneously render one or more pages in the same view that can be navigated independently. A pattern for highly dynamic applications.\nPrevious\ninstrumentation-client.js\nNext\nlayout.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: layout.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/layout",
    "html": "API Reference\nFile-system conventions\nlayout.js\nCopy page\nlayout.js\n\nThe layout file is used to define a layout in your Next.js application.\n\napp/dashboard/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function DashboardLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return <section>{children}</section>\n}\n\nA root layout is the top-most layout in the root app directory. It is used to define the <html> and <body> tags and other globally shared UI.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  )\n}\nReference\nProps\nchildren (required)\n\nLayout components should accept and use a children prop. During rendering, children will be populated with the route segments the layout is wrapping. These will primarily be the component of a child Layout (if it exists) or Page, but could also be other special files like Loading or Error when applicable.\n\nparams (optional)\n\nA promise that resolves to an object containing the dynamic route parameters object from the root segment down to that layout.\n\napp/dashboard/[team]/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Layout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: Promise<{ team: string }>\n}) {\n  const { team } = await params\n}\nExample Route\tURL\tparams\napp/dashboard/[team]/layout.js\t/dashboard/1\tPromise<{ team: '1' }>\napp/shop/[tag]/[item]/layout.js\t/shop/1/2\tPromise<{ tag: '1', item: '2' }>\napp/blog/[...slug]/layout.js\t/blog/1/2\tPromise<{ slug: ['1', '2'] }>\nSince the params prop is a promise. You must use async/await or React's use\n function to access the values.\nIn version 14 and earlier, params was a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\nLayout Props Helper\n\nYou can type layouts with LayoutProps to get a strongly typed params and named slots inferred from your directory structure. LayoutProps is a globally available helper.\n\napp/dashboard/layout.tsx\nexport default function Layout(props: LayoutProps<'/dashboard'>) {\n  return (\n    <section>\n      {props.children}\n      {/* If you have app/dashboard/@analytics, it appears as a typed slot: */}\n      {/* {props.analytics} */}\n    </section>\n  )\n}\n\nGood to know:\n\nTypes are generated during next dev, next build or next typegen.\nAfter type generation, the LayoutProps helper is globally available. It doesn't need to be imported.\nRoot Layout\n\nThe app directory must include a root layout, which is the top-most layout in the root app directory. Typically, the root layout is app/layout.js.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html>\n      <body>{children}</body>\n    </html>\n  )\n}\nThe root layout must define <html> and <body> tags.\nYou should not manually add <head> tags such as <title> and <meta> to root layouts. Instead, you should use the Metadata API which automatically handles advanced requirements such as streaming and de-duplicating <head> elements.\nYou can use route groups to create multiple root layouts.\nNavigating across multiple root layouts will cause a full page load (as opposed to a client-side navigation). For example, navigating from /cart that uses app/(shop)/layout.js to /blog that uses app/(marketing)/layout.js will cause a full page load. This only applies to multiple root layouts.\nThe root layout can be under a dynamic segment, for example when implementing internationalization with app/[lang]/layout.js.\nCaveats\nRequest Object\n\nLayouts are cached in the client during navigation to avoid unnecessary server requests.\n\nLayouts do not rerender. They can be cached and reused to avoid unnecessary computation when navigating between pages. By restricting layouts from accessing the raw request, Next.js can prevent the execution of potentially slow or expensive user code within the layout, which could negatively impact performance.\n\nTo access the request object, you can use headers and cookies APIs in Server Components and Functions.\n\napp/shop/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { cookies } from 'next/headers'\n \nexport default async function Layout({ children }) {\n  const cookieStore = await cookies()\n  const theme = cookieStore.get('theme')\n  return '...'\n}\nQuery params\n\nLayouts do not rerender on navigation, so they cannot access search params which would otherwise become stale.\n\nTo access updated query parameters, you can use the Page searchParams prop, or read them inside a Client Component using the useSearchParams hook. Since Client Components re-render on navigation, they have access to the latest query parameters.\n\napp/ui/search.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useSearchParams } from 'next/navigation'\n \nexport default function Search() {\n  const searchParams = useSearchParams()\n \n  const search = searchParams.get('search')\n \n  return '...'\n}\napp/shop/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Search from '@/app/ui/search'\n \nexport default function Layout({ children }) {\n  return (\n    <>\n      <Search />\n      {children}\n    </>\n  )\n}\nPathname\n\nLayouts do not re-render on navigation, so they do not access pathname which would otherwise become stale.\n\nTo access the current pathname, you can read it inside a Client Component using the usePathname hook. Since Client Components re-render during navigation, they have access to the latest pathname.\n\napp/ui/breadcrumbs.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { usePathname } from 'next/navigation'\n \n// Simplified breadcrumbs logic\nexport default function Breadcrumbs() {\n  const pathname = usePathname()\n  const segments = pathname.split('/')\n \n  return (\n    <nav>\n      {segments.map((segment, index) => (\n        <span key={index}>\n          {' > '}\n          {segment}\n        </span>\n      ))}\n    </nav>\n  )\n}\napp/docs/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Breadcrumbs } from '@/app/ui/Breadcrumbs'\n \nexport default function Layout({ children }) {\n  return (\n    <>\n      <Breadcrumbs />\n      <main>{children}</main>\n    </>\n  )\n}\nFetching Data\n\nLayouts cannot pass data to their children. However, you can fetch the same data in a route more than once, and use React cache\n to dedupe the requests without affecting performance.\n\nAlternatively, when using fetchin Next.js, requests are automatically deduped.\n\napp/lib/data.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function getUser(id: string) {\n  const res = await fetch(`https://.../users/${id}`)\n  return res.json()\n}\napp/dashboard/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { getUser } from '@/app/lib/data'\nimport { UserName } from '@/app/ui/user-name'\n \nexport default async function Layout({ children }) {\n  const user = await getUser('1')\n \n  return (\n    <>\n      <nav>\n        {/* ... */}\n        <UserName user={user.name} />\n      </nav>\n      {children}\n    </>\n  )\n}\napp/dashboard/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { getUser } from '@/app/lib/data'\nimport { UserName } from '@/app/ui/user-name'\n \nexport default async function Page() {\n  const user = await getUser('1')\n \n  return (\n    <div>\n      <h1>Welcome {user.name}</h1>\n    </div>\n  )\n}\nAccessing child segments\n\nLayouts do not have access to the route segments below itself. To access all route segments, you can use useSelectedLayoutSegment or useSelectedLayoutSegments in a Client Component.\n\napp/ui/nav-link.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport Link from 'next/link'\nimport { useSelectedLayoutSegment } from 'next/navigation'\n \nexport default function NavLink({\n  slug,\n  children,\n}: {\n  slug: string\n  children: React.ReactNode\n}) {\n  const segment = useSelectedLayoutSegment()\n  const isActive = slug === segment\n \n  return (\n    <Link\n      href={`/blog/${slug}`}\n      // Change style depending on whether the link is active\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\n    >\n      {children}\n    </Link>\n  )\n}\napp/blog/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { NavLink } from './nav-link'\nimport getPosts from './get-posts'\n \nexport default async function Layout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  const featuredPosts = await getPosts()\n  return (\n    <div>\n      {featuredPosts.map((post) => (\n        <div key={post.id}>\n          <NavLink slug={post.slug}>{post.title}</NavLink>\n        </div>\n      ))}\n      <div>{children}</div>\n    </div>\n  )\n}\nExamples\nMetadata\n\nYou can modify the <head> HTML elements such as title and meta using the metadata object or generateMetadata function.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  title: 'Next.js',\n}\n \nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return '...'\n}\n\nGood to know: You should not manually add <head> tags such as <title> and <meta> to root layouts. Instead, use the Metadata APIs which automatically handles advanced requirements such as streaming and de-duplicating <head> elements.\n\nActive Nav Links\n\nYou can use the usePathname hook to determine if a nav link is active.\n\nSince usePathname is a client hook, you need to extract the nav links into a Client Component, which can be imported into your layout:\n\napp/ui/nav-links.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { usePathname } from 'next/navigation'\nimport Link from 'next/link'\n \nexport function NavLinks() {\n  const pathname = usePathname()\n \n  return (\n    <nav>\n      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href=\"/\">\n        Home\n      </Link>\n \n      <Link\n        className={`link ${pathname === '/about' ? 'active' : ''}`}\n        href=\"/about\"\n      >\n        About\n      </Link>\n    </nav>\n  )\n}\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { NavLinks } from '@/app/ui/nav-links'\n \nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <NavLinks />\n        <main>{children}</main>\n      </body>\n    </html>\n  )\n}\nDisplaying content based on params\n\nUsing dynamic route segments, you can display or fetch specific content based on the params prop.\n\napp/dashboard/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function DashboardLayout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: Promise<{ team: string }>\n}) {\n  const { team } = await params\n \n  return (\n    <section>\n      <header>\n        <h1>Welcome to {team}'s Dashboard</h1>\n      </header>\n      <main>{children}</main>\n    </section>\n  )\n}\nReading params in Client Components\n\nTo use params in a Client Component (which cannot be async), you can use React's use\n function to read the promise:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { use } from 'react'\n \nexport default function Page({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = use(params)\n}\nVersion History\nVersion\tChanges\nv15.0.0-RC\tparams is now a promise. A codemod is available.\nv13.0.0\tlayout introduced.\nPrevious\nIntercepting Routes\nNext\nloading.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: loading.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/loading",
    "html": "API Reference\nFile-system conventions\nloading.js\nCopy page\nloading.js\n\nThe special file loading.js helps you create meaningful Loading UI with React Suspense\n. With this convention, you can show an instant loading state from the server while the content of a route segment streams in. The new content is automatically swapped in once complete.\n\napp/feed/loading.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Loading() {\n  // Or a custom loading skeleton component\n  return <p>Loading...</p>\n}\n\nInside the loading.js file, you can add any light-weight loading UI. You may find it helpful to use the React Developer Tools\n to manually toggle Suspense boundaries.\n\nBy default, this file is a Server Component - but can also be used as a Client Component through the \"use client\" directive.\n\nReference\nParameters\n\nLoading UI components do not accept any parameters.\n\nBehavior\nNavigation\nThe Fallback UI is prefetched, making navigation immediate unless prefetching hasn't completed.\nNavigation is interruptible, meaning changing routes does not need to wait for the content of the route to fully load before navigating to another route.\nShared layouts remain interactive while new route segments load.\nInstant Loading States\n\nAn instant loading state is fallback UI that is shown immediately upon navigation. You can pre-render loading indicators such as skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc. This helps users understand the app is responding and provides a better user experience.\n\nCreate a loading state by adding a loading.js file inside a folder.\n\napp/dashboard/loading.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Loading() {\n  // You can add any UI inside Loading, including a Skeleton.\n  return <LoadingSkeleton />\n}\n\nIn the same folder, loading.js will be nested inside layout.js. It will automatically wrap the page.js file and any children below in a <Suspense> boundary.\n\nSEO\nFor bots that only scrape static HTML, and cannot execute JavaScript like a full browser, such as Twitterbot, Next.js resolves generateMetadata before streaming UI, and metadata is placed in the <head> of the initial HTML.\nOtherwise, streaming metadata may be used used. Next.js automatically detects user agents to choose between blocking and streaming behavior.\nSince streaming is server-rendered, it does not impact SEO. You can use the Rich Results Test\n tool from Google to see how your page appears to Google's web crawlers and view the serialized HTML (source\n).\nStatus Codes\n\nWhen streaming, a 200 status code will be returned to signal that the request was successful.\n\nThe server can still communicate errors or issues to the client within the streamed content itself, for example, when using redirect or notFound. Because the response headers have already been sent to the client, the status code of the response cannot be updated.\n\nFor example, when a 404 page is streamed to the client, Next.js includes a <meta name=\"robots\" content=\"noindex\"> tag in the streamed HTML. This prevents search engines from indexing that URL even if the HTTP status is 200. See Google’s guidance on the robots meta tag\n.\n\nSome crawlers may label these responses as “soft 404s”. In the streaming case, this does not lead to indexation because the page is explicitly marked noindex in the HTML.\n\nIf you need a 404 status, for compliance or analytics, ensure the resource exists before the response body is streamed, so that the server can set the HTTP status code.\n\nYou can run this check in proxy to rewrite missing slugs to a not-found route, or produce a 404 response. Keep proxy checks fast, and avoid fetching full content there.\n\nWhen is the response body streamed?\nBrowser limits\n\nSome browsers\n buffer a streaming response. You may not see the streamed response until the response exceeds 1024 bytes. This typically only affects “hello world” applications, but not real applications.\n\nPlatform Support\nDeployment Option\tSupported\nNode.js server\tYes\nDocker container\tYes\nStatic export\tNo\nAdapters\tPlatform-specific\n\nLearn how to configure streaming when self-hosting Next.js.\n\nExamples\nStreaming with Suspense\n\nIn addition to loading.js, you can also manually create Suspense Boundaries for your own UI components. The App Router supports streaming with Suspense\n.\n\n<Suspense> works by wrapping a component that performs an asynchronous action (e.g. fetch data), showing fallback UI (e.g. skeleton, spinner) while it's happening, and then swapping in your component once the action completes.\n\napp/dashboard/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Suspense } from 'react'\nimport { PostFeed, Weather } from './Components'\n \nexport default function Posts() {\n  return (\n    <section>\n      <Suspense fallback={<p>Loading feed...</p>}>\n        <PostFeed />\n      </Suspense>\n      <Suspense fallback={<p>Loading weather...</p>}>\n        <Weather />\n      </Suspense>\n    </section>\n  )\n}\n\nBy using Suspense, you get the benefits of:\n\nStreaming Server Rendering - Progressively rendering HTML from the server to the client.\nSelective Hydration - React prioritizes what components to make interactive first based on user interaction.\n\nFor more Suspense examples and use cases, please see the React Documentation\n.\n\nVersion History\nVersion\tChanges\nv13.0.0\tloading introduced.\nPrevious\nlayout.js\nNext\nmdx-components.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: mdx-components.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/mdx-components",
    "html": "API Reference\nFile-system conventions\nmdx-components.js\nCopy page\nmdx-components.js\n\nThe mdx-components.js|tsx file is required to use @next/mdx with App Router and will not work without it. Additionally, you can use it to customize styles.\n\nUse the file mdx-components.tsx (or .js) in the root of your project to define MDX Components. For example, at the same level as pages or app, or inside src if applicable.\n\nmdx-components.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { MDXComponents } from 'mdx/types'\n \nconst components: MDXComponents = {}\n \nexport function useMDXComponents(): MDXComponents {\n  return components\n}\nExports\nuseMDXComponents function\n\nThe file must export a single function named useMDXComponents. This function does not accept any arguments.\n\nmdx-components.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { MDXComponents } from 'mdx/types'\n \nconst components: MDXComponents = {}\n \nexport function useMDXComponents(): MDXComponents {\n  return components\n}\nVersion History\nVersion\tChanges\nv13.1.2\tMDX Components added\nLearn more about MDX Components\nMDX\nLearn how to configure MDX and use it in your Next.js apps.\nPrevious\nloading.js\nNext\nnot-found.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: not-found.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/not-found",
    "html": "API Reference\nFile-system conventions\nnot-found.js\nCopy page\nnot-found.js\n\nNext.js provides two conventions to handle not found cases:\n\nnot-found.js: Used when you call the notFound function in a route segment.\nglobal-not-found.js: Used to define a global 404 page for unmatched routes across your entire app. This is handled at the routing level and doesn't depend on rendering a layout or page.\nnot-found.js\n\nThe not-found file is used to render UI when the notFound function is thrown within a route segment. Along with serving a custom UI, Next.js will return a 200 HTTP status code for streamed responses, and 404 for non-streamed responses.\n\napp/not-found.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \nexport default function NotFound() {\n  return (\n    <div>\n      <h2>Not Found</h2>\n      <p>Could not find requested resource</p>\n      <Link href=\"/\">Return Home</Link>\n    </div>\n  )\n}\nglobal-not-found.js (experimental)\n\nThe global-not-found.js file lets you define a 404 page for your entire application. Unlike not-found.js, which works at the route level, this is used when a requested URL doesn't match any route at all. Next.js skips rendering and directly returns this global page.\n\nThe global-not-found.js file bypasses your app's normal rendering, which means you'll need to import any global styles, fonts, or other dependencies that your 404 page requires.\n\nGood to know: A smaller version of your global styles, and a simpler font family could improve performance of this page.\n\nglobal-not-found.js is useful when you can't build a 404 page using a combination of layout.js and not-found.js. This can happen in two cases:\n\nYour app has multiple root layouts (e.g. app/(admin)/layout.tsx and app/(shop)/layout.tsx), so there's no single layout to compose a global 404 from.\nYour root layout is defined using top-level dynamic segments (e.g. app/[country]/layout.tsx), which makes composing a consistent 404 page harder.\n\nTo enable it, add the globalNotFound flag in next.config.ts:\n\nnext.config.ts\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    globalNotFound: true,\n  },\n}\n \nexport default nextConfig\n\nThen, create a file in the root of the app directory: app/global-not-found.js:\n\napp/global-not-found.tsx\nTypeScript\nJavaScript\nTypeScript\n// Import global styles and fonts\nimport './globals.css'\nimport { Inter } from 'next/font/google'\nimport type { Metadata } from 'next'\n \nconst inter = Inter({ subsets: ['latin'] })\n \nexport const metadata: Metadata = {\n  title: '404 - Page Not Found',\n  description: 'The page you are looking for does not exist.',\n}\n \nexport default function GlobalNotFound() {\n  return (\n    <html lang=\"en\" className={inter.className}>\n      <body>\n        <h1>404 - Page Not Found</h1>\n        <p>This page does not exist.</p>\n      </body>\n    </html>\n  )\n}\n\nUnlike not-found.js, this file must return a full HTML document, including <html> and <body> tags.\n\nReference\nProps\n\nnot-found.js or global-not-found.js components do not accept any props.\n\nGood to know: In addition to catching expected notFound() errors, the root app/not-found.js and app/global-not-found.js files handle any unmatched URLs for your whole application. This means users that visit a URL that is not handled by your app will be shown the exported UI.\n\nExamples\nData Fetching\n\nBy default, not-found is a Server Component. You can mark it as async to fetch and display data:\n\napp/not-found.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\nimport { headers } from 'next/headers'\n \nexport default async function NotFound() {\n  const headersList = await headers()\n  const domain = headersList.get('host')\n  const data = await getSiteData(domain)\n  return (\n    <div>\n      <h2>Not Found: {data.name}</h2>\n      <p>Could not find requested resource</p>\n      <p>\n        View <Link href=\"/blog\">all posts</Link>\n      </p>\n    </div>\n  )\n}\n\nIf you need to use Client Component hooks like usePathname to display content based on the path, you must fetch data on the client-side instead.\n\nMetadata\n\nFor global-not-found.js, you can export a metadata object or a generateMetadata function to customize the <title>, <meta>, and other head tags for your 404 page:\n\nGood to know: Next.js automatically injects <meta name=\"robots\" content=\"noindex\" /> for pages that return a 404 status code, including global-not-found.js pages.\n\napp/global-not-found.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  title: 'Not Found',\n  description: 'The page you are looking for does not exist.',\n}\n \nexport default function GlobalNotFound() {\n  return (\n    <html lang=\"en\">\n      <body>\n        <div>\n          <h1>Not Found</h1>\n          <p>The page you are looking for does not exist.</p>\n        </div>\n      </body>\n    </html>\n  )\n}\nVersion History\nVersion\tChanges\nv15.4.0\tglobal-not-found.js introduced (experimental).\nv13.3.0\tRoot app/not-found handles global unmatched URLs.\nv13.0.0\tnot-found introduced.\nPrevious\nmdx-components.js\nNext\npage.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: page.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/page",
    "html": "API Reference\nFile-system conventions\npage.js\nCopy page\npage.js\n\nThe page file allows you to define UI that is unique to a route. You can create a page by default exporting a component from the file:\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Page({\n  params,\n  searchParams,\n}: {\n  params: Promise<{ slug: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  return <h1>My Page</h1>\n}\nGood to know\nThe .js, .jsx, or .tsx file extensions can be used for page.\nA page is always the leaf of the route subtree.\nA page file is required to make a route segment publicly accessible.\nPages are Server Components\n by default, but can be set to a Client Component\n.\nReference\nProps\nparams (optional)\n\nA promise that resolves to an object containing the dynamic route parameters from the root segment down to that page.\n\napp/shop/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n}\nExample Route\tURL\tparams\napp/shop/[slug]/page.js\t/shop/1\tPromise<{ slug: '1' }>\napp/shop/[category]/[item]/page.js\t/shop/1/2\tPromise<{ category: '1', item: '2' }>\napp/shop/[...slug]/page.js\t/shop/1/2\tPromise<{ slug: ['1', '2'] }>\nSince the params prop is a promise, you must use async/await or React's use\n function to access the values.\nIn version 14 and earlier, params was a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\nsearchParams (optional)\n\nA promise that resolves to an object containing the search parameters\n of the current URL. For example:\n\napp/shop/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Page({\n  searchParams,\n}: {\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  const filters = (await searchParams).filters\n}\n\nClient Component pages can also access searchParams using React’s use\n hook:\n\napp/shop/page.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\nimport { use } from 'react'\n \nexport default function Page({\n  searchParams,\n}: {\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  const filters = use(searchParams).filters\n}\nExample URL\tsearchParams\n/shop?a=1\tPromise<{ a: '1' }>\n/shop?a=1&b=2\tPromise<{ a: '1', b: '2' }>\n/shop?a=1&a=2\tPromise<{ a: ['1', '2'] }>\nSince the searchParams prop is a promise. You must use async/await or React's use\n function to access the values.\nIn version 14 and earlier, searchParams was a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\nsearchParams is a Dynamic API whose values cannot be known ahead of time. Using it will opt the page into dynamic rendering at request time.\nsearchParams is a plain JavaScript object, not a URLSearchParams instance.\nPage Props Helper\n\nYou can type pages with PageProps to get strongly typed params and searchParams from the route literal. PageProps is a globally available helper.\n\napp/blog/[slug]/page.tsx\nexport default async function Page(props: PageProps<'/blog/[slug]'>) {\n  const { slug } = await props.params\n  const query = await props.searchParams\n  return <h1>Blog Post: {slug}</h1>\n}\n\nGood to know\n\nUsing a literal route (e.g. '/blog/[slug]') enables autocomplete and strict keys for params.\nStatic routes resolve params to {}.\nTypes are generated during next dev, next build, or with next typegen.\nAfter type generation, the PageProps helper is globally available. It doesn't need to be imported.\nExamples\nDisplaying content based on params\n\nUsing dynamic route segments, you can display or fetch specific content for the page based on the params prop.\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  return <h1>Blog Post: {slug}</h1>\n}\nHandling filtering with searchParams\n\nYou can use the searchParams prop to handle filtering, pagination, or sorting based on the query string of the URL.\n\napp/shop/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Page({\n  searchParams,\n}: {\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  const { page = '1', sort = 'asc', query = '' } = await searchParams\n \n  return (\n    <div>\n      <h1>Product Listing</h1>\n      <p>Search query: {query}</p>\n      <p>Current page: {page}</p>\n      <p>Sort order: {sort}</p>\n    </div>\n  )\n}\nReading searchParams and params in Client Components\n\nTo use searchParams and params in a Client Component (which cannot be async), you can use React's use\n function to read the promise:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { use } from 'react'\n \nexport default function Page({\n  params,\n  searchParams,\n}: {\n  params: Promise<{ slug: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  const { slug } = use(params)\n  const { query } = use(searchParams)\n}\nVersion History\nVersion\tChanges\nv15.0.0-RC\tparams and searchParams are now promises. A codemod is available.\nv13.0.0\tpage introduced.\nPrevious\nnot-found.js\nNext\nParallel Routes\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: Parallel Routes | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/parallel-routes",
    "html": "API Reference\nFile-system conventions\nParallel Routes\nCopy page\nParallel Routes\n\nParallel Routes allows you to simultaneously or conditionally render one or more pages within the same layout. They are useful for highly dynamic sections of an app, such as dashboards and feeds on social sites.\n\nFor example, considering a dashboard, you can use parallel routes to simultaneously render the team and analytics pages:\n\nConvention\nSlots\n\nParallel routes are created using named slots. Slots are defined with the @folder convention. For example, the following file structure defines two slots: @analytics and @team:\n\nSlots are passed as props to the shared parent layout. For the example above, the component in app/layout.js now accepts the @analytics and @team slots props, and can render them in parallel alongside the children prop:\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Layout({\n  children,\n  team,\n  analytics,\n}: {\n  children: React.ReactNode\n  analytics: React.ReactNode\n  team: React.ReactNode\n}) {\n  return (\n    <>\n      {children}\n      {team}\n      {analytics}\n    </>\n  )\n}\n\nHowever, slots are not route segments and do not affect the URL structure. For example, for /@analytics/views, the URL will be /views since @analytics is a slot. Slots are combined with the regular Page component to form the final page associated with the route segment. Because of this, you cannot have separate static and dynamic slots at the same route segment level. If one slot is dynamic, all slots at that level must be dynamic.\n\nGood to know:\n\nThe children prop is an implicit slot that does not need to be mapped to a folder. This means app/page.js is equivalent to app/@children/page.js.\ndefault.js\n\nYou can define a default.js file to render as a fallback for unmatched slots during the initial load or full-page reload.\n\nConsider the following folder structure. The @team slot has a /settings page, but @analytics does not.\n\nWhen navigating to /settings, the @team slot will render the /settings page while maintaining the currently active page for the @analytics slot.\n\nOn refresh, Next.js will render a default.js for @analytics. If default.js doesn't exist, a 404 is rendered instead.\n\nAdditionally, since children is an implicit slot, you also need to create a default.js file to render a fallback for children when Next.js cannot recover the active state of the parent page.\n\nBehavior\n\nBy default, Next.js keeps track of the active state (or subpage) for each slot. However, the content rendered within a slot will depend on the type of navigation:\n\nSoft Navigation: During client-side navigation, Next.js will perform a partial render, changing the subpage within the slot, while maintaining the other slot's active subpages, even if they don't match the current URL.\nHard Navigation: After a full-page load (browser refresh), Next.js cannot determine the active state for the slots that don't match the current URL. Instead, it will render a default.js file for the unmatched slots, or 404 if default.js doesn't exist.\n\nGood to know:\n\nThe 404 for unmatched routes helps ensure that you don't accidentally render a parallel route on a page that it was not intended for.\nExamples\nWith useSelectedLayoutSegment(s)\n\nBoth useSelectedLayoutSegment and useSelectedLayoutSegments accept a parallelRoutesKey parameter, which allows you to read the active route segment within a slot.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useSelectedLayoutSegment } from 'next/navigation'\n \nexport default function Layout({ auth }: { auth: React.ReactNode }) {\n  const loginSegment = useSelectedLayoutSegment('auth')\n  // ...\n}\n\nWhen a user navigates to app/@auth/login (or /login in the URL bar), loginSegment will be equal to the string \"login\".\n\nConditional Routes\n\nYou can use Parallel Routes to conditionally render routes based on certain conditions, such as user role. For example, to render a different dashboard page for the /admin or /user roles:\n\napp/dashboard/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { checkUserRole } from '@/lib/auth'\n \nexport default function Layout({\n  user,\n  admin,\n}: {\n  user: React.ReactNode\n  admin: React.ReactNode\n}) {\n  const role = checkUserRole()\n  return role === 'admin' ? admin : user\n}\nTab Groups\n\nYou can add a layout inside a slot to allow users to navigate the slot independently. This is useful for creating tabs.\n\nFor example, the @analytics slot has two subpages: /page-views and /visitors.\n\nWithin @analytics, create a layout file to share the tabs between the two pages:\n\napp/@analytics/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <>\n      <nav>\n        <Link href=\"/page-views\">Page Views</Link>\n        <Link href=\"/visitors\">Visitors</Link>\n      </nav>\n      <div>{children}</div>\n    </>\n  )\n}\nModals\n\nParallel Routes can be used together with Intercepting Routes to create modals that support deep linking. This allows you to solve common challenges when building modals, such as:\n\nMaking the modal content shareable through a URL.\nPreserving context when the page is refreshed, instead of closing the modal.\nClosing the modal on backwards navigation rather than going to the previous route.\nReopening the modal on forwards navigation.\n\nConsider the following UI pattern, where a user can open a login modal from a layout using client-side navigation, or access a separate /login page:\n\nTo implement this pattern, start by creating a /login route that renders your main login page.\n\napp/login/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Login } from '@/app/ui/login'\n \nexport default function Page() {\n  return <Login />\n}\n\nThen, inside the @auth slot, add default.js file that returns null. This ensures that the modal is not rendered when it's not active.\n\napp/@auth/default.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Default() {\n  return null\n}\n\nInside your @auth slot, intercept the /login route by importing the <Modal> component and its children into the @auth/(.)login/page.tsx file, and updating the folder name to /@auth/(.)login/page.tsx.\n\napp/@auth/(.)login/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Modal } from '@/app/ui/modal'\nimport { Login } from '@/app/ui/login'\n \nexport default function Page() {\n  return (\n    <Modal>\n      <Login />\n    </Modal>\n  )\n}\n\nGood to know:\n\nThe convention (.) is used for intercepting routes. See Intercepting Routes docs for more information.\nBy separating the <Modal> functionality from the modal content (<Login>), you can ensure any content inside the modal, e.g. forms, are Server Components. See Interleaving Client and Server Components for more information.\nOpening the modal\n\nNow, you can leverage the Next.js router to open and close the modal. This ensures the URL is correctly updated when the modal is open, and when navigating backwards and forwards.\n\nTo open the modal, pass the @auth slot as a prop to the parent layout and render it alongside the children prop.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \nexport default function Layout({\n  auth,\n  children,\n}: {\n  auth: React.ReactNode\n  children: React.ReactNode\n}) {\n  return (\n    <>\n      <nav>\n        <Link href=\"/login\">Open modal</Link>\n      </nav>\n      <div>{auth}</div>\n      <div>{children}</div>\n    </>\n  )\n}\n\nWhen the user clicks the <Link>, the modal will open instead of navigating to the /login page. However, on refresh or initial load, navigating to /login will take the user to the main login page.\n\nClosing the modal\n\nYou can close the modal by calling router.back() or by using the Link component.\n\napp/ui/modal.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useRouter } from 'next/navigation'\n \nexport function Modal({ children }: { children: React.ReactNode }) {\n  const router = useRouter()\n \n  return (\n    <>\n      <button\n        onClick={() => {\n          router.back()\n        }}\n      >\n        Close modal\n      </button>\n      <div>{children}</div>\n    </>\n  )\n}\n\nWhen using the Link component to navigate away from a page that shouldn't render the @auth slot anymore, we need to make sure the parallel route matches to a component that returns null. For example, when navigating back to the root page, we create a @auth/page.tsx component:\n\napp/ui/modal.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \nexport function Modal({ children }: { children: React.ReactNode }) {\n  return (\n    <>\n      <Link href=\"/\">Close modal</Link>\n      <div>{children}</div>\n    </>\n  )\n}\napp/@auth/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Page() {\n  return null\n}\n\nOr if navigating to any other page (such as /foo, /foo/bar, etc), you can use a catch-all slot:\n\napp/@auth/[...catchAll]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function CatchAll() {\n  return null\n}\n\nGood to know:\n\nWe use a catch-all route in our @auth slot to close the modal because of how parallel routes behave. Since client-side navigations to a route that no longer match the slot will remain visible, we need to match the slot to a route that returns null to close the modal.\nOther examples could include opening a photo modal in a gallery while also having a dedicated /photo/[id] page, or opening a shopping cart in a side modal.\nView an example\n of modals with Intercepted and Parallel Routes.\nLoading and Error UI\n\nParallel Routes can be streamed independently, allowing you to define independent error and loading states for each route:\n\nSee the Loading UI and Error Handling documentation for more information.\n\nNext Steps\ndefault.js\nAPI Reference for the default.js file.\nPrevious\npage.js\nNext\nproxy.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: proxy.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/proxy",
    "html": "API Reference\nFile-system conventions\nproxy.js\nCopy page\nproxy.js\n\nNote: The middleware file convention is deprecated and has been renamed to proxy. See Migration to Proxy for more details.\n\nThe proxy.js|ts file is used to write Proxy and run code on the server before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.\n\nProxy executes before routes are rendered. It's particularly useful for implementing custom server-side logic like authentication, logging, or handling redirects.\n\nGood to know:\n\nProxy is meant to be invoked separately of your render code and in optimized cases deployed to your CDN for fast redirect/rewrite handling, you should not attempt relying on shared modules or globals.\n\nTo pass information from Proxy to your application, use headers, cookies, rewrites, redirects, or the URL.\n\nCreate a proxy.ts (or .js) file in the project root, or inside src if applicable, so that it is located at the same level as pages or app.\n\nIf you’ve customized pageExtensions, for example to .page.ts or .page.js, name your file proxy.page.ts or proxy.page.js accordingly.\n\nproxy.ts\nTypeScript\nJavaScript\nTypeScript\nimport { NextResponse, NextRequest } from 'next/server'\n \n// This function can be marked `async` if using `await` inside\nexport function proxy(request: NextRequest) {\n  return NextResponse.redirect(new URL('/home', request.url))\n}\n \nexport const config = {\n  matcher: '/about/:path*',\n}\nExports\nProxy function\n\nThe file must export a single function, either as a default export or named proxy. Note that multiple proxy from the same file are not supported.\n\nproxy.js\n// Example of default export\nexport default function proxy(request) {\n  // Proxy logic\n}\nConfig object (optional)\n\nOptionally, a config object can be exported alongside the Proxy function. This object includes the matcher to specify paths where the Proxy applies.\n\nMatcher\n\nThe matcher option allows you to target specific paths for the Proxy to run on. You can specify these paths in several ways:\n\nFor a single path: Directly use a string to define the path, like '/about'.\nFor multiple paths: Use an array to list multiple paths, such as matcher: ['/about', '/contact'], which applies the Proxy to both /about and /contact.\nproxy.js\nexport const config = {\n  matcher: ['/about/:path*', '/dashboard/:path*'],\n}\n\nAdditionally, the matcher option supports complex path specifications through regular expressions, such as matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)'], enabling precise control over which paths to include or exclude.\n\nThe matcher option accepts an array of objects with the following keys:\n\nsource: The path or pattern used to match the request paths. It can be a string for direct path matching or a pattern for more complex matching.\nregexp (optional): A regular expression string that fine-tunes the matching based on the source. It provides additional control over which paths are included or excluded.\nlocale (optional): A boolean that, when set to false, ignores locale-based routing in path matching.\nhas (optional): Specifies conditions based on the presence of specific request elements such as headers, query parameters, or cookies.\nmissing (optional): Focuses on conditions where certain request elements are absent, like missing headers or cookies.\nproxy.js\nexport const config = {\n  matcher: [\n    {\n      source: '/api/*',\n      regexp: '^/api/(.*)',\n      locale: false,\n      has: [\n        { type: 'header', key: 'Authorization', value: 'Bearer Token' },\n        { type: 'query', key: 'userId', value: '123' },\n      ],\n      missing: [{ type: 'cookie', key: 'session', value: 'active' }],\n    },\n  ],\n}\n\nConfigured matchers:\n\nMUST start with /\nCan include named parameters: /about/:path matches /about/a and /about/b but not /about/a/c\nCan have modifiers on named parameters (starting with :): /about/:path* matches /about/a/b/c because * is zero or more. ? is zero or one and + one or more\nCan use regular expression enclosed in parenthesis: /about/(.*) is the same as /about/:path*\n\nRead more details on path-to-regexp\n documentation.\n\nGood to know:\n\nThe matcher values need to be constants so they can be statically analyzed at build-time. Dynamic values such as variables will be ignored.\nFor backward compatibility, Next.js always considers /public as /public/index. Therefore, a matcher of /public/:path will match.\nParams\nrequest\n\nWhen defining Proxy, the default export function accepts a single parameter, request. This parameter is an instance of NextRequest, which represents the incoming HTTP request.\n\nproxy.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextRequest } from 'next/server'\n \nexport function proxy(request: NextRequest) {\n  // Proxy logic goes here\n}\n\nGood to know:\n\nNextRequest is a type that represents incoming HTTP requests in Next.js Proxy, whereas NextResponse is a class used to manipulate and send back HTTP responses.\nNextResponse\n\nThe NextResponse API allows you to:\n\nredirect the incoming request to a different URL\nrewrite the response by displaying a given URL\nSet request headers for API Routes, getServerSideProps, and rewrite destinations\nSet response cookies\nSet response headers\n\nTo produce a response from Proxy, you can:\n\nrewrite to a route (Page or Route Handler) that produces a response\nreturn a NextResponse directly. See Producing a Response\n\nGood to know: For redirects, you can also use Response.redirect instead of NextResponse.redirect.\n\nExecution order\n\nProxy will be invoked for every route in your project. Given this, it's crucial to use matchers to precisely target or exclude specific routes. The following is the execution order:\n\nheaders from next.config.js\nredirects from next.config.js\nProxy (rewrites, redirects, etc.)\nbeforeFiles (rewrites) from next.config.js\nFilesystem routes (public/, _next/static/, pages/, app/, etc.)\nafterFiles (rewrites) from next.config.js\nDynamic Routes (/blog/[slug])\nfallback (rewrites) from next.config.js\nRuntime\n\nProxy defaults to using the Node.js runtime. The runtime config option is not available in Proxy files. Setting the runtime config option in Proxy will throw an error.\n\nAdvanced Proxy flags\n\nIn v13.1 of Next.js two additional flags were introduced for proxy, skipMiddlewareUrlNormalize and skipTrailingSlashRedirect to handle advanced use cases.\n\nskipTrailingSlashRedirect disables Next.js redirects for adding or removing trailing slashes. This allows custom handling inside proxy to maintain the trailing slash for some paths but not others, which can make incremental migrations easier.\n\nnext.config.js\nmodule.exports = {\n  skipTrailingSlashRedirect: true,\n}\nproxy.js\nconst legacyPrefixes = ['/docs', '/blog']\n \nexport default async function proxy(req) {\n  const { pathname } = req.nextUrl\n \n  if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {\n    return NextResponse.next()\n  }\n \n  // apply trailing slash handling\n  if (\n    !pathname.endsWith('/') &&\n    !pathname.match(/((?!\\.well-known(?:\\/.*)?)(?:[^/]+\\/)*[^/]+\\.\\w+)/)\n  ) {\n    return NextResponse.redirect(\n      new URL(`${req.nextUrl.pathname}/`, req.nextUrl)\n    )\n  }\n}\n\nskipMiddlewareUrlNormalize allows for disabling the URL normalization in Next.js to make handling direct visits and client-transitions the same. In some advanced cases, this option provides full control by using the original URL.\n\nnext.config.js\nmodule.exports = {\n  skipMiddlewareUrlNormalize: true,\n}\nproxy.js\nexport default async function proxy(req) {\n  const { pathname } = req.nextUrl\n \n  // GET /_next/data/build-id/hello.json\n \n  console.log(pathname)\n  // with the flag this now /_next/data/build-id/hello.json\n  // without the flag this would be normalized to /hello\n}\nExamples\nConditional Statements\nproxy.ts\nTypeScript\nJavaScript\nTypeScript\nimport { NextResponse } from 'next/server'\nimport type { NextRequest } from 'next/server'\n \nexport function proxy(request: NextRequest) {\n  if (request.nextUrl.pathname.startsWith('/about')) {\n    return NextResponse.rewrite(new URL('/about-2', request.url))\n  }\n \n  if (request.nextUrl.pathname.startsWith('/dashboard')) {\n    return NextResponse.rewrite(new URL('/dashboard/user', request.url))\n  }\n}\nUsing Cookies\n\nCookies are regular headers. On a Request, they are stored in the Cookie header. On a Response they are in the Set-Cookie header. Next.js provides a convenient way to access and manipulate these cookies through the cookies extension on NextRequest and NextResponse.\n\nFor incoming requests, cookies comes with the following methods: get, getAll, set, and delete cookies. You can check for the existence of a cookie with has or remove all cookies with clear.\nFor outgoing responses, cookies have the following methods get, getAll, set, and delete.\nproxy.ts\nTypeScript\nJavaScript\nTypeScript\nimport { NextResponse } from 'next/server'\nimport type { NextRequest } from 'next/server'\n \nexport function proxy(request: NextRequest) {\n  // Assume a \"Cookie:nextjs=fast\" header to be present on the incoming request\n  // Getting cookies from the request using the `RequestCookies` API\n  let cookie = request.cookies.get('nextjs')\n  console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }\n  const allCookies = request.cookies.getAll()\n  console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]\n \n  request.cookies.has('nextjs') // => true\n  request.cookies.delete('nextjs')\n  request.cookies.has('nextjs') // => false\n \n  // Setting cookies on the response using the `ResponseCookies` API\n  const response = NextResponse.next()\n  response.cookies.set('vercel', 'fast')\n  response.cookies.set({\n    name: 'vercel',\n    value: 'fast',\n    path: '/',\n  })\n  cookie = response.cookies.get('vercel')\n  console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }\n  // The outgoing response will have a `Set-Cookie:vercel=fast;path=/` header.\n \n  return response\n}\nSetting Headers\n\nYou can set request and response headers using the NextResponse API (setting request headers is available since Next.js v13.0.0).\n\nproxy.ts\nTypeScript\nJavaScript\nTypeScript\nimport { NextResponse } from 'next/server'\nimport type { NextRequest } from 'next/server'\n \nexport function proxy(request: NextRequest) {\n  // Clone the request headers and set a new header `x-hello-from-proxy1`\n  const requestHeaders = new Headers(request.headers)\n  requestHeaders.set('x-hello-from-proxy1', 'hello')\n \n  // You can also set request headers in NextResponse.next\n  const response = NextResponse.next({\n    request: {\n      // New request headers\n      headers: requestHeaders,\n    },\n  })\n \n  // Set a new response header `x-hello-from-proxy2`\n  response.headers.set('x-hello-from-proxy2', 'hello')\n  return response\n}\n\nNote that the snippet uses:\n\nNextResponse.next({ request: { headers: requestHeaders } }) to make requestHeaders available upstream\nNOT NextResponse.next({ headers: requestHeaders }) which makes requestHeaders available to clients\n\nLearn more in NextResponse headers in Proxy.\n\nGood to know: Avoid setting large headers as it might cause 431 Request Header Fields Too Large\n error depending on your backend web server configuration.\n\nCORS\n\nYou can set CORS headers in Proxy to allow cross-origin requests, including simple\n and preflighted\n requests.\n\nproxy.ts\nTypeScript\nJavaScript\nTypeScript\nimport { NextRequest, NextResponse } from 'next/server'\n \nconst allowedOrigins = ['https://acme.com', 'https://my-app.org']\n \nconst corsOptions = {\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n}\n \nexport function proxy(request: NextRequest) {\n  // Check the origin from the request\n  const origin = request.headers.get('origin') ?? ''\n  const isAllowedOrigin = allowedOrigins.includes(origin)\n \n  // Handle preflighted requests\n  const isPreflight = request.method === 'OPTIONS'\n \n  if (isPreflight) {\n    const preflightHeaders = {\n      ...(isAllowedOrigin && { 'Access-Control-Allow-Origin': origin }),\n      ...corsOptions,\n    }\n    return NextResponse.json({}, { headers: preflightHeaders })\n  }\n \n  // Handle simple requests\n  const response = NextResponse.next()\n \n  if (isAllowedOrigin) {\n    response.headers.set('Access-Control-Allow-Origin', origin)\n  }\n \n  Object.entries(corsOptions).forEach(([key, value]) => {\n    response.headers.set(key, value)\n  })\n \n  return response\n}\n \nexport const config = {\n  matcher: '/api/:path*',\n}\n\nGood to know: You can configure CORS headers for individual routes in Route Handlers.\n\nProducing a response\n\nYou can respond from Proxy directly by returning a Response or NextResponse instance. (This is available since Next.js v13.1.0\n)\n\nproxy.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextRequest } from 'next/server'\nimport { isAuthenticated } from '@lib/auth'\n \n// Limit the proxy to paths starting with `/api/`\nexport const config = {\n  matcher: '/api/:function*',\n}\n \nexport function proxy(request: NextRequest) {\n  // Call our authentication function to check the request\n  if (!isAuthenticated(request)) {\n    // Respond with JSON indicating an error message\n    return Response.json(\n      { success: false, message: 'authentication failed' },\n      { status: 401 }\n    )\n  }\n}\nNegative matching\n\nThe matcher config allows full regex so matching like negative lookaheads or character matching is supported. An example of a negative lookahead to match all except specific paths can be seen here:\n\nproxy.js\nexport const config = {\n  matcher: [\n    /*\n     * Match all request paths except for the ones starting with:\n     * - api (API routes)\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico, sitemap.xml, robots.txt (metadata files)\n     */\n    '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',\n  ],\n}\n\nYou can also bypass Proxy for certain requests by using the missing or has arrays, or a combination of both:\n\nproxy.js\nexport const config = {\n  matcher: [\n    /*\n     * Match all request paths except for the ones starting with:\n     * - api (API routes)\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico, sitemap.xml, robots.txt (metadata files)\n     */\n    {\n      source:\n        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',\n      missing: [\n        { type: 'header', key: 'next-router-prefetch' },\n        { type: 'header', key: 'purpose', value: 'prefetch' },\n      ],\n    },\n \n    {\n      source:\n        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',\n      has: [\n        { type: 'header', key: 'next-router-prefetch' },\n        { type: 'header', key: 'purpose', value: 'prefetch' },\n      ],\n    },\n \n    {\n      source:\n        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',\n      has: [{ type: 'header', key: 'x-present' }],\n      missing: [{ type: 'header', key: 'x-missing', value: 'prefetch' }],\n    },\n  ],\n}\nwaitUntil and NextFetchEvent\n\nThe NextFetchEvent object extends the native FetchEvent\n object, and includes the waitUntil()\n method.\n\nThe waitUntil() method takes a promise as an argument, and extends the lifetime of the Proxy until the promise settles. This is useful for performing work in the background.\n\nproxy.ts\nimport { NextResponse } from 'next/server'\nimport type { NextFetchEvent, NextRequest } from 'next/server'\n \nexport function proxy(req: NextRequest, event: NextFetchEvent) {\n  event.waitUntil(\n    fetch('https://my-analytics-platform.com', {\n      method: 'POST',\n      body: JSON.stringify({ pathname: req.nextUrl.pathname }),\n    })\n  )\n \n  return NextResponse.next()\n}\nUnit testing (experimental)\n\nStarting in Next.js 15.1, the next/experimental/testing/server package contains utilities to help unit test proxy files. Unit testing proxy can help ensure that it's only run on desired paths and that custom routing logic works as intended before code reaches production.\n\nThe unstable_doesProxyMatch function can be used to assert whether proxy will run for the provided URL, headers, and cookies.\n\nimport { unstable_doesProxyMatch } from 'next/experimental/testing/server'\n \nexpect(\n  unstable_doesProxyMatch({\n    config,\n    nextConfig,\n    url: '/test',\n  })\n).toEqual(false)\n\nThe entire proxy function can also be tested.\n\nimport { isRewrite, getRewrittenUrl } from 'next/experimental/testing/server'\n \nconst request = new NextRequest('https://nextjs.org/docs')\nconst response = await proxy(request)\nexpect(isRewrite(response)).toEqual(true)\nexpect(getRewrittenUrl(response)).toEqual('https://other-domain.com/docs')\n// getRedirectUrl could also be used if the response were a redirect\nPlatform support\nDeployment Option\tSupported\nNode.js server\tYes\nDocker container\tYes\nStatic export\tNo\nAdapters\tPlatform-specific\n\nLearn how to configure Proxy when self-hosting Next.js.\n\nMigration to Proxy\nWhy the Change\n\nThe reason behind the renaming of middleware is that the term \"middleware\" can often be confused with Express.js middleware, leading to a misinterpretation of its purpose. Also, Middleware is highly capable, so it may encourage the usage; however, this feature is recommended to be used as a last resort.\n\nNext.js is moving forward to provide better APIs with better ergonomics so that developers can achieve their goals without Middleware. This is the reason behind the renaming of middleware.\n\nWhy \"Proxy\"\n\nThe name Proxy clarifies what Middleware is capable of. The term \"proxy\" implies that it has a network boundary in front of the app, which is the behavior of Middleware. Also, Middleware defaults to run at the Edge Runtime, which can run closer to the client, separated from the app's region. These behaviors align better with the term \"proxy\" and provide a clearer purpose of the feature.\n\nHow to Migrate\n\nWe recommend users avoid relying on Middleware unless no other options exist. Our goal is to give them APIs with better ergonomics so they can achieve their goals without Middleware.\n\nThe term “middleware” often confuses users with Express.js middleware, which can encourage misuse. To clarify our direction, we are renaming the file convention to “proxy.” This highlights that we are moving away from Middleware, breaking down its overloaded features, and making the Proxy clear in its purpose.\n\nNext.js provides a codemod to migrate from middleware.ts to proxy.ts. You can run the following command to migrate:\n\nnpx @next/codemod@canary middleware-to-proxy .\n\nThe codemod will rename the file and the function name from middleware to proxy.\n\n// middleware.ts -> proxy.ts\n \n- export function middleware() {\n+ export function proxy() {\nVersion history\nVersion\tChanges\nv16.0.0\tMiddleware is deprecated and renamed to Proxy\nv15.5.0\tMiddleware can now use the Node.js runtime (stable)\nv15.2.0\tMiddleware can now use the Node.js runtime (experimental)\nv13.1.0\tAdvanced Middleware flags added\nv13.0.0\tMiddleware can modify request headers, response headers, and send responses\nv12.2.0\tMiddleware is stable, please see the upgrade guide\nv12.0.9\tEnforce absolute URLs in Edge Runtime (PR\n)\nv12.0.0\tMiddleware (Beta) added\nLearn more about Proxy\nNextRequest\nAPI Reference for NextRequest.\nNextResponse\nAPI Reference for NextResponse.\nPrevious\nParallel Routes\nNext\npublic\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: public | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/public-folder",
    "html": "API Reference\nFile-system conventions\npublic\nCopy page\npublic Folder\n\nNext.js can serve static files, like images, under a folder called public in the root directory. Files inside public can then be referenced by your code starting from the base URL (/).\n\nFor example, the file public/avatars/me.png can be viewed by visiting the /avatars/me.png path. The code to display that image might look like:\n\navatar.js\nimport Image from 'next/image'\n \nexport function Avatar({ id, alt }) {\n  return <Image src={`/avatars/${id}.png`} alt={alt} width=\"64\" height=\"64\" />\n}\n \nexport function AvatarOfMe() {\n  return <Avatar id=\"me\" alt=\"A portrait of me\" />\n}\nCaching\n\nNext.js cannot safely cache assets in the public folder because they may change. The default caching headers applied are:\n\nCache-Control: public, max-age=0\nRobots, Favicons, and others\n\nFor static metadata files, such as robots.txt, favicon.ico, etc, you should use special metadata files inside the app folder.\n\nPrevious\nproxy.js\nNext\nroute.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: route.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/route",
    "html": "API Reference\nFile-system conventions\nroute.js\nCopy page\nroute.js\n\nRoute Handlers allow you to create custom request handlers for a given route using the Web Request\n and Response\n APIs.\n\nroute.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function GET() {\n  return Response.json({ message: 'Hello World' })\n}\nReference\nHTTP Methods\n\nA route file allows you to create custom request handlers for a given route. The following HTTP methods\n are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS.\n\nroute.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function GET(request: Request) {}\n \nexport async function HEAD(request: Request) {}\n \nexport async function POST(request: Request) {}\n \nexport async function PUT(request: Request) {}\n \nexport async function DELETE(request: Request) {}\n \nexport async function PATCH(request: Request) {}\n \n// If `OPTIONS` is not defined, Next.js will automatically implement `OPTIONS` and set the appropriate Response `Allow` header depending on the other methods defined in the Route Handler.\nexport async function OPTIONS(request: Request) {}\nParameters\nrequest (optional)\n\nThe request object is a NextRequest object, which is an extension of the Web Request\n API. NextRequest gives you further control over the incoming request, including easily accessing cookies and an extended, parsed, URL object nextUrl.\n\nroute.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextRequest } from 'next/server'\n \nexport async function GET(request: NextRequest) {\n  const url = request.nextUrl\n}\ncontext (optional)\nparams: a promise that resolves to an object containing the dynamic route parameters for the current route.\napp/dashboard/[team]/route.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function GET(\n  request: Request,\n  { params }: { params: Promise<{ team: string }> }\n) {\n  const { team } = await params\n}\nExample\tURL\tparams\napp/dashboard/[team]/route.js\t/dashboard/1\tPromise<{ team: '1' }>\napp/shop/[tag]/[item]/route.js\t/shop/1/2\tPromise<{ tag: '1', item: '2' }>\napp/blog/[...slug]/route.js\t/blog/1/2\tPromise<{ slug: ['1', '2'] }>\nRoute Context Helper\n\nYou can type the Route Handler context using RouteContext to get strongly typed params from a route literal. RouteContext is a globally available helper.\n\napp/users/[id]/route.ts\nimport type { NextRequest } from 'next/server'\n \nexport async function GET(_req: NextRequest, ctx: RouteContext<'/users/[id]'>) {\n  const { id } = await ctx.params\n  return Response.json({ id })\n}\n\nGood to know\n\nTypes are generated during next dev, next build or next typegen.\nAfter type generation, the RouteContext helper is globally available. It doesn't need to be imported.\nExamples\nCookies\n\nYou can read or set cookies with cookies from next/headers.\n\nroute.ts\nTypeScript\nJavaScript\nTypeScript\nimport { cookies } from 'next/headers'\n \nexport async function GET(request: NextRequest) {\n  const cookieStore = await cookies()\n \n  const a = cookieStore.get('a')\n  const b = cookieStore.set('b', '1')\n  const c = cookieStore.delete('c')\n}\n\nAlternatively, you can return a new Response using the Set-Cookie\n header.\n\napp/api/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { cookies } from 'next/headers'\n \nexport async function GET(request: Request) {\n  const cookieStore = await cookies()\n  const token = cookieStore.get('token')\n \n  return new Response('Hello, Next.js!', {\n    status: 200,\n    headers: { 'Set-Cookie': `token=${token.value}` },\n  })\n}\n\nYou can also use the underlying Web APIs to read cookies from the request (NextRequest):\n\napp/api/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { type NextRequest } from 'next/server'\n \nexport async function GET(request: NextRequest) {\n  const token = request.cookies.get('token')\n}\nHeaders\n\nYou can read headers with headers from next/headers.\n\nroute.ts\nTypeScript\nJavaScript\nTypeScript\nimport { headers } from 'next/headers'\nimport type { NextRequest } from 'next/server'\n \nexport async function GET(request: NextRequest) {\n  const headersList = await headers()\n  const referer = headersList.get('referer')\n}\n\nThis headers instance is read-only. To set headers, you need to return a new Response with new headers.\n\napp/api/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { headers } from 'next/headers'\n \nexport async function GET(request: Request) {\n  const headersList = await headers()\n  const referer = headersList.get('referer')\n \n  return new Response('Hello, Next.js!', {\n    status: 200,\n    headers: { referer: referer },\n  })\n}\n\nYou can also use the underlying Web APIs to read headers from the request (NextRequest):\n\napp/api/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { type NextRequest } from 'next/server'\n \nexport async function GET(request: NextRequest) {\n  const requestHeaders = new Headers(request.headers)\n}\nRevalidating Cached Data\n\nYou can revalidate cached data using the revalidate route segment config option.\n\napp/posts/route.ts\nTypeScript\nJavaScript\nTypeScript\nexport const revalidate = 60\n \nexport async function GET() {\n  const data = await fetch('https://api.vercel.app/blog')\n  const posts = await data.json()\n \n  return Response.json(posts)\n}\nRedirects\napp/api/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { redirect } from 'next/navigation'\n \nexport async function GET(request: Request) {\n  redirect('https://nextjs.org/')\n}\nDynamic Route Segments\n\nRoute Handlers can use Dynamic Segments to create request handlers from dynamic data.\n\napp/items/[slug]/route.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function GET(\n  request: Request,\n  { params }: { params: Promise<{ slug: string }> }\n) {\n  const { slug } = await params // 'a', 'b', or 'c'\n}\nRoute\tExample URL\tparams\napp/items/[slug]/route.js\t/items/a\tPromise<{ slug: 'a' }>\napp/items/[slug]/route.js\t/items/b\tPromise<{ slug: 'b' }>\napp/items/[slug]/route.js\t/items/c\tPromise<{ slug: 'c' }>\nURL Query Parameters\n\nThe request object passed to the Route Handler is a NextRequest instance, which includes some additional convenience methods, such as those for more easily handling query parameters.\n\napp/api/search/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { type NextRequest } from 'next/server'\n \nexport function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams\n  const query = searchParams.get('query')\n  // query is \"hello\" for /api/search?query=hello\n}\nStreaming\n\nStreaming is commonly used in combination with Large Language Models (LLMs), such as OpenAI, for AI-generated content. Learn more about the AI SDK\n.\n\napp/api/chat/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { openai } from '@ai-sdk/openai'\nimport { StreamingTextResponse, streamText } from 'ai'\n \nexport async function POST(req: Request) {\n  const { messages } = await req.json()\n  const result = await streamText({\n    model: openai('gpt-4-turbo'),\n    messages,\n  })\n \n  return new StreamingTextResponse(result.toAIStream())\n}\n\nThese abstractions use the Web APIs to create a stream. You can also use the underlying Web APIs directly.\n\napp/api/route.ts\nTypeScript\nJavaScript\nTypeScript\n// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream\nfunction iteratorToStream(iterator: any) {\n  return new ReadableStream({\n    async pull(controller) {\n      const { value, done } = await iterator.next()\n \n      if (done) {\n        controller.close()\n      } else {\n        controller.enqueue(value)\n      }\n    },\n  })\n}\n \nfunction sleep(time: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, time)\n  })\n}\n \nconst encoder = new TextEncoder()\n \nasync function* makeIterator() {\n  yield encoder.encode('<p>One</p>')\n  await sleep(200)\n  yield encoder.encode('<p>Two</p>')\n  await sleep(200)\n  yield encoder.encode('<p>Three</p>')\n}\n \nexport async function GET() {\n  const iterator = makeIterator()\n  const stream = iteratorToStream(iterator)\n \n  return new Response(stream)\n}\nRequest Body\n\nYou can read the Request body using the standard Web API methods:\n\napp/items/route.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function POST(request: Request) {\n  const res = await request.json()\n  return Response.json({ res })\n}\nRequest Body FormData\n\nYou can read the FormData using the request.formData() function:\n\napp/items/route.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function POST(request: Request) {\n  const formData = await request.formData()\n  const name = formData.get('name')\n  const email = formData.get('email')\n  return Response.json({ name, email })\n}\n\nSince formData data are all strings, you may want to use zod-form-data\n to validate the request and retrieve data in the format you prefer (e.g. number).\n\nCORS\n\nYou can set CORS headers for a specific Route Handler using the standard Web API methods:\n\napp/api/route.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function GET(request: Request) {\n  return new Response('Hello, Next.js!', {\n    status: 200,\n    headers: {\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n    },\n  })\n}\n\nGood to know:\n\nTo add CORS headers to multiple Route Handlers, you can use Proxy or the next.config.js file.\nWebhooks\n\nYou can use a Route Handler to receive webhooks from third-party services:\n\napp/api/route.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function POST(request: Request) {\n  try {\n    const text = await request.text()\n    // Process the webhook payload\n  } catch (error) {\n    return new Response(`Webhook error: ${error.message}`, {\n      status: 400,\n    })\n  }\n \n  return new Response('Success!', {\n    status: 200,\n  })\n}\n\nNotably, unlike API Routes with the Pages Router, you do not need to use bodyParser to use any additional configuration.\n\nNon-UI Responses\n\nYou can use Route Handlers to return non-UI content. Note that sitemap.xml, robots.txt, app icons, and open graph images all have built-in support.\n\napp/rss.xml/route.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function GET() {\n  return new Response(\n    `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<rss version=\"2.0\">\n \n<channel>\n  <title>Next.js Documentation</title>\n  <link>https://nextjs.org/docs</link>\n  <description>The React Framework for the Web</description>\n</channel>\n \n</rss>`,\n    {\n      headers: {\n        'Content-Type': 'text/xml',\n      },\n    }\n  )\n}\nSegment Config Options\n\nRoute Handlers use the same route segment configuration as pages and layouts.\n\napp/items/route.ts\nTypeScript\nJavaScript\nTypeScript\nexport const dynamic = 'auto'\nexport const dynamicParams = true\nexport const revalidate = false\nexport const fetchCache = 'auto'\nexport const runtime = 'nodejs'\nexport const preferredRegion = 'auto'\n\nSee the API reference for more details.\n\nVersion History\nVersion\tChanges\nv15.0.0-RC\tcontext.params is now a promise. A codemod is available\nv15.0.0-RC\tThe default caching for GET handlers was changed from static to dynamic\nv13.2.0\tRoute Handlers are introduced.\nPrevious\npublic\nNext\nRoute Groups\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: Route Groups | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/route-groups",
    "html": "API Reference\nFile-system conventions\nRoute Groups\nCopy page\nRoute Groups\n\nRoute Groups are a folder convention that let you organize routes by category or team.\n\nConvention\n\nA route group can be created by wrapping a folder's name in parenthesis: (folderName).\n\nThis convention indicates the folder is for organizational purposes and should not be included in the route's URL path.\n\nUse cases\nOrganizing routes by team, concern, or feature.\nDefining multiple root layouts.\nOpting specific route segments into sharing a layout, while keeping others out.\nCaveats\nFull page load: If you navigate between routes that use different root layouts, it'll trigger a full page reload. For example, navigating from /cart that uses app/(shop)/layout.js to /blog that uses app/(marketing)/layout.js. This only applies to multiple root layouts.\nConflicting paths: Routes in different groups should not resolve to the same URL path. For example, (marketing)/about/page.js and (shop)/about/page.js would both resolve to /about and cause an error.\nTop-level root layout: If you use multiple root layouts without a top-level layout.js file, make sure your home route (/) is defined within one of the route groups, e.g. app/(marketing)/page.js.\nPrevious\nroute.js\nNext\nRoute Segment Config\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: Route Segment Config | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config",
    "html": "API Reference\nFile-system conventions\nRoute Segment Config\nCopy page\nRoute Segment Config\n\nGood to know:\n\nThe options outlined on this page are disabled if the cacheComponents flag is on, and will eventually be deprecated in the future.\nRoute Segment options only take effect in Server Component Pages, Layouts, or Route Handlers.\ngenerateStaticParams cannot be used inside a 'use client' file.\n\nThe Route Segment options allows you to configure the behavior of a Page, Layout, or Route Handler by directly exporting the following variables:\n\nOption\tType\tDefault\ndynamic\t'auto' | 'force-dynamic' | 'error' | 'force-static'\t'auto'\ndynamicParams\tboolean\ttrue\nrevalidate\tfalse | 0 | number\tfalse\nfetchCache\t'auto' | 'default-cache' | 'only-cache' | 'force-cache' | 'force-no-store' | 'default-no-store' | 'only-no-store'\t'auto'\nruntime\t'nodejs' | 'edge'\t'nodejs'\npreferredRegion\t'auto' | 'global' | 'home' | string | string[]\t'auto'\nmaxDuration\tnumber\tSet by deployment platform\nOptions\ndynamic\n\nChange the dynamic behavior of a layout or page to fully static or fully dynamic.\n\nlayout.tsx | page.tsx | route.ts\nTypeScript\nJavaScript\nTypeScript\nexport const dynamic = 'auto'\n// 'auto' | 'force-dynamic' | 'error' | 'force-static'\n\nGood to know: The new model in the app directory favors granular caching control at the fetch request level over the binary all-or-nothing model of getServerSideProps and getStaticProps at the page-level in the pages directory. The dynamic option is a way to opt back in to the previous model as a convenience and provides a simpler migration path.\n\n'auto' (default): The default option to cache as much as possible without preventing any components from opting into dynamic behavior.\n\n'force-dynamic': Force dynamic rendering, which will result in routes being rendered for each user at request time. This option is equivalent to:\n\nSetting the option of every fetch() request in a layout or page to { cache: 'no-store', next: { revalidate: 0 } }.\nSetting the segment config to export const fetchCache = 'force-no-store'\n\n'error': Force static rendering and cache the data of a layout or page by causing an error if any components use Dynamic APIs or uncached data. This option is equivalent to:\n\ngetStaticProps() in the pages directory.\nSetting the option of every fetch() request in a layout or page to { cache: 'force-cache' }.\nSetting the segment config to fetchCache = 'only-cache'.\n\n'force-static': Force static rendering and cache the data of a layout or page by forcing cookies, headers() and useSearchParams() to return empty values. It is possible to revalidate, revalidatePath, or revalidateTag, in pages or layouts rendered with force-static.\n\nGood to know:\n\nInstructions on how to migrate from getServerSideProps and getStaticProps to dynamic: 'force-dynamic' and dynamic: 'error' can be found in the upgrade guide.\ndynamicParams\n\nControl what happens when a dynamic segment is visited that was not generated with generateStaticParams.\n\nlayout.tsx | page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport const dynamicParams = true // true | false\ntrue (default): Dynamic segments not included in generateStaticParams are generated on demand.\nfalse: Dynamic segments not included in generateStaticParams will return a 404.\n\nGood to know:\n\nThis option replaces the fallback: true | false | blocking option of getStaticPaths in the pages directory.\nTo statically render all paths the first time they're visited, you'll need to return an empty array in generateStaticParams or utilize export const dynamic = 'force-static'.\nWhen dynamicParams = true, the segment uses Streaming Server Rendering.\nrevalidate\n\nSet the default revalidation time for a layout or page. This option does not override the revalidate value set by individual fetch requests.\n\nlayout.tsx | page.tsx | route.ts\nTypeScript\nJavaScript\nTypeScript\nexport const revalidate = false\n// false | 0 | number\nfalse (default): The default heuristic to cache any fetch requests that set their cache option to 'force-cache' or are discovered before a Dynamic API is used. Semantically equivalent to revalidate: Infinity which effectively means the resource should be cached indefinitely. It is still possible for individual fetch requests to use cache: 'no-store' or revalidate: 0 to avoid being cached and make the route dynamically rendered. Or set revalidate to a positive number lower than the route default to increase the revalidation frequency of a route.\n0: Ensure a layout or page is always dynamically rendered even if no Dynamic APIs or uncached data fetches are discovered. This option changes the default of fetch requests that do not set a cache option to 'no-store' but leaves fetch requests that opt into 'force-cache' or use a positive revalidate as is.\nnumber: (in seconds) Set the default revalidation frequency of a layout or page to n seconds.\n\nGood to know:\n\nThe revalidate value needs to be statically analyzable. For example revalidate = 600 is valid, but revalidate = 60 * 10 is not.\nThe revalidate value is not available when using runtime = 'edge'.\nIn Development, Pages are always rendered on-demand and are never cached. This allows you to see changes immediately without waiting for a revalidation period to pass.\nRevalidation Frequency\nThe lowest revalidate across each layout and page of a single route will determine the revalidation frequency of the entire route. This ensures that child pages are revalidated as frequently as their parent layouts.\nIndividual fetch requests can set a lower revalidate than the route's default revalidate to increase the revalidation frequency of the entire route. This allows you to dynamically opt-in to more frequent revalidation for certain routes based on some criteria.\nfetchCache\nThis is an advanced option that should only be used if you specifically need to override the default behavior.\nruntime\n\nWe recommend using the Node.js runtime for rendering your application. This option cannot be used in Proxy.\n\nGood to know: Using runtime: 'edge' is not supported for Cache Components.\n\nlayout.tsx | page.tsx | route.ts\nTypeScript\nJavaScript\nTypeScript\nexport const runtime = 'nodejs'\n// 'nodejs' | 'edge'\n'nodejs' (default)\n'edge'\npreferredRegion\nlayout.tsx | page.tsx | route.ts\nTypeScript\nJavaScript\nTypeScript\nexport const preferredRegion = 'auto'\n// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']\n\nSupport for preferredRegion, and regions supported, is dependent on your deployment platform.\n\nGood to know:\n\nIf a preferredRegion is not specified, it will inherit the option of the nearest parent layout.\nThe root layout defaults to all regions.\nmaxDuration\n\nBy default, Next.js does not limit the execution of server-side logic (rendering a page or handling an API). Deployment platforms can use maxDuration from the Next.js build output to add specific execution limits.\n\nNote: This setting requires Next.js 13.4.10 or higher.\n\nlayout.tsx | page.tsx | route.ts\nTypeScript\nJavaScript\nTypeScript\nexport const maxDuration = 5\n\nGood to know:\n\nIf using Server Actions, set the maxDuration at the page level to change the default timeout of all Server Actions used on the page.\ngenerateStaticParams\n\nThe generateStaticParams function can be used in combination with dynamic route segments to define the list of route segment parameters that will be statically generated at build time instead of on-demand at request time.\n\nSee the API reference for more details.\n\nVersion History\nVersion\t\nv16.0.0\texport const experimental_ppr = true removed. A codemod is available.\nv15.0.0-RC\texport const runtime = \"experimental-edge\" deprecated. A codemod is available.\nPrevious\nRoute Groups\nNext\nsrc\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: src | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/src-folder",
    "html": "API Reference\nFile-system conventions\nsrc\nCopy page\nsrc Folder\n\nAs an alternative to having the special Next.js app or pages directories in the root of your project, Next.js also supports the common pattern of placing application code under the src folder.\n\nThis separates application code from project configuration files which mostly live in the root of a project, which is preferred by some individuals and teams.\n\nTo use the src folder, move the app Router folder or pages Router folder to src/app or src/pages respectively.\n\nGood to know:\n\nThe /public directory should remain in the root of your project.\nConfig files like package.json, next.config.js and tsconfig.json should remain in the root of your project.\n.env.* files should remain in the root of your project.\nsrc/app or src/pages will be ignored if app or pages are present in the root directory.\nIf you're using src, you'll probably also move other application folders such as /components or /lib.\nIf you're using Proxy, ensure it is placed inside the src folder.\nIf you're using Tailwind CSS, you'll need to add the /src prefix to the tailwind.config.js file in the content section\n.\nIf you are using TypeScript paths for imports such as @/*, you should update the paths object in tsconfig.json to include src/.\nNext Steps\nProject Structure\nLearn the folder and file conventions in Next.js, and how to organize your project.\nPrevious\nRoute Segment Config\nNext\ntemplate.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: template.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/template",
    "html": "API Reference\nFile-system conventions\ntemplate.js\nCopy page\ntemplate.js\n\nA template file is similar to a layout in that it wraps a layout or page. Unlike layouts that persist across routes and maintain state, templates are given a unique key, meaning children Client Components reset their state on navigation.\n\nThey are useful when you need to:\n\nResynchronize useEffect on navigation.\nReset the state of a child Client Components on navigation. For example, an input field.\nTo change default framework behavior. For example, Suspense boundaries inside layouts only show a fallback on first load, while templates show it on every navigation.\nConvention\n\nA template can be defined by exporting a default React component from a template.js file. The component should accept a children prop.\n\napp/template.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Template({ children }: { children: React.ReactNode }) {\n  return <div>{children}</div>\n}\n\nIn terms of nesting, template.js is rendered between a layout and its children. Here's a simplified output:\n\nOutput\n<Layout>\n  {/* Note that the template is given a unique key. */}\n  <Template key={routeParam}>{children}</Template>\n</Layout>\nProps\nchildren (required)\n\nTemplate accepts a children prop.\n\nOutput\n<Layout>\n  {/* Note that the template is automatically given a unique key. */}\n  <Template key={routeParam}>{children}</Template>\n</Layout>\nBehavior\nServer Components: By default, templates are Server Components.\nWith navigation: Templates receive a unique key for their own segment level. They remount when that segment (including its dynamic params) changes. Navigations within deeper segments do not remount higher-level templates. Search params do not trigger remounts.\nState reset: Any Client Component inside the template will reset its state on navigation.\nEffect re-run: Effects like useEffect will re-synchronize as the component remounts.\nDOM reset: DOM elements inside the template are fully recreated.\nTemplates during navigation and remounting\n\nThis section illustrates how templates behave during navigation. It shows, step by step, which templates remount on each route change and why.\n\nUsing this project tree:\n\napp\n├── about\n│   ├── page.tsx\n├── blog\n│   ├── [slug]\n│   │   └── page.tsx\n│   ├── page.tsx\n│   └── template.tsx\n├── layout.tsx\n├── page.tsx\n└── template.tsx\n\n\nStarting at /, the React tree looks roughly like this.\n\nNote: The key values shown in the examples are illustrative, the values in your application may differ.\n\nOutput\n<RootLayout>\n  {/* app/template.tsx */}\n  <Template key=\"/\">\n    <Page />\n  </Template>\n</RootLayout>\n\nNavigating to /about (first segment changes), the root template key changes, it remounts:\n\nOutput\n<RootLayout>\n  {/* app/template.tsx */}\n  <Template key=\"/about\">\n    <AboutPage />\n  </Template>\n</RootLayout>\n\nNavigating to /blog (first segment changes), the root template key changes, it remounts and the blog-level template mounts:\n\nOutput\n<RootLayout>\n  {/* app/template.tsx (root) */}\n  <Template key=\"/blog\">\n    {/* app/blog/template.tsx */}\n    <Template key=\"/blog\">\n      <BlogIndexPage />\n    </Template>\n  </Template>\n</RootLayout>\n\nNavigating within the same first segment to /blog/first-post (child segment changes), the root template key doesn't change, but the blog-level template key changes, it remounts:\n\nOutput\n<RootLayout>\n  {/* app/template.tsx (root) */}\n  <Template key=\"/blog\">\n    {/* app/blog/template.tsx */}\n    {/* remounts because the child segment at this level changed */}\n    <Template key=\"/blog/first-post\">\n      <BlogPostPage slug=\"first-post\" />\n    </Template>\n  </Template>\n</RootLayout>\n\nNavigating to /blog/second-post (same first segment, different child segment), the root template key doesn't change, but the blog-level template key changes, it remounts again:\n\nOutput\n<RootLayout>\n  {/* app/template.tsx (root) */}\n  <Template key=\"/blog\">\n    {/* app/blog/template.tsx */}\n    {/* remounts again due to changed child segment */}\n    <Template key=\"/blog/second-post\">\n      <BlogPostPage slug=\"second-post\" />\n    </Template>\n  </Template>\n</RootLayout>\nVersion History\nVersion\tChanges\nv13.0.0\ttemplate introduced.\nPrevious\nsrc\nNext\nunauthorized.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: unauthorized.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized",
    "html": "API Reference\nFile-system conventions\nunauthorized.js\nCopy page\nunauthorized.js\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nThe unauthorized file is used to render UI when the unauthorized function is invoked during authentication. Along with allowing you to customize the UI, Next.js will return a 401 status code.\n\napp/unauthorized.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Login from '@/app/components/Login'\n \nexport default function Unauthorized() {\n  return (\n    <main>\n      <h1>401 - Unauthorized</h1>\n      <p>Please log in to access this page.</p>\n      <Login />\n    </main>\n  )\n}\nReference\nProps\n\nunauthorized.js components do not accept any props.\n\nExamples\nDisplaying login UI to unauthenticated users\n\nYou can use unauthorized function to render the unauthorized.js file with a login UI.\n\napp/dashboard/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\n \nexport default async function DashboardPage() {\n  const session = await verifySession()\n \n  if (!session) {\n    unauthorized()\n  }\n \n  return <div>Dashboard</div>\n}\napp/unauthorized.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Login from '@/app/components/Login'\n \nexport default function UnauthorizedPage() {\n  return (\n    <main>\n      <h1>401 - Unauthorized</h1>\n      <p>Please log in to access this page.</p>\n      <Login />\n    </main>\n  )\n}\nVersion History\nVersion\tChanges\nv15.1.0\tunauthorized.js introduced.\nNext Steps\nunauthorized\nAPI Reference for the unauthorized function.\nPrevious\ntemplate.js\nNext\nMetadata Files\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "File-system conventions: Metadata Files | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata",
    "html": "API Reference\nFile-system conventions\nMetadata Files\nCopy page\nMetadata Files API Reference\n\nThis section of the docs covers Metadata file conventions. File-based metadata can be defined by adding special metadata files to route segments.\n\nEach file convention can be defined using a static file (e.g. opengraph-image.jpg), or a dynamic variant that uses code to generate the file (e.g. opengraph-image.js).\n\nOnce a file is defined, Next.js will automatically serve the file (with hashes in production for caching) and update the relevant head elements with the correct metadata, such as the asset's URL, file type, and image size.\n\nGood to know:\n\nSpecial Route Handlers like sitemap.ts, opengraph-image.tsx, and icon.tsx, and other metadata files are cached by default.\nIf using along with proxy.ts, configure the matcher to exclude the metadata files.\nfavicon, icon, and apple-icon\nAPI Reference for the Favicon, Icon and Apple Icon file conventions.\nmanifest.json\nAPI Reference for manifest.json file.\nopengraph-image and twitter-image\nAPI Reference for the Open Graph Image and Twitter Image file conventions.\nrobots.txt\nAPI Reference for robots.txt file.\nsitemap.xml\nAPI Reference for the sitemap.xml file.\nPrevious\nunauthorized.js\nNext\nfavicon, icon, and apple-icon\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Metadata Files: favicon, icon, and apple-icon | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons",
    "html": "File-system conventions\nMetadata Files\nfavicon, icon, and apple-icon\nCopy page\nfavicon, icon, and apple-icon\n\nThe favicon, icon, or apple-icon file conventions allow you to set icons for your application.\n\nThey are useful for adding app icons that appear in places like web browser tabs, phone home screens, and search engine results.\n\nThere are two ways to set app icons:\n\nUsing image files (.ico, .jpg, .png)\nUsing code to generate an icon (.js, .ts, .tsx)\nImage files (.ico, .jpg, .png)\n\nUse an image file to set an app icon by placing a favicon, icon, or apple-icon image file within your /app directory. The favicon image can only be located in the top level of app/.\n\nNext.js will evaluate the file and automatically add the appropriate tags to your app's <head> element.\n\nFile convention\tSupported file types\tValid locations\nfavicon\t.ico\tapp/\nicon\t.ico, .jpg, .jpeg, .png, .svg\tapp/**/*\napple-icon\t.jpg, .jpeg, .png\tapp/**/*\nfavicon\n\nAdd a favicon.ico image file to the root /app route segment.\n\n<head> output\n<link rel=\"icon\" href=\"/favicon.ico\" sizes=\"any\" />\nicon\n\nAdd an icon.(ico|jpg|jpeg|png|svg) image file.\n\n<head> output\n<link\n  rel=\"icon\"\n  href=\"/icon?<generated>\"\n  type=\"image/<generated>\"\n  sizes=\"<generated>\"\n/>\napple-icon\n\nAdd an apple-icon.(jpg|jpeg|png) image file.\n\n<head> output\n<link\n  rel=\"apple-touch-icon\"\n  href=\"/apple-icon?<generated>\"\n  type=\"image/<generated>\"\n  sizes=\"<generated>\"\n/>\n\nGood to know:\n\nYou can set multiple icons by adding a number suffix to the file name. For example, icon1.png, icon2.png, etc. Numbered files will sort lexically.\nFavicons can only be set in the root /app segment. If you need more granularity, you can use icon.\nThe appropriate <link> tags and attributes such as rel, href, type, and sizes are determined by the icon type and metadata of the evaluated file.\nFor example, a 32 by 32px .png file will have type=\"image/png\" and sizes=\"32x32\" attributes.\nsizes=\"any\" is added to icons when the extension is .svg or the image size of the file is not determined. More details in this favicon handbook\n.\nGenerate icons using code (.js, .ts, .tsx)\n\nIn addition to using literal image files, you can programmatically generate icons using code.\n\nGenerate an app icon by creating an icon or apple-icon route that default exports a function.\n\nFile convention\tSupported file types\nicon\t.js, .ts, .tsx\napple-icon\t.js, .ts, .tsx\n\nThe easiest way to generate an icon is to use the ImageResponse API from next/og.\n\napp/icon.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { ImageResponse } from 'next/og'\n \n// Image metadata\nexport const size = {\n  width: 32,\n  height: 32,\n}\nexport const contentType = 'image/png'\n \n// Image generation\nexport default function Icon() {\n  return new ImageResponse(\n    (\n      // ImageResponse JSX element\n      <div\n        style={{\n          fontSize: 24,\n          background: 'black',\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          color: 'white',\n        }}\n      >\n        A\n      </div>\n    ),\n    // ImageResponse options\n    {\n      // For convenience, we can re-use the exported icons size metadata\n      // config to also set the ImageResponse's width and height.\n      ...size,\n    }\n  )\n}\n<head> output\n<link rel=\"icon\" href=\"/icon?<generated>\" type=\"image/png\" sizes=\"32x32\" />\n\nGood to know:\n\nBy default, generated icons are statically optimized (generated at build time and cached) unless they use Dynamic APIs or uncached data.\nYou can generate multiple icons in the same file using generateImageMetadata.\nYou cannot generate a favicon icon. Use icon or a favicon.ico file instead.\nApp icons are special Route Handlers that are cached by default unless they use a Dynamic API or dynamic config option.\nProps\n\nThe default export function receives the following props:\n\nparams (optional)\n\nA promise that resolves to an object containing the dynamic route parameters object from the root segment down to the segment icon or apple-icon is colocated in.\n\nGood to know: If you use generateImageMetadata, the function will also receive an id prop that is a promise resolving to the id value from one of the items returned by generateImageMetadata.\n\napp/shop/[slug]/icon.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Icon({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  // ...\n}\nRoute\tURL\tparams\napp/shop/icon.js\t/shop\tundefined\napp/shop/[slug]/icon.js\t/shop/1\tPromise<{ slug: '1' }>\napp/shop/[tag]/[item]/icon.js\t/shop/1/2\tPromise<{ tag: '1', item: '2' }>\nReturns\n\nThe default export function should return a Blob | ArrayBuffer | TypedArray | DataView | ReadableStream | Response.\n\nGood to know: ImageResponse satisfies this return type.\n\nConfig exports\n\nYou can optionally configure the icon's metadata by exporting size and contentType variables from the icon or apple-icon route.\n\nOption\tType\nsize\t{ width: number; height: number }\ncontentType\tstring - image MIME type\nsize\nicon.tsx | apple-icon.tsx\nTypeScript\nJavaScript\nTypeScript\nexport const size = { width: 32, height: 32 }\n \nexport default function Icon() {}\n<head> output\n<link rel=\"icon\" sizes=\"32x32\" />\ncontentType\nicon.tsx | apple-icon.tsx\nTypeScript\nJavaScript\nTypeScript\nexport const contentType = 'image/png'\n \nexport default function Icon() {}\n<head> output\n<link rel=\"icon\" type=\"image/png\" />\nRoute Segment Config\n\nicon and apple-icon are specialized Route Handlers that can use the same route segment configuration options as Pages and Layouts.\n\nVersion History\nVersion\tChanges\nv16.0.0\tparams is now a promise that resolves to an object\nv13.3.0\tfavicon icon and apple-icon introduced\nPrevious\nMetadata Files\nNext\nmanifest.json\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Metadata Files: manifest.json | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/manifest",
    "html": "File-system conventions\nMetadata Files\nmanifest.json\nCopy page\nmanifest.json\n\nAdd or generate a manifest.(json|webmanifest) file that matches the Web Manifest Specification\n in the root of app directory to provide information about your web application for the browser.\n\nStatic Manifest file\napp/manifest.json | app/manifest.webmanifest\n{\n  \"name\": \"My Next.js Application\",\n  \"short_name\": \"Next.js App\",\n  \"description\": \"An application built with Next.js\",\n  \"start_url\": \"/\"\n  // ...\n}\nGenerate a Manifest file\n\nAdd a manifest.js or manifest.ts file that returns a Manifest object.\n\nGood to know: manifest.js is special Route Handlers that is cached by default unless it uses a Dynamic API or dynamic config option.\n\napp/manifest.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { MetadataRoute } from 'next'\n \nexport default function manifest(): MetadataRoute.Manifest {\n  return {\n    name: 'Next.js App',\n    short_name: 'Next.js App',\n    description: 'Next.js App',\n    start_url: '/',\n    display: 'standalone',\n    background_color: '#fff',\n    theme_color: '#fff',\n    icons: [\n      {\n        src: '/favicon.ico',\n        sizes: 'any',\n        type: 'image/x-icon',\n      },\n    ],\n  }\n}\nManifest Object\n\nThe manifest object contains an extensive list of options that may be updated due to new web standards. For information on all the current options, refer to the MetadataRoute.Manifest type in your code editor if using TypeScript or see the MDN\n docs.\n\nPrevious\nfavicon, icon, and apple-icon\nNext\nopengraph-image and twitter-image\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Metadata Files: robots.txt | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/robots",
    "html": "File-system conventions\nMetadata Files\nrobots.txt\nCopy page\nrobots.txt\n\nAdd or generate a robots.txt file that matches the Robots Exclusion Standard\n in the root of app directory to tell search engine crawlers which URLs they can access on your site.\n\nStatic robots.txt\napp/robots.txt\nUser-Agent: *\nAllow: /\nDisallow: /private/\nSitemap: https://acme.com/sitemap.xml\nGenerate a Robots file\n\nAdd a robots.js or robots.ts file that returns a Robots object.\n\nGood to know: robots.js is a special Route Handlers that is cached by default unless it uses a Dynamic API or dynamic config option.\n\napp/robots.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { MetadataRoute } from 'next'\n \nexport default function robots(): MetadataRoute.Robots {\n  return {\n    rules: {\n      userAgent: '*',\n      allow: '/',\n      disallow: '/private/',\n    },\n    sitemap: 'https://acme.com/sitemap.xml',\n  }\n}\n\nOutput:\n\nUser-Agent: *\nAllow: /\nDisallow: /private/\nSitemap: https://acme.com/sitemap.xml\nCustomizing specific user agents\n\nYou can customise how individual search engine bots crawl your site by passing an array of user agents to the rules property. For example:\n\napp/robots.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { MetadataRoute } from 'next'\n \nexport default function robots(): MetadataRoute.Robots {\n  return {\n    rules: [\n      {\n        userAgent: 'Googlebot',\n        allow: ['/'],\n        disallow: '/private/',\n      },\n      {\n        userAgent: ['Applebot', 'Bingbot'],\n        disallow: ['/'],\n      },\n    ],\n    sitemap: 'https://acme.com/sitemap.xml',\n  }\n}\n\nOutput:\n\nUser-Agent: Googlebot\nAllow: /\nDisallow: /private/\nUser-Agent: Applebot\nDisallow: /\nUser-Agent: Bingbot\nDisallow: /\nSitemap: https://acme.com/sitemap.xml\nRobots object\ntype Robots = {\n  rules:\n    | {\n        userAgent?: string | string[]\n        allow?: string | string[]\n        disallow?: string | string[]\n        crawlDelay?: number\n      }\n    | Array<{\n        userAgent: string | string[]\n        allow?: string | string[]\n        disallow?: string | string[]\n        crawlDelay?: number\n      }>\n  sitemap?: string | string[]\n  host?: string\n}\nVersion History\nVersion\tChanges\nv13.3.0\trobots introduced.\nPrevious\nopengraph-image and twitter-image\nNext\nsitemap.xml\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Metadata Files: opengraph-image and twitter-image | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image",
    "html": "File-system conventions\nMetadata Files\nopengraph-image and twitter-image\nCopy page\nopengraph-image and twitter-image\n\nThe opengraph-image and twitter-image file conventions allow you to set Open Graph and Twitter images for a route segment.\n\nThey are useful for setting the images that appear on social networks and messaging apps when a user shares a link to your site.\n\nThere are two ways to set Open Graph and Twitter images:\n\nUsing image files (.jpg, .png, .gif)\nUsing code to generate images (.js, .ts, .tsx)\nImage files (.jpg, .png, .gif)\n\nUse an image file to set a route segment's shared image by placing an opengraph-image or twitter-image image file in the segment.\n\nNext.js will evaluate the file and automatically add the appropriate tags to your app's <head> element.\n\nFile convention\tSupported file types\nopengraph-image\t.jpg, .jpeg, .png, .gif\ntwitter-image\t.jpg, .jpeg, .png, .gif\nopengraph-image.alt\t.txt\ntwitter-image.alt\t.txt\n\nGood to know:\n\nThe twitter-image file size must not exceed 5MB\n, and the opengraph-image file size must not exceed 8MB\n. If the image file size exceeds these limits, the build will fail.\n\nopengraph-image\n\nAdd an opengraph-image.(jpg|jpeg|png|gif) image file to any route segment.\n\n<head> output\n<meta property=\"og:image\" content=\"<generated>\" />\n<meta property=\"og:image:type\" content=\"<generated>\" />\n<meta property=\"og:image:width\" content=\"<generated>\" />\n<meta property=\"og:image:height\" content=\"<generated>\" />\ntwitter-image\n\nAdd a twitter-image.(jpg|jpeg|png|gif) image file to any route segment.\n\n<head> output\n<meta name=\"twitter:image\" content=\"<generated>\" />\n<meta name=\"twitter:image:type\" content=\"<generated>\" />\n<meta name=\"twitter:image:width\" content=\"<generated>\" />\n<meta name=\"twitter:image:height\" content=\"<generated>\" />\nopengraph-image.alt.txt\n\nAdd an accompanying opengraph-image.alt.txt file in the same route segment as the opengraph-image.(jpg|jpeg|png|gif) image it's alt text.\n\nopengraph-image.alt.txt\nAbout Acme\n<head> output\n<meta property=\"og:image:alt\" content=\"About Acme\" />\ntwitter-image.alt.txt\n\nAdd an accompanying twitter-image.alt.txt file in the same route segment as the twitter-image.(jpg|jpeg|png|gif) image it's alt text.\n\ntwitter-image.alt.txt\nAbout Acme\n<head> output\n<meta property=\"twitter:image:alt\" content=\"About Acme\" />\nGenerate images using code (.js, .ts, .tsx)\n\nIn addition to using literal image files, you can programmatically generate images using code.\n\nGenerate a route segment's shared image by creating an opengraph-image or twitter-image route that default exports a function.\n\nFile convention\tSupported file types\nopengraph-image\t.js, .ts, .tsx\ntwitter-image\t.js, .ts, .tsx\n\nGood to know:\n\nBy default, generated images are statically optimized (generated at build time and cached) unless they use Dynamic APIs or uncached data.\nYou can generate multiple Images in the same file using generateImageMetadata.\nopengraph-image.js and twitter-image.js are special Route Handlers that is cached by default unless it uses a Dynamic API or dynamic config option.\n\nThe easiest way to generate an image is to use the ImageResponse API from next/og.\n\napp/about/opengraph-image.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { ImageResponse } from 'next/og'\nimport { readFile } from 'node:fs/promises'\nimport { join } from 'node:path'\n \n// Image metadata\nexport const alt = 'About Acme'\nexport const size = {\n  width: 1200,\n  height: 630,\n}\n \nexport const contentType = 'image/png'\n \n// Image generation\nexport default async function Image() {\n  // Font loading, process.cwd() is Next.js project directory\n  const interSemiBold = await readFile(\n    join(process.cwd(), 'assets/Inter-SemiBold.ttf')\n  )\n \n  return new ImageResponse(\n    (\n      // ImageResponse JSX element\n      <div\n        style={{\n          fontSize: 128,\n          background: 'white',\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n        }}\n      >\n        About Acme\n      </div>\n    ),\n    // ImageResponse options\n    {\n      // For convenience, we can re-use the exported opengraph-image\n      // size config to also set the ImageResponse's width and height.\n      ...size,\n      fonts: [\n        {\n          name: 'Inter',\n          data: interSemiBold,\n          style: 'normal',\n          weight: 400,\n        },\n      ],\n    }\n  )\n}\n<head> output\n<meta property=\"og:image\" content=\"<generated>\" />\n<meta property=\"og:image:alt\" content=\"About Acme\" />\n<meta property=\"og:image:type\" content=\"image/png\" />\n<meta property=\"og:image:width\" content=\"1200\" />\n<meta property=\"og:image:height\" content=\"630\" />\nProps\n\nThe default export function receives the following props:\n\nparams (optional)\n\nA promise that resolves to an object containing the dynamic route parameters object from the root segment down to the segment opengraph-image or twitter-image is colocated in.\n\nGood to know: If you use generateImageMetadata, the function will also receive an id prop that is a promise resolving to the id value from one of the items returned by generateImageMetadata.\n\napp/shop/[slug]/opengraph-image.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Image({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  // ...\n}\nRoute\tURL\tparams\napp/shop/opengraph-image.js\t/shop\tundefined\napp/shop/[slug]/opengraph-image.js\t/shop/1\tPromise<{ slug: '1' }>\napp/shop/[tag]/[item]/opengraph-image.js\t/shop/1/2\tPromise<{ tag: '1', item: '2' }>\nReturns\n\nThe default export function should return a Blob | ArrayBuffer | TypedArray | DataView | ReadableStream | Response.\n\nGood to know: ImageResponse satisfies this return type.\n\nConfig exports\n\nYou can optionally configure the image's metadata by exporting alt, size, and contentType variables from opengraph-image or twitter-image route.\n\nOption\tType\nalt\tstring\nsize\t{ width: number; height: number }\ncontentType\tstring - image MIME type\nalt\nopengraph-image.tsx | twitter-image.tsx\nTypeScript\nJavaScript\nTypeScript\nexport const alt = 'My images alt text'\n \nexport default function Image() {}\n<head> output\n<meta property=\"og:image:alt\" content=\"My images alt text\" />\nsize\nopengraph-image.tsx | twitter-image.tsx\nTypeScript\nJavaScript\nTypeScript\nexport const size = { width: 1200, height: 630 }\n \nexport default function Image() {}\n<head> output\n<meta property=\"og:image:width\" content=\"1200\" />\n<meta property=\"og:image:height\" content=\"630\" />\ncontentType\nopengraph-image.tsx | twitter-image.tsx\nTypeScript\nJavaScript\nTypeScript\nexport const contentType = 'image/png'\n \nexport default function Image() {}\n<head> output\n<meta property=\"og:image:type\" content=\"image/png\" />\nRoute Segment Config\n\nopengraph-image and twitter-image are specialized Route Handlers that can use the same route segment configuration options as Pages and Layouts.\n\nExamples\nUsing external data\n\nThis example uses the params object and external data to generate the image.\n\nGood to know: By default, this generated image will be statically optimized. You can configure the individual fetch options or route segments options to change this behavior.\n\napp/posts/[slug]/opengraph-image.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { ImageResponse } from 'next/og'\n \nexport const alt = 'About Acme'\nexport const size = {\n  width: 1200,\n  height: 630,\n}\nexport const contentType = 'image/png'\n \nexport default async function Image({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  const post = await fetch(`https://.../posts/${slug}`).then((res) =>\n    res.json()\n  )\n \n  return new ImageResponse(\n    (\n      <div\n        style={{\n          fontSize: 48,\n          background: 'white',\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n        }}\n      >\n        {post.title}\n      </div>\n    ),\n    {\n      ...size,\n    }\n  )\n}\nUsing Node.js runtime with local assets\n\nThese examples use the Node.js runtime to fetch a local image from the file system and pass it to the <img> src attribute, either as a base64 string or an ArrayBuffer. Place the local asset relative to the project root, not the example source file.\n\napp/opengraph-image.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { ImageResponse } from 'next/og'\nimport { join } from 'node:path'\nimport { readFile } from 'node:fs/promises'\n \nexport default async function Image() {\n  const logoData = await readFile(join(process.cwd(), 'logo.png'), 'base64')\n  const logoSrc = `data:image/png;base64,${logoData}`\n \n  return new ImageResponse(\n    (\n      <div\n        style={{\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n        }}\n      >\n        <img src={logoSrc} height=\"100\" />\n      </div>\n    )\n  )\n}\n\nPassing an ArrayBuffer to the src attribute of an <img> element is not part of the HTML spec. The rendering engine used by next/og supports it, but because TypeScript definitions follow the spec, you need a @ts-expect-error directive or similar to use this feature\n.\n\napp/opengraph-image.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { ImageResponse } from 'next/og'\nimport { join } from 'node:path'\nimport { readFile } from 'node:fs/promises'\n \nexport default async function Image() {\n  const logoData = await readFile(join(process.cwd(), 'logo.png'))\n  const logoSrc = Uint8Array.from(logoData).buffer\n \n  return new ImageResponse(\n    (\n      <div\n        style={{\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n        }}\n      >\n        {/* @ts-expect-error Satori accepts ArrayBuffer/typed arrays for <img src> at runtime */}\n        <img src={logoSrc} height=\"100\" />\n      </div>\n    )\n  )\n}\nVersion History\nVersion\tChanges\nv16.0.0\tparams is now a promise that resolves to an object\nv13.3.0\topengraph-image and twitter-image introduced.\nPrevious\nmanifest.json\nNext\nrobots.txt\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "API Reference: Functions | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions",
    "html": "App Router\nAPI Reference\nFunctions\nCopy page\nFunctions\nafter\nAPI Reference for the after function.\ncacheLife\nLearn how to use the cacheLife function to set the cache expiration time for a cached function or component.\ncacheTag\nLearn how to use the cacheTag function to manage cache invalidation in your Next.js application.\nconnection\nAPI Reference for the connection function.\ncookies\nAPI Reference for the cookies function.\ndraftMode\nAPI Reference for the draftMode function.\nfetch\nAPI reference for the extended fetch function.\nforbidden\nAPI Reference for the forbidden function.\ngenerateImageMetadata\nLearn how to generate multiple images in a single Metadata API special file.\ngenerateMetadata\nLearn how to add Metadata to your Next.js application for improved search engine optimization (SEO) and web shareability.\ngenerateSitemaps\nLearn how to use the generateSiteMaps function to create multiple sitemaps for your application.\ngenerateStaticParams\nAPI reference for the generateStaticParams function.\ngenerateViewport\nAPI Reference for the generateViewport function.\nheaders\nAPI reference for the headers function.\nImageResponse\nAPI Reference for the ImageResponse constructor.\nNextRequest\nAPI Reference for NextRequest.\nNextResponse\nAPI Reference for NextResponse.\nnotFound\nAPI Reference for the notFound function.\npermanentRedirect\nAPI Reference for the permanentRedirect function.\nredirect\nAPI Reference for the redirect function.\nrefresh\nAPI Reference for the refresh function.\nrevalidatePath\nAPI Reference for the revalidatePath function.\nrevalidateTag\nAPI Reference for the revalidateTag function.\nunauthorized\nAPI Reference for the unauthorized function.\nunstable_cache\nAPI Reference for the unstable_cache function.\nunstable_noStore\nAPI Reference for the unstable_noStore function.\nunstable_rethrow\nAPI Reference for the unstable_rethrow function.\nupdateTag\nAPI Reference for the updateTag function.\nuseLinkStatus\nAPI Reference for the useLinkStatus hook.\nuseParams\nAPI Reference for the useParams hook.\nusePathname\nAPI Reference for the usePathname hook.\nuseReportWebVitals\nAPI Reference for the useReportWebVitals function.\nuseRouter\nAPI reference for the useRouter hook.\nuseSearchParams\nAPI Reference for the useSearchParams hook.\nuseSelectedLayoutSegment\nAPI Reference for the useSelectedLayoutSegment hook.\nuseSelectedLayoutSegments\nAPI Reference for the useSelectedLayoutSegments hook.\nuserAgent\nThe userAgent helper extends the Web Request API with additional properties and methods to interact with the user agent object from the request.\nPrevious\nsitemap.xml\nNext\nafter\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Metadata Files: sitemap.xml | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap",
    "html": "File-system conventions\nMetadata Files\nsitemap.xml\nCopy page\nsitemap.xml\n\nsitemap.(xml|js|ts) is a special file that matches the Sitemaps XML format\n to help search engine crawlers index your site more efficiently.\n\nSitemap files (.xml)\n\nFor smaller applications, you can create a sitemap.xml file and place it in the root of your app directory.\n\napp/sitemap.xml\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <url>\n    <loc>https://acme.com</loc>\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\n    <changefreq>yearly</changefreq>\n    <priority>1</priority>\n  </url>\n  <url>\n    <loc>https://acme.com/about</loc>\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\n    <changefreq>monthly</changefreq>\n    <priority>0.8</priority>\n  </url>\n  <url>\n    <loc>https://acme.com/blog</loc>\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\n    <changefreq>weekly</changefreq>\n    <priority>0.5</priority>\n  </url>\n</urlset>\nGenerating a sitemap using code (.js, .ts)\n\nYou can use the sitemap.(js|ts) file convention to programmatically generate a sitemap by exporting a default function that returns an array of URLs. If using TypeScript, a Sitemap type is available.\n\nGood to know: sitemap.js is a special Route Handler that is cached by default unless it uses a Dynamic API or dynamic config option.\n\napp/sitemap.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { MetadataRoute } from 'next'\n \nexport default function sitemap(): MetadataRoute.Sitemap {\n  return [\n    {\n      url: 'https://acme.com',\n      lastModified: new Date(),\n      changeFrequency: 'yearly',\n      priority: 1,\n    },\n    {\n      url: 'https://acme.com/about',\n      lastModified: new Date(),\n      changeFrequency: 'monthly',\n      priority: 0.8,\n    },\n    {\n      url: 'https://acme.com/blog',\n      lastModified: new Date(),\n      changeFrequency: 'weekly',\n      priority: 0.5,\n    },\n  ]\n}\n\nOutput:\n\nacme.com/sitemap.xml\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <url>\n    <loc>https://acme.com</loc>\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\n    <changefreq>yearly</changefreq>\n    <priority>1</priority>\n  </url>\n  <url>\n    <loc>https://acme.com/about</loc>\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\n    <changefreq>monthly</changefreq>\n    <priority>0.8</priority>\n  </url>\n  <url>\n    <loc>https://acme.com/blog</loc>\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\n    <changefreq>weekly</changefreq>\n    <priority>0.5</priority>\n  </url>\n</urlset>\nImage Sitemaps\n\nYou can use images property to create image sitemaps. Learn more details in the Google Developer Docs\n.\n\napp/sitemap.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { MetadataRoute } from 'next'\n \nexport default function sitemap(): MetadataRoute.Sitemap {\n  return [\n    {\n      url: 'https://example.com',\n      lastModified: '2021-01-01',\n      changeFrequency: 'weekly',\n      priority: 0.5,\n      images: ['https://example.com/image.jpg'],\n    },\n  ]\n}\n\nOutput:\n\nacme.com/sitemap.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset\n  xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n  xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\"\n>\n  <url>\n    <loc>https://example.com</loc>\n    <image:image>\n      <image:loc>https://example.com/image.jpg</image:loc>\n    </image:image>\n    <lastmod>2021-01-01</lastmod>\n    <changefreq>weekly</changefreq>\n    <priority>0.5</priority>\n  </url>\n</urlset>\nVideo Sitemaps\n\nYou can use videos property to create video sitemaps. Learn more details in the Google Developer Docs\n.\n\napp/sitemap.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { MetadataRoute } from 'next'\n \nexport default function sitemap(): MetadataRoute.Sitemap {\n  return [\n    {\n      url: 'https://example.com',\n      lastModified: '2021-01-01',\n      changeFrequency: 'weekly',\n      priority: 0.5,\n      videos: [\n        {\n          title: 'example',\n          thumbnail_loc: 'https://example.com/image.jpg',\n          description: 'this is the description',\n        },\n      ],\n    },\n  ]\n}\n\nOutput:\n\nacme.com/sitemap.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset\n  xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n  xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\"\n>\n  <url>\n    <loc>https://example.com</loc>\n    <video:video>\n      <video:title>example</video:title>\n      <video:thumbnail_loc>https://example.com/image.jpg</video:thumbnail_loc>\n      <video:description>this is the description</video:description>\n    </video:video>\n    <lastmod>2021-01-01</lastmod>\n    <changefreq>weekly</changefreq>\n    <priority>0.5</priority>\n  </url>\n</urlset>\nGenerate a localized Sitemap\napp/sitemap.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { MetadataRoute } from 'next'\n \nexport default function sitemap(): MetadataRoute.Sitemap {\n  return [\n    {\n      url: 'https://acme.com',\n      lastModified: new Date(),\n      alternates: {\n        languages: {\n          es: 'https://acme.com/es',\n          de: 'https://acme.com/de',\n        },\n      },\n    },\n    {\n      url: 'https://acme.com/about',\n      lastModified: new Date(),\n      alternates: {\n        languages: {\n          es: 'https://acme.com/es/about',\n          de: 'https://acme.com/de/about',\n        },\n      },\n    },\n    {\n      url: 'https://acme.com/blog',\n      lastModified: new Date(),\n      alternates: {\n        languages: {\n          es: 'https://acme.com/es/blog',\n          de: 'https://acme.com/de/blog',\n        },\n      },\n    },\n  ]\n}\n\nOutput:\n\nacme.com/sitemap.xml\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\n  <url>\n    <loc>https://acme.com</loc>\n    <xhtml:link\n      rel=\"alternate\"\n      hreflang=\"es\"\n      href=\"https://acme.com/es\"/>\n    <xhtml:link\n      rel=\"alternate\"\n      hreflang=\"de\"\n      href=\"https://acme.com/de\"/>\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\n  </url>\n  <url>\n    <loc>https://acme.com/about</loc>\n    <xhtml:link\n      rel=\"alternate\"\n      hreflang=\"es\"\n      href=\"https://acme.com/es/about\"/>\n    <xhtml:link\n      rel=\"alternate\"\n      hreflang=\"de\"\n      href=\"https://acme.com/de/about\"/>\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\n  </url>\n  <url>\n    <loc>https://acme.com/blog</loc>\n    <xhtml:link\n      rel=\"alternate\"\n      hreflang=\"es\"\n      href=\"https://acme.com/es/blog\"/>\n    <xhtml:link\n      rel=\"alternate\"\n      hreflang=\"de\"\n      href=\"https://acme.com/de/blog\"/>\n    <lastmod>2023-04-06T15:02:24.021Z</lastmod>\n  </url>\n</urlset>\nGenerating multiple sitemaps\n\nWhile a single sitemap will work for most applications. For large web applications, you may need to split a sitemap into multiple files.\n\nThere are two ways you can create multiple sitemaps:\n\nBy nesting sitemap.(xml|js|ts) inside multiple route segments e.g. app/sitemap.xml and app/products/sitemap.xml.\nBy using the generateSitemaps function.\n\nFor example, to split a sitemap using generateSitemaps, return an array of objects with the sitemap id. Then, use the id to generate the unique sitemaps.\n\napp/product/sitemap.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { MetadataRoute } from 'next'\nimport { BASE_URL } from '@/app/lib/constants'\n \nexport async function generateSitemaps() {\n  // Fetch the total number of products and calculate the number of sitemaps needed\n  return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]\n}\n \nexport default async function sitemap({\n  id,\n}: {\n  id: number\n}): Promise<MetadataRoute.Sitemap> {\n  // Google's limit is 50,000 URLs per sitemap\n  const start = id * 50000\n  const end = start + 50000\n  const products = await getProducts(\n    `SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`\n  )\n  return products.map((product) => ({\n    url: `${BASE_URL}/product/${product.id}`,\n    lastModified: product.date,\n  }))\n}\n\nYour generated sitemaps will be available at /.../sitemap/[id]. For example, /product/sitemap/1.xml.\n\nSee the generateSitemaps API reference for more information.\n\nReturns\n\nThe default function exported from sitemap.(xml|ts|js) should return an array of objects with the following properties:\n\ntype Sitemap = Array<{\n  url: string\n  lastModified?: string | Date\n  changeFrequency?:\n    | 'always'\n    | 'hourly'\n    | 'daily'\n    | 'weekly'\n    | 'monthly'\n    | 'yearly'\n    | 'never'\n  priority?: number\n  alternates?: {\n    languages?: Languages<string>\n  }\n}>\nVersion History\nVersion\tChanges\nv14.2.0\tAdd localizations support.\nv13.4.14\tAdd changeFrequency and priority attributes to sitemaps.\nv13.3.0\tsitemap introduced.\nNext Steps\nLearn how to use the generateSitemaps function.\ngenerateSitemaps\nLearn how to use the generateSiteMaps function to create multiple sitemaps for your application.\nPrevious\nrobots.txt\nNext\nFunctions\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: after | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/after",
    "html": "API Reference\nFunctions\nafter\nCopy page\nafter\n\nafter allows you to schedule work to be executed after a response (or prerender) is finished. This is useful for tasks and other side effects that should not block the response, such as logging and analytics.\n\nIt can be used in Server Components (including generateMetadata), Server Actions, Route Handlers, and Proxy.\n\nThe function accepts a callback that will be executed after the response (or prerender) is finished:\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { after } from 'next/server'\n// Custom logging function\nimport { log } from '@/app/utils'\n \nexport default function Layout({ children }: { children: React.ReactNode }) {\n  after(() => {\n    // Execute after the layout is rendered and sent to the user\n    log()\n  })\n  return <>{children}</>\n}\n\nGood to know: after is not a Dynamic API and calling it does not cause a route to become dynamic. If it's used within a static page, the callback will execute at build time, or whenever a page is revalidated.\n\nReference\nParameters\nA callback function which will be executed after the response (or prerender) is finished.\nDuration\n\nafter will run for the platform's default or configured max duration of your route. If your platform supports it, you can configure the timeout limit using the maxDuration route segment config.\n\nGood to know\nafter will be executed even if the response didn't complete successfully. Including when an error is thrown or when notFound or redirect is called.\nYou can use React cache to deduplicate functions called inside after.\nafter can be nested inside other after calls, for example, you can create utility functions that wrap after calls to add additional functionality.\nExamples\nWith request APIs\n\nYou can use request APIs such as cookies and headers inside after in Server Actions and Route Handlers. This is useful for logging activity after a mutation. For example:\n\napp/api/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { after } from 'next/server'\nimport { cookies, headers } from 'next/headers'\nimport { logUserAction } from '@/app/utils'\n \nexport async function POST(request: Request) {\n  // Perform mutation\n  // ...\n \n  // Log user activity for analytics\n  after(async () => {\n    const userAgent = (await headers().get('user-agent')) || 'unknown'\n    const sessionCookie =\n      (await cookies().get('session-id'))?.value || 'anonymous'\n \n    logUserAction({ sessionCookie, userAgent })\n  })\n \n  return new Response(JSON.stringify({ status: 'success' }), {\n    status: 200,\n    headers: { 'Content-Type': 'application/json' },\n  })\n}\n\nHowever, you cannot use these request APIs inside after in Server Components. This is because Next.js needs to know which part of the tree access the request APIs to support Cache Components, but after runs after React's rendering lifecycle.\n\nPlatform Support\nDeployment Option\tSupported\nNode.js server\tYes\nDocker container\tYes\nStatic export\tNo\nAdapters\tPlatform-specific\n\nLearn how to configure after when self-hosting Next.js.\n\nReference: supporting after for serverless platforms\nVersion History\nVersion History\tDescription\nv15.1.0\tafter became stable.\nv15.0.0-rc\tunstable_after introduced.\nPrevious\nFunctions\nNext\ncacheLife\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: cacheLife | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/cacheLife",
    "html": "API Reference\nFunctions\ncacheLife\nCopy page\ncacheLife\n\nThe cacheLife function is used to set the cache lifetime of a function or component. It should be used alongside the use cache directive, and within the scope of the function or component.\n\nUsage\n\nTo use cacheLife, enable the cacheComponents flag in your next.config.js file:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  cacheComponents: true,\n}\n \nexport default nextConfig\n\nThen, import and invoke the cacheLife function within the scope of the function or component:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\n'use cache'\nimport { cacheLife } from 'next/cache'\n \nexport default async function Page() {\n  cacheLife('hours')\n  return <div>Page</div>\n}\nReference\nDefault cache profiles\n\nNext.js provides a set of named cache profiles modeled on various timescales. If you don't specify a cache profile in the cacheLife function alongside the use cache directive, Next.js will automatically apply the default cache profile.\n\nHowever, we recommend always adding a cache profile when using the use cache directive to explicitly define caching behavior.\n\nProfile\tstale\trevalidate\texpire\tDescription\ndefault\t5 minutes\t15 minutes\t1 year\tDefault profile, suitable for content that doesn't need frequent updates\nseconds\t30 seconds\t1 second\t1 minute\tFor rapidly changing content requiring near real-time updates\nminutes\t5 minutes\t1 minute\t1 hour\tFor content that updates frequently within an hour\nhours\t5 minutes\t1 hour\t1 day\tFor content that updates daily but can be slightly stale\ndays\t5 minutes\t1 day\t1 week\tFor content that updates weekly but can be a day old\nweeks\t5 minutes\t1 week\t30 days\tFor content that updates monthly but can be a week old\nmax\t5 minutes\t30 days\t1 year\tFor very stable content that rarely needs updating\n\nThe string values used to reference cache profiles don't carry inherent meaning; instead they serve as semantic labels. This allows you to better understand and manage your cached content within your codebase.\n\nGood to know: Updating the staleTimes and expireTime config options also updates the stale and expire properties of the default cache profile.\n\nCustom cache profiles\n\nYou can configure custom cache profiles by adding them to the cacheLife option in your next.config.ts file.\n\nCache profiles are objects that contain the following properties:\n\nProperty\tValue\tDescription\tRequirement\nstale\tnumber\tDuration the client should cache a value without checking the server.\tOptional\nrevalidate\tnumber\tFrequency at which the cache should refresh on the server; stale values may be served while revalidating.\tOptional\nexpire\tnumber\tMaximum duration for which a value can remain stale before switching to dynamic fetching; must be longer than revalidate.\tOptional - Must be longer than revalidate\n\nThe \"stale\" property differs from the staleTimes setting in that it specifically controls client-side router caching. While staleTimes is a global setting that affects all instances of both dynamic and static data, the cacheLife configuration allows you to define \"stale\" times on a per-function or per-route basis.\n\nstale time in the client router cache\n\nThe \"stale\" property does not set the Cache-control: max-age header. Instead, it controls the client-side router cache. The server sends this value to the client via the x-nextjs-stale-time response header (in seconds), which the client router uses to determine how long to cache the route before needing to revalidate.\n\nThe client enforces a minimum stale time of 30 seconds: This ensures that prefetched data remains usable long enough for users to click on links after they've been prefetched. Without this minimum, very short stale times would cause prefetched data to expire before it could be used, making prefetching ineffective.\n\nThis minimum only applies to time-based expiration. When you call revalidateTag, revalidatePath, updateTag, or refresh from a Server Action, the entire client cache is immediately cleared, bypassing the stale time entirely.\n\nExamples\nDefining reusable cache profiles\n\nYou can create a reusable cache profile by defining them in your next.config.ts file. Choose a name that suits your use case and set values for the stale, revalidate, and expire properties. You can create as many custom cache profiles as needed. Each profile can be referenced by its name as a string value passed to the cacheLife function.\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  cacheComponents: true,\n  cacheLife: {\n    biweekly: {\n      stale: 60 * 60 * 24 * 14, // 14 days\n      revalidate: 60 * 60 * 24, // 1 day\n      expire: 60 * 60 * 24 * 14, // 14 days\n    },\n  },\n}\n \nmodule.exports = nextConfig\n\nThe example above caches for 14 days, checks for updates daily, and expires the cache after 14 days. You can then reference this profile throughout your application by its name:\n\napp/page.tsx\n'use cache'\nimport { cacheLife } from 'next/cache'\n \nexport default async function Page() {\n  cacheLife('biweekly')\n  return <div>Page</div>\n}\nOverriding the default cache profiles\n\nWhile the default cache profiles provide a useful way to think about how fresh or stale any given part of cacheable output can be, you may prefer different named profiles to better align with your applications caching strategies.\n\nYou can override the default named cache profiles by creating a new configuration with the same name as the defaults.\n\nThe example below shows how to override the default “days” cache profile:\n\nnext.config.ts\nconst nextConfig = {\n  cacheComponents: true,\n  cacheLife: {\n    days: {\n      stale: 3600, // 1 hour\n      revalidate: 900, // 15 minutes\n      expire: 86400, // 1 day\n    },\n  },\n}\n \nmodule.exports = nextConfig\nDefining cache profiles inline\n\nFor specific use cases, you can set a custom cache profile by passing an object to the cacheLife function:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\n'use cache'\nimport { cacheLife } from 'next/cache'\n \nexport default async function Page() {\n  cacheLife({\n    stale: 3600, // 1 hour\n    revalidate: 900, // 15 minutes\n    expire: 86400, // 1 day\n  })\n \n  return <div>Page</div>\n}\n\nThis inline cache profile will only be applied to the function or file it was created in. If you want to reuse the same profile throughout your application, you can add the configuration to the cacheLife property of your next.config.ts file.\n\nNested usage of use cache and cacheLife\n\nWhen defining multiple caching behaviors in the same route or component tree, if the inner caches specify their own cacheLife profile, the outer cache will respect the shortest cache duration among them. This applies only if the outer cache does not have its own explicit cacheLife profile defined.\n\nFor example, if you add the use cache directive to your page, without specifying a cache profile, the default cache profile will be applied implicitly (cacheLife(”default”)). If a component imported into the page also uses the use cache directive with its own cache profile, the outer and inner cache profiles are compared, and shortest duration set in the profiles will be applied.\n\napp/components/parent.tsx\n// Parent component\nimport { cacheLife } from 'next/cache'\nimport { ChildComponent } from './child'\n \nexport async function ParentComponent() {\n  'use cache'\n  cacheLife('days')\n \n  return (\n    <div>\n      <ChildComponent />\n    </div>\n  )\n}\n\nAnd in a separate file, we defined the Child component that was imported:\n\napp/components/child.tsx\n// Child component\nimport { cacheLife } from 'next/cache'\n \nexport async function ChildComponent() {\n  'use cache'\n  cacheLife('hours')\n  return <div>Child Content</div>\n \n  // This component's cache will respect the shorter 'hours' profile\n}\nRelated\nView related API references.\ncacheComponents\nLearn how to enable the cacheComponents flag in Next.js.\nuse cache\nLearn how to use the use cache directive to cache data in your Next.js application.\nrevalidateTag\nAPI Reference for the revalidateTag function.\ncacheTag\nLearn how to use the cacheTag function to manage cache invalidation in your Next.js application.\nPrevious\nafter\nNext\ncacheTag\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: cacheTag | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/cacheTag",
    "html": "API Reference\nFunctions\ncacheTag\nCopy page\ncacheTag\n\nThe cacheTag function allows you to tag cached data for on-demand invalidation. By associating tags with cache entries, you can selectively purge or revalidate specific cache entries without affecting other cached data.\n\nUsage\n\nTo use cacheTag, enable the cacheComponents flag in your next.config.js file:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  cacheComponents: true,\n}\n \nexport default nextConfig\n\nThe cacheTag function takes one or more string values.\n\napp/data.ts\nTypeScript\nJavaScript\nTypeScript\nimport { cacheTag } from 'next/cache'\n \nexport async function getData() {\n  'use cache'\n  cacheTag('my-data')\n  const data = await fetch('/api/data')\n  return data\n}\n\nYou can then purge the cache on-demand using revalidateTag API in another function, for example, a route handler or Server Action:\n\napp/action.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { revalidateTag } from 'next/cache'\n \nexport default async function submit() {\n  await addPost()\n  revalidateTag('my-data')\n}\nGood to know\nIdempotent Tags: Applying the same tag multiple times has no additional effect.\nMultiple Tags: You can assign multiple tags to a single cache entry by passing multiple string values to cacheTag.\ncacheTag('tag-one', 'tag-two')\nLimits: The max length for a custom tag is 256 characters and the max tag items is 128.\nExamples\nTagging components or functions\n\nTag your cached data by calling cacheTag within a cached function or component:\n\napp/components/bookings.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { cacheTag } from 'next/cache'\n \ninterface BookingsProps {\n  type: string\n}\n \nexport async function Bookings({ type = 'haircut' }: BookingsProps) {\n  'use cache'\n  cacheTag('bookings-data')\n \n  async function getBookingsData() {\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)\n    return data\n  }\n \n  return //...\n}\nCreating tags from external data\n\nYou can use the data returned from an async function to tag the cache entry.\n\napp/components/bookings.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { cacheTag } from 'next/cache'\n \ninterface BookingsProps {\n  type: string\n}\n \nexport async function Bookings({ type = 'haircut' }: BookingsProps) {\n  async function getBookingsData() {\n    'use cache'\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)\n    cacheTag('bookings-data', data.id)\n    return data\n  }\n  return //...\n}\nInvalidating tagged cache\n\nUsing revalidateTag, you can invalidate the cache for a specific tag when needed:\n\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { revalidateTag } from 'next/cache'\n \nexport async function updateBookings() {\n  await updateBookingData()\n  revalidateTag('bookings-data')\n}\nRelated\nView related API references.\ncacheComponents\nLearn how to enable the cacheComponents flag in Next.js.\nuse cache\nLearn how to use the use cache directive to cache data in your Next.js application.\nrevalidateTag\nAPI Reference for the revalidateTag function.\ncacheLife\nLearn how to use the cacheLife function to set the cache expiration time for a cached function or component.\nPrevious\ncacheLife\nNext\nconnection\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: connection | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/connection",
    "html": "API Reference\nFunctions\nconnection\nCopy page\nconnection\n\nThe connection() function allows you to indicate rendering should wait for an incoming user request before continuing.\n\nIt's useful when a component doesn't use Dynamic APIs, but you want it to be dynamically rendered at runtime and not statically rendered at build time. This usually occurs when you access external information that you intentionally want to change the result of a render, such as Math.random() or new Date().\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { connection } from 'next/server'\n \nexport default async function Page() {\n  await connection()\n  // Everything below will be excluded from prerendering\n  const rand = Math.random()\n  return <span>{rand}</span>\n}\nReference\nType\nfunction connection(): Promise<void>\nParameters\nThe function does not accept any parameters.\nReturns\nThe function returns a void Promise. It is not meant to be consumed.\nGood to know\nconnection replaces unstable_noStore to better align with the future of Next.js.\nThe function is only necessary when dynamic rendering is required and common Dynamic APIs are not used.\nVersion History\nVersion\tChanges\nv15.0.0\tconnection stabilized.\nv15.0.0-RC\tconnection introduced.\nPrevious\ncacheTag\nNext\ncookies\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: cookies | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/cookies",
    "html": "API Reference\nFunctions\ncookies\nCopy page\ncookies\n\ncookies is an async function that allows you to read the HTTP incoming request cookies in Server Components, and read/write outgoing request cookies in Server Actions or Route Handlers.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { cookies } from 'next/headers'\n \nexport default async function Page() {\n  const cookieStore = await cookies()\n  const theme = cookieStore.get('theme')\n  return '...'\n}\nReference\nMethods\n\nThe following methods are available:\n\nMethod\tReturn Type\tDescription\nget('name')\tObject\tAccepts a cookie name and returns an object with the name and value.\ngetAll()\tArray of objects\tReturns a list of all the cookies with a matching name.\nhas('name')\tBoolean\tAccepts a cookie name and returns a boolean based on if the cookie exists.\nset(name, value, options)\t-\tAccepts a cookie name, value, and options and sets the outgoing request cookie.\ndelete(name)\t-\tAccepts a cookie name and deletes the cookie.\nclear()\t-\tDeletes all cookies.\ntoString()\tString\tReturns a string representation of the cookies.\nOptions\n\nWhen setting a cookie, the following properties from the options object are supported:\n\nOption\tType\tDescription\nname\tString\tSpecifies the name of the cookie.\nvalue\tString\tSpecifies the value to be stored in the cookie.\nexpires\tDate\tDefines the exact date when the cookie will expire.\nmaxAge\tNumber\tSets the cookie’s lifespan in seconds.\ndomain\tString\tSpecifies the domain where the cookie is available.\npath\tString, default: '/'\tLimits the cookie's scope to a specific path within the domain.\nsecure\tBoolean\tEnsures the cookie is sent only over HTTPS connections for added security.\nhttpOnly\tBoolean\tRestricts the cookie to HTTP requests, preventing client-side access.\nsameSite\tBoolean, 'lax', 'strict', 'none'\tControls the cookie's cross-site request behavior.\npriority\tString (\"low\", \"medium\", \"high\")\tSpecifies the cookie's priority\npartitioned\tBoolean\tIndicates whether the cookie is partitioned\n.\n\nThe only option with a default value is path.\n\nTo learn more about these options, see the MDN docs\n.\n\nGood to know\ncookies is an asynchronous function that returns a promise. You must use async/await or React's use\n function to access cookies.\nIn version 14 and earlier, cookies was a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\ncookies is a Dynamic API whose returned values cannot be known ahead of time. Using it in a layout or page will opt a route into dynamic rendering.\nThe .delete method can only be called:\nIn a Server Action or Route Handler.\nIf it belongs to the same domain from which .set is called. For wildcard domains, the specific subdomain must be an exact match. Additionally, the code must be executed on the same protocol (HTTP or HTTPS) as the cookie you want to delete.\nHTTP does not allow setting cookies after streaming starts, so you must use .set in a Server Action or Route Handler.\nUnderstanding Cookie Behavior in Server Components\n\nWhen working with cookies in Server Components, it's important to understand that cookies are fundamentally a client-side storage mechanism:\n\nReading cookies works in Server Components because you're accessing the cookie data that the client's browser sends to the server in the HTTP request headers.\nSetting cookies cannot be done directly in a Server Component, even when using a Route Handler or Server Action. This is because cookies are actually stored by the browser, not the server.\n\nThe server can only send instructions (via Set-Cookie headers) to tell the browser to store cookies - the actual storage happens on the client side. This is why cookie operations that modify state (.set, .delete, .clear) must be performed in a Route Handler or Server Action where the response headers can be properly set.\n\nUnderstanding Cookie Behavior in Server Actions\n\nAfter you set or delete a cookie in a Server Action, Next.js re-renders the current page and its layouts on the server so the UI reflects the new cookie value. See the Caching guide.\n\nThe UI is not unmounted, but effects that depend on data coming from the server will re-run.\n\nTo refresh cached data too, call revalidatePath or revalidateTag inside the action.\n\nExamples\nGetting a cookie\n\nYou can use the (await cookies()).get('name') method to get a single cookie:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { cookies } from 'next/headers'\n \nexport default async function Page() {\n  const cookieStore = await cookies()\n  const theme = cookieStore.get('theme')\n  return '...'\n}\nGetting all cookies\n\nYou can use the (await cookies()).getAll() method to get all cookies with a matching name. If name is unspecified, it returns all the available cookies.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { cookies } from 'next/headers'\n \nexport default async function Page() {\n  const cookieStore = await cookies()\n  return cookieStore.getAll().map((cookie) => (\n    <div key={cookie.name}>\n      <p>Name: {cookie.name}</p>\n      <p>Value: {cookie.value}</p>\n    </div>\n  ))\n}\nSetting a cookie\n\nYou can use the (await cookies()).set(name, value, options) method in a Server Action or Route Handler to set a cookie. The options object is optional.\n\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { cookies } from 'next/headers'\n \nexport async function create(data) {\n  const cookieStore = await cookies()\n \n  cookieStore.set('name', 'lee')\n  // or\n  cookieStore.set('name', 'lee', { secure: true })\n  // or\n  cookieStore.set({\n    name: 'name',\n    value: 'lee',\n    httpOnly: true,\n    path: '/',\n  })\n}\nChecking if a cookie exists\n\nYou can use the (await cookies()).has(name) method to check if a cookie exists:\n\napp/page.ts\nTypeScript\nJavaScript\nTypeScript\nimport { cookies } from 'next/headers'\n \nexport default async function Page() {\n  const cookieStore = await cookies()\n  const hasCookie = cookieStore.has('theme')\n  return '...'\n}\nDeleting cookies\n\nThere are three ways you can delete a cookie.\n\nUsing the delete() method:\n\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { cookies } from 'next/headers'\n \nexport async function delete(data) {\n  (await cookies()).delete('name')\n}\n\nSetting a new cookie with the same name and an empty value:\n\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { cookies } from 'next/headers'\n \nexport async function delete(data) {\n  (await cookies()).set('name', '')\n}\n\nSetting the maxAge to 0 will immediately expire a cookie. maxAge accepts a value in seconds.\n\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { cookies } from 'next/headers'\n \nexport async function delete(data) {\n  (await cookies()).set('name', 'value', { maxAge: 0 })\n}\nVersion History\nVersion\tChanges\nv15.0.0-RC\tcookies is now an async function. A codemod is available.\nv13.0.0\tcookies introduced.\nPrevious\nconnection\nNext\ndraftMode\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: draftMode | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/draft-mode",
    "html": "API Reference\nFunctions\ndraftMode\nCopy page\ndraftMode\n\ndraftMode is an async function allows you to enable and disable Draft Mode, as well as check if Draft Mode is enabled in a Server Component.\n\napp/page.ts\nTypeScript\nJavaScript\nTypeScript\nimport { draftMode } from 'next/headers'\n \nexport default async function Page() {\n  const { isEnabled } = await draftMode()\n}\nReference\n\nThe following methods and properties are available:\n\nMethod\tDescription\nisEnabled\tA boolean value that indicates if Draft Mode is enabled.\nenable()\tEnables Draft Mode in a Route Handler by setting a cookie (__prerender_bypass).\ndisable()\tDisables Draft Mode in a Route Handler by deleting a cookie.\nGood to know\ndraftMode is an asynchronous function that returns a promise. You must use async/await or React's use\n function.\nIn version 14 and earlier, draftMode was a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\nA new bypass cookie value will be generated each time you run next build. This ensures that the bypass cookie can’t be guessed.\nTo test Draft Mode locally over HTTP, your browser will need to allow third-party cookies and local storage access.\nExamples\nEnabling Draft Mode\n\nTo enable Draft Mode, create a new Route Handler and call the enable() method:\n\napp/draft/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { draftMode } from 'next/headers'\n \nexport async function GET(request: Request) {\n  const draft = await draftMode()\n  draft.enable()\n  return new Response('Draft mode is enabled')\n}\nDisabling Draft Mode\n\nBy default, the Draft Mode session ends when the browser is closed.\n\nTo disable Draft Mode manually, call the disable() method in your Route Handler:\n\napp/draft/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { draftMode } from 'next/headers'\n \nexport async function GET(request: Request) {\n  const draft = await draftMode()\n  draft.disable()\n  return new Response('Draft mode is disabled')\n}\n\nThen, send a request to invoke the Route Handler. If calling the route using the <Link> component, you must pass prefetch={false} to prevent accidentally deleting the cookie on prefetch.\n\nChecking if Draft Mode is enabled\n\nYou can check if Draft Mode is enabled in a Server Component with the isEnabled property:\n\napp/page.ts\nTypeScript\nJavaScript\nTypeScript\nimport { draftMode } from 'next/headers'\n \nexport default async function Page() {\n  const { isEnabled } = await draftMode()\n  return (\n    <main>\n      <h1>My Blog Post</h1>\n      <p>Draft Mode is currently {isEnabled ? 'Enabled' : 'Disabled'}</p>\n    </main>\n  )\n}\nVersion History\nVersion\tChanges\nv15.0.0-RC\tdraftMode is now an async function. A codemod is available.\nv13.4.0\tdraftMode introduced.\nNext Steps\nLearn how to use Draft Mode with this step-by-step guide.\nDraft Mode\nNext.js has draft mode to toggle between static and dynamic pages. You can learn how it works with App Router here.\nPrevious\ncookies\nNext\nfetch\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: fetch | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/fetch",
    "html": "API Reference\nFunctions\nfetch\nCopy page\nfetch\n\nNext.js extends the Web fetch() API\n to allow each request on the server to set its own persistent caching and revalidation semantics.\n\nIn the browser, the cache option indicates how a fetch request will interact with the browser's HTTP cache. With this extension, cache indicates how a server-side fetch request will interact with the framework's persistent Data Cache.\n\nYou can call fetch with async and await directly within Server Components.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Page() {\n  let data = await fetch('https://api.vercel.app/blog')\n  let posts = await data.json()\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\nfetch(url, options)\n\nSince Next.js extends the Web fetch() API\n, you can use any of the native options available\n.\n\noptions.cache\n\nConfigure how the request should interact with Next.js Data Cache.\n\nfetch(`https://...`, { cache: 'force-cache' | 'no-store' })\nauto no cache (default): Next.js fetches the resource from the remote server on every request in development, but will fetch once during next build because the route will be statically prerendered. If Dynamic APIs are detected on the route, Next.js will fetch the resource on every request.\nno-store: Next.js fetches the resource from the remote server on every request, even if Dynamic APIs are not detected on the route.\nforce-cache: Next.js looks for a matching request in its Data Cache.\nIf there is a match and it is fresh, it will be returned from the cache.\nIf there is no match or a stale match, Next.js will fetch the resource from the remote server and update the cache with the downloaded resource.\noptions.next.revalidate\nfetch(`https://...`, { next: { revalidate: false | 0 | number } })\n\nSet the cache lifetime of a resource (in seconds). Data Cache.\n\nfalse - Cache the resource indefinitely. Semantically equivalent to revalidate: Infinity. The HTTP cache may evict older resources over time.\n0 - Prevent the resource from being cached.\nnumber - (in seconds) Specify the resource should have a cache lifetime of at most n seconds.\n\nGood to know:\n\nIf an individual fetch() request sets a revalidate number lower than the default revalidate of a route, the whole route revalidation interval will be decreased.\nIf two fetch requests with the same URL in the same route have different revalidate values, the lower value will be used.\nConflicting options such as { revalidate: 3600, cache: 'no-store' } are not allowed, both will be ignored, and in development mode a warning will be printed to the terminal.\noptions.next.tags\nfetch(`https://...`, { next: { tags: ['collection'] } })\n\nSet the cache tags of a resource. Data can then be revalidated on-demand using revalidateTag. The max length for a custom tag is 256 characters and the max tag items is 128.\n\nTroubleshooting\nFetch default auto no store and cache: 'no-store' not showing fresh data in development\n\nNext.js caches fetch responses in Server Components across Hot Module Replacement (HMR) in local development for faster responses and to reduce costs for billed API calls.\n\nBy default, the HMR cache applies to all fetch requests, including those with the default auto no cache and cache: 'no-store' option. This means uncached requests will not show fresh data between HMR refreshes. However, the cache will be cleared on navigation or full-page reloads.\n\nSee the serverComponentsHmrCache docs for more information.\n\nHard refresh and caching in development\n\nIn development mode, if the request includes the cache-control: no-cache header, options.cache, options.next.revalidate, and options.next.tags are ignored, and the fetch request is served from the source.\n\nBrowsers typically include cache-control: no-cache when the cache is disabled in developer tools or during a hard refresh.\n\nVersion History\nVersion\tChanges\nv13.0.0\tfetch introduced.\nPrevious\ndraftMode\nNext\nforbidden\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: generateImageMetadata | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/generate-image-metadata",
    "html": "API Reference\nFunctions\ngenerateImageMetadata\nCopy page\ngenerateImageMetadata\n\nYou can use generateImageMetadata to generate different versions of one image or return multiple images for one route segment. This is useful for when you want to avoid hard-coding metadata values, such as for icons.\n\nParameters\n\ngenerateImageMetadata function accepts the following parameters:\n\nparams (optional)\n\nAn object containing the dynamic route parameters object from the root segment down to the segment generateImageMetadata is called from.\n\nicon.tsx\nTypeScript\nJavaScript\nTypeScript\nexport function generateImageMetadata({\n  params,\n}: {\n  params: { slug: string }\n}) {\n  // ...\n}\nRoute\tURL\tparams\napp/shop/icon.js\t/shop\tundefined\napp/shop/[slug]/icon.js\t/shop/1\t{ slug: '1' }\napp/shop/[tag]/[item]/icon.js\t/shop/1/2\t{ tag: '1', item: '2' }\nReturns\n\nThe generateImageMetadata function should return an array of objects containing the image's metadata such as alt and size. In addition, each item must include an id value which will be passed as a promise to the props of the image generating function.\n\nImage Metadata Object\tType\nid\tstring (required)\nalt\tstring\nsize\t{ width: number; height: number }\ncontentType\tstring\nicon.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { ImageResponse } from 'next/og'\n \nexport function generateImageMetadata() {\n  return [\n    {\n      contentType: 'image/png',\n      size: { width: 48, height: 48 },\n      id: 'small',\n    },\n    {\n      contentType: 'image/png',\n      size: { width: 72, height: 72 },\n      id: 'medium',\n    },\n  ]\n}\n \nexport default async function Icon({ id }: { id: Promise<string | number> }) {\n  const iconId = await id\n  return new ImageResponse(\n    (\n      <div\n        style={{\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          fontSize: 88,\n          background: '#000',\n          color: '#fafafa',\n        }}\n      >\n        Icon {iconId}\n      </div>\n    )\n  )\n}\nImage generation function props\n\nWhen using generateImageMetadata, the default export image generation function receives the following props:\n\nid\n\nA promise that resolves to the id value from one of the items returned by generateImageMetadata. The id will be a string or number depending on what was returned from generateImageMetadata.\n\nicon.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Icon({ id }: { id: Promise<string | number> }) {\n  const iconId = await id\n  // Use iconId to generate the image\n}\nparams (optional)\n\nA promise that resolves to an object containing the dynamic route parameters from the root segment down to the segment the image is colocated in.\n\nicon.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Icon({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  // Use slug to generate the image\n}\nExamples\nUsing external data\n\nThis example uses the params object and external data to generate multiple Open Graph images for a route segment.\n\napp/products/[id]/opengraph-image.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { ImageResponse } from 'next/og'\nimport { getCaptionForImage, getOGImages } from '@/app/utils/images'\n \nexport async function generateImageMetadata({\n  params,\n}: {\n  params: { id: string }\n}) {\n  const images = await getOGImages(params.id)\n \n  return images.map((image, idx) => ({\n    id: idx,\n    size: { width: 1200, height: 600 },\n    alt: image.text,\n    contentType: 'image/png',\n  }))\n}\n \nexport default async function Image({\n  params,\n  id,\n}: {\n  params: Promise<{ id: string }>\n  id: Promise<number>\n}) {\n  const productId = (await params).id\n  const imageId = await id\n  const text = await getCaptionForImage(productId, imageId)\n \n  return new ImageResponse(\n    (\n      <div\n        style={\n          {\n            // ...\n          }\n        }\n      >\n        {text}\n      </div>\n    )\n  )\n}\nVersion History\nVersion\tChanges\nv16.0.0\tid passed to the Image generation function is now a promise that resolves to string or number\nv16.0.0\tparams passed to the Image generation function is now a promise that resolves to an object\nv13.3.0\tgenerateImageMetadata introduced.\nNext Steps\nView all the Metadata API options.\nMetadata Files\nAPI documentation for the metadata file conventions.\nPrevious\nforbidden\nNext\ngenerateMetadata\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: forbidden | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/forbidden",
    "html": "API Reference\nFunctions\nforbidden\nCopy page\nforbidden\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nThe forbidden function throws an error that renders a Next.js 403 error page. It's useful for handling authorization errors in your application. You can customize the UI using the forbidden.js file.\n\nTo start using forbidden, enable the experimental authInterrupts configuration option in your next.config.js file:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    authInterrupts: true,\n  },\n}\n \nexport default nextConfig\n\nforbidden can be invoked in Server Components, Server Actions, and Route Handlers.\n\napp/auth/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { verifySession } from '@/app/lib/dal'\nimport { forbidden } from 'next/navigation'\n \nexport default async function AdminPage() {\n  const session = await verifySession()\n \n  // Check if the user has the 'admin' role\n  if (session.role !== 'admin') {\n    forbidden()\n  }\n \n  // Render the admin page for authorized users\n  return <></>\n}\nGood to know\nThe forbidden function cannot be called in the root layout.\nExamples\nRole-based route protection\n\nYou can use forbidden to restrict access to certain routes based on user roles. This ensures that users who are authenticated but lack the required permissions cannot access the route.\n\napp/admin/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { verifySession } from '@/app/lib/dal'\nimport { forbidden } from 'next/navigation'\n \nexport default async function AdminPage() {\n  const session = await verifySession()\n \n  // Check if the user has the 'admin' role\n  if (session.role !== 'admin') {\n    forbidden()\n  }\n \n  // Render the admin page for authorized users\n  return (\n    <main>\n      <h1>Admin Dashboard</h1>\n      <p>Welcome, {session.user.name}!</p>\n    </main>\n  )\n}\nMutations with Server Actions\n\nWhen implementing mutations in Server Actions, you can use forbidden to only allow users with a specific role to update sensitive data.\n\napp/actions/update-role.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { verifySession } from '@/app/lib/dal'\nimport { forbidden } from 'next/navigation'\nimport db from '@/app/lib/db'\n \nexport async function updateRole(formData: FormData) {\n  const session = await verifySession()\n \n  // Ensure only admins can update roles\n  if (session.role !== 'admin') {\n    forbidden()\n  }\n \n  // Perform the role update for authorized users\n  // ...\n}\nVersion History\nVersion\tChanges\nv15.1.0\tforbidden introduced.\nNext Steps\nforbidden.js\nAPI reference for the forbidden.js special file.\nPrevious\nfetch\nNext\ngenerateImageMetadata\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: generateSitemaps | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/generate-sitemaps",
    "html": "API Reference\nFunctions\ngenerateSitemaps\nCopy page\ngenerateSitemaps\n\nYou can use the generateSitemaps function to generate multiple sitemaps for your application.\n\nReturns\n\nThe generateSitemaps returns an array of objects with an id property.\n\nURLs\n\nYour generated sitemaps will be available at /.../sitemap/[id].xml. For example, /product/sitemap/1.xml.\n\nExample\n\nFor example, to split a sitemap using generateSitemaps, return an array of objects with the sitemap id. Then, use the id to generate the unique sitemaps.\n\napp/product/sitemap.ts\nTypeScript\nJavaScript\nTypeScript\nimport { BASE_URL } from '@/app/lib/constants'\n \nexport async function generateSitemaps() {\n  // Fetch the total number of products and calculate the number of sitemaps needed\n  return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]\n}\n \nexport default async function sitemap({\n  id,\n}: {\n  id: number\n}): Promise<MetadataRoute.Sitemap> {\n  // Google's limit is 50,000 URLs per sitemap\n  const start = id * 50000\n  const end = start + 50000\n  const products = await getProducts(\n    `SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`\n  )\n  return products.map((product) => ({\n    url: `${BASE_URL}/product/${product.id}`,\n    lastModified: product.date,\n  }))\n}\nVersion History\nVersion\tChanges\nv15.0.0\tgenerateSitemaps now generates consistent URLs between development and production\nv13.3.2\tgenerateSitemaps introduced. In development, you can view the generated sitemap on /.../sitemap.xml/[id]. For example, /product/sitemap.xml/1.\nNext Steps\nLearn how to create sitemaps for your Next.js application.\nsitemap.xml\nAPI Reference for the sitemap.xml file.\nPrevious\ngenerateMetadata\nNext\ngenerateStaticParams\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: generateMetadata | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/generate-metadata",
    "html": "API Reference\nFunctions\ngenerateMetadata\nCopy page\ngenerateMetadata\n\nYou can use the metadata object or the generateMetadata function to define metadata.\n\nThe metadata object\n\nTo define static metadata, export a Metadata object from a layout.js or page.js file.\n\nlayout.tsx | page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  title: '...',\n  description: '...',\n}\n \nexport default function Page() {}\n\nSee the Metadata Fields for a complete list of supported options.\n\ngenerateMetadata function\n\nDynamic metadata depends on dynamic information, such as the current route parameters, external data, or metadata in parent segments, can be set by exporting a generateMetadata function that returns a Metadata object.\n\nResolving generateMetadata is part of rendering the page. If the page can be pre-rendered and generateMetadata doesn't introduce dynamic behavior, the resulting metadata is included in the page’s initial HTML.\n\nOtherwise the metadata resolved from generateMetadata can be streamed after sending the initial UI.\n\napp/products/[id]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata, ResolvingMetadata } from 'next'\n \ntype Props = {\n  params: Promise<{ id: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}\n \nexport async function generateMetadata(\n  { params, searchParams }: Props,\n  parent: ResolvingMetadata\n): Promise<Metadata> {\n  // read route params\n  const { id } = await params\n \n  // fetch data\n  const product = await fetch(`https://.../${id}`).then((res) => res.json())\n \n  // optionally access and extend (rather than replace) parent metadata\n  const previousImages = (await parent).openGraph?.images || []\n \n  return {\n    title: product.title,\n    openGraph: {\n      images: ['/some-specific-page-image.jpg', ...previousImages],\n    },\n  }\n}\n \nexport default function Page({ params, searchParams }: Props) {}\n\nFor type completion of params and searchParams, you can type the first argument with PageProps<'/route'> or LayoutProps<'/route'> for pages and layouts respectively.\n\nGood to know:\n\nMetadata can be added to layout.js and page.js files.\nNext.js will automatically resolve the metadata, and create the relevant <head> tags for the page.\nThe metadata object and generateMetadata function exports are only supported in Server Components.\nYou cannot export both the metadata object and generateMetadata function from the same route segment.\nfetch requests inside generateMetadata are automatically memoized for the same data across generateMetadata, generateStaticParams, Layouts, Pages, and Server Components.\nReact cache can be used if fetch is unavailable.\nFile-based metadata has the higher priority and will override the metadata object and generateMetadata function.\nReference\nParameters\n\ngenerateMetadata function accepts the following parameters:\n\nprops - An object containing the parameters of the current route:\n\nparams - An object containing the dynamic route parameters object from the root segment down to the segment generateMetadata is called from. Examples:\n\nRoute\tURL\tparams\napp/shop/[slug]/page.js\t/shop/1\t{ slug: '1' }\napp/shop/[tag]/[item]/page.js\t/shop/1/2\t{ tag: '1', item: '2' }\napp/shop/[...slug]/page.js\t/shop/1/2\t{ slug: ['1', '2'] }\n\nsearchParams - An object containing the current URL's search params\n. Examples:\n\nURL\tsearchParams\n/shop?a=1\t{ a: '1' }\n/shop?a=1&b=2\t{ a: '1', b: '2' }\n/shop?a=1&a=2\t{ a: ['1', '2'] }\n\nparent - A promise of the resolved metadata from parent route segments.\n\nReturns\n\ngenerateMetadata should return a Metadata object containing one or more metadata fields.\n\nGood to know:\n\nIf metadata doesn't depend on runtime information, it should be defined using the static metadata object rather than generateMetadata.\nfetch requests are automatically memoized for the same data across generateMetadata, generateStaticParams, Layouts, Pages, and Server Components. React cache can be used if fetch is unavailable.\nsearchParams are only available in page.js segments.\nThe redirect() and notFound() Next.js methods can also be used inside generateMetadata.\nMetadata Fields\n\nThe following fields are supported:\n\ntitle\n\nThe title attribute is used to set the title of the document. It can be defined as a simple string or an optional template object.\n\nString\nlayout.js | page.js\nexport const metadata = {\n  title: 'Next.js',\n}\n<head> output\n<title>Next.js</title>\ndefault\n\ntitle.default can be used to provide a fallback title to child route segments that don't define a title.\n\napp/layout.tsx\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  title: {\n    default: 'Acme',\n  },\n}\napp/about/page.tsx\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {}\n \n// Output: <title>Acme</title>\ntemplate\n\ntitle.template can be used to add a prefix or a suffix to titles defined in child route segments.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  title: {\n    template: '%s | Acme',\n    default: 'Acme', // a default is required when creating a template\n  },\n}\napp/about/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  title: 'About',\n}\n \n// Output: <title>About | Acme</title>\n\nGood to know:\n\ntitle.template applies to child route segments and not the segment it's defined in. This means:\ntitle.default is required when you add a title.template.\ntitle.template defined in layout.js will not apply to a title defined in a page.js of the same route segment.\ntitle.template defined in page.js has no effect because a page is always the terminating segment (it doesn't have any children route segments).\ntitle.template has no effect if a route has not defined a title or title.default.\nabsolute\n\ntitle.absolute can be used to provide a title that ignores title.template set in parent segments.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  title: {\n    template: '%s | Acme',\n  },\n}\napp/about/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  title: {\n    absolute: 'About',\n  },\n}\n \n// Output: <title>About</title>\n\nGood to know:\n\nlayout.js\ntitle (string) and title.default define the default title for child segments (that do not define their own title). It will augment title.template from the closest parent segment if it exists.\ntitle.absolute defines the default title for child segments. It ignores title.template from parent segments.\ntitle.template defines a new title template for child segments.\npage.js\nIf a page does not define its own title the closest parents resolved title will be used.\ntitle (string) defines the routes title. It will augment title.template from the closest parent segment if it exists.\ntitle.absolute defines the route title. It ignores title.template from parent segments.\ntitle.template has no effect in page.js because a page is always the terminating segment of a route.\ndescription\nlayout.js | page.js\nexport const metadata = {\n  description: 'The React Framework for the Web',\n}\n<head> output\n<meta name=\"description\" content=\"The React Framework for the Web\" />\nOther fields\nlayout.js | page.js\nexport const metadata = {\n  generator: 'Next.js',\n  applicationName: 'Next.js',\n  referrer: 'origin-when-cross-origin',\n  keywords: ['Next.js', 'React', 'JavaScript'],\n  authors: [{ name: 'Seb' }, { name: 'Josh', url: 'https://nextjs.org' }],\n  creator: 'Jiachi Liu',\n  publisher: 'Sebastian Markbåge',\n  formatDetection: {\n    email: false,\n    address: false,\n    telephone: false,\n  },\n}\n<head> output\n<meta name=\"application-name\" content=\"Next.js\" />\n<meta name=\"author\" content=\"Seb\" />\n<link rel=\"author\" href=\"https://nextjs.org\" />\n<meta name=\"author\" content=\"Josh\" />\n<meta name=\"generator\" content=\"Next.js\" />\n<meta name=\"keywords\" content=\"Next.js,React,JavaScript\" />\n<meta name=\"referrer\" content=\"origin-when-cross-origin\" />\n<meta name=\"color-scheme\" content=\"dark\" />\n<meta name=\"creator\" content=\"Jiachi Liu\" />\n<meta name=\"publisher\" content=\"Sebastian Markbåge\" />\n<meta name=\"format-detection\" content=\"telephone=no, address=no, email=no\" />\nmetadataBase\n\nmetadataBase is a convenience option to set a base URL prefix for metadata fields that require a fully qualified URL.\n\nmetadataBase allows URL-based metadata fields defined in the current route segment and below to use a relative path instead of an otherwise required absolute URL.\nThe field's relative path will be composed with metadataBase to form a fully qualified URL.\nlayout.js | page.js\nexport const metadata = {\n  metadataBase: new URL('https://acme.com'),\n  alternates: {\n    canonical: '/',\n    languages: {\n      'en-US': '/en-US',\n      'de-DE': '/de-DE',\n    },\n  },\n  openGraph: {\n    images: '/og-image.png',\n  },\n}\n<head> output\n<link rel=\"canonical\" href=\"https://acme.com\" />\n<link rel=\"alternate\" hreflang=\"en-US\" href=\"https://acme.com/en-US\" />\n<link rel=\"alternate\" hreflang=\"de-DE\" href=\"https://acme.com/de-DE\" />\n<meta property=\"og:image\" content=\"https://acme.com/og-image.png\" />\n\nGood to know:\n\nmetadataBase is typically set in root app/layout.js to apply to URL-based metadata fields across all routes.\nAll URL-based metadata fields that require absolute URLs can be configured with a metadataBase option.\nmetadataBase can contain a subdomain e.g. https://app.acme.com or base path e.g. https://acme.com/start/from/here\nIf a metadata field provides an absolute URL, metadataBase will be ignored.\nUsing a relative path in a URL-based metadata field without configuring a metadataBase will cause a build error.\nNext.js will normalize duplicate slashes between metadataBase (e.g. https://acme.com/) and a relative field (e.g. /path) to a single slash (e.g. https://acme.com/path)\nURL Composition\n\nURL composition favors developer intent over default directory traversal semantics.\n\nTrailing slashes between metadataBase and metadata fields are normalized.\nAn \"absolute\" path in a metadata field (that typically would replace the whole URL path) is treated as a \"relative\" path (starting from the end of metadataBase).\n\nFor example, given the following metadataBase:\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  metadataBase: new URL('https://acme.com'),\n}\n\nAny metadata fields that inherit the above metadataBase and set their own value will be resolved as follows:\n\nmetadata field\tResolved URL\n/\thttps://acme.com\n./\thttps://acme.com\npayments\thttps://acme.com/payments\n/payments\thttps://acme.com/payments\n./payments\thttps://acme.com/payments\n../payments\thttps://acme.com/payments\nhttps://beta.acme.com/payments\thttps://beta.acme.com/payments\nopenGraph\nlayout.js | page.js\nexport const metadata = {\n  openGraph: {\n    title: 'Next.js',\n    description: 'The React Framework for the Web',\n    url: 'https://nextjs.org',\n    siteName: 'Next.js',\n    images: [\n      {\n        url: 'https://nextjs.org/og.png', // Must be an absolute URL\n        width: 800,\n        height: 600,\n      },\n      {\n        url: 'https://nextjs.org/og-alt.png', // Must be an absolute URL\n        width: 1800,\n        height: 1600,\n        alt: 'My custom alt',\n      },\n    ],\n    videos: [\n      {\n        url: 'https://nextjs.org/video.mp4', // Must be an absolute URL\n        width: 800,\n        height: 600,\n      },\n    ],\n    audio: [\n      {\n        url: 'https://nextjs.org/audio.mp3', // Must be an absolute URL\n      },\n    ],\n    locale: 'en_US',\n    type: 'website',\n  },\n}\n<head> output\n<meta property=\"og:title\" content=\"Next.js\" />\n<meta property=\"og:description\" content=\"The React Framework for the Web\" />\n<meta property=\"og:url\" content=\"https://nextjs.org/\" />\n<meta property=\"og:site_name\" content=\"Next.js\" />\n<meta property=\"og:locale\" content=\"en_US\" />\n<meta property=\"og:image\" content=\"https://nextjs.org/og.png\" />\n<meta property=\"og:image:width\" content=\"800\" />\n<meta property=\"og:image:height\" content=\"600\" />\n<meta property=\"og:image\" content=\"https://nextjs.org/og-alt.png\" />\n<meta property=\"og:image:width\" content=\"1800\" />\n<meta property=\"og:image:height\" content=\"1600\" />\n<meta property=\"og:image:alt\" content=\"My custom alt\" />\n<meta property=\"og:video\" content=\"https://nextjs.org/video.mp4\" />\n<meta property=\"og:video:width\" content=\"800\" />\n<meta property=\"og:video:height\" content=\"600\" />\n<meta property=\"og:audio\" content=\"https://nextjs.org/audio.mp3\" />\n<meta property=\"og:type\" content=\"website\" />\nlayout.js | page.js\nexport const metadata = {\n  openGraph: {\n    title: 'Next.js',\n    description: 'The React Framework for the Web',\n    type: 'article',\n    publishedTime: '2023-01-01T00:00:00.000Z',\n    authors: ['Seb', 'Josh'],\n  },\n}\n<head> output\n<meta property=\"og:title\" content=\"Next.js\" />\n<meta property=\"og:description\" content=\"The React Framework for the Web\" />\n<meta property=\"og:type\" content=\"article\" />\n<meta property=\"article:published_time\" content=\"2023-01-01T00:00:00.000Z\" />\n<meta property=\"article:author\" content=\"Seb\" />\n<meta property=\"article:author\" content=\"Josh\" />\n\nGood to know:\n\nIt may be more convenient to use the file-based Metadata API for Open Graph images. Rather than having to sync the config export with actual files, the file-based API will automatically generate the correct metadata for you.\nrobots\nlayout.tsx | page.tsx\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  robots: {\n    index: true,\n    follow: true,\n    nocache: false,\n    googleBot: {\n      index: true,\n      follow: true,\n      noimageindex: false,\n      'max-video-preview': -1,\n      'max-image-preview': 'large',\n      'max-snippet': -1,\n    },\n  },\n}\n<head> output\n<meta name=\"robots\" content=\"index, follow\" />\n<meta\n  name=\"googlebot\"\n  content=\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"\n/>\nicons\n\nGood to know: We recommend using the file-based Metadata API for icons where possible. Rather than having to sync the config export with actual files, the file-based API will automatically generate the correct metadata for you.\n\nlayout.js | page.js\nexport const metadata = {\n  icons: {\n    icon: '/icon.png',\n    shortcut: '/shortcut-icon.png',\n    apple: '/apple-icon.png',\n    other: {\n      rel: 'apple-touch-icon-precomposed',\n      url: '/apple-touch-icon-precomposed.png',\n    },\n  },\n}\n<head> output\n<link rel=\"shortcut icon\" href=\"/shortcut-icon.png\" />\n<link rel=\"icon\" href=\"/icon.png\" />\n<link rel=\"apple-touch-icon\" href=\"/apple-icon.png\" />\n<link\n  rel=\"apple-touch-icon-precomposed\"\n  href=\"/apple-touch-icon-precomposed.png\"\n/>\nlayout.js | page.js\nexport const metadata = {\n  icons: {\n    icon: [\n      { url: '/icon.png' },\n      new URL('/icon.png', 'https://example.com'),\n      { url: '/icon-dark.png', media: '(prefers-color-scheme: dark)' },\n    ],\n    shortcut: ['/shortcut-icon.png'],\n    apple: [\n      { url: '/apple-icon.png' },\n      { url: '/apple-icon-x3.png', sizes: '180x180', type: 'image/png' },\n    ],\n    other: [\n      {\n        rel: 'apple-touch-icon-precomposed',\n        url: '/apple-touch-icon-precomposed.png',\n      },\n    ],\n  },\n}\n<head> output\n<link rel=\"shortcut icon\" href=\"/shortcut-icon.png\" />\n<link rel=\"icon\" href=\"/icon.png\" />\n<link rel=\"icon\" href=\"https://example.com/icon.png\" />\n<link rel=\"icon\" href=\"/icon-dark.png\" media=\"(prefers-color-scheme: dark)\" />\n<link rel=\"apple-touch-icon\" href=\"/apple-icon.png\" />\n<link\n  rel=\"apple-touch-icon-precomposed\"\n  href=\"/apple-touch-icon-precomposed.png\"\n/>\n<link\n  rel=\"apple-touch-icon\"\n  href=\"/apple-icon-x3.png\"\n  sizes=\"180x180\"\n  type=\"image/png\"\n/>\n\nGood to know: The msapplication-* meta tags are no longer supported in Chromium builds of Microsoft Edge, and thus no longer needed.\n\nthemeColor\n\nDeprecated: The themeColor option in metadata is deprecated as of Next.js 14. Please use the viewport configuration instead.\n\ncolorScheme\n\nDeprecated: The colorScheme option in metadata is deprecated as of Next.js 14. Please use the viewport configuration instead.\n\nmanifest\n\nA web application manifest, as defined in the Web Application Manifest specification\n.\n\nlayout.js | page.js\nexport const metadata = {\n  manifest: 'https://nextjs.org/manifest.json',\n}\n<head> output\n<link rel=\"manifest\" href=\"https://nextjs.org/manifest.json\" />\ntwitter\n\nThe Twitter specification is (surprisingly) used for more than just X (formerly known as Twitter).\n\nLearn more about the Twitter Card markup reference\n.\n\nlayout.js | page.js\nexport const metadata = {\n  twitter: {\n    card: 'summary_large_image',\n    title: 'Next.js',\n    description: 'The React Framework for the Web',\n    siteId: '1467726470533754880',\n    creator: '@nextjs',\n    creatorId: '1467726470533754880',\n    images: ['https://nextjs.org/og.png'], // Must be an absolute URL\n  },\n}\n<head> output\n<meta name=\"twitter:card\" content=\"summary_large_image\" />\n<meta name=\"twitter:site:id\" content=\"1467726470533754880\" />\n<meta name=\"twitter:creator\" content=\"@nextjs\" />\n<meta name=\"twitter:creator:id\" content=\"1467726470533754880\" />\n<meta name=\"twitter:title\" content=\"Next.js\" />\n<meta name=\"twitter:description\" content=\"The React Framework for the Web\" />\n<meta name=\"twitter:image\" content=\"https://nextjs.org/og.png\" />\nlayout.js | page.js\nexport const metadata = {\n  twitter: {\n    card: 'app',\n    title: 'Next.js',\n    description: 'The React Framework for the Web',\n    siteId: '1467726470533754880',\n    creator: '@nextjs',\n    creatorId: '1467726470533754880',\n    images: {\n      url: 'https://nextjs.org/og.png',\n      alt: 'Next.js Logo',\n    },\n    app: {\n      name: 'twitter_app',\n      id: {\n        iphone: 'twitter_app://iphone',\n        ipad: 'twitter_app://ipad',\n        googleplay: 'twitter_app://googleplay',\n      },\n      url: {\n        iphone: 'https://iphone_url',\n        ipad: 'https://ipad_url',\n      },\n    },\n  },\n}\n<head> output\n<meta name=\"twitter:site:id\" content=\"1467726470533754880\" />\n<meta name=\"twitter:creator\" content=\"@nextjs\" />\n<meta name=\"twitter:creator:id\" content=\"1467726470533754880\" />\n<meta name=\"twitter:title\" content=\"Next.js\" />\n<meta name=\"twitter:description\" content=\"The React Framework for the Web\" />\n<meta name=\"twitter:card\" content=\"app\" />\n<meta name=\"twitter:image\" content=\"https://nextjs.org/og.png\" />\n<meta name=\"twitter:image:alt\" content=\"Next.js Logo\" />\n<meta name=\"twitter:app:name:iphone\" content=\"twitter_app\" />\n<meta name=\"twitter:app:id:iphone\" content=\"twitter_app://iphone\" />\n<meta name=\"twitter:app:id:ipad\" content=\"twitter_app://ipad\" />\n<meta name=\"twitter:app:id:googleplay\" content=\"twitter_app://googleplay\" />\n<meta name=\"twitter:app:url:iphone\" content=\"https://iphone_url\" />\n<meta name=\"twitter:app:url:ipad\" content=\"https://ipad_url\" />\n<meta name=\"twitter:app:name:ipad\" content=\"twitter_app\" />\n<meta name=\"twitter:app:name:googleplay\" content=\"twitter_app\" />\nviewport\n\nDeprecated: The viewport option in metadata is deprecated as of Next.js 14. Please use the viewport configuration instead.\n\nverification\nlayout.js | page.js\nexport const metadata = {\n  verification: {\n    google: 'google',\n    yandex: 'yandex',\n    yahoo: 'yahoo',\n    other: {\n      me: ['my-email', 'my-link'],\n    },\n  },\n}\n<head> output\n<meta name=\"google-site-verification\" content=\"google\" />\n<meta name=\"y_key\" content=\"yahoo\" />\n<meta name=\"yandex-verification\" content=\"yandex\" />\n<meta name=\"me\" content=\"my-email\" />\n<meta name=\"me\" content=\"my-link\" />\nappleWebApp\nlayout.js | page.js\nexport const metadata = {\n  itunes: {\n    appId: 'myAppStoreID',\n    appArgument: 'myAppArgument',\n  },\n  appleWebApp: {\n    title: 'Apple Web App',\n    statusBarStyle: 'black-translucent',\n    startupImage: [\n      '/assets/startup/apple-touch-startup-image-768x1004.png',\n      {\n        url: '/assets/startup/apple-touch-startup-image-1536x2008.png',\n        media: '(device-width: 768px) and (device-height: 1024px)',\n      },\n    ],\n  },\n}\n<head> output\n<meta\n  name=\"apple-itunes-app\"\n  content=\"app-id=myAppStoreID, app-argument=myAppArgument\"\n/>\n<meta name=\"mobile-web-app-capable\" content=\"yes\" />\n<meta name=\"apple-mobile-web-app-title\" content=\"Apple Web App\" />\n<link\n  href=\"/assets/startup/apple-touch-startup-image-768x1004.png\"\n  rel=\"apple-touch-startup-image\"\n/>\n<link\n  href=\"/assets/startup/apple-touch-startup-image-1536x2008.png\"\n  media=\"(device-width: 768px) and (device-height: 1024px)\"\n  rel=\"apple-touch-startup-image\"\n/>\n<meta\n  name=\"apple-mobile-web-app-status-bar-style\"\n  content=\"black-translucent\"\n/>\nalternates\nlayout.js | page.js\nexport const metadata = {\n  alternates: {\n    canonical: 'https://nextjs.org',\n    languages: {\n      'en-US': 'https://nextjs.org/en-US',\n      'de-DE': 'https://nextjs.org/de-DE',\n    },\n    media: {\n      'only screen and (max-width: 600px)': 'https://nextjs.org/mobile',\n    },\n    types: {\n      'application/rss+xml': 'https://nextjs.org/rss',\n    },\n  },\n}\n<head> output\n<link rel=\"canonical\" href=\"https://nextjs.org\" />\n<link rel=\"alternate\" hreflang=\"en-US\" href=\"https://nextjs.org/en-US\" />\n<link rel=\"alternate\" hreflang=\"de-DE\" href=\"https://nextjs.org/de-DE\" />\n<link\n  rel=\"alternate\"\n  media=\"only screen and (max-width: 600px)\"\n  href=\"https://nextjs.org/mobile\"\n/>\n<link\n  rel=\"alternate\"\n  type=\"application/rss+xml\"\n  href=\"https://nextjs.org/rss\"\n/>\nappLinks\nlayout.js | page.js\nexport const metadata = {\n  appLinks: {\n    ios: {\n      url: 'https://nextjs.org/ios',\n      app_store_id: 'app_store_id',\n    },\n    android: {\n      package: 'com.example.android/package',\n      app_name: 'app_name_android',\n    },\n    web: {\n      url: 'https://nextjs.org/web',\n      should_fallback: true,\n    },\n  },\n}\n<head> output\n<meta property=\"al:ios:url\" content=\"https://nextjs.org/ios\" />\n<meta property=\"al:ios:app_store_id\" content=\"app_store_id\" />\n<meta property=\"al:android:package\" content=\"com.example.android/package\" />\n<meta property=\"al:android:app_name\" content=\"app_name_android\" />\n<meta property=\"al:web:url\" content=\"https://nextjs.org/web\" />\n<meta property=\"al:web:should_fallback\" content=\"true\" />\narchives\n\nDescribes a collection of records, documents, or other materials of historical interest (source\n).\n\nlayout.js | page.js\nexport const metadata = {\n  archives: ['https://nextjs.org/13'],\n}\n<head> output\n<link rel=\"archives\" href=\"https://nextjs.org/13\" />\nassets\nlayout.js | page.js\nexport const metadata = {\n  assets: ['https://nextjs.org/assets'],\n}\n<head> output\n<link rel=\"assets\" href=\"https://nextjs.org/assets\" />\nbookmarks\nlayout.js | page.js\nexport const metadata = {\n  bookmarks: ['https://nextjs.org/13'],\n}\n<head> output\n<link rel=\"bookmarks\" href=\"https://nextjs.org/13\" />\ncategory\nlayout.js | page.js\nexport const metadata = {\n  category: 'technology',\n}\n<head> output\n<meta name=\"category\" content=\"technology\" />\nfacebook\n\nYou can connect a Facebook app or Facebook account to your webpage for certain Facebook Social Plugins Facebook Documentation\n\nGood to know: You can specify either appId or admins, but not both.\n\nlayout.js | page.js\nexport const metadata = {\n  facebook: {\n    appId: '12345678',\n  },\n}\n<head> output\n<meta property=\"fb:app_id\" content=\"12345678\" />\nlayout.js | page.js\nexport const metadata = {\n  facebook: {\n    admins: '12345678',\n  },\n}\n<head> output\n<meta property=\"fb:admins\" content=\"12345678\" />\n\nIf you want to generate multiple fb:admins meta tags you can use array value.\n\nlayout.js | page.js\nexport const metadata = {\n  facebook: {\n    admins: ['12345678', '87654321'],\n  },\n}\n<head> output\n<meta property=\"fb:admins\" content=\"12345678\" />\n<meta property=\"fb:admins\" content=\"87654321\" />\npinterest\n\nYou can enable or disable Pinterest Rich Pins\n on your webpage.\n\nlayout.js | page.js\nexport const metadata = {\n  pinterest: {\n    richPin: true,\n  },\n}\n<head> output\n<meta name=\"pinterest-rich-pin\" content=\"true\" />\nother\n\nAll metadata options should be covered using the built-in support. However, there may be custom metadata tags specific to your site, or brand new metadata tags just released. You can use the other option to render any custom metadata tag.\n\nlayout.js | page.js\nexport const metadata = {\n  other: {\n    custom: 'meta',\n  },\n}\n<head> output\n<meta name=\"custom\" content=\"meta\" />\n\nIf you want to generate multiple same key meta tags you can use array value.\n\nlayout.js | page.js\nexport const metadata = {\n  other: {\n    custom: ['meta1', 'meta2'],\n  },\n}\n<head> output\n<meta name=\"custom\" content=\"meta1\" /> <meta name=\"custom\" content=\"meta2\" />\nTypes\n\nYou can add type safety to your metadata by using the Metadata type. If you are using the built-in TypeScript plugin in your IDE, you do not need to manually add the type, but you can still explicitly add it if you want.\n\nmetadata object\nlayout.tsx | page.tsx\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  title: 'Next.js',\n}\ngenerateMetadata function\nRegular function\nlayout.tsx | page.tsx\nimport type { Metadata } from 'next'\n \nexport function generateMetadata(): Metadata {\n  return {\n    title: 'Next.js',\n  }\n}\nAsync function\nlayout.tsx | page.tsx\nimport type { Metadata } from 'next'\n \nexport async function generateMetadata(): Promise<Metadata> {\n  return {\n    title: 'Next.js',\n  }\n}\nWith segment props\nlayout.tsx | page.tsx\nimport type { Metadata } from 'next'\n \ntype Props = {\n  params: Promise<{ id: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}\n \nexport function generateMetadata({ params, searchParams }: Props): Metadata {\n  return {\n    title: 'Next.js',\n  }\n}\n \nexport default function Page({ params, searchParams }: Props) {}\nWith parent metadata\nlayout.tsx | page.tsx\nimport type { Metadata, ResolvingMetadata } from 'next'\n \nexport async function generateMetadata(\n  { params, searchParams }: Props,\n  parent: ResolvingMetadata\n): Promise<Metadata> {\n  return {\n    title: 'Next.js',\n  }\n}\nJavaScript Projects\n\nFor JavaScript projects, you can use JSDoc to add type safety.\n\nlayout.js | page.js\n/** @type {import(\"next\").Metadata} */\nexport const metadata = {\n  title: 'Next.js',\n}\nUnsupported Metadata\n\nThe following metadata types do not currently have built-in support. However, they can still be rendered in the layout or page itself.\n\nMetadata\tRecommendation\n<meta http-equiv=\"...\">\tUse appropriate HTTP Headers via redirect(), Proxy, Security Headers\n<base>\tRender the tag in the layout or page itself.\n<noscript>\tRender the tag in the layout or page itself.\n<style>\tLearn more about styling in Next.js.\n<script>\tLearn more about using scripts.\n<link rel=\"stylesheet\" />\timport stylesheets directly in the layout or page itself.\n<link rel=\"preload />\tUse ReactDOM preload method\n<link rel=\"preconnect\" />\tUse ReactDOM preconnect method\n<link rel=\"dns-prefetch\" />\tUse ReactDOM prefetchDNS method\nResource hints\n\nThe <link> element has a number of rel keywords that can be used to hint to the browser that an external resource is likely to be needed. The browser uses this information to apply preloading optimizations depending on the keyword.\n\nWhile the Metadata API doesn't directly support these hints, you can use new ReactDOM methods\n to safely insert them into the <head> of the document.\n\napp/preload-resources.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport ReactDOM from 'react-dom'\n \nexport function PreloadResources() {\n  ReactDOM.preload('...', { as: '...' })\n  ReactDOM.preconnect('...', { crossOrigin: '...' })\n  ReactDOM.prefetchDNS('...')\n \n  return '...'\n}\n<link rel=\"preload\">\n\nStart loading a resource early in the page rendering (browser) lifecycle. MDN Docs\n.\n\nReactDOM.preload(href: string, options: { as: string })\n<head> output\n<link rel=\"preload\" href=\"...\" as=\"...\" />\n<link rel=\"preconnect\">\n\nPreemptively initiate a connection to an origin. MDN Docs\n.\n\nReactDOM.preconnect(href: string, options?: { crossOrigin?: string })\n<head> output\n<link rel=\"preconnect\" href=\"...\" crossorigin />\n<link rel=\"dns-prefetch\">\n\nAttempt to resolve a domain name before resources get requested. MDN Docs\n.\n\nReactDOM.prefetchDNS(href: string)\n<head> output\n<link rel=\"dns-prefetch\" href=\"...\" />\n\nGood to know:\n\nThese methods are currently only supported in Client Components, which are still Server Side Rendered on initial page load.\nNext.js in-built features such as next/font, next/image and next/script automatically handle relevant resource hints.\nBehavior\nDefault Fields\n\nThere are two default meta tags that are always added even if a route doesn't define metadata:\n\nThe meta charset tag\n sets the character encoding for the website.\nThe meta viewport tag\n sets the viewport width and scale for the website to adjust for different devices.\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\nGood to know: You can overwrite the default viewport meta tag.\n\nStreaming metadata\n\nStreaming metadata allows Next.js to render and send the initial UI to the browser, without waiting for generateMetadata to complete.\n\nWhen generateMetadata resolves, the resulting metadata tags are appended to the <body> tag. We have verified that metadata is interpreted correctly by bots that execute JavaScript and inspect the full DOM (e.g. Googlebot).\n\nFor HTML-limited bots that can’t execute JavaScript (e.g. facebookexternalhit), metadata continues to block page rendering. The resulting metadata will be available in the <head> tag.\n\nNext.js automatically detects HTML-limited bots by looking at the User Agent header. You can use the htmlLimitedBots option in your Next.js config file to override the default User Agent list\n.\n\nTo fully disable streaming metadata:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst config: NextConfig = {\n  htmlLimitedBots: /.*/,\n}\n \nexport default config\n\nStreaming metadata improves perceived performance by reducing TTFB\n and can help lowering LCP\n time.\n\nOverriding htmlLimitedBots could lead to longer response times. Streaming metadata is an advanced feature, and the default should be sufficient for most cases.\n\nOrdering\n\nMetadata is evaluated in order, starting from the root segment down to the segment closest to the final page.js segment. For example:\n\napp/layout.tsx (Root Layout)\napp/blog/layout.tsx (Nested Blog Layout)\napp/blog/[slug]/page.tsx (Blog Page)\nMerging\n\nFollowing the evaluation order, Metadata objects exported from multiple segments in the same route are shallowly merged together to form the final metadata output of a route. Duplicate keys are replaced based on their ordering.\n\nThis means metadata with nested fields such as openGraph and robots that are defined in an earlier segment are overwritten by the last segment to define them.\n\nOverwriting fields\napp/layout.js\nexport const metadata = {\n  title: 'Acme',\n  openGraph: {\n    title: 'Acme',\n    description: 'Acme is a...',\n  },\n}\napp/blog/page.js\nexport const metadata = {\n  title: 'Blog',\n  openGraph: {\n    title: 'Blog',\n  },\n}\n \n// Output:\n// <title>Blog</title>\n// <meta property=\"og:title\" content=\"Blog\" />\n\nIn the example above:\n\ntitle from app/layout.js is replaced by title in app/blog/page.js.\nAll openGraph fields from app/layout.js are replaced in app/blog/page.js because app/blog/page.js sets openGraph metadata. Note the absence of openGraph.description.\n\nIf you'd like to share some nested fields between segments while overwriting others, you can pull them out into a separate variable:\n\napp/shared-metadata.js\nexport const openGraphImage = { images: ['http://...'] }\napp/page.js\nimport { openGraphImage } from './shared-metadata'\n \nexport const metadata = {\n  openGraph: {\n    ...openGraphImage,\n    title: 'Home',\n  },\n}\napp/about/page.js\nimport { openGraphImage } from '../shared-metadata'\n \nexport const metadata = {\n  openGraph: {\n    ...openGraphImage,\n    title: 'About',\n  },\n}\n\nIn the example above, the OG image is shared between app/layout.js and app/about/page.js while the titles are different.\n\nInheriting fields\napp/layout.js\nexport const metadata = {\n  title: 'Acme',\n  openGraph: {\n    title: 'Acme',\n    description: 'Acme is a...',\n  },\n}\napp/about/page.js\nexport const metadata = {\n  title: 'About',\n}\n \n// Output:\n// <title>About</title>\n// <meta property=\"og:title\" content=\"Acme\" />\n// <meta property=\"og:description\" content=\"Acme is a...\" />\n\nNotes\n\ntitle from app/layout.js is replaced by title in app/about/page.js.\nAll openGraph fields from app/layout.js are inherited in app/about/page.js because app/about/page.js doesn't set openGraph metadata.\nVersion History\nVersion\tChanges\nv15.2.0\tIntroduced streaming support to generateMetadata.\nv13.2.0\tviewport, themeColor, and colorScheme deprecated in favor of the viewport configuration.\nv13.2.0\tmetadata and generateMetadata introduced.\nNext Steps\nView all the Metadata API options.\nMetadata Files\nAPI documentation for the metadata file conventions.\ngenerateViewport\nAPI Reference for the generateViewport function.\nPrevious\ngenerateImageMetadata\nNext\ngenerateSitemaps\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: generateStaticParams | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/generate-static-params",
    "html": "API Reference\nFunctions\ngenerateStaticParams\nCopy page\ngenerateStaticParams\n\nThe generateStaticParams function can be used in combination with dynamic route segments to statically generate routes at build time instead of on-demand at request time.\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\n// Return a list of `params` to populate the [slug] dynamic segment\nexport async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) => res.json())\n \n  return posts.map((post) => ({\n    slug: post.slug,\n  }))\n}\n \n// Multiple versions of this page will be statically generated\n// using the `params` returned by `generateStaticParams`\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  // ...\n}\n\nGood to know:\n\nYou can use the dynamicParams segment config option to control what happens when a dynamic segment is visited that was not generated with generateStaticParams.\nYou must return an empty array from generateStaticParams or utilize export const dynamic = 'force-static' in order to revalidate (ISR) paths at runtime.\nDuring next dev, generateStaticParams will be called when you navigate to a route.\nDuring next build, generateStaticParams runs before the corresponding Layouts or Pages are generated.\nDuring revalidation (ISR), generateStaticParams will not be called again.\ngenerateStaticParams replaces the getStaticPaths function in the Pages Router.\nParameters\n\noptions.params (optional)\n\nIf multiple dynamic segments in a route use generateStaticParams, the child generateStaticParams function is executed once for each set of params the parent generates.\n\nThe params object contains the populated params from the parent generateStaticParams, which can be used to generate the params in a child segment.\n\nReturns\n\ngenerateStaticParams should return an array of objects where each object represents the populated dynamic segments of a single route.\n\nEach property in the object is a dynamic segment to be filled in for the route.\nThe properties name is the segment's name, and the properties value is what that segment should be filled in with.\nExample Route\tgenerateStaticParams Return Type\n/product/[id]\t{ id: string }[]\n/products/[category]/[product]\t{ category: string, product: string }[]\n/products/[...slug]\t{ slug: string[] }[]\nSingle Dynamic Segment\napp/product/[id]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport function generateStaticParams() {\n  return [{ id: '1' }, { id: '2' }, { id: '3' }]\n}\n \n// Three versions of this page will be statically generated\n// using the `params` returned by `generateStaticParams`\n// - /product/1\n// - /product/2\n// - /product/3\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n  // ...\n}\nMultiple Dynamic Segments\napp/products/[category]/[product]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport function generateStaticParams() {\n  return [\n    { category: 'a', product: '1' },\n    { category: 'b', product: '2' },\n    { category: 'c', product: '3' },\n  ]\n}\n \n// Three versions of this page will be statically generated\n// using the `params` returned by `generateStaticParams`\n// - /products/a/1\n// - /products/b/2\n// - /products/c/3\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ category: string; product: string }>\n}) {\n  const { category, product } = await params\n  // ...\n}\nCatch-all Dynamic Segment\napp/product/[...slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport function generateStaticParams() {\n  return [{ slug: ['a', '1'] }, { slug: ['b', '2'] }, { slug: ['c', '3'] }]\n}\n \n// Three versions of this page will be statically generated\n// using the `params` returned by `generateStaticParams`\n// - /product/a/1\n// - /product/b/2\n// - /product/c/3\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ slug: string[] }>\n}) {\n  const { slug } = await params\n  // ...\n}\nExamples\nStatic Rendering\nAll paths at build time\n\nTo statically render all paths at build time, supply the full list of paths to generateStaticParams:\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) => res.json())\n \n  return posts.map((post) => ({\n    slug: post.slug,\n  }))\n}\nSubset of paths at build time\n\nTo statically render a subset of paths at build time, and the rest the first time they're visited at runtime, return a partial list of paths:\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) => res.json())\n \n  // Render the first 10 posts at build time\n  return posts.slice(0, 10).map((post) => ({\n    slug: post.slug,\n  }))\n}\n\nThen, by using the dynamicParams segment config option, you can control what happens when a dynamic segment is visited that was not generated with generateStaticParams.\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\n// All posts besides the top 10 will be a 404\nexport const dynamicParams = false\n \nexport async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) => res.json())\n  const topPosts = posts.slice(0, 10)\n \n  return topPosts.map((post) => ({\n    slug: post.slug,\n  }))\n}\nAll paths at runtime\n\nTo statically render all paths the first time they're visited, return an empty array (no paths will be rendered at build time) or utilize export const dynamic = 'force-static':\n\napp/blog/[slug]/page.js\nexport async function generateStaticParams() {\n  return []\n}\n\nGood to know: You must always return an array from generateStaticParams, even if it's empty. Otherwise, the route will be dynamically rendered.\n\napp/changelog/[slug]/page.js\nexport const dynamic = 'force-static'\nDisable rendering for unspecified paths\n\nTo prevent unspecified paths from being statically rendered at runtime, add the export const dynamicParams = false option in a route segment. When this config option is used, only paths provided by generateStaticParams will be served, and unspecified routes will 404 or match (in the case of catch-all routes).\n\nMultiple Dynamic Segments in a Route\n\nYou can generate params for dynamic segments above the current layout or page, but not below. For example, given the app/products/[category]/[product] route:\n\napp/products/[category]/[product]/page.js can generate params for both [category] and [product].\napp/products/[category]/layout.js can only generate params for [category].\n\nThere are two approaches to generating params for a route with multiple dynamic segments:\n\nGenerate params from the bottom up\n\nGenerate multiple dynamic segments from the child route segment.\n\napp/products/[category]/[product]/page.tsx\nTypeScript\nJavaScript\nTypeScript\n// Generate segments for both [category] and [product]\nexport async function generateStaticParams() {\n  const products = await fetch('https://.../products').then((res) => res.json())\n \n  return products.map((product) => ({\n    category: product.category.slug,\n    product: product.id,\n  }))\n}\n \nexport default function Page({\n  params,\n}: {\n  params: Promise<{ category: string; product: string }>\n}) {\n  // ...\n}\nGenerate params from the top down\n\nGenerate the parent segments first and use the result to generate the child segments.\n\napp/products/[category]/layout.tsx\nTypeScript\nJavaScript\nTypeScript\n// Generate segments for [category]\nexport async function generateStaticParams() {\n  const products = await fetch('https://.../products').then((res) => res.json())\n \n  return products.map((product) => ({\n    category: product.category.slug,\n  }))\n}\n \nexport default function Layout({\n  params,\n}: {\n  params: Promise<{ category: string }>\n}) {\n  // ...\n}\n\nA child route segment's generateStaticParams function is executed once for each segment a parent generateStaticParams generates.\n\nThe child generateStaticParams function can use the params returned from the parent generateStaticParams function to dynamically generate its own segments.\n\napp/products/[category]/[product]/page.tsx\nTypeScript\nJavaScript\nTypeScript\n// Generate segments for [product] using the `params` passed from\n// the parent segment's `generateStaticParams` function\nexport async function generateStaticParams({\n  params: { category },\n}: {\n  params: { category: string }\n}) {\n  const products = await fetch(\n    `https://.../products?category=${category}`\n  ).then((res) => res.json())\n \n  return products.map((product) => ({\n    product: product.id,\n  }))\n}\n \nexport default function Page({\n  params,\n}: {\n  params: Promise<{ category: string; product: string }>\n}) {\n  // ...\n}\n\nNotice that the params argument can be accessed synchronously and includes only parent segment params.\n\nFor type completion, you can make use of the TypeScript Awaited helper in combination with either Page Props helper or Layout Props helper:\n\napp/products/[category]/[product]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport async function generateStaticParams({\n  params: { category },\n}: {\n  params: Awaited<LayoutProps<'/products/[category]'>['params']>\n}) {\n  const products = await fetch(\n    `https://.../products?category=${category}`\n  ).then((res) => res.json())\n \n  return products.map((product) => ({\n    product: product.id,\n  }))\n}\n\nGood to know: fetch requests are automatically memoized for the same data across all generate-prefixed functions, Layouts, Pages, and Server Components. React cache can be used if fetch is unavailable.\n\nVersion History\nVersion\tChanges\nv13.0.0\tgenerateStaticParams introduced.\nPrevious\ngenerateSitemaps\nNext\ngenerateViewport\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: generateViewport | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/generate-viewport",
    "html": "API Reference\nFunctions\ngenerateViewport\nCopy page\ngenerateViewport\n\nYou can customize the initial viewport of the page with the static viewport object or the dynamic generateViewport function.\n\nGood to know:\n\nThe viewport object and generateViewport function exports are only supported in Server Components.\nYou cannot export both the viewport object and generateViewport function from the same route segment.\nIf you're coming from migrating metadata exports, you can use metadata-to-viewport-export codemod to update your changes.\nThe viewport object\n\nTo define the viewport options, export a viewport object from a layout.jsx or page.jsx file.\n\nlayout.tsx | page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Viewport } from 'next'\n \nexport const viewport: Viewport = {\n  themeColor: 'black',\n}\n \nexport default function Page() {}\ngenerateViewport function\n\ngenerateViewport should return a Viewport object containing one or more viewport fields.\n\nlayout.tsx | page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport function generateViewport({ params }) {\n  return {\n    themeColor: '...',\n  }\n}\n\nIn TypeScript, the params argument can be typed via PageProps<'/route'> or LayoutProps<'/route'> depending on where generateViewport is defined.\n\nGood to know:\n\nIf the viewport doesn't depend on runtime information, it should be defined using the static viewport object rather than generateViewport.\nViewport Fields\nthemeColor\n\nLearn more about theme-color\n.\n\nSimple theme color\n\nlayout.tsx | page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Viewport } from 'next'\n \nexport const viewport: Viewport = {\n  themeColor: 'black',\n}\n<head> output\n<meta name=\"theme-color\" content=\"black\" />\n\nWith media attribute\n\nlayout.tsx | page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Viewport } from 'next'\n \nexport const viewport: Viewport = {\n  themeColor: [\n    { media: '(prefers-color-scheme: light)', color: 'cyan' },\n    { media: '(prefers-color-scheme: dark)', color: 'black' },\n  ],\n}\n<head> output\n<meta name=\"theme-color\" media=\"(prefers-color-scheme: light)\" content=\"cyan\" />\n<meta name=\"theme-color\" media=\"(prefers-color-scheme: dark)\" content=\"black\" />\nwidth, initialScale, maximumScale and userScalable\n\nGood to know: The viewport meta tag is automatically set, and manual configuration is usually unnecessary as the default is sufficient. However, the information is provided for completeness.\n\nlayout.tsx | page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Viewport } from 'next'\n \nexport const viewport: Viewport = {\n  width: 'device-width',\n  initialScale: 1,\n  maximumScale: 1,\n  userScalable: false,\n  // Also supported but less commonly used\n  // interactiveWidget: 'resizes-visual',\n}\n<head> output\n<meta\n  name=\"viewport\"\n  content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"\n/>\ncolorScheme\n\nLearn more about color-scheme\n.\n\nlayout.tsx | page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Viewport } from 'next'\n \nexport const viewport: Viewport = {\n  colorScheme: 'dark',\n}\n<head> output\n<meta name=\"color-scheme\" content=\"dark\" />\nTypes\n\nYou can add type safety to your viewport object by using the Viewport type. If you are using the built-in TypeScript plugin in your IDE, you do not need to manually add the type, but you can still explicitly add it if you want.\n\nviewport object\nimport type { Viewport } from 'next'\n \nexport const viewport: Viewport = {\n  themeColor: 'black',\n}\ngenerateViewport function\nRegular function\nimport type { Viewport } from 'next'\n \nexport function generateViewport(): Viewport {\n  return {\n    themeColor: 'black',\n  }\n}\nWith segment props\nimport type { Viewport } from 'next'\n \ntype Props = {\n  params: Promise<{ id: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}\n \nexport function generateViewport({ params, searchParams }: Props): Viewport {\n  return {\n    themeColor: 'black',\n  }\n}\n \nexport default function Page({ params, searchParams }: Props) {}\nJavaScript Projects\n\nFor JavaScript projects, you can use JSDoc to add type safety.\n\n/** @type {import(\"next\").Viewport} */\nexport const viewport = {\n  themeColor: 'black',\n}\nVersion History\nVersion\tChanges\nv14.0.0\tviewport and generateViewport introduced.\nNext Steps\nView all the Metadata API options.\nMetadata Files\nAPI documentation for the metadata file conventions.\nPrevious\ngenerateStaticParams\nNext\nheaders\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: headers | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/headers",
    "html": "API Reference\nFunctions\nheaders\nCopy page\nheaders\n\nheaders is an async function that allows you to read the HTTP incoming request headers from a Server Component.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { headers } from 'next/headers'\n \nexport default async function Page() {\n  const headersList = await headers()\n  const userAgent = headersList.get('user-agent')\n}\nReference\nParameters\n\nheaders does not take any parameters.\n\nReturns\n\nheaders returns a read-only Web Headers\n object.\n\nHeaders.entries()\n: Returns an iterator\n allowing to go through all key/value pairs contained in this object.\nHeaders.forEach()\n: Executes a provided function once for each key/value pair in this Headers object.\nHeaders.get()\n: Returns a String\n sequence of all the values of a header within a Headers object with a given name.\nHeaders.has()\n: Returns a boolean stating whether a Headers object contains a certain header.\nHeaders.keys()\n: Returns an iterator\n allowing you to go through all keys of the key/value pairs contained in this object.\nHeaders.values()\n: Returns an iterator\n allowing you to go through all values of the key/value pairs contained in this object.\nGood to know\nheaders is an asynchronous function that returns a promise. You must use async/await or React's use\n function.\nIn version 14 and earlier, headers was a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\nSince headers is read-only, you cannot set or delete the outgoing request headers.\nheaders is a Dynamic API whose returned values cannot be known ahead of time. Using it in will opt a route into dynamic rendering.\nExamples\nUsing the Authorization header\napp/page.js\nimport { headers } from 'next/headers'\n \nexport default async function Page() {\n  const authorization = (await headers()).get('authorization')\n  const res = await fetch('...', {\n    headers: { authorization }, // Forward the authorization header\n  })\n  const user = await res.json()\n \n  return <h1>{user.name}</h1>\n}\nVersion History\nVersion\tChanges\nv15.0.0-RC\theaders is now an async function. A codemod is available.\nv13.0.0\theaders introduced.\nPrevious\ngenerateViewport\nNext\nImageResponse\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: ImageResponse | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/image-response",
    "html": "API Reference\nFunctions\nImageResponse\nCopy page\nImageResponse\n\nThe ImageResponse constructor allows you to generate dynamic images using JSX and CSS. This is useful for generating social media images such as Open Graph images, Twitter cards, and more.\n\nReference\nParameters\n\nThe following parameters are available for ImageResponse:\n\nimport { ImageResponse } from 'next/og'\n \nnew ImageResponse(\n  element: ReactElement,\n  options: {\n    width?: number = 1200\n    height?: number = 630\n    emoji?: 'twemoji' | 'blobmoji' | 'noto' | 'openmoji' = 'twemoji',\n    fonts?: {\n      name: string,\n      data: ArrayBuffer,\n      weight: number,\n      style: 'normal' | 'italic'\n    }[]\n    debug?: boolean = false\n \n    // Options that will be passed to the HTTP response\n    status?: number = 200\n    statusText?: string\n    headers?: Record<string, string>\n  },\n)\n\nExamples are available in the Vercel OG Playground\n.\n\nSupported HTML and CSS features\n\nImageResponse supports common CSS properties including flexbox and absolute positioning, custom fonts, text wrapping, centering, and nested images.\n\nPlease refer to Satori’s documentation\n for a list of supported HTML and CSS features.\n\nBehavior\nImageResponse uses @vercel/og\n, Satori\n, and Resvg to convert HTML and CSS into PNG.\nOnly flexbox and a subset of CSS properties are supported. Advanced layouts (e.g. display: grid) will not work.\nMaximum bundle size of 500KB. The bundle size includes your JSX, CSS, fonts, images, and any other assets. If you exceed the limit, consider reducing the size of any assets or fetching at runtime.\nOnly ttf, otf, and woff font formats are supported. To maximize the font parsing speed, ttf or otf are preferred over woff.\nExamples\nRoute Handlers\n\nImageResponse can be used in Route Handlers to generate images dynamically at request time.\n\napp/api/route.js\nimport { ImageResponse } from 'next/og'\n \nexport async function GET() {\n  try {\n    return new ImageResponse(\n      (\n        <div\n          style={{\n            height: '100%',\n            width: '100%',\n            display: 'flex',\n            flexDirection: 'column',\n            alignItems: 'center',\n            justifyContent: 'center',\n            backgroundColor: 'white',\n            padding: '40px',\n          }}\n        >\n          <div\n            style={{\n              fontSize: 60,\n              fontWeight: 'bold',\n              color: 'black',\n              textAlign: 'center',\n            }}\n          >\n            Welcome to My Site\n          </div>\n          <div\n            style={{\n              fontSize: 30,\n              color: '#666',\n              marginTop: '20px',\n            }}\n          >\n            Generated with Next.js ImageResponse\n          </div>\n        </div>\n      ),\n      {\n        width: 1200,\n        height: 630,\n      }\n    )\n  } catch (e) {\n    console.log(`${e.message}`)\n    return new Response(`Failed to generate the image`, {\n      status: 500,\n    })\n  }\n}\nFile-based Metadata\n\nYou can use ImageResponse in a opengraph-image.tsx file to generate Open Graph images at build time or dynamically at request time.\n\napp/opengraph-image.tsx\nimport { ImageResponse } from 'next/og'\n \n// Image metadata\nexport const alt = 'My site'\nexport const size = {\n  width: 1200,\n  height: 630,\n}\n \nexport const contentType = 'image/png'\n \n// Image generation\nexport default async function Image() {\n  return new ImageResponse(\n    (\n      // ImageResponse JSX element\n      <div\n        style={{\n          fontSize: 128,\n          background: 'white',\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n        }}\n      >\n        My site\n      </div>\n    ),\n    // ImageResponse options\n    {\n      // For convenience, we can re-use the exported opengraph-image\n      // size config to also set the ImageResponse's width and height.\n      ...size,\n    }\n  )\n}\nCustom fonts\n\nYou can use custom fonts in your ImageResponse by providing a fonts array in the options.\n\napp/opengraph-image.tsx\nimport { ImageResponse } from 'next/og'\nimport { readFile } from 'node:fs/promises'\nimport { join } from 'node:path'\n \n// Image metadata\nexport const alt = 'My site'\nexport const size = {\n  width: 1200,\n  height: 630,\n}\n \nexport const contentType = 'image/png'\n \n// Image generation\nexport default async function Image() {\n  // Font loading, process.cwd() is Next.js project directory\n  const interSemiBold = await readFile(\n    join(process.cwd(), 'assets/Inter-SemiBold.ttf')\n  )\n \n  return new ImageResponse(\n    (\n      // ...\n    ),\n    // ImageResponse options\n    {\n      // For convenience, we can re-use the exported opengraph-image\n      // size config to also set the ImageResponse's width and height.\n      ...size,\n      fonts: [\n        {\n          name: 'Inter',\n          data: interSemiBold,\n          style: 'normal',\n          weight: 400,\n        },\n      ],\n    }\n  )\n}\nVersion History\nVersion\tChanges\nv14.0.0\tImageResponse moved from next/server to next/og\nv13.3.0\tImageResponse can be imported from next/server.\nv13.0.0\tImageResponse introduced via @vercel/og package.\nPrevious\nheaders\nNext\nNextRequest\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: NextRequest | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/next-request",
    "html": "API Reference\nFunctions\nNextRequest\nCopy page\nNextRequest\n\nNextRequest extends the Web Request API\n with additional convenience methods.\n\ncookies\n\nRead or mutate the Set-Cookie\n header of the request.\n\nset(name, value)\n\nGiven a name, set a cookie with the given value on the request.\n\n// Given incoming request /home\n// Set a cookie to hide the banner\n// request will have a `Set-Cookie:show-banner=false;path=/home` header\nrequest.cookies.set('show-banner', 'false')\nget(name)\n\nGiven a cookie name, return the value of the cookie. If the cookie is not found, undefined is returned. If multiple cookies are found, the first one is returned.\n\n// Given incoming request /home\n// { name: 'show-banner', value: 'false', Path: '/home' }\nrequest.cookies.get('show-banner')\ngetAll()\n\nGiven a cookie name, return the values of the cookie. If no name is given, return all cookies on the request.\n\n// Given incoming request /home\n// [\n//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },\n//   { name: 'experiments', value: 'winter-launch', Path: '/home' },\n// ]\nrequest.cookies.getAll('experiments')\n// Alternatively, get all cookies for the request\nrequest.cookies.getAll()\ndelete(name)\n\nGiven a cookie name, delete the cookie from the request.\n\n// Returns true for deleted, false is nothing is deleted\nrequest.cookies.delete('experiments')\nhas(name)\n\nGiven a cookie name, return true if the cookie exists on the request.\n\n// Returns true if cookie exists, false if it does not\nrequest.cookies.has('experiments')\nclear()\n\nRemove the Set-Cookie header from the request.\n\nrequest.cookies.clear()\nnextUrl\n\nExtends the native URL\n API with additional convenience methods, including Next.js specific properties.\n\n// Given a request to /home, pathname is /home\nrequest.nextUrl.pathname\n// Given a request to /home?name=lee, searchParams is { 'name': 'lee' }\nrequest.nextUrl.searchParams\n\nThe following options are available:\n\nProperty\tType\tDescription\nbasePath\tstring\tThe base path of the URL.\nbuildId\tstring | undefined\tThe build identifier of the Next.js application. Can be customized.\npathname\tstring\tThe pathname of the URL.\nsearchParams\tObject\tThe search parameters of the URL.\n\nNote: The internationalization properties from the Pages Router are not available for usage in the App Router. Learn more about internationalization with the App Router.\n\nVersion History\nVersion\tChanges\nv15.0.0\tip and geo removed.\nPrevious\nImageResponse\nNext\nNextResponse\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: NextResponse | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/next-response",
    "html": "API Reference\nFunctions\nNextResponse\nCopy page\nNextResponse\n\nNextResponse extends the Web Response API\n with additional convenience methods.\n\ncookies\n\nRead or mutate the Set-Cookie\n header of the response.\n\nset(name, value)\n\nGiven a name, set a cookie with the given value on the response.\n\n// Given incoming request /home\nlet response = NextResponse.next()\n// Set a cookie to hide the banner\nresponse.cookies.set('show-banner', 'false')\n// Response will have a `Set-Cookie:show-banner=false;path=/home` header\nreturn response\nget(name)\n\nGiven a cookie name, return the value of the cookie. If the cookie is not found, undefined is returned. If multiple cookies are found, the first one is returned.\n\n// Given incoming request /home\nlet response = NextResponse.next()\n// { name: 'show-banner', value: 'false', Path: '/home' }\nresponse.cookies.get('show-banner')\ngetAll()\n\nGiven a cookie name, return the values of the cookie. If no name is given, return all cookies on the response.\n\n// Given incoming request /home\nlet response = NextResponse.next()\n// [\n//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },\n//   { name: 'experiments', value: 'winter-launch', Path: '/home' },\n// ]\nresponse.cookies.getAll('experiments')\n// Alternatively, get all cookies for the response\nresponse.cookies.getAll()\ndelete(name)\n\nGiven a cookie name, delete the cookie from the response.\n\n// Given incoming request /home\nlet response = NextResponse.next()\n// Returns true for deleted, false if nothing is deleted\nresponse.cookies.delete('experiments')\njson()\n\nProduce a response with the given JSON body.\n\napp/api/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { NextResponse } from 'next/server'\n \nexport async function GET(request: Request) {\n  return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })\n}\nredirect()\n\nProduce a response that redirects to a URL\n.\n\nimport { NextResponse } from 'next/server'\n \nreturn NextResponse.redirect(new URL('/new', request.url))\n\nThe URL\n can be created and modified before being used in the NextResponse.redirect() method. For example, you can use the request.nextUrl property to get the current URL, and then modify it to redirect to a different URL.\n\nimport { NextResponse } from 'next/server'\n \n// Given an incoming request...\nconst loginUrl = new URL('/login', request.url)\n// Add ?from=/incoming-url to the /login URL\nloginUrl.searchParams.set('from', request.nextUrl.pathname)\n// And redirect to the new URL\nreturn NextResponse.redirect(loginUrl)\nrewrite()\n\nProduce a response that rewrites (proxies) the given URL\n while preserving the original URL.\n\nimport { NextResponse } from 'next/server'\n \n// Incoming request: /about, browser shows /about\n// Rewritten request: /proxy, browser shows /about\nreturn NextResponse.rewrite(new URL('/proxy', request.url))\nnext()\n\nThe next() method is useful for Proxy, as it allows you to return early and continue routing.\n\nimport { NextResponse } from 'next/server'\n \nreturn NextResponse.next()\n\nYou can also forward headers upstream when producing the response, using NextResponse.next({ request: { headers } }):\n\nimport { NextResponse } from 'next/server'\n \n// Given an incoming request...\nconst newHeaders = new Headers(request.headers)\n// Add a new header\nnewHeaders.set('x-version', '123')\n// Forward the modified request headers upstream\nreturn NextResponse.next({\n  request: {\n    // New request headers\n    headers: newHeaders,\n  },\n})\n\nThis forwards newHeaders upstream to the target page, route, or server action, and does not expose them to the client. While this pattern is useful for passing data upstream, it should be used with caution because the headers containing this data may be forwarded to external services.\n\nIn contrast, NextResponse.next({ headers }) is a shorthand for sending headers from proxy to the client. This is NOT good practice and should be avoided. Among other reasons because setting response headers like Content-Type, can override framework expectations (for example, the Content-Type used by Server Actions), leading to failed submissions or broken streaming responses.\n\nimport { type NextRequest, NextResponse } from 'next/server'\n \nasync function proxy(request: NextRequest) {\n  const headers = await injectAuth(request.headers)\n  // DO NOT forward headers like this\n  return NextResponse.next({ headers })\n}\n\nIn general, avoid copying all incoming request headers because doing so can leak sensitive data to clients or upstream services.\n\nPrefer a defensive approach by creating a subset of incoming request headers using an allow-list. For example, you might discard custom x-* headers and only forward known-safe headers:\n\nimport { type NextRequest, NextResponse } from 'next/server'\n \nfunction proxy(request: NextRequest) {\n  const incoming = new Headers(request.headers)\n  const forwarded = new Headers()\n \n  for (const [name, value] of incoming) {\n    const headerName = name.toLowerCase()\n    // Keep only known-safe headers, discard custom x-* and other sensitive ones\n    if (\n      !headerName.startsWith('x-') &&\n      headerName !== 'authorization' &&\n      headerName !== 'cookie'\n    ) {\n      // Preserve original header name casing\n      forwarded.set(name, value)\n    }\n  }\n \n  return NextResponse.next({\n    request: {\n      headers: forwarded,\n    },\n  })\n}\nPrevious\nNextRequest\nNext\nnotFound\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: notFound | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/not-found",
    "html": "API Reference\nFunctions\nnotFound\nCopy page\nnotFound\n\nThe notFound function allows you to render the not-found file within a route segment as well as inject a <meta name=\"robots\" content=\"noindex\" /> tag.\n\nnotFound()\n\nInvoking the notFound() function throws a NEXT_HTTP_ERROR_FALLBACK;404 error and terminates rendering of the route segment in which it was thrown. Specifying a not-found file allows you to gracefully handle such errors by rendering a Not Found UI within the segment.\n\napp/user/[id]/page.js\nimport { notFound } from 'next/navigation'\n \nasync function fetchUser(id) {\n  const res = await fetch('https://...')\n  if (!res.ok) return undefined\n  return res.json()\n}\n \nexport default async function Profile({ params }) {\n  const { id } = await params\n  const user = await fetchUser(id)\n \n  if (!user) {\n    notFound()\n  }\n \n  // ...\n}\n\nGood to know: notFound() does not require you to use return notFound() due to using the TypeScript never\n type.\n\nVersion History\nVersion\tChanges\nv13.0.0\tnotFound introduced.\nPrevious\nNextResponse\nNext\npermanentRedirect\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: permanentRedirect | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/permanentRedirect",
    "html": "API Reference\nFunctions\npermanentRedirect\nCopy page\npermanentRedirect\n\nThe permanentRedirect function allows you to redirect the user to another URL. permanentRedirect can be used in Server Components, Client Components, Route Handlers, and Server Actions.\n\nWhen used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will serve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 308 (Permanent) HTTP redirect response to the caller.\n\nIf a resource doesn't exist, you can use the notFound function instead.\n\nGood to know: If you prefer to return a 307 (Temporary) HTTP redirect instead of 308 (Permanent), you can use the redirect function instead.\n\nParameters\n\nThe permanentRedirect function accepts two arguments:\n\npermanentRedirect(path, type)\nParameter\tType\tDescription\npath\tstring\tThe URL to redirect to. Can be a relative or absolute path.\ntype\t'replace' (default) or 'push' (default in Server Actions)\tThe type of redirect to perform.\n\nBy default, permanentRedirect will use push (adding a new entry to the browser history stack) in Server Actions and replace (replacing the current URL in the browser history stack) everywhere else. You can override this behavior by specifying the type parameter.\n\nThe type parameter has no effect when used in Server Components.\n\nReturns\n\npermanentRedirect does not return a value.\n\nExample\n\nInvoking the permanentRedirect() function throws a NEXT_REDIRECT error and terminates rendering of the route segment in which it was thrown.\n\napp/team/[id]/page.js\nimport { permanentRedirect } from 'next/navigation'\n \nasync function fetchTeam(id) {\n  const res = await fetch('https://...')\n  if (!res.ok) return undefined\n  return res.json()\n}\n \nexport default async function Profile({ params }) {\n  const { id } = await params\n  const team = await fetchTeam(id)\n  if (!team) {\n    permanentRedirect('/login')\n  }\n \n  // ...\n}\n\nGood to know: permanentRedirect does not require you to use return permanentRedirect() as it uses the TypeScript never\n type.\n\nNext Steps\nredirect\nAPI Reference for the redirect function.\nPrevious\nnotFound\nNext\nredirect\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: redirect | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/redirect",
    "html": "API Reference\nFunctions\nredirect\nCopy page\nredirect\n\nThe redirect function allows you to redirect the user to another URL. redirect can be used while rendering in Server and Client Components, Route Handlers, and Server Actions.\n\nWhen used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will serve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 307 HTTP redirect response to the caller.\n\nIf a resource doesn't exist, you can use the notFound function instead.\n\nReference\nParameters\n\nThe redirect function accepts two arguments:\n\nredirect(path, type)\nParameter\tType\tDescription\npath\tstring\tThe URL to redirect to. Can be a relative or absolute path.\ntype\t'replace' (default) or 'push' (default in Server Actions)\tThe type of redirect to perform.\n\nBy default, redirect will use push (adding a new entry to the browser history stack) in Server Actions and replace (replacing the current URL in the browser history stack) everywhere else. You can override this behavior by specifying the type parameter.\n\nThe RedirectType object contains the available options for the type parameter.\n\nimport { redirect, RedirectType } from 'next/navigation'\n \nredirect('/redirect-to', RedirectType.replace)\n// or\nredirect('/redirect-to', RedirectType.push)\n\nThe type parameter has no effect when used in Server Components.\n\nReturns\n\nredirect does not return a value.\n\nBehavior\nIn Server Actions and Route Handlers, redirect should be called outside the try block when using try/catch statements.\nIf you prefer to return a 308 (Permanent) HTTP redirect instead of 307 (Temporary), you can use the permanentRedirect function instead.\nredirect throws an error so it should be called outside the try block when using try/catch statements.\nredirect can be called in Client Components during the rendering process but not in event handlers. You can use the useRouter hook instead.\nredirect also accepts absolute URLs and can be used to redirect to external links.\nIf you'd like to redirect before the render process, use next.config.js or Proxy.\nExample\nServer Component\n\nInvoking the redirect() function throws a NEXT_REDIRECT error and terminates rendering of the route segment in which it was thrown.\n\napp/team/[id]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { redirect } from 'next/navigation'\n \nasync function fetchTeam(id: string) {\n  const res = await fetch('https://...')\n  if (!res.ok) return undefined\n  return res.json()\n}\n \nexport default async function Profile({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n  const team = await fetchTeam(id)\n \n  if (!team) {\n    redirect('/login')\n  }\n \n  // ...\n}\n\nGood to know: redirect does not require you to use return redirect() as it uses the TypeScript never\n type.\n\nClient Component\n\nredirect can be directly used in a Client Component.\n\ncomponents/client-redirect.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { redirect, usePathname } from 'next/navigation'\n \nexport function ClientRedirect() {\n  const pathname = usePathname()\n \n  if (pathname.startsWith('/admin') && !pathname.includes('/login')) {\n    redirect('/admin/login')\n  }\n \n  return <div>Login Page</div>\n}\n\nGood to know: When using redirect in a Client Component on initial page load during Server-Side Rendering (SSR), it will perform a server-side redirect.\n\nredirect can be used in a Client Component through a Server Action. If you need to use an event handler to redirect the user, you can use the useRouter hook.\n\napp/client-redirect.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { navigate } from './actions'\n \nexport function ClientRedirect() {\n  return (\n    <form action={navigate}>\n      <input type=\"text\" name=\"id\" />\n      <button>Submit</button>\n    </form>\n  )\n}\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { redirect } from 'next/navigation'\n \nexport async function navigate(data: FormData) {\n  redirect(`/posts/${data.get('id')}`)\n}\nFAQ\nWhy does redirect use 307 and 308?\n\nWhen using redirect() you may notice that the status codes used are 307 for a temporary redirect, and 308 for a permanent redirect. While traditionally a 302 was used for a temporary redirect, and a 301 for a permanent redirect, many browsers changed the request method of the redirect, from a POST to GET request when using a 302, regardless of the origins request method.\n\nTaking the following example of a redirect from /users to /people, if you make a POST request to /users to create a new user, and are conforming to a 302 temporary redirect, the request method will be changed from a POST to a GET request. This doesn't make sense, as to create a new user, you should be making a POST request to /people, and not a GET request.\n\nThe introduction of the 307 status code means that the request method is preserved as POST.\n\n302 - Temporary redirect, will change the request method from POST to GET\n307 - Temporary redirect, will preserve the request method as POST\n\nThe redirect() method uses a 307 by default, instead of a 302 temporary redirect, meaning your requests will always be preserved as POST requests.\n\nLearn more\n about HTTP Redirects.\n\nVersion History\nVersion\tChanges\nv13.0.0\tredirect introduced.\nNext Steps\npermanentRedirect\nAPI Reference for the permanentRedirect function.\nPrevious\npermanentRedirect\nNext\nrefresh\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: refresh | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/refresh",
    "html": "API Reference\nFunctions\nrefresh\nCopy page\nrefresh\n\nrefresh allows you to refresh the client router from within a Server Action.\n\nUsage\n\nrefresh can only be called from within Server Actions. It cannot be used in Route Handlers, Client Components, or any other context.\n\nParameters\nrefresh(): void;\nReturns\n\nrefresh does not return a value.\n\nExamples\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { refresh } from 'next/cache'\nimport { redirect } from 'next/navigation'\n \nexport async function createPost(formData: FormData) {\n  const title = formData.get('title')\n  const content = formData.get('content')\n \n  // Create the post in your database\n  const post = await db.post.create({\n    data: { title, content },\n  })\n \n  refresh()\n}\nError when used outside Server Actions\napp/api/posts/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { refresh } from 'next/cache'\n \nexport async function POST() {\n  // This will throw an error\n  refresh()\n}\nPrevious\nredirect\nNext\nrevalidatePath\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: revalidatePath | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/revalidatePath",
    "html": "API Reference\nFunctions\nrevalidatePath\nCopy page\nrevalidatePath\n\nrevalidatePath allows you to invalidate cached data on-demand for a specific path.\n\nUsage\n\nrevalidatePath can be called in Server Functions and Route Handlers.\n\nrevalidatePath cannot be called in Client Components or Proxy, as it only works in server environments.\n\nGood to know:\n\nServer Functions: Updates the UI immediately (if viewing the affected path). Currently, it also causes all previously visited pages to refresh when navigated to again. This behavior is temporary and will be updated in the future to apply only to the specific path.\nRoute Handlers: Marks the path for revalidation. The revalidation is done on the next visit to the specified path. This means calling revalidatePath with a dynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when the path is next visited.\nParameters\nrevalidatePath(path: string, type?: 'page' | 'layout'): void;\npath: Either a route pattern corresponding to the data you want to revalidate, for example /product/[slug], or a specific URL, /product/123. Do not append /page or /layout, use the type parameter instead. Must not exceed 1024 characters. This value is case-sensitive.\ntype: (optional) 'page' or 'layout' string to change the type of path to revalidate. If path contains a dynamic segment, for example /product/[slug], this parameter is required. If path is a specific URL, /product/1, omit type.\n\nUse a specific URL when you want to refresh a single page. Use a route pattern plus type to refresh multiple URLs.\n\nReturns\n\nrevalidatePath does not return a value.\n\nWhat can be invalidated\n\nThe path parameter can point to pages, layouts, or route handlers:\n\nPages: Invalidates the specific page\nLayouts: Invalidates the layout (the layout.tsx at that segment), all nested layouts beneath it, and all pages beneath them\nRoute Handlers: Invalidates Data Cache entries accessed within route handlers. For example revalidatePath(\"/api/data\") invalidates this GET handler:\napp/api/data/route.ts\nexport async function GET() {\n  const data = await fetch('https://api.vercel.app/blog', {\n    cache: 'force-cache',\n  })\n \n  return Response.json(await data.json())\n}\nRelationship with revalidateTag and updateTag\n\nrevalidatePath, revalidateTag and updateTag serve different purposes:\n\nrevalidatePath: Invalidates a specific page or layout path\nrevalidateTag: Marks data with specific tags as stale. Applies across all pages that use those tags\nupdateTag: Expires data with specific tags. Applies across all pages that use those tags\n\nWhen you call revalidatePath, only the specified path gets fresh data on the next visit. Other pages that use the same data tags will continue to serve cached data until those specific tags are also revalidated:\n\n// Page A: /blog\nconst posts = await fetch('https://api.vercel.app/blog', {\n  next: { tags: ['posts'] },\n})\n \n// Page B: /dashboard\nconst recentPosts = await fetch('https://api.vercel.app/blog?limit=5', {\n  next: { tags: ['posts'] },\n})\n\nAfter calling revalidatePath('/blog'):\n\nPage A (/blog): Shows fresh data (page re-rendered)\nPage B (/dashboard): Still shows stale data (cache tag 'posts' not invalidated)\n\nLearn about the difference between revalidateTag and updateTag.\n\nBuilding revalidation utilities\n\nrevalidatePath and updateTag are complementary primitives that are often used together in utility functions to ensure comprehensive data consistency across your application:\n\n'use server'\n \nimport { revalidatePath, updateTag } from 'next/cache'\n \nexport async function updatePost() {\n  await updatePostInDatabase()\n \n  revalidatePath('/blog') // Refresh the blog page\n  updateTag('posts') // Refresh all pages using 'posts' tag\n}\n\nThis pattern ensures that both the specific page and any other pages using the same data remain consistent.\n\nExamples\nRevalidating a specific URL\nimport { revalidatePath } from 'next/cache'\nrevalidatePath('/blog/post-1')\n\nThis will invalidate one specific URL for revalidation on the next page visit.\n\nRevalidating a Page path\nimport { revalidatePath } from 'next/cache'\nrevalidatePath('/blog/[slug]', 'page')\n// or with route groups\nrevalidatePath('/(main)/blog/[slug]', 'page')\n\nThis will invalidate any URL that matches the provided page file for revalidation on the next page visit. This will not invalidate pages beneath the specific page. For example, /blog/[slug] won't invalidate /blog/[slug]/[author].\n\nRevalidating a Layout path\nimport { revalidatePath } from 'next/cache'\nrevalidatePath('/blog/[slug]', 'layout')\n// or with route groups\nrevalidatePath('/(main)/post/[slug]', 'layout')\n\nThis will invalidate any URL that matches the provided layout file for revalidation on the next page visit. This will cause pages beneath with the same layout to be invalidated and revalidated on the next visit. For example, in the above case, /blog/[slug]/[another] would also be invalidated and revalidated on the next visit.\n\nRevalidating all data\nimport { revalidatePath } from 'next/cache'\n \nrevalidatePath('/', 'layout')\n\nThis will purge the Client-side Router Cache, and invalidate the Data Cache for revalidation on the next page visit.\n\nServer Function\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { revalidatePath } from 'next/cache'\n \nexport default async function submit() {\n  await submitForm()\n  revalidatePath('/')\n}\nRoute Handler\napp/api/revalidate/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { revalidatePath } from 'next/cache'\nimport type { NextRequest } from 'next/server'\n \nexport async function GET(request: NextRequest) {\n  const path = request.nextUrl.searchParams.get('path')\n \n  if (path) {\n    revalidatePath(path)\n    return Response.json({ revalidated: true, now: Date.now() })\n  }\n \n  return Response.json({\n    revalidated: false,\n    now: Date.now(),\n    message: 'Missing path to revalidate',\n  })\n}\nPrevious\nrefresh\nNext\nrevalidateTag\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: revalidateTag | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/revalidateTag",
    "html": "API Reference\nFunctions\nrevalidateTag\nCopy page\nrevalidateTag\n\nrevalidateTag allows you to invalidate cached data on-demand for a specific cache tag.\n\nThis function is ideal for content where a slight delay in updates is acceptable, such as blog posts, product catalogs, or documentation. Users receive stale content while fresh data loads in the background.\n\nUsage\n\nrevalidateTag can be called in Server Functions and Route Handlers.\n\nrevalidateTag cannot be called in Client Components or Proxy, as it only works in server environments.\n\nRevalidation Behavior\n\nThe revalidation behavior depends on whether you provide the second argument:\n\nWith profile=\"max\" (recommended): The tag entry is marked as stale, and the next time a resource with that tag is visited, it will use stale-while-revalidate semantics. This means the stale content is served while fresh content is fetched in the background.\nWith a custom cache life profile: For advanced usage, you can specify any cache life profile that your application has defined, allowing for custom revalidation behaviors tailored to your specific caching requirements.\nWithout the second argument (deprecated): The tag entry is expired immediately, and the next request to that resource will be a blocking revalidate/cache miss. This behavior is now deprecated, and you should either use profile=\"max\" or migrate to updateTag.\n\nGood to know: When using profile=\"max\", revalidateTag marks tagged data as stale, but fresh data is only fetched when pages using that tag are next visited. This means calling revalidateTag will not immediately trigger many revalidations at once. The invalidation only happens when any page using that tag is next visited.\n\nParameters\nrevalidateTag(tag: string, profile?: string | { expire?: number }): void;\ntag: A string representing the cache tag associated with the data you want to revalidate. Must not exceed 256 characters. This value is case-sensitive.\nprofile: A string that specifies the revalidation behavior. The recommended value is \"max\" which provides stale-while-revalidate semantics, or any of the other default or custom profiles defined in cacheLife. Alternatively, you can pass an object with an expire property for custom expiration behavior.\n\nTags must first be assigned to cached data. You can do this in two ways:\n\nUsing the next.tags option with fetch for caching external API requests:\nfetch(url, { next: { tags: ['posts'] } })\nUsing cacheTag inside cached functions or components with the 'use cache' directive:\nimport { cacheTag } from 'next/cache'\n \nasync function getData() {\n  'use cache'\n  cacheTag('posts')\n  // ...\n}\nReturns\n\nrevalidateTag does not return a value.\n\nRelationship with revalidatePath\n\nrevalidateTag invalidates data with specific tags across all pages that use those tags, while revalidatePath invalidates specific page or layout paths.\n\nGood to know: These functions serve different purposes and may need to be used together for comprehensive data consistency. For detailed examples and considerations, see relationship with revalidateTag and updateTag for more information.\n\nExamples\n\nThe following examples demonstrate how to use revalidateTag in different contexts. In both cases, we're using profile=\"max\" to mark data as stale and use stale-while-revalidate semantics, which is the recommended approach for most use cases.\n\nServer Action\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { revalidateTag } from 'next/cache'\n \nexport default async function submit() {\n  await addPost()\n  revalidateTag('posts', 'max')\n}\nRoute Handler\napp/api/revalidate/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextRequest } from 'next/server'\nimport { revalidateTag } from 'next/cache'\n \nexport async function GET(request: NextRequest) {\n  const tag = request.nextUrl.searchParams.get('tag')\n \n  if (tag) {\n    revalidateTag(tag, 'max')\n    return Response.json({ revalidated: true, now: Date.now() })\n  }\n \n  return Response.json({\n    revalidated: false,\n    now: Date.now(),\n    message: 'Missing tag to revalidate',\n  })\n}\n\nGood to know: For webhooks or third-party services that need immediate expiration, you can pass { expire: 0 } as the second argument: revalidateTag(tag, { expire: 0 }). This pattern is necessary when external systems call your Route Handlers and require data to expire immediately. For all other cases, it's recommended to use updateTag in Server Actions for immediate updates instead.\n\nPrevious\nrevalidatePath\nNext\nunauthorized\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: unauthorized | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/unauthorized",
    "html": "API Reference\nFunctions\nunauthorized\nCopy page\nunauthorized\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nThe unauthorized function throws an error that renders a Next.js 401 error page. It's useful for handling authorization errors in your application. You can customize the UI using the unauthorized.js file.\n\nTo start using unauthorized, enable the experimental authInterrupts configuration option in your next.config.js file:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    authInterrupts: true,\n  },\n}\n \nexport default nextConfig\n\nunauthorized can be invoked in Server Components, Server Actions, and Route Handlers.\n\napp/dashboard/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\n \nexport default async function DashboardPage() {\n  const session = await verifySession()\n \n  if (!session) {\n    unauthorized()\n  }\n \n  // Render the dashboard for authenticated users\n  return (\n    <main>\n      <h1>Welcome to the Dashboard</h1>\n      <p>Hi, {session.user.name}.</p>\n    </main>\n  )\n}\nGood to know\nThe unauthorized function cannot be called in the root layout.\nExamples\nDisplaying login UI to unauthenticated users\n\nYou can use unauthorized function to display the unauthorized.js file with a login UI.\n\napp/dashboard/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\n \nexport default async function DashboardPage() {\n  const session = await verifySession()\n \n  if (!session) {\n    unauthorized()\n  }\n \n  return <div>Dashboard</div>\n}\napp/unauthorized.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Login from '@/app/components/Login'\n \nexport default function UnauthorizedPage() {\n  return (\n    <main>\n      <h1>401 - Unauthorized</h1>\n      <p>Please log in to access this page.</p>\n      <Login />\n    </main>\n  )\n}\nMutations with Server Actions\n\nYou can invoke unauthorized in Server Actions to ensure only authenticated users can perform specific mutations.\n\napp/actions/update-profile.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\nimport db from '@/app/lib/db'\n \nexport async function updateProfile(data: FormData) {\n  const session = await verifySession()\n \n  // If the user is not authenticated, return a 401\n  if (!session) {\n    unauthorized()\n  }\n \n  // Proceed with mutation\n  // ...\n}\nFetching data with Route Handlers\n\nYou can use unauthorized in Route Handlers to ensure only authenticated users can access the endpoint.\n\napp/api/profile/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { NextRequest, NextResponse } from 'next/server'\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\n \nexport async function GET(req: NextRequest): Promise<NextResponse> {\n  // Verify the user's session\n  const session = await verifySession()\n \n  // If no session exists, return a 401 and render unauthorized.tsx\n  if (!session) {\n    unauthorized()\n  }\n \n  // Fetch data\n  // ...\n}\nVersion History\nVersion\tChanges\nv15.1.0\tunauthorized introduced.\nNext Steps\nunauthorized.js\nAPI reference for the unauthorized.js special file.\nPrevious\nrevalidateTag\nNext\nunstable_cache\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: unstable_cache | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/unstable_cache",
    "html": "API Reference\nFunctions\nunstable_cache\nCopy page\nunstable_cache\n\nWarning: This API will be replaced by use cache when it reaches stability.\n\nunstable_cache allows you to cache the results of expensive operations, like database queries, and reuse them across multiple requests.\n\nimport { getUser } from './data';\nimport { unstable_cache } from 'next/cache';\n \nconst getCachedUser = unstable_cache(\n  async (id) => getUser(id),\n  ['my-app-user']\n);\n \nexport default async function Component({ userID }) {\n  const user = await getCachedUser(userID);\n  ...\n}\n\nGood to know:\n\nAccessing dynamic data sources such as headers or cookies inside a cache scope is not supported. If you need this data inside a cached function use headers outside of the cached function and pass the required dynamic data in as an argument.\nThis API uses Next.js' built-in Data Cache to persist the result across requests and deployments.\nParameters\nconst data = unstable_cache(fetchData, keyParts, options)()\nfetchData: This is an asynchronous function that fetches the data you want to cache. It must be a function that returns a Promise.\nkeyParts: This is an extra array of keys that further adds identification to the cache. By default, unstable_cache already uses the arguments and the stringified version of your function as the cache key. It is optional in most cases; the only time you need to use it is when you use external variables without passing them as parameters. However, it is important to add closures used within the function if you do not pass them as parameters.\noptions: This is an object that controls how the cache behaves. It can contain the following properties:\ntags: An array of tags that can be used to control cache invalidation. Next.js will not use this to uniquely identify the function.\nrevalidate: The number of seconds after which the cache should be revalidated. Omit or pass false to cache indefinitely or until matching revalidateTag() or revalidatePath() methods are called.\nReturns\n\nunstable_cache returns a function that when invoked, returns a Promise that resolves to the cached data. If the data is not in the cache, the provided function will be invoked, and its result will be cached and returned.\n\nExample\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { unstable_cache } from 'next/cache'\n \nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ userId: string }>\n}) {\n  const { userId } = await params\n  const getCachedUser = unstable_cache(\n    async () => {\n      return { id: userId }\n    },\n    [userId], // add the user ID to the cache key\n    {\n      tags: ['users'],\n      revalidate: 60,\n    }\n  )\n \n  //...\n}\nVersion History\nVersion\tChanges\nv14.0.0\tunstable_cache introduced.\nPrevious\nunauthorized\nNext\nunstable_noStore\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: unstable_noStore | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/unstable_noStore",
    "html": "API Reference\nFunctions\nunstable_noStore\nCopy page\nunstable_noStore\nThis is a legacy API and no longer recommended. It's still supported for backward compatibility.\n\nIn version 15, we recommend using connection instead of unstable_noStore.\n\nunstable_noStore can be used to declaratively opt out of static rendering and indicate a particular component should not be cached.\n\nimport { unstable_noStore as noStore } from 'next/cache';\n \nexport default async function ServerComponent() {\n  noStore();\n  const result = await db.query(...);\n  ...\n}\n\nGood to know:\n\nunstable_noStore is equivalent to cache: 'no-store' on a fetch\nunstable_noStore is preferred over export const dynamic = 'force-dynamic' as it is more granular and can be used on a per-component basis\nUsing unstable_noStore inside unstable_cache will not opt out of static generation. Instead, it will defer to the cache configuration to determine whether to cache the result or not.\nUsage\n\nIf you prefer not to pass additional options to fetch, like cache: 'no-store', next: { revalidate: 0 } or in cases where fetch is not available, you can use noStore() as a replacement for all of these use cases.\n\nimport { unstable_noStore as noStore } from 'next/cache';\n \nexport default async function ServerComponent() {\n  noStore();\n  const result = await db.query(...);\n  ...\n}\nVersion History\nVersion\tChanges\nv15.0.0\tunstable_noStore deprecated for connection.\nv14.0.0\tunstable_noStore introduced.\nPrevious\nunstable_cache\nNext\nunstable_rethrow\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: unstable_rethrow | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow",
    "html": "API Reference\nFunctions\nunstable_rethrow\nCopy page\nunstable_rethrow\nThis feature is currently unstable and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nunstable_rethrow can be used to avoid catching internal errors thrown by Next.js when attempting to handle errors thrown in your application code.\n\nFor example, calling the notFound function will throw an internal Next.js error and render the not-found.js component. However, if used inside the try block of a try/catch statement, the error will be caught, preventing not-found.js from rendering:\n\n@/app/ui/component.tsx\nimport { notFound } from 'next/navigation'\n \nexport default async function Page() {\n  try {\n    const post = await fetch('https://.../posts/1').then((res) => {\n      if (res.status === 404) notFound()\n      if (!res.ok) throw new Error(res.statusText)\n      return res.json()\n    })\n  } catch (err) {\n    console.error(err)\n  }\n}\n\nYou can use unstable_rethrow API to re-throw the internal error and continue with the expected behavior:\n\n@/app/ui/component.tsx\nimport { notFound, unstable_rethrow } from 'next/navigation'\n \nexport default async function Page() {\n  try {\n    const post = await fetch('https://.../posts/1').then((res) => {\n      if (res.status === 404) notFound()\n      if (!res.ok) throw new Error(res.statusText)\n      return res.json()\n    })\n  } catch (err) {\n    unstable_rethrow(err)\n    console.error(err)\n  }\n}\n\nThe following Next.js APIs rely on throwing an error which should be rethrown and handled by Next.js itself:\n\nnotFound()\nredirect()\npermanentRedirect()\n\nIf a route segment is marked to throw an error unless it's static, a Dynamic API call will also throw an error that should similarly not be caught by the developer. Note that Partial Prerendering (PPR) affects this behavior as well. These APIs are:\n\ncookies\nheaders\nsearchParams\nfetch(..., { cache: 'no-store' })\nfetch(..., { next: { revalidate: 0 } })\n\nGood to know:\n\nThis method should be called at the top of the catch block, passing the error object as its only argument. It can also be used within a .catch handler of a promise.\nYou may be able to avoid using unstable_rethrow if you encapsulate your API calls that throw and let the caller handle the exception.\nOnly use unstable_rethrow if your caught exceptions may include both application errors and framework-controlled exceptions (like redirect() or notFound()).\nAny resource cleanup (like clearing intervals, timers, etc) would have to either happen prior to the call to unstable_rethrow or within a finally block.\nPrevious\nunstable_noStore\nNext\nupdateTag\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: updateTag | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/updateTag",
    "html": "API Reference\nFunctions\nupdateTag\nCopy page\nupdateTag\n\nupdateTag allows you to update cached data on-demand for a specific cache tag from within Server Actions.\n\nThis function is designed for read-your-own-writes scenarios, where a user makes a change (like creating a post), and the UI immediately shows the change, rather than stale data.\n\nUsage\n\nupdateTag can only be called from within Server Actions. It cannot be used in Route Handlers, Client Components, or any other context.\n\nIf you need to invalidate cache tags in Route Handlers or other contexts, use revalidateTag instead.\n\nGood to know: updateTag immediately expires the cached data for the specified tag. The next request will wait to fetch fresh data rather than serving stale content from the cache, ensuring users see their changes immediately.\n\nParameters\nupdateTag(tag: string): void;\ntag: A string representing the cache tag associated with the data you want to update. Must not exceed 256 characters. This value is case-sensitive.\n\nTags must first be assigned to cached data. You can do this in two ways:\n\nUsing the next.tags option with fetch for caching external API requests:\nfetch(url, { next: { tags: ['posts'] } })\nUsing cacheTag inside cached functions or components with the 'use cache' directive:\nimport { cacheTag } from 'next/cache'\n \nasync function getData() {\n  'use cache'\n  cacheTag('posts')\n  // ...\n}\nReturns\n\nupdateTag does not return a value.\n\nDifferences from revalidateTag\n\nWhile both updateTag and revalidateTag invalidate cached data, they serve different purposes:\n\nupdateTag:\n\nCan only be used in Server Actions\nNext request waits for fresh data (no stale content served)\nDesigned for read-your-own-writes scenarios\n\nrevalidateTag:\n\nCan be used in Server Actions and Route Handlers\nWith profile=\"max\" (recommended): Serves cached data while fetching fresh data in the background (stale-while-revalidate)\nWith custom profile: Can be configured to any cache life profile for advanced usage\nWithout profile: legacy behavior which is equivalent to updateTag\nExamples\nServer Action with Read-Your-Own-Writes\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { updateTag } from 'next/cache'\nimport { redirect } from 'next/navigation'\n \nexport async function createPost(formData: FormData) {\n  const title = formData.get('title')\n  const content = formData.get('content')\n \n  // Create the post in your database\n  const post = await db.post.create({\n    data: { title, content },\n  })\n \n  // Invalidate cache tags so the new post is immediately visible\n  // 'posts' tag: affects any page that displays a list of posts\n  updateTag('posts')\n  // 'post-{id}' tag: affects the individual post detail page\n  updateTag(`post-${post.id}`)\n \n  // Redirect to the new post - user will see fresh data, not cached\n  redirect(`/posts/${post.id}`)\n}\nError when used outside Server Actions\napp/api/posts/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport { updateTag } from 'next/cache'\n \nexport async function POST() {\n  // This will throw an error\n  updateTag('posts')\n  // Error: updateTag can only be called from within a Server Action\n \n  // Use revalidateTag instead in Route Handlers\n  revalidateTag('posts', 'max')\n}\nWhen to use updateTag\n\nUse updateTag when:\n\nYou're in a Server Action\nYou need immediate cache invalidation for read-your-own-writes\nYou want to ensure the next request sees updated data\n\nUse revalidateTag instead when:\n\nYou're in a Route Handler or other non-action context\nYou want stale-while-revalidate semantics\nYou're building a webhook or API endpoint for cache invalidation\nRelated\nrevalidateTag - For invalidating tags in Route Handlers\nrevalidatePath - For invalidating specific paths\nPrevious\nunstable_rethrow\nNext\nuseLinkStatus\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: useLinkStatus | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/use-link-status",
    "html": "API Reference\nFunctions\nuseLinkStatus\nCopy page\nuseLinkStatus\n\nThe useLinkStatus hook lets you track the pending state of a <Link>. Use it for subtle, inline feedback, for example a shimmer effect over the clicked link, while navigation completes. Prefer route-level fallbacks with loading.js, and prefetching for instant transitions.\n\nuseLinkStatus is useful when:\n\nPrefetching is disabled or in progress meaning navigation is blocked.\nThe destination route is dynamic and doesn't include a loading.js file that would allow an instant navigation.\napp/hint.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport Link from 'next/link'\nimport { useLinkStatus } from 'next/link'\n \nfunction Hint() {\n  const { pending } = useLinkStatus()\n  return (\n    <span aria-hidden className={`link-hint ${pending ? 'is-pending' : ''}`} />\n  )\n}\n \nexport default function Header() {\n  return (\n    <header>\n      <Link href=\"/dashboard\" prefetch={false}>\n        <span className=\"label\">Dashboard</span> <Hint />\n      </Link>\n    </header>\n  )\n}\n\nGood to know:\n\nuseLinkStatus must be used within a descendant component of a Link component\nThe hook is most useful when prefetch={false} is set on the Link component\nIf the linked route has been prefetched, the pending state will be skipped\nWhen clicking multiple links in quick succession, only the last link's pending state is shown\nThis hook is not supported in the Pages Router and always returns { pending: false }\nInline indicators can easily introduce layout shifts. Prefer a fixed-size, always-rendered hint element and toggle its opacity, or use an animation.\nYou might not need useLinkStatus\n\nBefore adding inline feedback, consider if:\n\nThe destination is static and prefetched in production, so the pending phase may be skipped.\nThe route has a loading.js file, enabling instant transitions with a route-level fallback.\n\nNavigation is typically fast. Use useLinkStatus as a quick patch when you identify a slow transition, then iterate to fix the root cause with prefetching or a loading.js fallback.\n\nParameters\nconst { pending } = useLinkStatus()\n\nuseLinkStatus does not take any parameters.\n\nReturns\n\nuseLinkStatus returns an object with a single property:\n\nProperty\tType\tDescription\npending\tboolean\ttrue before history updates, false after\nExample\nInline link hint\n\nAdd a subtle, fixed-size hint that doesn’t affect layout to confirm a click when prefetching hasn’t completed.\n\napp/components/loading-indicator.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useLinkStatus } from 'next/link'\n \nexport default function LoadingIndicator() {\n  const { pending } = useLinkStatus()\n  return (\n    <span aria-hidden className={`link-hint ${pending ? 'is-pending' : ''}`} />\n  )\n}\napp/shop/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\nimport LoadingIndicator from './components/loading-indicator'\n \nconst links = [\n  { href: '/shop/electronics', label: 'Electronics' },\n  { href: '/shop/clothing', label: 'Clothing' },\n  { href: '/shop/books', label: 'Books' },\n]\n \nfunction Menubar() {\n  return (\n    <div>\n      {links.map((link) => (\n        <Link key={link.label} href={link.href}>\n          <span className=\"label\">{link.label}</span> <LoadingIndicator />\n        </Link>\n      ))}\n    </div>\n  )\n}\n \nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <div>\n      <Menubar />\n      {children}\n    </div>\n  )\n}\nGracefully handling fast navigation\n\nIf the navigation to a new route is fast, users may see an unnecessary flash of the hint. One way to improve the user experience and only show the hint when the navigation takes time to complete is to add an initial animation delay (e.g. 100ms) and start the animation as invisible (e.g. opacity: 0).\n\napp/styles/global.css\n.link-hint {\n  display: inline-block;\n  width: 0.6em;\n  height: 0.6em;\n  margin-left: 0.25rem;\n  border-radius: 9999px;\n  background: currentColor;\n  opacity: 0;\n  visibility: hidden; /* reserve space without showing the hint */\n}\n \n.link-hint.is-pending {\n  /* Animation 1: fade in after 100ms and keep final opacity */\n  /* Animation 2: subtle pulsing while pending */\n  visibility: visible;\n  animation-name: fadeIn, pulse;\n  animation-duration: 200ms, 1s;\n  /* Appear only if navigation actually takes time */\n  animation-delay: 100ms, 100ms;\n  animation-timing-function: ease, ease-in-out;\n  animation-iteration-count: 1, infinite;\n  animation-fill-mode: forwards, none;\n}\n \n@keyframes fadeIn {\n  to {\n    opacity: 0.35;\n  }\n}\n@keyframes pulse {\n  50% {\n    opacity: 0.15;\n  }\n}\nVersion History\nVersion\tChanges\nv15.3.0\tuseLinkStatus introduced.\nNext Steps\nLearn more about the features mentioned in this page by reading the API Reference.\nLink Component\nEnable fast client-side navigation with the built-in `next/link` component.\nloading.js\nAPI reference for the loading.js file.\nPrevious\nupdateTag\nNext\nuseParams\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: useParams | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/use-params",
    "html": "API Reference\nFunctions\nuseParams\nCopy page\nuseParams\n\nuseParams is a Client Component hook that lets you read a route's dynamic params filled in by the current URL.\n\napp/example-client-component.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useParams } from 'next/navigation'\n \nexport default function ExampleClientComponent() {\n  const params = useParams<{ tag: string; item: string }>()\n \n  // Route -> /shop/[tag]/[item]\n  // URL -> /shop/shoes/nike-air-max-97\n  // `params` -> { tag: 'shoes', item: 'nike-air-max-97' }\n  console.log(params)\n \n  return '...'\n}\nParameters\nconst params = useParams()\n\nuseParams does not take any parameters.\n\nReturns\n\nuseParams returns an object containing the current route's filled in dynamic parameters.\n\nEach property in the object is an active dynamic segment.\nThe properties name is the segment's name, and the properties value is what the segment is filled in with.\nThe properties value will either be a string or array of string's depending on the type of dynamic segment.\nIf the route contains no dynamic parameters, useParams returns an empty object.\nIf used in Pages Router, useParams will return null on the initial render and updates with properties following the rules above once the router is ready.\n\nFor example:\n\nRoute\tURL\tuseParams()\napp/shop/page.js\t/shop\t{}\napp/shop/[slug]/page.js\t/shop/1\t{ slug: '1' }\napp/shop/[tag]/[item]/page.js\t/shop/1/2\t{ tag: '1', item: '2' }\napp/shop/[...slug]/page.js\t/shop/1/2\t{ slug: ['1', '2'] }\nVersion History\nVersion\tChanges\nv13.3.0\tuseParams introduced.\nPrevious\nuseLinkStatus\nNext\nusePathname\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: usePathname | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/use-pathname",
    "html": "API Reference\nFunctions\nusePathname\nCopy page\nusePathname\n\nusePathname is a Client Component hook that lets you read the current URL's pathname.\n\nGood to know: When cacheComponents is enabled usePathname may require a Suspense boundary around it if your route has a dynamic param. If you use generateStaticParams the Suspense boundary is optional\n\napp/example-client-component.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { usePathname } from 'next/navigation'\n \nexport default function ExampleClientComponent() {\n  const pathname = usePathname()\n  return <p>Current pathname: {pathname}</p>\n}\n\nusePathname intentionally requires using a Client Component. It's important to note Client Components are not a de-optimization. They are an integral part of the Server Components architecture.\n\nFor example, a Client Component with usePathname will be rendered into HTML on the initial page load. When navigating to a new route, this component does not need to be re-fetched. Instead, the component is downloaded once (in the client JavaScript bundle), and re-renders based on the current state.\n\nGood to know:\n\nReading the current URL from a Server Component is not supported. This design is intentional to support layout state being preserved across page navigations.\nIf your page is being statically pre-rendered and your app has rewrites in next.config or a Proxy file, reading the pathname with usePathname() can result in hydration mismatch errors—because the initial value comes from the server and may not match the actual browser pathname after routing. See our example for a way to mitigate this issue.\nCompatibility with Pages Router\nParameters\nconst pathname = usePathname()\n\nusePathname does not take any parameters.\n\nReturns\n\nusePathname returns a string of the current URL's pathname. For example:\n\nURL\tReturned value\n/\t'/'\n/dashboard\t'/dashboard'\n/dashboard?v=2\t'/dashboard'\n/blog/hello-world\t'/blog/hello-world'\nExamples\nDo something in response to a route change\napp/example-client-component.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useEffect } from 'react'\nimport { usePathname, useSearchParams } from 'next/navigation'\n \nfunction ExampleClientComponent() {\n  const pathname = usePathname()\n  const searchParams = useSearchParams()\n  useEffect(() => {\n    // Do something here...\n  }, [pathname, searchParams])\n}\nAvoid hydration mismatch with rewrites\n\nWhen a page is pre-rendered, the HTML is generated for the source pathname. If the page is then reached through a rewrite using next.config or Proxy, the browser URL may differ, and usePathname() will read the rewritten pathname on the client.\n\nTo avoid hydration mismatches, design the UI so that only a small, isolated part depends on the client pathname. Render a stable fallback on the server and update that part after mount.\n\napp/example-client-component.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useEffect, useState } from 'react'\nimport { usePathname } from 'next/navigation'\n \nexport default function PathnameBadge() {\n  const pathname = usePathname()\n  const [clientPathname, setClientPathname] = useState('')\n \n  useEffect(() => {\n    setClientPathname(pathname)\n  }, [pathname])\n \n  return (\n    <p>\n      Current pathname: <span>{clientPathname}</span>\n    </p>\n  )\n}\nVersion\tChanges\nv13.0.0\tusePathname introduced.\nPrevious\nuseParams\nNext\nuseReportWebVitals\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: useReportWebVitals | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/use-report-web-vitals",
    "html": "API Reference\nFunctions\nuseReportWebVitals\nCopy page\nuseReportWebVitals\n\nThe useReportWebVitals hook allows you to report Core Web Vitals\n, and can be used in combination with your analytics service.\n\nNew functions passed to useReportWebVitals are called with the available metrics up to that point. To prevent reporting duplicated data, ensure that the callback function reference does not change (as shown in the code examples below).\n\napp/_components/web-vitals.js\n'use client'\n \nimport { useReportWebVitals } from 'next/web-vitals'\n \nconst logWebVitals = (metric) => {\n  console.log(metric)\n}\n \nexport function WebVitals() {\n  useReportWebVitals(logWebVitals)\n \n  return null\n}\napp/layout.js\nimport { WebVitals } from './_components/web-vitals'\n \nexport default function Layout({ children }) {\n  return (\n    <html>\n      <body>\n        <WebVitals />\n        {children}\n      </body>\n    </html>\n  )\n}\n\nSince the useReportWebVitals hook requires the 'use client' directive, the most performant approach is to create a separate component that the root layout imports. This confines the client boundary exclusively to the WebVitals component.\n\nuseReportWebVitals\n\nThe metric object passed as the hook's argument consists of a number of properties:\n\nid: Unique identifier for the metric in the context of the current page load\nname: The name of the performance metric. Possible values include names of Web Vitals metrics (TTFB, FCP, LCP, FID, CLS) specific to a web application.\ndelta: The difference between the current value and the previous value of the metric. The value is typically in milliseconds and represents the change in the metric's value over time.\nentries: An array of Performance Entries\n associated with the metric. These entries provide detailed information about the performance events related to the metric.\nnavigationType: Indicates the type of navigation\n that triggered the metric collection. Possible values include \"navigate\", \"reload\", \"back_forward\", and \"prerender\".\nrating: A qualitative rating of the metric value, providing an assessment of the performance. Possible values are \"good\", \"needs-improvement\", and \"poor\". The rating is typically determined by comparing the metric value against predefined thresholds that indicate acceptable or suboptimal performance.\nvalue: The actual value or duration of the performance entry, typically in milliseconds. The value provides a quantitative measure of the performance aspect being tracked by the metric. The source of the value depends on the specific metric being measured and can come from various Performance API\ns.\nWeb Vitals\n\nWeb Vitals\n are a set of useful metrics that aim to capture the user experience of a web page. The following web vitals are all included:\n\nTime to First Byte\n (TTFB)\nFirst Contentful Paint\n (FCP)\nLargest Contentful Paint\n (LCP)\nFirst Input Delay\n (FID)\nCumulative Layout Shift\n (CLS)\nInteraction to Next Paint\n (INP)\n\nYou can handle all the results of these metrics using the name property.\n\napp/components/web-vitals.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useReportWebVitals } from 'next/web-vitals'\n \ntype ReportWebVitalsCallback = Parameters<typeof useReportWebVitals>[0]\n \nconst handleWebVitals: ReportWebVitalsCallback = (metric) => {\n  switch (metric.name) {\n    case 'FCP': {\n      // handle FCP results\n    }\n    case 'LCP': {\n      // handle LCP results\n    }\n    // ...\n  }\n}\n \nexport function WebVitals() {\n  useReportWebVitals(handleWebVitals)\n}\nSending results to external systems\n\nYou can send results to any endpoint to measure and track real user performance on your site. For example:\n\nfunction postWebVitals(metrics) {\n  const body = JSON.stringify(metric)\n  const url = 'https://example.com/analytics'\n \n  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.\n  if (navigator.sendBeacon) {\n    navigator.sendBeacon(url, body)\n  } else {\n    fetch(url, { body, method: 'POST', keepalive: true })\n  }\n}\n \nuseReportWebVitals(postWebVitals)\n\nGood to know: If you use Google Analytics\n, using the id value can allow you to construct metric distributions manually (to calculate percentiles, etc.)\n\nuseReportWebVitals(metric => {\n  // Use `window.gtag` if you initialized Google Analytics as this example:\n  // https://github.com/vercel/next.js/blob/canary/examples/with-google-analytics\n  window.gtag('event', metric.name, {\n    value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value), // values must be integers\n    event_label: metric.id, // id unique to current page load\n    non_interaction: true, // avoids affecting bounce rate.\n  });\n}\n\nRead more about sending results to Google Analytics\n.\n\nPrevious\nusePathname\nNext\nuseRouter\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: useRouter | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/use-router",
    "html": "API Reference\nFunctions\nuseRouter\nCopy page\nuseRouter\n\nThe useRouter hook allows you to programmatically change routes inside Client Components.\n\nRecommendation: Use the <Link> component for navigation unless you have a specific requirement for using useRouter.\n\napp/example-client-component.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useRouter } from 'next/navigation'\n \nexport default function Page() {\n  const router = useRouter()\n \n  return (\n    <button type=\"button\" onClick={() => router.push('/dashboard')}>\n      Dashboard\n    </button>\n  )\n}\nuseRouter()\nrouter.push(href: string, { scroll: boolean }): Perform a client-side navigation to the provided route. Adds a new entry into the browser's history stack\n.\nrouter.replace(href: string, { scroll: boolean }): Perform a client-side navigation to the provided route without adding a new entry into the browser’s history stack.\nrouter.refresh(): Refresh the current route. Making a new request to the server, re-fetching data requests, and re-rendering Server Components. The client will merge the updated React Server Component payload without losing unaffected client-side React (e.g. useState) or browser state (e.g. scroll position).\nrouter.prefetch(href: string, options?: { onInvalidate?: () => void }): Prefetch the provided route for faster client-side transitions. The optional onInvalidate callback is called when the prefetched data becomes stale.\nrouter.back(): Navigate back to the previous route in the browser’s history stack.\nrouter.forward(): Navigate forwards to the next page in the browser’s history stack.\n\nGood to know:\n\nYou must not send untrusted or unsanitized URLs to router.push or router.replace, as this can open your site to cross-site scripting (XSS) vulnerabilities. For example, javascript: URLs sent to router.push or router.replace will be executed in the context of your page.\nThe <Link> component automatically prefetch routes as they become visible in the viewport.\nrefresh() could re-produce the same result if fetch requests are cached. Other Dynamic APIs like cookies and headers could also change the response.\nThe onInvalidate callback is called at most once per prefetch request. It signals when you may want to trigger a new prefetch for updated route data.\nMigrating from next/router\nThe useRouter hook should be imported from next/navigation and not next/router when using the App Router\nThe pathname string has been removed and is replaced by usePathname()\nThe query object has been removed and is replaced by useSearchParams()\nrouter.events has been replaced. See below.\n\nView the full migration guide.\n\nExamples\nRouter events\n\nYou can listen for page changes by composing other Client Component hooks like usePathname and useSearchParams.\n\napp/components/navigation-events.js\n'use client'\n \nimport { useEffect } from 'react'\nimport { usePathname, useSearchParams } from 'next/navigation'\n \nexport function NavigationEvents() {\n  const pathname = usePathname()\n  const searchParams = useSearchParams()\n \n  useEffect(() => {\n    const url = `${pathname}?${searchParams}`\n    console.log(url)\n    // You can now use the current URL\n    // ...\n  }, [pathname, searchParams])\n \n  return '...'\n}\n\nWhich can be imported into a layout.\n\napp/layout.js\nimport { Suspense } from 'react'\nimport { NavigationEvents } from './components/navigation-events'\n \nexport default function Layout({ children }) {\n  return (\n    <html lang=\"en\">\n      <body>\n        {children}\n \n        <Suspense fallback={null}>\n          <NavigationEvents />\n        </Suspense>\n      </body>\n    </html>\n  )\n}\n\nGood to know: <NavigationEvents> is wrapped in a Suspense boundary becauseuseSearchParams() causes client-side rendering up to the closest Suspense boundary during static rendering. Learn more.\n\nDisabling scroll to top\n\nBy default, Next.js will scroll to the top of the page when navigating to a new route. You can disable this behavior by passing scroll: false to router.push() or router.replace().\n\napp/example-client-component.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useRouter } from 'next/navigation'\n \nexport default function Page() {\n  const router = useRouter()\n \n  return (\n    <button\n      type=\"button\"\n      onClick={() => router.push('/dashboard', { scroll: false })}\n    >\n      Dashboard\n    </button>\n  )\n}\nVersion History\nVersion\tChanges\nv15.4.0\tOptional onInvalidate callback for router.prefetch introduced\nv13.0.0\tuseRouter from next/navigation introduced.\nPrevious\nuseReportWebVitals\nNext\nuseSearchParams\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: useSearchParams | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/use-search-params",
    "html": "API Reference\nFunctions\nuseSearchParams\nCopy page\nuseSearchParams\n\nuseSearchParams is a Client Component hook that lets you read the current URL's query string.\n\nuseSearchParams returns a read-only version of the URLSearchParams\n interface.\n\napp/dashboard/search-bar.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useSearchParams } from 'next/navigation'\n \nexport default function SearchBar() {\n  const searchParams = useSearchParams()\n \n  const search = searchParams.get('search')\n \n  // URL -> `/dashboard?search=my-project`\n  // `search` -> 'my-project'\n  return <>Search: {search}</>\n}\nParameters\nconst searchParams = useSearchParams()\n\nuseSearchParams does not take any parameters.\n\nReturns\n\nuseSearchParams returns a read-only version of the URLSearchParams\n interface, which includes utility methods for reading the URL's query string:\n\nURLSearchParams.get()\n: Returns the first value associated with the search parameter. For example:\n\nURL\tsearchParams.get(\"a\")\n/dashboard?a=1\t'1'\n/dashboard?a=\t''\n/dashboard?b=3\tnull\n/dashboard?a=1&a=2\t'1' - use getAll()\n to get all values\n\nURLSearchParams.has()\n: Returns a boolean value indicating if the given parameter exists. For example:\n\nURL\tsearchParams.has(\"a\")\n/dashboard?a=1\ttrue\n/dashboard?b=3\tfalse\n\nLearn more about other read-only methods of URLSearchParams\n, including the getAll()\n, keys()\n, values()\n, entries()\n, forEach()\n, and toString()\n.\n\nGood to know:\n\nuseSearchParams is a Client Component hook and is not supported in Server Components to prevent stale values during partial rendering.\nIf you want to fetch data in a Server Component based on search params, it's often a better option to read the searchParams prop of the corresponding Page. You can then pass it down by props to any component (Server or Client) within that Page.\nIf an application includes the /pages directory, useSearchParams will return ReadonlyURLSearchParams | null. The null value is for compatibility during migration since search params cannot be known during pre-rendering of a page that doesn't use getServerSideProps\nBehavior\nStatic Rendering\n\nIf a route is statically rendered, calling useSearchParams will cause the Client Component tree up to the closest Suspense boundary to be client-side rendered.\n\nThis allows a part of the route to be statically rendered while the dynamic part that uses useSearchParams is client-side rendered.\n\nWe recommend wrapping the Client Component that uses useSearchParams in a <Suspense/> boundary. This will allow any Client Components above it to be statically rendered and sent as part of initial HTML. Example.\n\nFor example:\n\napp/dashboard/search-bar.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useSearchParams } from 'next/navigation'\n \nexport default function SearchBar() {\n  const searchParams = useSearchParams()\n \n  const search = searchParams.get('search')\n \n  // This will not be logged on the server when using static rendering\n  console.log(search)\n \n  return <>Search: {search}</>\n}\napp/dashboard/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Suspense } from 'react'\nimport SearchBar from './search-bar'\n \n// This component passed as a fallback to the Suspense boundary\n// will be rendered in place of the search bar in the initial HTML.\n// When the value is available during React hydration the fallback\n// will be replaced with the `<SearchBar>` component.\nfunction SearchBarFallback() {\n  return <>placeholder</>\n}\n \nexport default function Page() {\n  return (\n    <>\n      <nav>\n        <Suspense fallback={<SearchBarFallback />}>\n          <SearchBar />\n        </Suspense>\n      </nav>\n      <h1>Dashboard</h1>\n    </>\n  )\n}\n\nGood to know:\n\nIn development, routes are rendered on-demand, so useSearchParams doesn't suspend and things may appear to work without Suspense.\nDuring production builds, a static page that calls useSearchParams from a Client Component must be wrapped in a Suspense boundary, otherwise the build fails with the Missing Suspense boundary with useSearchParams error.\nIf you intend the route to be dynamically rendered, prefer using the connection function first in a Server Component to wait for an incoming request, this excludes everything below from prerendering. See what makes a route dynamic in the Dynamic Rendering guide.\nIf you're already in a Server Component Page, consider using the searchParams prop and passing the values to Client Components.\nYou can also pass the Page searchParams prop directly to a Client Component and unwrap it with React's use(). Although this will suspend, so the Client Component should be wrapped with a Suspense boundary.\nDynamic Rendering\n\nIf a route is dynamically rendered, useSearchParams will be available on the server during the initial server render of the Client Component.\n\nFor example:\n\napp/dashboard/search-bar.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useSearchParams } from 'next/navigation'\n \nexport default function SearchBar() {\n  const searchParams = useSearchParams()\n \n  const search = searchParams.get('search')\n \n  // This will be logged on the server during the initial render\n  // and on the client on subsequent navigations.\n  console.log(search)\n \n  return <>Search: {search}</>\n}\napp/dashboard/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { connection } from 'next/server'\nimport SearchBar from './search-bar'\n \nexport default async function Page() {\n  await connection()\n  return (\n    <>\n      <nav>\n        <SearchBar />\n      </nav>\n      <h1>Dashboard</h1>\n    </>\n  )\n}\n\nGood to know:\n\nPreviously, setting export const dynamic = 'force-dynamic' on the page was used to force dynamic rendering. Prefer using connection() instead, as it semantically ties dynamic rendering to the incoming request.\nServer Components\nPages\n\nTo access search params in Pages (Server Components), use the searchParams prop.\n\nLayouts\n\nUnlike Pages, Layouts (Server Components) do not receive the searchParams prop. This is because a shared layout is not re-rendered during navigation which could lead to stale searchParams between navigations. View detailed explanation.\n\nInstead, use the Page searchParams prop or the useSearchParams hook in a Client Component, which is re-rendered on the client with the latest searchParams.\n\nExamples\nUpdating searchParams\n\nYou can use useRouter or Link to set new searchParams. After a navigation is performed, the current page.js will receive an updated searchParams prop.\n\napp/example-client-component.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nexport default function ExampleClientComponent() {\n  const router = useRouter()\n  const pathname = usePathname()\n  const searchParams = useSearchParams()\n \n  // Get a new searchParams string by merging the current\n  // searchParams with a provided key/value pair\n  const createQueryString = useCallback(\n    (name: string, value: string) => {\n      const params = new URLSearchParams(searchParams.toString())\n      params.set(name, value)\n \n      return params.toString()\n    },\n    [searchParams]\n  )\n \n  return (\n    <>\n      <p>Sort By</p>\n \n      {/* using useRouter */}\n      <button\n        onClick={() => {\n          // <pathname>?sort=asc\n          router.push(pathname + '?' + createQueryString('sort', 'asc'))\n        }}\n      >\n        ASC\n      </button>\n \n      {/* using <Link> */}\n      <Link\n        href={\n          // <pathname>?sort=desc\n          pathname + '?' + createQueryString('sort', 'desc')\n        }\n      >\n        DESC\n      </Link>\n    </>\n  )\n}\nVersion History\nVersion\tChanges\nv13.0.0\tuseSearchParams introduced.\nPrevious\nuseRouter\nNext\nuseSelectedLayoutSegment\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: useSelectedLayoutSegment | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment",
    "html": "API Reference\nFunctions\nuseSelectedLayoutSegment\nCopy page\nuseSelectedLayoutSegment\n\nuseSelectedLayoutSegment is a Client Component hook that lets you read the active route segment one level below the Layout it is called from.\n\nIt is useful for navigation UI, such as tabs inside a parent layout that change style depending on the active child segment.\n\napp/example-client-component.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useSelectedLayoutSegment } from 'next/navigation'\n \nexport default function ExampleClientComponent() {\n  const segment = useSelectedLayoutSegment()\n \n  return <p>Active segment: {segment}</p>\n}\n\nGood to know:\n\nSince useSelectedLayoutSegment is a Client Component hook, and Layouts are Server Components by default, useSelectedLayoutSegment is usually called via a Client Component that is imported into a Layout.\nuseSelectedLayoutSegment only returns the segment one level down. To return all active segments, see useSelectedLayoutSegments\nParameters\nconst segment = useSelectedLayoutSegment(parallelRoutesKey?: string)\n\nuseSelectedLayoutSegment optionally accepts a parallelRoutesKey, which allows you to read the active route segment within that slot.\n\nReturns\n\nuseSelectedLayoutSegment returns a string of the active segment or null if one doesn't exist.\n\nFor example, given the Layouts and URLs below, the returned segment would be:\n\nLayout\tVisited URL\tReturned Segment\napp/layout.js\t/\tnull\napp/layout.js\t/dashboard\t'dashboard'\napp/dashboard/layout.js\t/dashboard\tnull\napp/dashboard/layout.js\t/dashboard/settings\t'settings'\napp/dashboard/layout.js\t/dashboard/analytics\t'analytics'\napp/dashboard/layout.js\t/dashboard/analytics/monthly\t'analytics'\nExamples\nCreating an active link component\n\nYou can use useSelectedLayoutSegment to create an active link component that changes style depending on the active segment. For example, a featured posts list in the sidebar of a blog:\n\napp/blog/blog-nav-link.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport Link from 'next/link'\nimport { useSelectedLayoutSegment } from 'next/navigation'\n \n// This *client* component will be imported into a blog layout\nexport default function BlogNavLink({\n  slug,\n  children,\n}: {\n  slug: string\n  children: React.ReactNode\n}) {\n  // Navigating to `/blog/hello-world` will return 'hello-world'\n  // for the selected layout segment\n  const segment = useSelectedLayoutSegment()\n  const isActive = slug === segment\n \n  return (\n    <Link\n      href={`/blog/${slug}`}\n      // Change style depending on whether the link is active\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\n    >\n      {children}\n    </Link>\n  )\n}\napp/blog/layout.tsx\nTypeScript\nJavaScript\nTypeScript\n// Import the Client Component into a parent Layout (Server Component)\nimport { BlogNavLink } from './blog-nav-link'\nimport getFeaturedPosts from './get-featured-posts'\n \nexport default async function Layout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  const featuredPosts = await getFeaturedPosts()\n  return (\n    <div>\n      {featuredPosts.map((post) => (\n        <div key={post.id}>\n          <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink>\n        </div>\n      ))}\n      <div>{children}</div>\n    </div>\n  )\n}\nVersion History\nVersion\tChanges\nv13.0.0\tuseSelectedLayoutSegment introduced.\nPrevious\nuseSearchParams\nNext\nuseSelectedLayoutSegments\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: useSelectedLayoutSegments | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments",
    "html": "API Reference\nFunctions\nuseSelectedLayoutSegments\nCopy page\nuseSelectedLayoutSegments\n\nuseSelectedLayoutSegments is a Client Component hook that lets you read the active route segments below the Layout it is called from.\n\nIt is useful for creating UI in parent Layouts that need knowledge of active child segments such as breadcrumbs.\n\napp/example-client-component.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useSelectedLayoutSegments } from 'next/navigation'\n \nexport default function ExampleClientComponent() {\n  const segments = useSelectedLayoutSegments()\n \n  return (\n    <ul>\n      {segments.map((segment, index) => (\n        <li key={index}>{segment}</li>\n      ))}\n    </ul>\n  )\n}\n\nGood to know:\n\nSince useSelectedLayoutSegments is a Client Component hook, and Layouts are Server Components by default, useSelectedLayoutSegments is usually called via a Client Component that is imported into a Layout.\nThe returned segments include Route Groups, which you might not want to be included in your UI. You can use the filter\n array method to remove items that start with a bracket.\nParameters\nconst segments = useSelectedLayoutSegments(parallelRoutesKey?: string)\n\nuseSelectedLayoutSegments optionally accepts a parallelRoutesKey, which allows you to read the active route segment within that slot.\n\nReturns\n\nuseSelectedLayoutSegments returns an array of strings containing the active segments one level down from the layout the hook was called from. Or an empty array if none exist.\n\nFor example, given the Layouts and URLs below, the returned segments would be:\n\nLayout\tVisited URL\tReturned Segments\napp/layout.js\t/\t[]\napp/layout.js\t/dashboard\t['dashboard']\napp/layout.js\t/dashboard/settings\t['dashboard', 'settings']\napp/dashboard/layout.js\t/dashboard\t[]\napp/dashboard/layout.js\t/dashboard/settings\t['settings']\nVersion History\nVersion\tChanges\nv13.0.0\tuseSelectedLayoutSegments introduced.\nPrevious\nuseSelectedLayoutSegment\nNext\nuserAgent\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Functions: userAgent | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/functions/userAgent",
    "html": "API Reference\nFunctions\nuserAgent\nCopy page\nuserAgent\n\nThe userAgent helper extends the Web Request API\n with additional properties and methods to interact with the user agent object from the request.\n\nproxy.ts\nTypeScript\nJavaScript\nTypeScript\nimport { NextRequest, NextResponse, userAgent } from 'next/server'\n \nexport function proxy(request: NextRequest) {\n  const url = request.nextUrl\n  const { device } = userAgent(request)\n \n  // device.type can be: 'mobile', 'tablet', 'console', 'smarttv',\n  // 'wearable', 'embedded', or undefined (for desktop browsers)\n  const viewport = device.type || 'desktop'\n \n  url.searchParams.set('viewport', viewport)\n  return NextResponse.rewrite(url)\n}\nisBot\n\nA boolean indicating whether the request comes from a known bot.\n\nbrowser\n\nAn object containing information about the browser used in the request.\n\nname: A string representing the browser's name, or undefined if not identifiable.\nversion: A string representing the browser's version, or undefined.\ndevice\n\nAn object containing information about the device used in the request.\n\nmodel: A string representing the model of the device, or undefined.\ntype: A string representing the type of the device, such as console, mobile, tablet, smarttv, wearable, embedded, or undefined.\nvendor: A string representing the vendor of the device, or undefined.\nengine\n\nAn object containing information about the browser's engine.\n\nname: A string representing the engine's name. Possible values include: Amaya, Blink, EdgeHTML, Flow, Gecko, Goanna, iCab, KHTML, Links, Lynx, NetFront, NetSurf, Presto, Tasman, Trident, w3m, WebKit or undefined.\nversion: A string representing the engine's version, or undefined.\nos\n\nAn object containing information about the operating system.\n\nname: A string representing the name of the OS, or undefined.\nversion: A string representing the version of the OS, or undefined.\ncpu\n\nAn object containing information about the CPU architecture.\n\narchitecture: A string representing the architecture of the CPU. Possible values include: 68k, amd64, arm, arm64, armhf, avr, ia32, ia64, irix, irix64, mips, mips64, pa-risc, ppc, sparc, sparc64 or undefined\nPrevious\nuseSelectedLayoutSegments\nNext\nConfiguration\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "API Reference: Configuration | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config",
    "html": "App Router\nAPI Reference\nConfiguration\nCopy page\nConfiguration\nnext.config.js\nLearn how to configure your application with next.config.js.\nTypeScript\nNext.js provides a TypeScript-first development experience for building your React application.\nESLint\nLearn how to use and configure the ESLint plugin to catch common issues and problems in a Next.js application.\nPrevious\nuserAgent\nNext\nnext.config.js\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Configuration: next.config.js | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js",
    "html": "API Reference\nConfiguration\nnext.config.js\nCopy page\nnext.config.js\n\nNext.js can be configured through a next.config.js file in the root of your project directory (for example, by package.json) with a default export.\n\nnext.config.js\n// @ts-check\n \n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  /* config options here */\n}\n \nmodule.exports = nextConfig\nECMAScript Modules\n\nnext.config.js is a regular Node.js module, not a JSON file. It gets used by the Next.js server and build phases, and it's not included in the browser build.\n\nIf you need ECMAScript modules\n, you can use next.config.mjs:\n\nnext.config.mjs\n// @ts-check\n \n/**\n * @type {import('next').NextConfig}\n */\nconst nextConfig = {\n  /* config options here */\n}\n \nexport default nextConfig\n\nGood to know: next.config with the .cjs, .cts, or .mts extensions are currently not supported.\n\nConfiguration as a Function\n\nYou can also use a function:\n\nnext.config.mjs\n// @ts-check\n \nexport default (phase, { defaultConfig }) => {\n  /**\n   * @type {import('next').NextConfig}\n   */\n  const nextConfig = {\n    /* config options here */\n  }\n  return nextConfig\n}\nAsync Configuration\n\nSince Next.js 12.1.0, you can use an async function:\n\nnext.config.js\n// @ts-check\n \nmodule.exports = async (phase, { defaultConfig }) => {\n  /**\n   * @type {import('next').NextConfig}\n   */\n  const nextConfig = {\n    /* config options here */\n  }\n  return nextConfig\n}\nPhase\n\nphase is the current context in which the configuration is loaded. You can see the available phases\n. Phases can be imported from next/constants:\n\nnext.config.js\n// @ts-check\n \nconst { PHASE_DEVELOPMENT_SERVER } = require('next/constants')\n \nmodule.exports = (phase, { defaultConfig }) => {\n  if (phase === PHASE_DEVELOPMENT_SERVER) {\n    return {\n      /* development only config options here */\n    }\n  }\n \n  return {\n    /* config options for all phases except development here */\n  }\n}\nTypeScript\n\nIf you are using TypeScript in your project, you can use next.config.ts to use TypeScript in your configuration:\n\nnext.config.ts\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  /* config options here */\n}\n \nexport default nextConfig\n\nThe commented lines are the place where you can put the configs allowed by next.config.js, which are defined in this file\n.\n\nHowever, none of the configs are required, and it's not necessary to understand what each config does. Instead, search for the features you need to enable or modify in this section and they will show you what to do.\n\nAvoid using new JavaScript features not available in your target Node.js version. next.config.js will not be parsed by Webpack or Babel.\n\nThis page documents all the available configuration options:\n\nUnit Testing (experimental)\n\nStarting in Next.js 15.1, the next/experimental/testing/server package contains utilities to help unit test next.config.js files.\n\nThe unstable_getResponseFromNextConfig function runs the headers, redirects, and rewrites functions from next.config.js with the provided request information and returns NextResponse with the results of the routing.\n\nThe response from unstable_getResponseFromNextConfig only considers next.config.js fields and does not consider proxy or filesystem routes, so the result in production may be different than the unit test.\n\nimport {\n  getRedirectUrl,\n  unstable_getResponseFromNextConfig,\n} from 'next/experimental/testing/server'\n \nconst response = await unstable_getResponseFromNextConfig({\n  url: 'https://nextjs.org/test',\n  nextConfig: {\n    async redirects() {\n      return [{ source: '/test', destination: '/test2', permanent: false }]\n    },\n  },\n})\nexpect(response.status).toEqual(307)\nexpect(getRedirectUrl(response)).toEqual('https://nextjs.org/test2')\nexperimental.adapterPath\nConfigure a custom adapter for Next.js to hook into the build process with modifyConfig and onBuildComplete callbacks.\nallowedDevOrigins\nUse `allowedDevOrigins` to configure additional origins that can request the dev server.\nappDir\nEnable the App Router to use layouts, streaming, and more.\nassetPrefix\nLearn how to use the assetPrefix config option to configure your CDN.\nauthInterrupts\nLearn how to enable the experimental `authInterrupts` configuration option to use `forbidden` and `unauthorized`.\nbasePath\nUse `basePath` to deploy a Next.js application under a sub-path of a domain.\nbrowserDebugInfoInTerminal\nForward browser console logs and errors to your terminal during development.\ncacheComponents\nLearn how to enable the cacheComponents flag in Next.js.\ncacheLife\nLearn how to set up cacheLife configurations in Next.js.\ncompress\nNext.js provides gzip compression to compress rendered content and static files, it only works with the server target. Learn more about it here.\ncrossOrigin\nUse the `crossOrigin` option to add a crossOrigin tag on the `script` tags generated by `next/script`.\ncssChunking\nUse the `cssChunking` option to control how CSS files are chunked in your Next.js application.\ndevIndicators\nConfiguration options for the on-screen indicator that gives context about the current route you're viewing during development.\ndistDir\nSet a custom build directory to use instead of the default .next directory.\nenv\nLearn to add and access environment variables in your Next.js application at build time.\nexpireTime\nCustomize stale-while-revalidate expire time for ISR enabled pages.\nexportPathMap\nCustomize the pages that will be exported as HTML files when using `next export`.\ngenerateBuildId\nConfigure the build id, which is used to identify the current build in which your application is being served.\ngenerateEtags\nNext.js will generate etags for every page by default. Learn more about how to disable etag generation here.\nheaders\nAdd custom HTTP headers to your Next.js app.\nhtmlLimitedBots\nSpecify a list of user agents that should receive blocking metadata.\nhttpAgentOptions\nNext.js will automatically use HTTP Keep-Alive by default. Learn more about how to disable HTTP Keep-Alive here.\nimages\nCustom configuration for the next/image loader\ncacheHandler\nConfigure the Next.js cache used for storing and revalidating data to use any external service like Redis, Memcached, or others.\ninlineCss\nEnable inline CSS support.\nisolatedDevBuild\nUse isolated build outputs for development server to prevent conflicts with production builds.\nlogging\nConfigure how data fetches are logged to the console when running Next.js in development mode.\nmdxRs\nUse the new Rust compiler to compile MDX files in the App Router.\nonDemandEntries\nConfigure how Next.js will dispose and keep in memory pages created in development.\noptimizePackageImports\nAPI Reference for optimizePackageImports Next.js Config Option\noutput\nNext.js automatically traces which files are needed by each page to allow for easy deployment of your application. Learn how it works here.\npageExtensions\nExtend the default page extensions used by Next.js when resolving pages in the Pages Router.\npoweredByHeader\nNext.js will add the `x-powered-by` header by default. Learn to opt-out of it here.\nproductionBrowserSourceMaps\nEnables browser source map generation during the production build.\nproxyClientMaxBodySize\nConfigure the maximum request body size when using proxy.\nreactCompiler\nEnable the React Compiler to automatically optimize component rendering.\nreactMaxHeadersLength\nThe maximum length of the headers that are emitted by React and added to the response.\nreactStrictMode\nThe complete Next.js runtime is now Strict Mode-compliant, learn how to opt-in\nredirects\nAdd redirects to your Next.js app.\nrewrites\nAdd rewrites to your Next.js app.\nsassOptions\nConfigure Sass options.\nserverActions\nConfigure Server Actions behavior in your Next.js application.\nserverComponentsHmrCache\nConfigure whether fetch responses in Server Components are cached across HMR refresh requests.\nserverExternalPackages\nOpt-out specific dependencies from the Server Components bundling and use native Node.js `require`.\nstaleTimes\nLearn how to override the invalidation time of the Client Router Cache.\nstaticGeneration*\nLearn how to configure static generation in your Next.js application.\ntaint\nEnable tainting Objects and Values.\ntrailingSlash\nConfigure Next.js pages to resolve with or without a trailing slash.\ntranspilePackages\nAutomatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (`node_modules`).\nturbopack\nConfigure Next.js with Turbopack-specific options\nturbopackFileSystemCache\nLearn how to enable FileSystem Caching for Turbopack builds\ntypedRoutes\nEnable support for statically typed links.\ntypescript\nNext.js reports TypeScript errors by default. Learn to opt-out of this behavior here.\nurlImports\nConfigure Next.js to allow importing modules from external URLs.\nuseLightningcss\nEnable experimental support for Lightning CSS.\nviewTransition\nEnable ViewTransition API from React in App Router\nwebpack\nLearn how to customize the webpack config used by Next.js\nwebVitalsAttribution\nLearn how to use the webVitalsAttribution option to pinpoint the source of Web Vitals issues.\nPrevious\nConfiguration\nNext\nexperimental.adapterPath\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: allowedDevOrigins | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/allowedDevOrigins",
    "html": "Configuration\nnext.config.js\nallowedDevOrigins\nCopy page\nallowedDevOrigins\n\nNext.js does not automatically block cross-origin requests during development, but will block by default in a future major version of Next.js to prevent unauthorized requesting of internal assets/endpoints that are available in development mode.\n\nTo configure a Next.js application to allow requests from origins other than the hostname the server was initialized with (localhost by default) you can use the allowedDevOrigins config option.\n\nallowedDevOrigins allows you to set additional origins that can be used in development mode. For example, to use local-origin.dev instead of only localhost, open next.config.js and add the allowedDevOrigins config:\n\nnext.config.js\nmodule.exports = {\n  allowedDevOrigins: ['local-origin.dev', '*.local-origin.dev'],\n}\nPrevious\nexperimental.adapterPath\nNext\nappDir\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: experimental.adapterPath | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/adapterPath",
    "html": "Configuration\nnext.config.js\nexperimental.adapterPath\nCopy page\nexperimental.adapterPath\n\nNext.js provides an experimental API that allows you to create custom adapters to hook into the build process. This is useful for deployment platforms or custom build integrations that need to modify the Next.js configuration or process the build output.\n\nConfiguration\n\nTo use an adapter, specify the path to your adapter module in experimental.adapterPath:\n\nnext.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    adapterPath: require.resolve('./my-adapter.js'),\n  },\n}\n \nmodule.exports = nextConfig\nCreating an Adapter\n\nAn adapter is a module that exports an object implementing the NextAdapter interface:\n\nexport interface NextAdapter {\n  name: string\n  modifyConfig?: (\n    config: NextConfigComplete,\n    ctx: {\n      phase: PHASE_TYPE\n    }\n  ) => Promise<NextConfigComplete> | NextConfigComplete\n  onBuildComplete?: (ctx: {\n    routes: {\n      headers: Array<ManifestHeaderRoute>\n      redirects: Array<ManifestRedirectRoute>\n      rewrites: {\n        beforeFiles: Array<ManifestRewriteRoute>\n        afterFiles: Array<ManifestRewriteRoute>\n        fallback: Array<ManifestRewriteRoute>\n      }\n      dynamicRoutes: ReadonlyArray<ManifestRoute>\n    }\n    outputs: AdapterOutputs\n    projectDir: string\n    repoRoot: string\n    distDir: string\n    config: NextConfigComplete\n    nextVersion: string\n  }) => Promise<void> | void\n}\nBasic Adapter Structure\n\nHere's a minimal adapter example:\n\nmy-adapter.js\n/** @type {import('next').NextAdapter} */\nconst adapter = {\n  name: 'my-custom-adapter',\n \n  async modifyConfig(config, { phase }) {\n    // Modify the Next.js config based on the build phase\n    if (phase === 'phase-production-build') {\n      return {\n        ...config,\n        // Add your modifications\n      }\n    }\n    return config\n  },\n \n  async onBuildComplete({\n    routes,\n    outputs,\n    projectDir,\n    repoRoot,\n    distDir,\n    config,\n    nextVersion,\n  }) {\n    // Process the build output\n    console.log('Build completed with', outputs.pages.length, 'pages')\n \n    // Access different output types\n    for (const page of outputs.pages) {\n      console.log('Page:', page.pathname, 'at', page.filePath)\n    }\n \n    for (const apiRoute of outputs.pagesApi) {\n      console.log('API Route:', apiRoute.pathname, 'at', apiRoute.filePath)\n    }\n \n    for (const appPage of outputs.appPages) {\n      console.log('App Page:', appPage.pathname, 'at', appPage.filePath)\n    }\n \n    for (const prerender of outputs.prerenders) {\n      console.log('Prerendered:', prerender.pathname)\n    }\n  },\n}\n \nmodule.exports = adapter\nAPI Reference\nmodifyConfig(config, context)\n\nCalled for any CLI command that loads the next.config to allow modification of the configuration.\n\nParameters:\n\nconfig: The complete Next.js configuration object\ncontext.phase: The current build phase (see phases)\n\nReturns: The modified configuration object (can be async)\n\nonBuildComplete(context)\n\nCalled after the build process completes with detailed information about routes and outputs.\n\nParameters:\n\nroutes: Object containing route manifests for headers, redirects, rewrites, and dynamic routes\nroutes.headers: Array of header route objects with source, sourceRegex, headers, has, missing, and optional priority fields\nroutes.redirects: Array of redirect route objects with source, sourceRegex, destination, statusCode, has, missing, and optional priority fields\nroutes.rewrites: Object with beforeFiles, afterFiles, and fallback arrays, each containing rewrite route objects with source, sourceRegex, destination, has, and missing fields\nroutes.dynamicRoutes: Array of dynamic route objects with source, sourceRegex, destination, has, and missing fields\noutputs: Detailed information about all build outputs organized by type\nprojectDir: Absolute path to the Next.js project directory\nrepoRoot: Absolute path to the detected repository root\ndistDir: Absolute path to the build output directory\nconfig: The final Next.js configuration (with modifyConfig applied)\nnextVersion: Version of Next.js being used\nbuildId: Unique identifier for the current build\nOutput Types\n\nThe outputs object contains arrays of different output types:\n\nPages (outputs.pages)\n\nReact pages from the pages/ directory:\n\n{\n  type: 'PAGES'\n  id: string           // Route identifier\n  filePath: string     // Path to the built file\n  pathname: string     // URL pathname\n  sourcePage: string   // Original source file path in pages/ directory\n  runtime: 'nodejs' | 'edge'\n  assets: Record<string, string>  // Traced dependencies (key: relative path from repo root, value: absolute path)\n  wasmAssets?: Record<string, string>  // Bundled wasm files (key: name, value: absolute path)\n  config: {\n    maxDuration?: number\n    preferredRegion?: string | string[]\n    env?: Record<string, string>  // Environment variables (edge runtime only)\n  }\n}\nAPI Routes (outputs.pagesApi)\n\nAPI routes from pages/api/:\n\n{\n  type: 'PAGES_API'\n  id: string\n  filePath: string\n  pathname: string\n  sourcePage: string   // Original relative source file path\n  runtime: 'nodejs' | 'edge'\n  assets: Record<string, string>\n  wasmAssets?: Record<string, string>\n  config: {\n    maxDuration?: number\n    preferredRegion?: string | string[]\n    env?: Record<string, string>\n  }\n}\nApp Pages (outputs.appPages)\n\nReact pages from the app/ directory with page.{js,ts,jsx,tsx}:\n\n{\n  type: 'APP_PAGE'\n  id: string\n  filePath: string\n  pathname: string     // Includes .rsc suffix for RSC routes\n  sourcePage: string   // Original relative source file path\n  runtime: 'nodejs' | 'edge'\n  assets: Record<string, string>\n  wasmAssets?: Record<string, string>\n  config: {\n    maxDuration?: number\n    preferredRegion?: string | string[]\n    env?: Record<string, string>\n  }\n}\nApp Routes (outputs.appRoutes)\n\nAPI and metadata routes from app/ with route.{js,ts,jsx,tsx}:\n\n{\n  type: 'APP_ROUTE'\n  id: string\n  filePath: string\n  pathname: string\n  sourcePage: string\n  runtime: 'nodejs' | 'edge'\n  assets: Record<string, string>\n  wasmAssets?: Record<string, string>\n  config: {\n    maxDuration?: number\n    preferredRegion?: string | string[]\n    env?: Record<string, string>\n  }\n}\nPrerenders (outputs.prerenders)\n\nISR-enabled routes and static prerenders:\n\n{\n  type: 'PRERENDER'\n  id: string\n  pathname: string\n  parentOutputId: string  // ID of the source page/route\n  groupId: number        // Revalidation group identifier (prerenders with same groupId revalidate together)\n  pprChain?: {\n    headers: Record<string, string>  // PPR chain headers (e.g., 'x-nextjs-resume': '1')\n  }\n  parentFallbackMode?: 'blocking' | false | null  // Fallback mode from getStaticPaths\n  fallback?: {\n    filePath: string\n    initialStatus?: number\n    initialHeaders?: Record<string, string | string[]>\n    initialExpiration?: number\n    initialRevalidate?: number\n    postponedState?: string  // PPR postponed state\n  }\n  config: {\n    allowQuery?: string[]     // Allowed query parameters\n    allowHeader?: string[]    // Allowed headers for ISR\n    bypassFor?: RouteHas[]    // Cache bypass conditions\n    renderingMode?: RenderingMode\n    bypassToken?: string\n  }\n}\nStatic Files (outputs.staticFiles)\n\nStatic assets and auto-statically optimized pages:\n\n{\n  type: 'STATIC_FILE'\n  id: string\n  filePath: string\n  pathname: string\n}\nMiddleware (outputs.middleware)\n\nMiddleware function (if present):\n\n{\n  type: 'MIDDLEWARE'\n  id: string\n  filePath: string\n  pathname: string      // Always '/_middleware'\n  sourcePage: string    // Always 'middleware'\n  runtime: 'nodejs' | 'edge'\n  assets: Record<string, string>\n  wasmAssets?: Record<string, string>\n  config: {\n    maxDuration?: number\n    preferredRegion?: string | string[]\n    env?: Record<string, string>\n    matchers?: Array<{\n      source: string\n      sourceRegex: string\n      has: RouteHas[] | undefined\n      missing: RouteHas[] | undefined\n    }>\n  }\n}\nRoutes Information\n\nThe routes object in onBuildComplete provides complete routing information with processed patterns ready for deployment:\n\nHeaders\n\nEach header route includes:\n\nsource: Original route pattern (e.g., /about)\nsourceRegex: Compiled regex for matching requests\nheaders: Key-value pairs of headers to apply\nhas: Optional conditions that must be met\nmissing: Optional conditions that must not be met\npriority: Optional flag for internal routes\nRedirects\n\nEach redirect route includes:\n\nsource: Original route pattern\nsourceRegex: Compiled regex for matching\ndestination: Target URL (can include captured groups)\nstatusCode: HTTP status code (301, 302, 307, 308)\nhas: Optional positive conditions\nmissing: Optional negative conditions\npriority: Optional flag for internal routes\nRewrites\n\nRewrites are categorized into three phases:\n\nbeforeFiles: Checked before filesystem (including pages and public files)\nafterFiles: Checked after pages/public files but before dynamic routes\nfallback: Checked after all other routes\n\nEach rewrite includes source, sourceRegex, destination, has, and missing.\n\nDynamic Routes\n\nGenerated from dynamic route segments (e.g., [slug], [...path]). Each includes:\n\nsource: Route pattern\nsourceRegex: Compiled regex with named capture groups\ndestination: Internal destination with parameter substitution\nhas: Optional positive conditions\nmissing: Optional negative conditions\nUse Cases\n\nCommon use cases for adapters include:\n\nDeployment Platform Integration: Automatically configure build outputs for specific hosting platforms\nAsset Processing: Transform or optimize build outputs\nMonitoring Integration: Collect build metrics and route information\nCustom Bundling: Package outputs in platform-specific formats\nBuild Validation: Ensure outputs meet specific requirements\nRoute Generation: Use processed route information to generate platform-specific routing configs\nPrevious\nnext.config.js\nNext\nallowedDevOrigins\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: appDir | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/appDir",
    "html": "Configuration\nnext.config.js\nappDir\nCopy page\nappDir\nThis is a legacy API and no longer recommended. It's still supported for backward compatibility.\n\nGood to know: This option is no longer needed as of Next.js 13.4. The App Router is now stable.\n\nThe App Router (app directory) enables support for layouts, Server Components, streaming, and colocated data fetching.\n\nUsing the app directory will automatically enable React Strict Mode\n. Learn how to incrementally adopt app.\n\nPrevious\nallowedDevOrigins\nNext\nassetPrefix\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: assetPrefix | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/assetPrefix",
    "html": "Configuration\nnext.config.js\nassetPrefix\nCopy page\nassetPrefix\n\nAttention: Deploying to Vercel automatically configures a global CDN for your Next.js project. You do not need to manually setup an Asset Prefix.\n\nGood to know: Next.js 9.5+ added support for a customizable Base Path, which is better suited for hosting your application on a sub-path like /docs. We do not suggest you use a custom Asset Prefix for this use case.\n\nSet up a CDN\n\nTo set up a CDN\n, you can set up an asset prefix and configure your CDN's origin to resolve to the domain that Next.js is hosted on.\n\nOpen next.config.mjs and add the assetPrefix config based on the phase:\n\nnext.config.mjs\n// @ts-check\nimport { PHASE_DEVELOPMENT_SERVER } from 'next/constants'\n \nexport default (phase) => {\n  const isDev = phase === PHASE_DEVELOPMENT_SERVER\n  /**\n   * @type {import('next').NextConfig}\n   */\n  const nextConfig = {\n    assetPrefix: isDev ? undefined : 'https://cdn.mydomain.com',\n  }\n  return nextConfig\n}\n\nNext.js will automatically use your asset prefix for the JavaScript and CSS files it loads from the /_next/ path (.next/static/ folder). For example, with the above configuration, the following request for a JS chunk:\n\n/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js\n\n\nWould instead become:\n\nhttps://cdn.mydomain.com/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js\n\n\nThe exact configuration for uploading your files to a given CDN will depend on your CDN of choice. The only folder you need to host on your CDN is the contents of .next/static/, which should be uploaded as _next/static/ as the above URL request indicates. Do not upload the rest of your .next/ folder, as you should not expose your server code and other configuration to the public.\n\nWhile assetPrefix covers requests to _next/static, it does not influence the following paths:\n\nFiles in the public folder; if you want to serve those assets over a CDN, you'll have to introduce the prefix yourself\nPrevious\nappDir\nNext\nauthInterrupts\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: authInterrupts | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/authInterrupts",
    "html": "Configuration\nnext.config.js\nauthInterrupts\nCopy page\nauthInterrupts\nThis feature is currently available in the canary channel and subject to change. Try it out by upgrading Next.js, and share your feedback on GitHub.\n\nThe authInterrupts configuration option allows you to use forbidden and unauthorized APIs in your application. While these functions are experimental, you must enable the authInterrupts option in your next.config.js file to use them:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    authInterrupts: true,\n  },\n}\n \nexport default nextConfig\nNext Steps\nforbidden\nAPI Reference for the forbidden function.\nunauthorized\nAPI Reference for the unauthorized function.\nforbidden.js\nAPI reference for the forbidden.js special file.\nunauthorized.js\nAPI reference for the unauthorized.js special file.\nPrevious\nassetPrefix\nNext\nbasePath\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: basePath | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/basePath",
    "html": "Configuration\nnext.config.js\nbasePath\nCopy page\nbasePath\n\nTo deploy a Next.js application under a sub-path of a domain you can use the basePath config option.\n\nbasePath allows you to set a path prefix for the application. For example, to use /docs instead of '' (an empty string, the default), open next.config.js and add the basePath config:\n\nnext.config.js\nmodule.exports = {\n  basePath: '/docs',\n}\n\nGood to know: This value must be set at build time and cannot be changed without re-building as the value is inlined in the client-side bundles.\n\nLinks\n\nWhen linking to other pages using next/link and next/router the basePath will be automatically applied.\n\nFor example, using /about will automatically become /docs/about when basePath is set to /docs.\n\nexport default function HomePage() {\n  return (\n    <>\n      <Link href=\"/about\">About Page</Link>\n    </>\n  )\n}\n\nOutput html:\n\n<a href=\"/docs/about\">About Page</a>\n\nThis makes sure that you don't have to change all links in your application when changing the basePath value.\n\nImages\n\nWhen using the next/image component, you will need to add the basePath in front of src.\n\nFor example, using /docs/me.png will properly serve your image when basePath is set to /docs.\n\nimport Image from 'next/image'\n \nfunction Home() {\n  return (\n    <>\n      <h1>My Homepage</h1>\n      <Image\n        src=\"/docs/me.png\"\n        alt=\"Picture of the author\"\n        width={500}\n        height={500}\n      />\n      <p>Welcome to my homepage!</p>\n    </>\n  )\n}\n \nexport default Home\nPrevious\nauthInterrupts\nNext\nbrowserDebugInfoInTerminal\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: cacheComponents | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/cacheComponents",
    "html": "Configuration\nnext.config.js\ncacheComponents\nCopy page\ncacheComponents\n\nThe cacheComponents flag is a feature in Next.js that causes data fetching operations in the App Router to be excluded from pre-renders unless they are explicitly cached. This can be useful for optimizing the performance of dynamic data fetching in Server Components.\n\nIt is useful if your application requires fresh data fetching during runtime rather than serving from a pre-rendered cache.\n\nIt is expected to be used in conjunction with use cache so that your data fetching happens at runtime by default unless you define specific parts of your application to be cached with use cache at the page, function, or component level.\n\nUsage\n\nTo enable the cacheComponents flag, set it to true in your next.config.ts file:\n\nnext.config.ts\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  cacheComponents: true,\n}\n \nexport default nextConfig\n\nWhen cacheComponents is enabled, you can use the following cache functions and configurations:\n\nThe use cache directive\nThe cacheLife function with use cache\nThe cacheTag function\nNotes\nWhile cacheComponents can optimize performance by ensuring fresh data fetching during runtime, it may also introduce additional latency compared to serving pre-rendered content.\nVersion History\nVersion\tChange\n16.0.0\tcacheComponents introduced. This flag controls the ppr, useCache, and dynamicIO flags as a single, unified configuration.\nPrevious\nbrowserDebugInfoInTerminal\nNext\ncacheLife\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: browserDebugInfoInTerminal | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/browserDebugInfoInTerminal",
    "html": "Configuration\nnext.config.js\nbrowserDebugInfoInTerminal\nCopy page\nbrowserDebugInfoInTerminal\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nThe experimental.browserDebugInfoInTerminal option forwards console output and runtime errors originating in the browser to the dev server terminal.\n\nThis option is disabled by default. When enabled it only works in development mode.\n\nUsage\n\nEnable forwarding:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    browserDebugInfoInTerminal: true,\n  },\n}\n \nexport default nextConfig\nSerialization limits\n\nDeeply nested objects/arrays are truncated using sensible defaults. You can tweak these limits:\n\ndepthLimit: (optional) Limit stringification depth for nested objects/arrays. Default: 5\nedgeLimit: (optional) Max number of properties or elements to include per object or array. Default: 100\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    browserDebugInfoInTerminal: {\n      depthLimit: 5,\n      edgeLimit: 100,\n    },\n  },\n}\n \nexport default nextConfig\nSource location\n\nSource locations are included by default when this feature is enabled.\n\napp/page.tsx\n'use client'\n \nexport default function Home() {\n  return (\n    <button\n      type=\"button\"\n      onClick={() => {\n        console.log('Hello World')\n      }}\n    >\n      Click me\n    </button>\n  )\n}\n\nClicking the button prints this message to the terminal.\n\nTerminal\n[browser] Hello World (app/page.tsx:8:17)\n\nTo suppress them, set showSourceLocation: false.\n\nshowSourceLocation: Include source location info when available.\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    browserDebugInfoInTerminal: {\n      showSourceLocation: false,\n    },\n  },\n}\n \nexport default nextConfig\nVersion\tChanges\nv15.4.0\texperimental browserDebugInfoInTerminal introduced\nPrevious\nbasePath\nNext\ncacheComponents\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: cacheLife | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/cacheLife",
    "html": "Configuration\nnext.config.js\ncacheLife\nCopy page\ncacheLife\n\nThe cacheLife option allows you to define custom cache profiles when using the cacheLife function inside components or functions, and within the scope of the use cache directive.\n\nUsage\n\nTo define a profile, enable the cacheComponents flag and add the cache profile in the cacheLife object in the next.config.js file. For example, a blog profile:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  cacheComponents: true,\n  cacheLife: {\n    blog: {\n      stale: 3600, // 1 hour\n      revalidate: 900, // 15 minutes\n      expire: 86400, // 1 day\n    },\n  },\n}\n \nexport default nextConfig\n\nYou can now use this custom blog configuration in your component or function as follows:\n\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\nimport { cacheLife } from 'next/cache'\n \nexport async function getCachedData() {\n  'use cache'\n  cacheLife('blog')\n  const data = await fetch('/api/data')\n  return data\n}\nReference\n\nThe configuration object has key values with the following format:\n\nProperty\tValue\tDescription\tRequirement\nstale\tnumber\tDuration the client should cache a value without checking the server.\tOptional\nrevalidate\tnumber\tFrequency at which the cache should refresh on the server; stale values may be served while revalidating.\tOptional\nexpire\tnumber\tMaximum duration for which a value can remain stale before switching to dynamic.\tOptional - Must be longer than revalidate\nPrevious\ncacheComponents\nNext\ncompress\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: compress | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/compress",
    "html": "Configuration\nnext.config.js\ncompress\nCopy page\ncompress\n\nBy default, Next.js uses gzip to compress rendered content and static files when using next start or a custom server. This is an optimization for applications that do not have compression configured. If compression is already configured in your application via a custom server, Next.js will not add compression.\n\nYou can check if compression is enabled and which algorithm is used by looking at the Accept-Encoding\n (browser accepted options) and Content-Encoding\n (currently used) headers in the response.\n\nDisabling compression\n\nTo disable compression, set the compress config option to false:\n\nnext.config.js\nmodule.exports = {\n  compress: false,\n}\n\nWe do not recommend disabling compression unless you have compression configured on your server, as compression reduces bandwidth usage and improves the performance of your application. For example, you're using nginx\n and want to switch to brotli, set the compress option to false to allow nginx to handle compression.\n\nPrevious\ncacheLife\nNext\ncrossOrigin\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: crossOrigin | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/crossOrigin",
    "html": "Configuration\nnext.config.js\ncrossOrigin\nCopy page\ncrossOrigin\n\nUse the crossOrigin option to add a crossOrigin attribute\n in all <script> tags generated by the next/script component , and define how cross-origin requests should be handled.\n\nnext.config.js\nmodule.exports = {\n  crossOrigin: 'anonymous',\n}\nOptions\n'anonymous': Adds crossOrigin=\"anonymous\"\n attribute.\n'use-credentials': Adds crossOrigin=\"use-credentials\"\n.\nPrevious\ncompress\nNext\ncssChunking\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: cssChunking | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/cssChunking",
    "html": "Configuration\nnext.config.js\ncssChunking\nCopy page\ncssChunking\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nCSS Chunking is a strategy used to improve the performance of your web application by splitting and re-ordering CSS files into chunks. This allows you to load only the CSS that is needed for a specific route, instead of loading all the application's CSS at once.\n\nYou can control how CSS files are chunked using the experimental.cssChunking option in your next.config.js file:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig = {\n  experimental: {\n    cssChunking: true, // default\n  },\n} satisfies NextConfig\n \nexport default nextConfig\nOptions\ntrue (default): Next.js will try to merge CSS files whenever possible, determining explicit and implicit dependencies between files from import order to reduce the number of chunks and therefore the number of requests.\nfalse: Next.js will not attempt to merge or re-order your CSS files.\n'strict': Next.js will load CSS files in the correct order they are imported into your files, which can lead to more chunks and requests.\n\nYou may consider using 'strict' if you run into unexpected CSS behavior. For example, if you import a.css and b.css in different files using a different import order (a before b, or b before a), true will merge the files in any order and assume there are no dependencies between them. However, if b.css depends on a.css, you may want to use 'strict' to prevent the files from being merged, and instead, load them in the order they are imported - which can result in more chunks and requests.\n\nFor most applications, we recommend true as it leads to fewer requests and better performance.\n\nPrevious\ncrossOrigin\nNext\ndevIndicators\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: devIndicators | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/devIndicators",
    "html": "Configuration\nnext.config.js\ndevIndicators\nCopy page\ndevIndicators\n\ndevIndicators allows you to configure the on-screen indicator that gives context about the current route you're viewing during development.\n\nTypes\n  devIndicators: false | {\n    position?: 'bottom-right'\n    | 'bottom-left'\n    | 'top-right'\n    | 'top-left', // defaults to 'bottom-left',\n  },\n\nSetting devIndicators to false will hide the indicator, however Next.js will continue to surface any build or runtime errors that were encountered.\n\nTroubleshooting\nIndicator not marking a route as static\n\nIf you expect a route to be static and the indicator has marked it as dynamic, it's likely the route has opted out of static rendering.\n\nYou can confirm if a route is static or dynamic by building your application using next build --debug, and checking the output in your terminal. Static (or prerendered) routes will display a ○ symbol, whereas dynamic routes will display a ƒ symbol. For example:\n\nBuild Output\nRoute (app)\n┌ ○ /_not-found\n└ ƒ /products/[id]\n \n○  (Static)   prerendered as static content\nƒ  (Dynamic)  server-rendered on demand\n\nThere are two reasons a route might opt out of static rendering:\n\nThe presence of Dynamic APIs which rely on runtime information.\nAn uncached data request, like a call to an ORM or database driver.\n\nCheck your route for any of these conditions, and if you are not able to statically render the route, then consider using loading.js or <Suspense />\n to leverage streaming.\n\nVersion History\nVersion\tChanges\nv16.0.0\tappIsrStatus, buildActivity, and buildActivityPosition options have been removed.\nv15.2.0\tImproved on-screen indicator with new position option. appIsrStatus, buildActivity, and buildActivityPosition options have been deprecated.\nv15.0.0\tStatic on-screen indicator added with appIsrStatus option.\nPrevious\ncssChunking\nNext\ndistDir\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: distDir | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/distDir",
    "html": "Configuration\nnext.config.js\ndistDir\nCopy page\ndistDir\n\nYou can specify a name to use for a custom build directory to use instead of .next.\n\nOpen next.config.js and add the distDir config:\n\nnext.config.js\nmodule.exports = {\n  distDir: 'build',\n}\n\nNow if you run next build Next.js will use build instead of the default .next folder.\n\ndistDir should not leave your project directory. For example, ../build is an invalid directory.\n\nPrevious\ndevIndicators\nNext\nenv\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: env | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/env",
    "html": "Configuration\nnext.config.js\nenv\nCopy page\nenv\nThis is a legacy API and no longer recommended. It's still supported for backward compatibility.\n\nSince the release of Next.js 9.4\n we now have a more intuitive and ergonomic experience for adding environment variables. Give it a try!\n\nGood to know: environment variables specified in this way will always be included in the JavaScript bundle, prefixing the environment variable name with NEXT_PUBLIC_ only has an effect when specifying them through the environment or .env files.\n\nTo add environment variables to the JavaScript bundle, open next.config.js and add the env config:\n\nnext.config.js\nmodule.exports = {\n  env: {\n    customKey: 'my-value',\n  },\n}\n\nNow you can access process.env.customKey in your code. For example:\n\nfunction Page() {\n  return <h1>The value of customKey is: {process.env.customKey}</h1>\n}\n \nexport default Page\n\nNext.js will replace process.env.customKey with 'my-value' at build time. Trying to destructure process.env variables won't work due to the nature of webpack DefinePlugin\n.\n\nFor example, the following line:\n\nreturn <h1>The value of customKey is: {process.env.customKey}</h1>\n\nWill end up being:\n\nreturn <h1>The value of customKey is: {'my-value'}</h1>\nPrevious\ndistDir\nNext\nexpireTime\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: expireTime | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/expireTime",
    "html": "Configuration\nnext.config.js\nexpireTime\nCopy page\nexpireTime\n\nYou can specify a custom stale-while-revalidate expire time for CDNs to consume in the Cache-Control header for ISR enabled pages.\n\nOpen next.config.js and add the expireTime config:\n\nnext.config.js\nmodule.exports = {\n  // one hour in seconds\n  expireTime: 3600,\n}\n\nNow when sending the Cache-Control header the expire time will be calculated depending on the specific revalidate period.\n\nFor example, if you have a revalidate of 15 minutes on a path and the expire time is one hour the generated Cache-Control header will be s-maxage=900, stale-while-revalidate=2700 so that it can stay stale for 15 minutes less than the configured expire time.\n\nPrevious\nenv\nNext\nexportPathMap\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: exportPathMap | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/exportPathMap",
    "html": "Configuration\nnext.config.js\nexportPathMap\nCopy page\nexportPathMap\nThis is a legacy API and no longer recommended. It's still supported for backward compatibility.\n\nThis feature is exclusive to next export and currently deprecated in favor of getStaticPaths with pages or generateStaticParams with app.\n\nexportPathMap allows you to specify a mapping of request paths to page destinations, to be used during export. Paths defined in exportPathMap will also be available when using next dev.\n\nLet's start with an example, to create a custom exportPathMap for an app with the following pages:\n\npages/index.js\npages/about.js\npages/post.js\n\nOpen next.config.js and add the following exportPathMap config:\n\nnext.config.js\nmodule.exports = {\n  exportPathMap: async function (\n    defaultPathMap,\n    { dev, dir, outDir, distDir, buildId }\n  ) {\n    return {\n      '/': { page: '/' },\n      '/about': { page: '/about' },\n      '/p/hello-nextjs': { page: '/post', query: { title: 'hello-nextjs' } },\n      '/p/learn-nextjs': { page: '/post', query: { title: 'learn-nextjs' } },\n      '/p/deploy-nextjs': { page: '/post', query: { title: 'deploy-nextjs' } },\n    }\n  },\n}\n\nGood to know: the query field in exportPathMap cannot be used with automatically statically optimized pages or getStaticProps pages as they are rendered to HTML files at build-time and additional query information cannot be provided during next export.\n\nThe pages will then be exported as HTML files, for example, /about will become /about.html.\n\nexportPathMap is an async function that receives 2 arguments: the first one is defaultPathMap, which is the default map used by Next.js. The second argument is an object with:\n\ndev - true when exportPathMap is being called in development. false when running next export. In development exportPathMap is used to define routes.\ndir - Absolute path to the project directory\noutDir - Absolute path to the out/ directory (configurable with -o). When dev is true the value of outDir will be null.\ndistDir - Absolute path to the .next/ directory (configurable with the distDir config)\nbuildId - The generated build id\n\nThe returned object is a map of pages where the key is the pathname and the value is an object that accepts the following fields:\n\npage: String - the page inside the pages directory to render\nquery: Object - the query object passed to getInitialProps when prerendering. Defaults to {}\n\nThe exported pathname can also be a filename (for example, /readme.md), but you may need to set the Content-Type header to text/html when serving its content if it is different than .html.\n\nAdding a trailing slash\n\nIt is possible to configure Next.js to export pages as index.html files and require trailing slashes, /about becomes /about/index.html and is routable via /about/. This was the default behavior prior to Next.js 9.\n\nTo switch back and add a trailing slash, open next.config.js and enable the trailingSlash config:\n\nnext.config.js\nmodule.exports = {\n  trailingSlash: true,\n}\nCustomizing the output directory\n\nnext export will use out as the default output directory, you can customize this using the -o argument, like so:\n\nTerminal\nnext export -o outdir\n\nWarning: Using exportPathMap is deprecated and is overridden by getStaticPaths inside pages. We don't recommend using them together.\n\nPrevious\nexpireTime\nNext\ngenerateBuildId\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: generateBuildId | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/generateBuildId",
    "html": "Configuration\nnext.config.js\ngenerateBuildId\nCopy page\ngenerateBuildId\n\nNext.js generates an ID during next build to identify which version of your application is being served. The same build should be used and boot up multiple containers.\n\nIf you are rebuilding for each stage of your environment, you will need to generate a consistent build ID to use between containers. Use the generateBuildId command in next.config.js:\n\nnext.config.js\nmodule.exports = {\n  generateBuildId: async () => {\n    // This could be anything, using the latest git hash\n    return process.env.GIT_HASH\n  },\n}\nPrevious\nexportPathMap\nNext\ngenerateEtags\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: generateEtags | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/generateEtags",
    "html": "Configuration\nnext.config.js\ngenerateEtags\nCopy page\ngenerateEtags\n\nNext.js will generate etags\n for every page by default. You may want to disable etag generation for HTML pages depending on your cache strategy.\n\nOpen next.config.js and disable the generateEtags option:\n\nnext.config.js\nmodule.exports = {\n  generateEtags: false,\n}\nPrevious\ngenerateBuildId\nNext\nheaders\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: headers | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/headers",
    "html": "Configuration\nnext.config.js\nheaders\nCopy page\nheaders\n\nHeaders allow you to set custom HTTP headers on the response to an incoming request on a given path.\n\nTo set custom HTTP headers you can use the headers key in next.config.js:\n\nnext.config.js\nmodule.exports = {\n  async headers() {\n    return [\n      {\n        source: '/about',\n        headers: [\n          {\n            key: 'x-custom-header',\n            value: 'my custom header value',\n          },\n          {\n            key: 'x-another-custom-header',\n            value: 'my other custom header value',\n          },\n        ],\n      },\n    ]\n  },\n}\n\nheaders is an async function that expects an array to be returned holding objects with source and headers properties:\n\nsource is the incoming request path pattern.\nheaders is an array of response header objects, with key and value properties.\nbasePath: false or undefined - if false the basePath won't be included when matching, can be used for external rewrites only.\nlocale: false or undefined - whether the locale should not be included when matching.\nhas is an array of has objects with the type, key and value properties.\nmissing is an array of missing objects with the type, key and value properties.\n\nHeaders are checked before the filesystem which includes pages and /public files.\n\nHeader Overriding Behavior\n\nIf two headers match the same path and set the same header key, the last header key will override the first. Using the below headers, the path /hello will result in the header x-hello being world due to the last header value set being world.\n\nnext.config.js\nmodule.exports = {\n  async headers() {\n    return [\n      {\n        source: '/:path*',\n        headers: [\n          {\n            key: 'x-hello',\n            value: 'there',\n          },\n        ],\n      },\n      {\n        source: '/hello',\n        headers: [\n          {\n            key: 'x-hello',\n            value: 'world',\n          },\n        ],\n      },\n    ]\n  },\n}\nPath Matching\n\nPath matches are allowed, for example /blog/:slug will match /blog/hello-world (no nested paths):\n\nnext.config.js\nmodule.exports = {\n  async headers() {\n    return [\n      {\n        source: '/blog/:slug',\n        headers: [\n          {\n            key: 'x-slug',\n            value: ':slug', // Matched parameters can be used in the value\n          },\n          {\n            key: 'x-slug-:slug', // Matched parameters can be used in the key\n            value: 'my other custom header value',\n          },\n        ],\n      },\n    ]\n  },\n}\nWildcard Path Matching\n\nTo match a wildcard path you can use * after a parameter, for example /blog/:slug* will match /blog/a/b/c/d/hello-world:\n\nnext.config.js\nmodule.exports = {\n  async headers() {\n    return [\n      {\n        source: '/blog/:slug*',\n        headers: [\n          {\n            key: 'x-slug',\n            value: ':slug*', // Matched parameters can be used in the value\n          },\n          {\n            key: 'x-slug-:slug*', // Matched parameters can be used in the key\n            value: 'my other custom header value',\n          },\n        ],\n      },\n    ]\n  },\n}\nRegex Path Matching\n\nTo match a regex path you can wrap the regex in parenthesis after a parameter, for example /blog/:slug(\\\\d{1,}) will match /blog/123 but not /blog/abc:\n\nnext.config.js\nmodule.exports = {\n  async headers() {\n    return [\n      {\n        source: '/blog/:post(\\\\d{1,})',\n        headers: [\n          {\n            key: 'x-post',\n            value: ':post',\n          },\n        ],\n      },\n    ]\n  },\n}\n\nThe following characters (, ), {, }, :, *, +, ? are used for regex path matching, so when used in the source as non-special values they must be escaped by adding \\\\ before them:\n\nnext.config.js\nmodule.exports = {\n  async headers() {\n    return [\n      {\n        // this will match `/english(default)/something` being requested\n        source: '/english\\\\(default\\\\)/:slug',\n        headers: [\n          {\n            key: 'x-header',\n            value: 'value',\n          },\n        ],\n      },\n    ]\n  },\n}\nHeader, Cookie, and Query Matching\n\nTo only apply a header when header, cookie, or query values also match the has field or don't match the missing field can be used. Both the source and all has items must match and all missing items must not match for the header to be applied.\n\nhas and missing items can have the following fields:\n\ntype: String - must be either header, cookie, host, or query.\nkey: String - the key from the selected type to match against.\nvalue: String or undefined - the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the value first-(?<paramName>.*) is used for first-second then second will be usable in the destination with :paramName.\nnext.config.js\nmodule.exports = {\n  async headers() {\n    return [\n      // if the header `x-add-header` is present,\n      // the `x-another-header` header will be applied\n      {\n        source: '/:path*',\n        has: [\n          {\n            type: 'header',\n            key: 'x-add-header',\n          },\n        ],\n        headers: [\n          {\n            key: 'x-another-header',\n            value: 'hello',\n          },\n        ],\n      },\n      // if the header `x-no-header` is not present,\n      // the `x-another-header` header will be applied\n      {\n        source: '/:path*',\n        missing: [\n          {\n            type: 'header',\n            key: 'x-no-header',\n          },\n        ],\n        headers: [\n          {\n            key: 'x-another-header',\n            value: 'hello',\n          },\n        ],\n      },\n      // if the source, query, and cookie are matched,\n      // the `x-authorized` header will be applied\n      {\n        source: '/specific/:path*',\n        has: [\n          {\n            type: 'query',\n            key: 'page',\n            // the page value will not be available in the\n            // header key/values since value is provided and\n            // doesn't use a named capture group e.g. (?<page>home)\n            value: 'home',\n          },\n          {\n            type: 'cookie',\n            key: 'authorized',\n            value: 'true',\n          },\n        ],\n        headers: [\n          {\n            key: 'x-authorized',\n            value: ':authorized',\n          },\n        ],\n      },\n      // if the header `x-authorized` is present and\n      // contains a matching value, the `x-another-header` will be applied\n      {\n        source: '/:path*',\n        has: [\n          {\n            type: 'header',\n            key: 'x-authorized',\n            value: '(?<authorized>yes|true)',\n          },\n        ],\n        headers: [\n          {\n            key: 'x-another-header',\n            value: ':authorized',\n          },\n        ],\n      },\n      // if the host is `example.com`,\n      // this header will be applied\n      {\n        source: '/:path*',\n        has: [\n          {\n            type: 'host',\n            value: 'example.com',\n          },\n        ],\n        headers: [\n          {\n            key: 'x-another-header',\n            value: ':authorized',\n          },\n        ],\n      },\n    ]\n  },\n}\nHeaders with basePath support\n\nWhen leveraging basePath support with headers each source is automatically prefixed with the basePath unless you add basePath: false to the header:\n\nnext.config.js\nmodule.exports = {\n  basePath: '/docs',\n \n  async headers() {\n    return [\n      {\n        source: '/with-basePath', // becomes /docs/with-basePath\n        headers: [\n          {\n            key: 'x-hello',\n            value: 'world',\n          },\n        ],\n      },\n      {\n        source: '/without-basePath', // is not modified since basePath: false is set\n        headers: [\n          {\n            key: 'x-hello',\n            value: 'world',\n          },\n        ],\n        basePath: false,\n      },\n    ]\n  },\n}\nHeaders with i18n support\n\nWhen leveraging i18n support with headers each source is automatically prefixed to handle the configured locales unless you add locale: false to the header. If locale: false is used you must prefix the source with a locale for it to be matched correctly.\n\nnext.config.js\nmodule.exports = {\n  i18n: {\n    locales: ['en', 'fr', 'de'],\n    defaultLocale: 'en',\n  },\n \n  async headers() {\n    return [\n      {\n        source: '/with-locale', // automatically handles all locales\n        headers: [\n          {\n            key: 'x-hello',\n            value: 'world',\n          },\n        ],\n      },\n      {\n        // does not handle locales automatically since locale: false is set\n        source: '/nl/with-locale-manual',\n        locale: false,\n        headers: [\n          {\n            key: 'x-hello',\n            value: 'world',\n          },\n        ],\n      },\n      {\n        // this matches '/' since `en` is the defaultLocale\n        source: '/en',\n        locale: false,\n        headers: [\n          {\n            key: 'x-hello',\n            value: 'world',\n          },\n        ],\n      },\n      {\n        // this gets converted to /(en|fr|de)/(.*) so will not match the top-level\n        // `/` or `/fr` routes like /:path* would\n        source: '/(.*)',\n        headers: [\n          {\n            key: 'x-hello',\n            value: 'world',\n          },\n        ],\n      },\n    ]\n  },\n}\nCache-Control\n\nNext.js sets the Cache-Control header of public, max-age=31536000, immutable for truly immutable assets. It cannot be overridden. These immutable files contain a SHA-hash in the file name, so they can be safely cached indefinitely. For example, Static Image Imports. You cannot set Cache-Control headers in next.config.js for these assets.\n\nHowever, you can set Cache-Control headers for other responses or data.\n\nLearn more about caching with the App Router.\n\nOptions\nCORS\n\nCross-Origin Resource Sharing (CORS)\n is a security feature that allows you to control which sites can access your resources. You can set the Access-Control-Allow-Origin header to allow a specific origin to access your Route Handlers.\n\nasync headers() {\n    return [\n      {\n        source: \"/api/:path*\",\n        headers: [\n          {\n            key: \"Access-Control-Allow-Origin\",\n            value: \"*\", // Set your origin\n          },\n          {\n            key: \"Access-Control-Allow-Methods\",\n            value: \"GET, POST, PUT, DELETE, OPTIONS\",\n          },\n          {\n            key: \"Access-Control-Allow-Headers\",\n            value: \"Content-Type, Authorization\",\n          },\n        ],\n      },\n    ];\n  },\nX-DNS-Prefetch-Control\n\nThis header\n controls DNS prefetching, allowing browsers to proactively perform domain name resolution on external links, images, CSS, JavaScript, and more. This prefetching is performed in the background, so the DNS\n is more likely to be resolved by the time the referenced items are needed. This reduces latency when the user clicks a link.\n\n{\n  key: 'X-DNS-Prefetch-Control',\n  value: 'on'\n}\nStrict-Transport-Security\n\nThis header\n informs browsers it should only be accessed using HTTPS, instead of using HTTP. Using the configuration below, all present and future subdomains will use HTTPS for a max-age of 2 years. This blocks access to pages or subdomains that can only be served over HTTP.\n\n{\n  key: 'Strict-Transport-Security',\n  value: 'max-age=63072000; includeSubDomains; preload'\n}\nX-Frame-Options\n\nThis header\n indicates whether the site should be allowed to be displayed within an iframe. This can prevent against clickjacking attacks.\n\nThis header has been superseded by CSP's frame-ancestors option, which has better support in modern browsers (see Content Security Policy for configuration details).\n\n{\n  key: 'X-Frame-Options',\n  value: 'SAMEORIGIN'\n}\nPermissions-Policy\n\nThis header\n allows you to control which features and APIs can be used in the browser. It was previously named Feature-Policy.\n\n{\n  key: 'Permissions-Policy',\n  value: 'camera=(), microphone=(), geolocation=(), browsing-topics=()'\n}\nX-Content-Type-Options\n\nThis header\n prevents the browser from attempting to guess the type of content if the Content-Type header is not explicitly set. This can prevent XSS exploits for websites that allow users to upload and share files.\n\nFor example, a user trying to download an image, but having it treated as a different Content-Type like an executable, which could be malicious. This header also applies to downloading browser extensions. The only valid value for this header is nosniff.\n\n{\n  key: 'X-Content-Type-Options',\n  value: 'nosniff'\n}\nReferrer-Policy\n\nThis header\n controls how much information the browser includes when navigating from the current website (origin) to another.\n\n{\n  key: 'Referrer-Policy',\n  value: 'origin-when-cross-origin'\n}\nContent-Security-Policy\n\nLearn more about adding a Content Security Policy to your application.\n\nVersion History\nVersion\tChanges\nv13.3.0\tmissing added.\nv10.2.0\thas added.\nv9.5.0\tHeaders added.\nPrevious\ngenerateEtags\nNext\nhtmlLimitedBots\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: htmlLimitedBots | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/htmlLimitedBots",
    "html": "Configuration\nnext.config.js\nhtmlLimitedBots\nCopy page\nhtmlLimitedBots\n\nThe htmlLimitedBots config allows you to specify a list of user agents that should receive blocking metadata instead of streaming metadata.\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst config: NextConfig = {\n  htmlLimitedBots: /MySpecialBot|MyAnotherSpecialBot|SimpleCrawler/,\n}\n \nexport default config\nDefault list\n\nNext.js includes a default list of HTML limited bots, including:\n\nGoogle crawlers (e.g. Mediapartners-Google, AdsBot-Google, Google-PageRenderer)\nBingbot\nTwitterbot\nSlackbot\n\nSee the full list here\n.\n\nSpecifying a htmlLimitedBots config will override the Next.js' default list. However, this is advanced behavior, and the default should be sufficient for most cases.\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nconst config: NextConfig = {\n  htmlLimitedBots: /MySpecialBot|MyAnotherSpecialBot|SimpleCrawler/,\n}\n \nexport default config\nDisabling\n\nTo fully disable streaming metadata:\n\nnext.config.ts\nimport type { NextConfig } from 'next'\n \nconst config: NextConfig = {\n  htmlLimitedBots: /.*/,\n}\n \nexport default config\nVersion History\nVersion\tChanges\n15.2.0\thtmlLimitedBots option introduced.\nPrevious\nheaders\nNext\nhttpAgentOptions\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: httpAgentOptions | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/httpAgentOptions",
    "html": "Configuration\nnext.config.js\nhttpAgentOptions\nCopy page\nhttpAgentOptions\n\nIn Node.js versions prior to 18, Next.js automatically polyfills fetch() with undici and enables HTTP Keep-Alive\n by default.\n\nTo disable HTTP Keep-Alive for all fetch() calls on the server-side, open next.config.js and add the httpAgentOptions config:\n\nnext.config.js\nmodule.exports = {\n  httpAgentOptions: {\n    keepAlive: false,\n  },\n}\nPrevious\nhtmlLimitedBots\nNext\nimages\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: images | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/images",
    "html": "Configuration\nnext.config.js\nimages\nCopy page\nimages\n\nIf you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configure next.config.js with the following:\n\nnext.config.js\nmodule.exports = {\n  images: {\n    loader: 'custom',\n    loaderFile: './my/image/loader.js',\n  },\n}\n\nThis loaderFile must point to a file relative to the root of your Next.js application. The file must export a default function that returns a string, for example:\n\nmy/image/loader.js\n'use client'\n \nexport default function myImageLoader({ src, width, quality }) {\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\n}\n\nAlternatively, you can use the loader prop to pass the function to each instance of next/image.\n\nGood to know: Customizing the image loader file, which accepts a function, requires using Client Components to serialize the provided function.\n\nTo learn more about configuring the behavior of the built-in Image Optimization API and the Image Component, see Image Configuration Options for available options.\n\nExample Loader Configuration\nAkamai\nAWS CloudFront\nCloudinary\nCloudflare\nContentful\nFastly\nGumlet\nImageEngine\nImgix\nPixelBin\nSanity\nSirv\nSupabase\nThumbor\nImagekit\nNitrogen AIO\nAkamai\n// Docs: https://techdocs.akamai.com/ivm/reference/test-images-on-demand\nexport default function akamaiLoader({ src, width, quality }) {\n  return `https://example.com/${src}?imwidth=${width}`\n}\nAWS CloudFront\n// Docs: https://aws.amazon.com/developer/application-security-performance/articles/image-optimization\nexport default function cloudfrontLoader({ src, width, quality }) {\n  const url = new URL(`https://example.com${src}`)\n  url.searchParams.set('format', 'auto')\n  url.searchParams.set('width', width.toString())\n  url.searchParams.set('quality', (quality || 75).toString())\n  return url.href\n}\nCloudinary\n// Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg\nexport default function cloudinaryLoader({ src, width, quality }) {\n  const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`]\n  return `https://example.com/${params.join(',')}${src}`\n}\nCloudflare\n// Docs: https://developers.cloudflare.com/images/transform-images\nexport default function cloudflareLoader({ src, width, quality }) {\n  const params = [`width=${width}`, `quality=${quality || 75}`, 'format=auto']\n  return `https://example.com/cdn-cgi/image/${params.join(',')}/${src}`\n}\nContentful\n// Docs: https://www.contentful.com/developers/docs/references/images-api/\nexport default function contentfulLoader({ src, width, quality }) {\n  const url = new URL(`https://example.com${src}`)\n  url.searchParams.set('fm', 'webp')\n  url.searchParams.set('w', width.toString())\n  url.searchParams.set('q', (quality || 75).toString())\n  return url.href\n}\nFastly\n// Docs: https://developer.fastly.com/reference/io/\nexport default function fastlyLoader({ src, width, quality }) {\n  const url = new URL(`https://example.com${src}`)\n  url.searchParams.set('auto', 'webp')\n  url.searchParams.set('width', width.toString())\n  url.searchParams.set('quality', (quality || 75).toString())\n  return url.href\n}\nGumlet\n// Docs: https://docs.gumlet.com/reference/image-transform-size\nexport default function gumletLoader({ src, width, quality }) {\n  const url = new URL(`https://example.com${src}`)\n  url.searchParams.set('format', 'auto')\n  url.searchParams.set('w', width.toString())\n  url.searchParams.set('q', (quality || 75).toString())\n  return url.href\n}\nImageEngine\n// Docs: https://support.imageengine.io/hc/en-us/articles/360058880672-Directives\nexport default function imageengineLoader({ src, width, quality }) {\n  const compression = 100 - (quality || 50)\n  const params = [`w_${width}`, `cmpr_${compression}`)]\n  return `https://example.com${src}?imgeng=/${params.join('/')`\n}\nImgix\n// Demo: https://static.imgix.net/daisy.png?format=auto&fit=max&w=300\nexport default function imgixLoader({ src, width, quality }) {\n  const url = new URL(`https://example.com${src}`)\n  const params = url.searchParams\n  params.set('auto', params.getAll('auto').join(',') || 'format')\n  params.set('fit', params.get('fit') || 'max')\n  params.set('w', params.get('w') || width.toString())\n  params.set('q', (quality || 50).toString())\n  return url.href\n}\nPixelBin\n// Doc (Resize): https://www.pixelbin.io/docs/transformations/basic/resize/#width-w\n// Doc (Optimise): https://www.pixelbin.io/docs/optimizations/quality/#image-quality-when-delivering\n// Doc (Auto Format Delivery): https://www.pixelbin.io/docs/optimizations/format/#automatic-format-selection-with-f_auto-url-parameter\nexport default function pixelBinLoader({ src, width, quality }) {\n  const name = '<your-cloud-name>'\n  const opt = `t.resize(w:${width})~t.compress(q:${quality || 75})`\n  return `https://cdn.pixelbin.io/v2/${name}/${opt}/${src}?f_auto=true`\n}\nSanity\n// Docs: https://www.sanity.io/docs/image-urls\nexport default function sanityLoader({ src, width, quality }) {\n  const prj = 'zp7mbokg'\n  const dataset = 'production'\n  const url = new URL(`https://cdn.sanity.io/images/${prj}/${dataset}${src}`)\n  url.searchParams.set('auto', 'format')\n  url.searchParams.set('fit', 'max')\n  url.searchParams.set('w', width.toString())\n  if (quality) {\n    url.searchParams.set('q', quality.toString())\n  }\n  return url.href\n}\nSirv\n// Docs: https://sirv.com/help/articles/dynamic-imaging/\nexport default function sirvLoader({ src, width, quality }) {\n  const url = new URL(`https://example.com${src}`)\n  const params = url.searchParams\n  params.set('format', params.getAll('format').join(',') || 'optimal')\n  params.set('w', params.get('w') || width.toString())\n  params.set('q', (quality || 85).toString())\n  return url.href\n}\nSupabase\n// Docs: https://supabase.com/docs/guides/storage/image-transformations#nextjs-loader\nexport default function supabaseLoader({ src, width, quality }) {\n  const url = new URL(`https://example.com${src}`)\n  url.searchParams.set('width', width.toString())\n  url.searchParams.set('quality', (quality || 75).toString())\n  return url.href\n}\nThumbor\n// Docs: https://thumbor.readthedocs.io/en/latest/\nexport default function thumborLoader({ src, width, quality }) {\n  const params = [`${width}x0`, `filters:quality(${quality || 75})`]\n  return `https://example.com${params.join('/')}${src}`\n}\nImageKit.io\n// Docs: https://imagekit.io/docs/image-transformation\nexport default function imageKitLoader({ src, width, quality }) {\n  const params = [`w-${width}`, `q-${quality || 80}`]\n  return `https://ik.imagekit.io/your_imagekit_id/${src}?tr=${params.join(',')}`\n}\nNitrogen AIO\n// Docs: https://docs.n7.io/aio/intergrations/\nexport default function aioLoader({ src, width, quality }) {\n  const url = new URL(src, window.location.href)\n  const params = url.searchParams\n  const aioParams = params.getAll('aio')\n  aioParams.push(`w-${width}`)\n  if (quality) {\n    aioParams.push(`q-${quality.toString()}`)\n  }\n  params.set('aio', aioParams.join(';'))\n  return url.href\n}\nPrevious\nhttpAgentOptions\nNext\ncacheHandler\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: cacheHandler | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/incrementalCacheHandlerPath",
    "html": "Configuration\nnext.config.js\ncacheHandler\nCopy page\nCustom Next.js Cache Handler\n\nYou can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application.\n\nGood to know: The cacheHandler configuration is specifically used by Next.js for server cache operations such as storing and revalidating ISR and route handler responses. It is not used by 'use cache', 'use cache: remote', nor 'use cache: private', which manage their own cache independently.\n\nnext.config.js\nmodule.exports = {\n  cacheHandler: require.resolve('./cache-handler.js'),\n  cacheMaxMemorySize: 0, // disable default in-memory caching\n}\n\nView an example of a custom cache handler and learn more about the implementation.\n\nAPI Reference\n\nThe cache handler can implement the following methods: get, set, revalidateTag, and resetRequestCache.\n\nget()\nParameter\tType\tDescription\nkey\tstring\tThe key to the cached value.\n\nReturns the cached value or null if not found.\n\nset()\nParameter\tType\tDescription\nkey\tstring\tThe key to store the data under.\ndata\tData or null\tThe data to be cached.\nctx\t{ tags: [] }\tThe cache tags provided.\n\nReturns Promise<void>.\n\nrevalidateTag()\nParameter\tType\tDescription\ntag\tstring or string[]\tThe cache tags to revalidate.\n\nReturns Promise<void>. Learn more about revalidating data or the revalidateTag() function.\n\nresetRequestCache()\n\nThis method resets the temporary in-memory cache for a single request before the next request.\n\nReturns void.\n\nGood to know:\n\nrevalidatePath is a convenience layer on top of cache tags. Calling revalidatePath will call your revalidateTag function, which you can then choose if you want to tag cache keys based on the path.\nPlatform Support\nDeployment Option\tSupported\nNode.js server\tYes\nDocker container\tYes\nStatic export\tNo\nAdapters\tPlatform-specific\n\nLearn how to configure ISR when self-hosting Next.js.\n\nVersion History\nVersion\tChanges\nv14.1.0\tRenamed to cacheHandler and became stable.\nv13.4.0\tincrementalCacheHandlerPath support for revalidateTag.\nv13.4.0\tincrementalCacheHandlerPath support for standalone output.\nv12.2.0\tExperimental incrementalCacheHandlerPath added.\nPrevious\nimages\nNext\ninlineCss\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: inlineCss | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/inlineCss",
    "html": "Configuration\nnext.config.js\ninlineCss\nCopy page\ninlineCss\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\nUsage\n\nExperimental support for inlining CSS in the <head>. When this flag is enabled, all places where we normally generate a <link> tag will instead have a generated <style> tag.\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    inlineCss: true,\n  },\n}\n \nexport default nextConfig\nTrade-Offs\nWhen to Use Inline CSS\n\nInlining CSS can be beneficial in several scenarios:\n\nFirst-Time Visitors: Since CSS files are render-blocking resources, inlining eliminates the initial download delay that first-time visitors experience, improving page load performance.\n\nPerformance Metrics: By removing the additional network requests for CSS files, inlining can significantly improve key metrics like First Contentful Paint (FCP) and Largest Contentful Paint (LCP).\n\nSlow Connections: For users on slower networks where each request adds considerable latency, inlining CSS can provide a noticeable performance boost by reducing network roundtrips.\n\nAtomic CSS Bundles (e.g., Tailwind): With utility-first frameworks like Tailwind CSS, the size of the styles required for a page is often O(1) relative to the complexity of the design. This makes inlining a compelling choice because the entire set of styles for the current page is lightweight and doesn’t grow with the page size. Inlining Tailwind styles ensures minimal payload and eliminates the need for additional network requests, which can further enhance performance.\n\nWhen Not to Use Inline CSS\n\nWhile inlining CSS offers significant benefits for performance, there are scenarios where it may not be the best choice:\n\nLarge CSS Bundles: If your CSS bundle is too large, inlining it may significantly increase the size of the HTML, resulting in slower Time to First Byte (TTFB) and potentially worse performance for users with slow connections.\n\nDynamic or Page-Specific CSS: For applications with highly dynamic styles or pages that use different sets of CSS, inlining may lead to redundancy and bloat, as the full CSS for all pages may need to be inlined repeatedly.\n\nBrowser Caching: In cases where visitors frequently return to your site, external CSS files allow browsers to cache styles efficiently, reducing data transfer for subsequent visits. Inlining CSS eliminates this benefit.\n\nEvaluate these trade-offs carefully, and consider combining inlining with other strategies, such as critical CSS extraction or a hybrid approach, for the best results tailored to your site's needs.\n\nGood to know:\n\nThis feature is currently experimental and has some known limitations:\n\nCSS inlining is applied globally and cannot be configured on a per-page basis\nStyles are duplicated during initial page load - once within <style> tags for SSR and once in the RSC payload\nWhen navigating to statically rendered pages, styles will use <link> tags instead of inline CSS to avoid duplication\nThis feature is not available in development mode and only works in production builds\nPrevious\ncacheHandler\nNext\nisolatedDevBuild\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: isolatedDevBuild | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/isolatedDevBuild",
    "html": "Configuration\nnext.config.js\nisolatedDevBuild\nCopy page\nisolatedDevBuild\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nThe experimental isolatedDevBuild option separates development and production build outputs into different directories. When enabled, the development server (next dev) writes its output to .next/dev instead of .next, preventing conflicts when running next dev and next build concurrently.\n\nThis is especially helpful when automated tools (for example, AI agents) run next build to validate changes while your development server is running, ensuring the dev server is not affected by changes made by the build process.\n\nThis feature is enabled by default to keep development and production outputs separate and prevent conflicts.\n\nConfiguration\n\nTo opt out of this feature, set isolatedDevBuild to false in your configuration:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    isolatedDevBuild: false, // defaults to true\n  },\n}\n \nexport default nextConfig\nVersion History\nVersion\tChanges\nv16.0.0\texperimental.isolatedDevBuild is introduced.\nPrevious\ninlineCss\nNext\nlogging\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: logging | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/logging",
    "html": "Configuration\nnext.config.js\nlogging\nCopy page\nlogging\nOptions\nFetching\n\nYou can configure the logging level and whether the full URL is logged to the console when running Next.js in development mode.\n\nCurrently, logging only applies to data fetching using the fetch API. It does not yet apply to other logs inside of Next.js.\n\nnext.config.js\nmodule.exports = {\n  logging: {\n    fetches: {\n      fullUrl: true,\n    },\n  },\n}\n\nAny fetch requests that are restored from the Server Components HMR cache are not logged by default. However, this can be enabled by setting logging.fetches.hmrRefreshes to true.\n\nnext.config.js\nmodule.exports = {\n  logging: {\n    fetches: {\n      hmrRefreshes: true,\n    },\n  },\n}\nIncoming Requests\n\nBy default all the incoming requests will be logged in the console during development. You can use the incomingRequests option to decide which requests to ignore. Since this is only logged in development, this option doesn't affect production builds.\n\nnext.config.js\nmodule.exports = {\n  logging: {\n    incomingRequests: {\n      ignore: [/\\api\\/v1\\/health/],\n    },\n  },\n}\n\nOr you can disable incoming request logging by setting incomingRequests to false.\n\nnext.config.js\nmodule.exports = {\n  logging: {\n    incomingRequests: false,\n  },\n}\nDisabling Logging\n\nIn addition, you can disable the development logging by setting logging to false.\n\nnext.config.js\nmodule.exports = {\n  logging: false,\n}\nPrevious\nisolatedDevBuild\nNext\nmdxRs\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: mdxRs | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/mdxRs",
    "html": "Configuration\nnext.config.js\nmdxRs\nCopy page\nmdxRs\n\nFor experimental use with @next/mdx. Compiles MDX files using the new Rust compiler.\n\nnext.config.js\nconst withMDX = require('@next/mdx')()\n \n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  pageExtensions: ['ts', 'tsx', 'mdx'],\n  experimental: {\n    mdxRs: true,\n  },\n}\n \nmodule.exports = withMDX(nextConfig)\nPrevious\nlogging\nNext\nonDemandEntries\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: onDemandEntries | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/onDemandEntries",
    "html": "Configuration\nnext.config.js\nonDemandEntries\nCopy page\nonDemandEntries\n\nNext.js exposes some options that give you some control over how the server will dispose or keep in memory built pages in development.\n\nTo change the defaults, open next.config.js and add the onDemandEntries config:\n\nnext.config.js\nmodule.exports = {\n  onDemandEntries: {\n    // period (in ms) where the server will keep pages in the buffer\n    maxInactiveAge: 25 * 1000,\n    // number of pages that should be kept simultaneously without being disposed\n    pagesBufferLength: 2,\n  },\n}\nPrevious\nmdxRs\nNext\noptimizePackageImports\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: optimizePackageImports | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/optimizePackageImports",
    "html": "Configuration\nnext.config.js\noptimizePackageImports\nCopy page\noptimizePackageImports\n\nSome packages can export hundreds or thousands of modules, which can cause performance issues in development and production.\n\nAdding a package to experimental.optimizePackageImports will only load the modules you are actually using, while still giving you the convenience of writing import statements with many named exports.\n\nnext.config.js\nmodule.exports = {\n  experimental: {\n    optimizePackageImports: ['package-name'],\n  },\n}\n\nThe following libraries are optimized by default:\n\nlucide-react\ndate-fns\nlodash-es\nramda\nantd\nreact-bootstrap\nahooks\n@ant-design/icons\n@headlessui/react\n@headlessui-float/react\n@heroicons/react/20/solid\n@heroicons/react/24/solid\n@heroicons/react/24/outline\n@visx/visx\n@tremor/react\nrxjs\n@mui/material\n@mui/icons-material\nrecharts\nreact-use\n@material-ui/core\n@material-ui/icons\n@tabler/icons-react\nmui-core\nreact-icons/*\neffect\n@effect/*\nPrevious\nonDemandEntries\nNext\noutput\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: output | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/output",
    "html": "Configuration\nnext.config.js\noutput\nCopy page\noutput\n\nDuring a build, Next.js will automatically trace each page and its dependencies to determine all of the files that are needed for deploying a production version of your application.\n\nThis feature helps reduce the size of deployments drastically. Previously, when deploying with Docker you would need to have all files from your package's dependencies installed to run next start. Starting with Next.js 12, you can leverage Output File Tracing in the .next/ directory to only include the necessary files.\n\nFurthermore, this removes the need for the deprecated serverless target which can cause various issues and also creates unnecessary duplication.\n\nHow it Works\n\nDuring next build, Next.js will use @vercel/nft\n to statically analyze import, require, and fs usage to determine all files that a page might load.\n\nNext.js' production server is also traced for its needed files and output at .next/next-server.js.nft.json which can be leveraged in production.\n\nTo leverage the .nft.json files emitted to the .next output directory, you can read the list of files in each trace that are relative to the .nft.json file and then copy them to your deployment location.\n\nAutomatically Copying Traced Files\n\nNext.js can automatically create a standalone folder that copies only the necessary files for a production deployment including select files in node_modules.\n\nTo leverage this automatic copying you can enable it in your next.config.js:\n\nnext.config.js\nmodule.exports = {\n  output: 'standalone',\n}\n\nThis will create a folder at .next/standalone which can then be deployed on its own without installing node_modules.\n\nAdditionally, a minimal server.js file is also output which can be used instead of next start. This minimal server does not copy the public or .next/static folders by default as these should ideally be handled by a CDN instead, although these folders can be copied to the standalone/public and standalone/.next/static folders manually, after which server.js file will serve these automatically.\n\nTo copy these manually, you can use the cp command-line tool after you next build:\n\nTerminal\ncp -r public .next/standalone/ && cp -r .next/static .next/standalone/.next/\n\nTo start your minimal server.js file locally, run the following command:\n\nTerminal\nnode .next/standalone/server.js\n\nGood to know:\n\nIf your project needs to listen to a specific port or hostname, you can define PORT or HOSTNAME environment variables before running server.js. For example, run PORT=8080 HOSTNAME=0.0.0.0 node server.js to start the server on http://0.0.0.0:8080.\nCaveats\nWhile tracing in monorepo setups, the project directory is used for tracing by default. For next build packages/web-app, packages/web-app would be the tracing root and any files outside of that folder will not be included. To include files outside of this folder you can set outputFileTracingRoot in your next.config.js.\npackages/web-app/next.config.js\nconst path = require('path')\n \nmodule.exports = {\n  // this includes files from the monorepo base two directories up\n  outputFileTracingRoot: path.join(__dirname, '../../'),\n}\nThere are some cases in which Next.js might fail to include required files, or might incorrectly include unused files. In those cases, you can leverage outputFileTracingExcludes and outputFileTracingIncludes respectively in next.config.js. Each option accepts an object whose keys are route globs (matched with picomatch\n against the route path, e.g. /api/hello) and whose values are glob patterns resolved from the project root that specify files to include or exclude in the trace.\n\nGood to know: In a monorepo, project root refers to the Next.js project root (the folder containing next.config.js, e.g., packages/web-app), not necessarily the monorepo root.\n\nnext.config.js\nmodule.exports = {\n  outputFileTracingExcludes: {\n    '/api/hello': ['./un-necessary-folder/**/*'],\n  },\n  outputFileTracingIncludes: {\n    '/api/another': ['./necessary-folder/**/*'],\n    '/api/login/\\\\[\\\\[\\\\.\\\\.\\\\.slug\\\\]\\\\]': [\n      './node_modules/aws-crt/dist/bin/**/*',\n    ],\n  },\n}\n\nUsing a src/ directory does not change how you write these options:\n\nKeys still match the route path ('/api/hello', '/products/[id]', etc.).\nValues can reference paths under src/ since they are resolved relative to the project root.\nnext.config.js\nmodule.exports = {\n  outputFileTracingIncludes: {\n    '/products/*': ['src/lib/payments/**/*'],\n    '/*': ['src/config/runtime/**/*.json'],\n  },\n  outputFileTracingExcludes: {\n    '/api/*': ['src/temp/**/*', 'public/large-logs/**/*'],\n  },\n}\n\nYou can also target all routes using a global key like '/*':\n\nnext.config.js\nmodule.exports = {\n  outputFileTracingIncludes: {\n    '/*': ['src/i18n/locales/**/*.json'],\n  },\n}\n\nThese options are applied to server traces and do not affect routes that do not produce a server trace file:\n\nEdge Runtime routes are not affected.\nFully static pages are not affected.\n\nIn monorepos or when you need to include files outside the app folder, combine outputFileTracingRoot with includes:\n\nnext.config.js\nconst path = require('path')\n \nmodule.exports = {\n  // Trace from the monorepo root\n  outputFileTracingRoot: path.join(__dirname, '../../'),\n  outputFileTracingIncludes: {\n    '/route1': ['../shared/assets/**/*'],\n  },\n}\n\nGood to know:\n\nPrefer forward slashes (/) in patterns for cross-platform compatibility.\nKeep patterns as narrow as possible to avoid oversized traces (avoid **/* at the repo root).\n\nCommon include patterns for native/runtime assets:\n\nnext.config.js\nmodule.exports = {\n  outputFileTracingIncludes: {\n    '/*': ['node_modules/sharp/**/*', 'node_modules/aws-crt/dist/bin/**/*'],\n  },\n}\nPrevious\noptimizePackageImports\nNext\npageExtensions\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: pageExtensions | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/pageExtensions",
    "html": "Configuration\nnext.config.js\npageExtensions\nCopy page\npageExtensions\n\nBy default, Next.js accepts files with the following extensions: .tsx, .ts, .jsx, .js. This can be modified to allow other extensions like markdown (.md, .mdx).\n\nnext.config.js\nconst withMDX = require('@next/mdx')()\n \n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  pageExtensions: ['js', 'jsx', 'ts', 'tsx', 'md', 'mdx'],\n}\n \nmodule.exports = withMDX(nextConfig)\nPrevious\noutput\nNext\npoweredByHeader\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: poweredByHeader | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/poweredByHeader",
    "html": "Configuration\nnext.config.js\npoweredByHeader\nCopy page\npoweredByHeader\n\nBy default Next.js will add the x-powered-by header. To opt-out of it, open next.config.js and disable the poweredByHeader config:\n\nnext.config.js\nmodule.exports = {\n  poweredByHeader: false,\n}\nPrevious\npageExtensions\nNext\nproductionBrowserSourceMaps\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: productionBrowserSourceMaps | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/productionBrowserSourceMaps",
    "html": "Configuration\nnext.config.js\nproductionBrowserSourceMaps\nCopy page\nproductionBrowserSourceMaps\n\nSource Maps are enabled by default during development. During production builds, they are disabled to prevent you leaking your source on the client, unless you specifically opt-in with the configuration flag.\n\nNext.js provides a configuration flag you can use to enable browser source map generation during the production build:\n\nnext.config.js\nmodule.exports = {\n  productionBrowserSourceMaps: true,\n}\n\nWhen the productionBrowserSourceMaps option is enabled, the source maps will be output in the same directory as the JavaScript files. Next.js will automatically serve these files when requested.\n\nAdding source maps can increase next build time\nIncreases memory usage during next build\nPrevious\npoweredByHeader\nNext\nproxyClientMaxBodySize\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: proxyClientMaxBodySize | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/proxyClientMaxBodySize",
    "html": "Configuration\nnext.config.js\nproxyClientMaxBodySize\nCopy page\nproxyClientMaxBodySize\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nWhen proxy is used, Next.js automatically clones the request body and buffers it in memory to enable multiple reads - both in proxy and the underlying route handler. To prevent excessive memory usage, this configuration option sets a size limit on the buffered body.\n\nBy default, the maximum body size is 10MB. If a request body exceeds this limit, the body will only be buffered up to the limit, and a warning will be logged indicating which route exceeded the limit.\n\nOptions\nString format (recommended)\n\nSpecify the size using a human-readable string format:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    proxyClientMaxBodySize: '1mb',\n  },\n}\n \nexport default nextConfig\n\nSupported units: b, kb, mb, gb\n\nNumber format\n\nAlternatively, specify the size in bytes as a number:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    proxyClientMaxBodySize: 1048576, // 1MB in bytes\n  },\n}\n \nexport default nextConfig\nBehavior\n\nWhen a request body exceeds the configured limit:\n\nNext.js will buffer only the first N bytes (up to the limit)\nA warning will be logged to the console indicating the route that exceeded the limit\nThe request will continue processing normally, but only the partial body will be available\nThe request will not fail or return an error to the client\n\nIf your application needs to process the full request body, you should either:\n\nIncrease the proxyClientMaxBodySize limit\nHandle the partial body gracefully in your application logic\nExample\nproxy.ts\nimport { NextRequest, NextResponse } from 'next/server'\n \nexport async function proxy(request: NextRequest) {\n  // Next.js automatically buffers the body with the configured size limit\n  // You can read the body in proxy...\n  const body = await request.text()\n \n  // If the body exceeded the limit, only partial data will be available\n  console.log('Body size:', body.length)\n \n  return NextResponse.next()\n}\napp/api/upload/route.ts\nimport { NextRequest, NextResponse } from 'next/server'\n \nexport async function POST(request: NextRequest) {\n  // ...and the body is still available in your route handler\n  const body = await request.text()\n \n  console.log('Body in route handler:', body.length)\n \n  return NextResponse.json({ received: body.length })\n}\nGood to know\nThis setting only applies when proxy is used in your application\nThe default limit of 10MB is designed to balance memory usage and typical use cases\nThe limit applies per-request, not globally across all concurrent requests\nFor applications handling large file uploads, consider increasing the limit accordingly\nPrevious\nproductionBrowserSourceMaps\nNext\nreactCompiler\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: reactCompiler | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/reactCompiler",
    "html": "Configuration\nnext.config.js\nreactCompiler\nCopy page\nreactCompiler\n\nNext.js includes support for the React Compiler\n, a tool designed to improve performance by automatically optimizing component rendering. This reduces the need for manual memoization using useMemo and useCallback.\n\nNext.js includes a custom performance optimization written in SWC that makes the React Compiler more efficient. Instead of running the compiler on every file, Next.js analyzes your project and only applies the React Compiler to relevant files. This avoids unnecessary work and leads to faster builds compared to using the Babel plugin on its own.\n\nHow It Works\n\nThe React Compiler runs through a Babel plugin. To keep builds fast, Next.js uses a custom SWC optimization that only applies the React Compiler to relevant files—like those with JSX or React Hooks.\n\nThis avoids compiling everything and keeps the performance cost minimal. You may still see slightly slower builds compared to the default Rust-based compiler, but the impact is small and localized.\n\nTo use it, install the babel-plugin-react-compiler:\n\nTerminal\nnpm install -D babel-plugin-react-compiler\n\nThen, add reactCompiler option in next.config.js:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  reactCompiler: true,\n}\n \nexport default nextConfig\nAnnotations\n\nYou can configure the compiler to run in \"opt-in\" mode as follows:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  reactCompiler: {\n    compilationMode: 'annotation',\n  },\n}\n \nexport default nextConfig\n\nThen, you can annotate specific components or hooks with the \"use memo\" directive from React to opt-in:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Page() {\n  'use memo'\n  // ...\n}\n\nNote: You can also use the \"use no memo\" directive from React for the opposite effect, to opt-out a component or hook.\n\nPrevious\nproxyClientMaxBodySize\nNext\nreactMaxHeadersLength\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: reactMaxHeadersLength | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/reactMaxHeadersLength",
    "html": "Configuration\nnext.config.js\nreactMaxHeadersLength\nCopy page\nreactMaxHeadersLength\n\nDuring static rendering, React can emit headers that can be added to the response. These can be used to improve performance by allowing the browser to preload resources like fonts, scripts, and stylesheets. The default value is 6000, but you can override this value by configuring the reactMaxHeadersLength option in next.config.js:\n\nnext.config.js\nmodule.exports = {\n  reactMaxHeadersLength: 1000,\n}\n\nGood to know: This option is only available in App Router.\n\nDepending on the type of proxy between the browser and the server, the headers can be truncated. For example, if you are using a reverse proxy that doesn't support long headers, you should set a lower value to ensure that the headers are not truncated.\n\nPrevious\nreactCompiler\nNext\nreactStrictMode\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: reactStrictMode | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/reactStrictMode",
    "html": "Configuration\nnext.config.js\nreactStrictMode\nCopy page\nreactStrictMode\n\nGood to know: Since Next.js 13.5.1, Strict Mode is true by default with app router, so the above configuration is only necessary for pages. You can still disable Strict Mode by setting reactStrictMode: false.\n\nSuggested: We strongly suggest you enable Strict Mode in your Next.js application to better prepare your application for the future of React.\n\nReact's Strict Mode\n is a development mode only feature for highlighting potential problems in an application. It helps to identify unsafe lifecycles, legacy API usage, and a number of other features.\n\nThe Next.js runtime is Strict Mode-compliant. To opt-in to Strict Mode, configure the following option in your next.config.js:\n\nnext.config.js\nmodule.exports = {\n  reactStrictMode: true,\n}\n\nIf you or your team are not ready to use Strict Mode in your entire application, that's OK! You can incrementally migrate on a page-by-page basis using <React.StrictMode>.\n\nPrevious\nreactMaxHeadersLength\nNext\nredirects\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: redirects | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/redirects",
    "html": "Configuration\nnext.config.js\nredirects\nCopy page\nredirects\n\nRedirects allow you to redirect an incoming request path to a different destination path.\n\nTo use redirects you can use the redirects key in next.config.js:\n\nnext.config.js\nmodule.exports = {\n  async redirects() {\n    return [\n      {\n        source: '/about',\n        destination: '/',\n        permanent: true,\n      },\n    ]\n  },\n}\n\nredirects is an async function that expects an array to be returned holding objects with source, destination, and permanent properties:\n\nsource is the incoming request path pattern.\ndestination is the path you want to route to.\npermanent true or false - if true will use the 308 status code which instructs clients/search engines to cache the redirect forever, if false will use the 307 status code which is temporary and is not cached.\n\nWhy does Next.js use 307 and 308? Traditionally a 302 was used for a temporary redirect, and a 301 for a permanent redirect, but many browsers changed the request method of the redirect to GET, regardless of the original method. For example, if the browser made a request to POST /v1/users which returned status code 302 with location /v2/users, the subsequent request might be GET /v2/users instead of the expected POST /v2/users. Next.js uses the 307 temporary redirect, and 308 permanent redirect status codes to explicitly preserve the request method used.\n\nbasePath: false or undefined - if false the basePath won't be included when matching, can be used for external redirects only.\nlocale: false or undefined - whether the locale should not be included when matching.\nhas is an array of has objects with the type, key and value properties.\nmissing is an array of missing objects with the type, key and value properties.\n\nRedirects are checked before the filesystem which includes pages and /public files.\n\nWhen using the Pages Router, redirects are not applied to client-side routing (Link, router.push) unless Proxy is present and matches the path.\n\nWhen a redirect is applied, any query values provided in the request will be passed through to the redirect destination. For example, see the following redirect configuration:\n\n{\n  source: '/old-blog/:path*',\n  destination: '/blog/:path*',\n  permanent: false\n}\n\nGood to know: Remember to include the forward slash / before the colon : in path parameters of the source and destination paths, otherwise the path will be treated as a literal string and you run the risk of causing infinite redirects.\n\nWhen /old-blog/post-1?hello=world is requested, the client will be redirected to /blog/post-1?hello=world.\n\nPath Matching\n\nPath matches are allowed, for example /old-blog/:slug will match /old-blog/hello-world (no nested paths):\n\nnext.config.js\nmodule.exports = {\n  async redirects() {\n    return [\n      {\n        source: '/old-blog/:slug',\n        destination: '/news/:slug', // Matched parameters can be used in the destination\n        permanent: true,\n      },\n    ]\n  },\n}\nWildcard Path Matching\n\nTo match a wildcard path you can use * after a parameter, for example /blog/:slug* will match /blog/a/b/c/d/hello-world:\n\nnext.config.js\nmodule.exports = {\n  async redirects() {\n    return [\n      {\n        source: '/blog/:slug*',\n        destination: '/news/:slug*', // Matched parameters can be used in the destination\n        permanent: true,\n      },\n    ]\n  },\n}\nRegex Path Matching\n\nTo match a regex path you can wrap the regex in parentheses after a parameter, for example /post/:slug(\\\\d{1,}) will match /post/123 but not /post/abc:\n\nnext.config.js\nmodule.exports = {\n  async redirects() {\n    return [\n      {\n        source: '/post/:slug(\\\\d{1,})',\n        destination: '/news/:slug', // Matched parameters can be used in the destination\n        permanent: false,\n      },\n    ]\n  },\n}\n\nThe following characters (, ), {, }, :, *, +, ? are used for regex path matching, so when used in the source as non-special values they must be escaped by adding \\\\ before them:\n\nnext.config.js\nmodule.exports = {\n  async redirects() {\n    return [\n      {\n        // this will match `/english(default)/something` being requested\n        source: '/english\\\\(default\\\\)/:slug',\n        destination: '/en-us/:slug',\n        permanent: false,\n      },\n    ]\n  },\n}\nHeader, Cookie, and Query Matching\n\nTo only match a redirect when header, cookie, or query values also match the has field or don't match the missing field can be used. Both the source and all has items must match and all missing items must not match for the redirect to be applied.\n\nhas and missing items can have the following fields:\n\ntype: String - must be either header, cookie, host, or query.\nkey: String - the key from the selected type to match against.\nvalue: String or undefined - the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the value first-(?<paramName>.*) is used for first-second then second will be usable in the destination with :paramName.\nnext.config.js\nmodule.exports = {\n  async redirects() {\n    return [\n      // if the header `x-redirect-me` is present,\n      // this redirect will be applied\n      {\n        source: '/:path((?!another-page$).*)',\n        has: [\n          {\n            type: 'header',\n            key: 'x-redirect-me',\n          },\n        ],\n        permanent: false,\n        destination: '/another-page',\n      },\n      // if the header `x-dont-redirect` is present,\n      // this redirect will NOT be applied\n      {\n        source: '/:path((?!another-page$).*)',\n        missing: [\n          {\n            type: 'header',\n            key: 'x-do-not-redirect',\n          },\n        ],\n        permanent: false,\n        destination: '/another-page',\n      },\n      // if the source, query, and cookie are matched,\n      // this redirect will be applied\n      {\n        source: '/specific/:path*',\n        has: [\n          {\n            type: 'query',\n            key: 'page',\n            // the page value will not be available in the\n            // destination since value is provided and doesn't\n            // use a named capture group e.g. (?<page>home)\n            value: 'home',\n          },\n          {\n            type: 'cookie',\n            key: 'authorized',\n            value: 'true',\n          },\n        ],\n        permanent: false,\n        destination: '/another/:path*',\n      },\n      // if the header `x-authorized` is present and\n      // contains a matching value, this redirect will be applied\n      {\n        source: '/',\n        has: [\n          {\n            type: 'header',\n            key: 'x-authorized',\n            value: '(?<authorized>yes|true)',\n          },\n        ],\n        permanent: false,\n        destination: '/home?authorized=:authorized',\n      },\n      // if the host is `example.com`,\n      // this redirect will be applied\n      {\n        source: '/:path((?!another-page$).*)',\n        has: [\n          {\n            type: 'host',\n            value: 'example.com',\n          },\n        ],\n        permanent: false,\n        destination: '/another-page',\n      },\n    ]\n  },\n}\nRedirects with basePath support\n\nWhen leveraging basePath support with redirects each source and destination is automatically prefixed with the basePath unless you add basePath: false to the redirect:\n\nnext.config.js\nmodule.exports = {\n  basePath: '/docs',\n \n  async redirects() {\n    return [\n      {\n        source: '/with-basePath', // automatically becomes /docs/with-basePath\n        destination: '/another', // automatically becomes /docs/another\n        permanent: false,\n      },\n      {\n        // does not add /docs since basePath: false is set\n        source: '/without-basePath',\n        destination: 'https://example.com',\n        basePath: false,\n        permanent: false,\n      },\n    ]\n  },\n}\nRedirects with i18n support\n\nWhen implementing redirects with internationalization in the App Router, you can include locales in next.config.js redirects, but only as hardcoded paths.\n\nFor dynamic or per-request locale handling, use dynamic route segments and proxy, which can redirect based on the user's preferred language.\n\nnext.config.js\nmodule.exports = {\n  async redirects() {\n    return [\n      {\n        // Manually handle locale prefixes for App Router\n        source: '/en/old-path',\n        destination: '/en/new-path',\n        permanent: false,\n      },\n      {\n        // Redirect for all locales using a parameter\n        source: '/:locale/old-path',\n        destination: '/:locale/new-path',\n        permanent: false,\n      },\n      {\n        // Redirect from one locale to another\n        source: '/de/old-path',\n        destination: '/en/new-path',\n        permanent: false,\n      },\n      {\n        // Catch-all redirect for multiple locales\n        source: '/:locale(en|fr|de)/:path*',\n        destination: '/:locale/new-section/:path*',\n        permanent: false,\n      },\n    ]\n  },\n}\n\nIn some rare cases, you might need to assign a custom status code for older HTTP Clients to properly redirect. In these cases, you can use the statusCode property instead of the permanent property, but not both. To ensure IE11 compatibility, a Refresh header is automatically added for the 308 status code.\n\nOther Redirects\nInside API Routes and Route Handlers, you can redirect based on the incoming request.\nInside getStaticProps and getServerSideProps, you can redirect specific pages at request-time.\nVersion History\nVersion\tChanges\nv13.3.0\tmissing added.\nv10.2.0\thas added.\nv9.5.0\tredirects added.\nPrevious\nreactStrictMode\nNext\nrewrites\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: sassOptions | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/sassOptions",
    "html": "Configuration\nnext.config.js\nsassOptions\nCopy page\nsassOptions\n\nsassOptions allow you to configure the Sass compiler.\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst sassOptions = {\n  additionalData: `\n    $var: red;\n  `,\n}\n \nconst nextConfig: NextConfig = {\n  sassOptions: {\n    ...sassOptions,\n    implementation: 'sass-embedded',\n  },\n}\n \nexport default nextConfig\n\nGood to know:\n\nsassOptions are not typed outside of implementation because Next.js does not maintain the other possible properties.\nThe functions property for defining custom Sass functions is only supported with webpack. When using Turbopack, custom Sass functions are not available because Turbopack's Rust-based architecture cannot directly execute JavaScript functions passed through this option.\nPrevious\nrewrites\nNext\nserverActions\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: rewrites | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites",
    "html": "Configuration\nnext.config.js\nrewrites\nCopy page\nrewrites\n\nRewrites allow you to map an incoming request path to a different destination path.\n\nRewrites act as a URL proxy and mask the destination path, making it appear the user hasn't changed their location on the site. In contrast, redirects will reroute to a new page and show the URL changes.\n\nTo use rewrites you can use the rewrites key in next.config.js:\n\nnext.config.js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/about',\n        destination: '/',\n      },\n    ]\n  },\n}\n\nRewrites are applied to client-side routing. In the example above, navigating to <Link href=\"/about\"> will serve content from / while keeping the URL as /about.\n\nrewrites is an async function that expects to return either an array or an object of arrays (see below) holding objects with source and destination properties:\n\nsource: String - is the incoming request path pattern.\ndestination: String is the path you want to route to.\nbasePath: false or undefined - if false the basePath won't be included when matching, can be used for external rewrites only.\nlocale: false or undefined - whether the locale should not be included when matching.\nhas is an array of has objects with the type, key and value properties.\nmissing is an array of missing objects with the type, key and value properties.\n\nWhen the rewrites function returns an array, rewrites are applied after checking the filesystem (pages and /public files) and before dynamic routes. When the rewrites function returns an object of arrays with a specific shape, this behavior can be changed and more finely controlled, as of v10.1 of Next.js:\n\nnext.config.js\nmodule.exports = {\n  async rewrites() {\n    return {\n      beforeFiles: [\n        // These rewrites are checked after headers/redirects\n        // and before all files including _next/public files which\n        // allows overriding page files\n        {\n          source: '/some-page',\n          destination: '/somewhere-else',\n          has: [{ type: 'query', key: 'overrideMe' }],\n        },\n      ],\n      afterFiles: [\n        // These rewrites are checked after pages/public files\n        // are checked but before dynamic routes\n        {\n          source: '/non-existent',\n          destination: '/somewhere-else',\n        },\n      ],\n      fallback: [\n        // These rewrites are checked after both pages/public files\n        // and dynamic routes are checked\n        {\n          source: '/:path*',\n          destination: `https://my-old-site.com/:path*`,\n        },\n      ],\n    }\n  },\n}\n\nGood to know: rewrites in beforeFiles do not check the filesystem/dynamic routes immediately after matching a source, they continue until all beforeFiles have been checked.\n\nThe order Next.js routes are checked is:\n\nheaders are checked/applied\nredirects are checked/applied\nproxy\nbeforeFiles rewrites are checked/applied\nstatic files from the public directory, _next/static files, and non-dynamic pages are checked/served\nafterFiles rewrites are checked/applied, if one of these rewrites is matched we check dynamic routes/static files after each match\nfallback rewrites are checked/applied, these are applied before rendering the 404 page and after dynamic routes/all static assets have been checked. If you use fallback: true/'blocking' in getStaticPaths, the fallback rewrites defined in your next.config.js will not be run.\nRewrite parameters\n\nWhen using parameters in a rewrite the parameters will be passed in the query by default when none of the parameters are used in the destination.\n\nnext.config.js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/old-about/:path*',\n        destination: '/about', // The :path parameter isn't used here so will be automatically passed in the query\n      },\n    ]\n  },\n}\n\nIf a parameter is used in the destination none of the parameters will be automatically passed in the query.\n\nnext.config.js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/docs/:path*',\n        destination: '/:path*', // The :path parameter is used here so will not be automatically passed in the query\n      },\n    ]\n  },\n}\n\nYou can still pass the parameters manually in the query if one is already used in the destination by specifying the query in the destination.\n\nnext.config.js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/:first/:second',\n        destination: '/:first?second=:second',\n        // Since the :first parameter is used in the destination the :second parameter\n        // will not automatically be added in the query although we can manually add it\n        // as shown above\n      },\n    ]\n  },\n}\n\nGood to know: Static pages from Automatic Static Optimization or prerendering params from rewrites will be parsed on the client after hydration and provided in the query.\n\nPath Matching\n\nPath matches are allowed, for example /blog/:slug will match /blog/hello-world (no nested paths):\n\nnext.config.js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/blog/:slug',\n        destination: '/news/:slug', // Matched parameters can be used in the destination\n      },\n    ]\n  },\n}\nWildcard Path Matching\n\nTo match a wildcard path you can use * after a parameter, for example /blog/:slug* will match /blog/a/b/c/d/hello-world:\n\nnext.config.js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/blog/:slug*',\n        destination: '/news/:slug*', // Matched parameters can be used in the destination\n      },\n    ]\n  },\n}\nRegex Path Matching\n\nTo match a regex path you can wrap the regex in parenthesis after a parameter, for example /blog/:slug(\\\\d{1,}) will match /blog/123 but not /blog/abc:\n\nnext.config.js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/old-blog/:post(\\\\d{1,})',\n        destination: '/blog/:post', // Matched parameters can be used in the destination\n      },\n    ]\n  },\n}\n\nThe following characters (, ), {, }, [, ], |, \\, ^, ., :, *, +, -, ?, $ are used for regex path matching, so when used in the source as non-special values they must be escaped by adding \\\\ before them:\n\nnext.config.js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        // this will match `/english(default)/something` being requested\n        source: '/english\\\\(default\\\\)/:slug',\n        destination: '/en-us/:slug',\n      },\n    ]\n  },\n}\nHeader, Cookie, and Query Matching\n\nTo only match a rewrite when header, cookie, or query values also match the has field or don't match the missing field can be used. Both the source and all has items must match and all missing items must not match for the rewrite to be applied.\n\nhas and missing items can have the following fields:\n\ntype: String - must be either header, cookie, host, or query.\nkey: String - the key from the selected type to match against.\nvalue: String or undefined - the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the value first-(?<paramName>.*) is used for first-second then second will be usable in the destination with :paramName.\nnext.config.js\nmodule.exports = {\n  async rewrites() {\n    return [\n      // if the header `x-rewrite-me` is present,\n      // this rewrite will be applied\n      {\n        source: '/:path*',\n        has: [\n          {\n            type: 'header',\n            key: 'x-rewrite-me',\n          },\n        ],\n        destination: '/another-page',\n      },\n      // if the header `x-rewrite-me` is not present,\n      // this rewrite will be applied\n      {\n        source: '/:path*',\n        missing: [\n          {\n            type: 'header',\n            key: 'x-rewrite-me',\n          },\n        ],\n        destination: '/another-page',\n      },\n      // if the source, query, and cookie are matched,\n      // this rewrite will be applied\n      {\n        source: '/specific/:path*',\n        has: [\n          {\n            type: 'query',\n            key: 'page',\n            // the page value will not be available in the\n            // destination since value is provided and doesn't\n            // use a named capture group e.g. (?<page>home)\n            value: 'home',\n          },\n          {\n            type: 'cookie',\n            key: 'authorized',\n            value: 'true',\n          },\n        ],\n        destination: '/:path*/home',\n      },\n      // if the header `x-authorized` is present and\n      // contains a matching value, this rewrite will be applied\n      {\n        source: '/:path*',\n        has: [\n          {\n            type: 'header',\n            key: 'x-authorized',\n            value: '(?<authorized>yes|true)',\n          },\n        ],\n        destination: '/home?authorized=:authorized',\n      },\n      // if the host is `example.com`,\n      // this rewrite will be applied\n      {\n        source: '/:path*',\n        has: [\n          {\n            type: 'host',\n            value: 'example.com',\n          },\n        ],\n        destination: '/another-page',\n      },\n    ]\n  },\n}\nRewriting to an external URL\nExamples\n\nRewrites allow you to rewrite to an external URL. This is especially useful for incrementally adopting Next.js. The following is an example rewrite for redirecting the /blog route of your main app to an external site.\n\nnext.config.js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/blog',\n        destination: 'https://example.com/blog',\n      },\n      {\n        source: '/blog/:slug',\n        destination: 'https://example.com/blog/:slug', // Matched parameters can be used in the destination\n      },\n    ]\n  },\n}\n\nIf you're using trailingSlash: true, you also need to insert a trailing slash in the source parameter. If the destination server is also expecting a trailing slash it should be included in the destination parameter as well.\n\nnext.config.js\nmodule.exports = {\n  trailingSlash: true,\n  async rewrites() {\n    return [\n      {\n        source: '/blog/',\n        destination: 'https://example.com/blog/',\n      },\n      {\n        source: '/blog/:path*/',\n        destination: 'https://example.com/blog/:path*/',\n      },\n    ]\n  },\n}\nIncremental adoption of Next.js\n\nYou can also have Next.js fall back to proxying to an existing website after checking all Next.js routes.\n\nThis way you don't have to change the rewrites configuration when migrating more pages to Next.js\n\nnext.config.js\nmodule.exports = {\n  async rewrites() {\n    return {\n      fallback: [\n        {\n          source: '/:path*',\n          destination: `https://custom-routes-proxying-endpoint.vercel.app/:path*`,\n        },\n      ],\n    }\n  },\n}\nRewrites with basePath support\n\nWhen leveraging basePath support with rewrites each source and destination is automatically prefixed with the basePath unless you add basePath: false to the rewrite:\n\nnext.config.js\nmodule.exports = {\n  basePath: '/docs',\n \n  async rewrites() {\n    return [\n      {\n        source: '/with-basePath', // automatically becomes /docs/with-basePath\n        destination: '/another', // automatically becomes /docs/another\n      },\n      {\n        // does not add /docs to /without-basePath since basePath: false is set\n        // Note: this can not be used for internal rewrites e.g. `destination: '/another'`\n        source: '/without-basePath',\n        destination: 'https://example.com',\n        basePath: false,\n      },\n    ]\n  },\n}\nVersion History\nVersion\tChanges\nv13.3.0\tmissing added.\nv10.2.0\thas added.\nv9.5.0\tHeaders added.\nPrevious\nredirects\nNext\nsassOptions\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: serverActions | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/serverActions",
    "html": "Configuration\nnext.config.js\nserverActions\nCopy page\nserverActions\n\nOptions for configuring Server Actions behavior in your Next.js application.\n\nallowedOrigins\n\nA list of extra safe origin domains from which Server Actions can be invoked. Next.js compares the origin of a Server Action request with the host domain, ensuring they match to prevent CSRF attacks. If not provided, only the same origin is allowed.\n\nnext.config.js\n/** @type {import('next').NextConfig} */\n \nmodule.exports = {\n  experimental: {\n    serverActions: {\n      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],\n    },\n  },\n}\nbodySizeLimit\n\nBy default, the maximum size of the request body sent to a Server Action is 1MB, to prevent the consumption of excessive server resources in parsing large amounts of data, as well as potential DDoS attacks.\n\nHowever, you can configure this limit using the serverActions.bodySizeLimit option. It can take the number of bytes or any string format supported by bytes, for example 1000, '500kb' or '3mb'.\n\nnext.config.js\n/** @type {import('next').NextConfig} */\n \nmodule.exports = {\n  experimental: {\n    serverActions: {\n      bodySizeLimit: '2mb',\n    },\n  },\n}\nEnabling Server Actions (v13)\n\nServer Actions became a stable feature in Next.js 14, and are enabled by default. However, if you are using an earlier version of Next.js, you can enable them by setting experimental.serverActions to true.\n\nnext.config.js\n/** @type {import('next').NextConfig} */\nconst config = {\n  experimental: {\n    serverActions: true,\n  },\n}\n \nmodule.exports = config\nPrevious\nsassOptions\nNext\nserverComponentsHmrCache\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: serverComponentsHmrCache | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/serverComponentsHmrCache",
    "html": "Configuration\nnext.config.js\nserverComponentsHmrCache\nCopy page\nserverComponentsHmrCache\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nThe experimental serverComponentsHmrCache option allows you to cache fetch responses in Server Components across Hot Module Replacement (HMR) refreshes in local development. This results in faster responses and reduced costs for billed API calls.\n\nBy default, the HMR cache applies to all fetch requests, including those with the cache: 'no-store' option. This means uncached requests will not show fresh data between HMR refreshes. However, the cache will be cleared on navigation or full-page reloads.\n\nYou can disable the HMR cache by setting serverComponentsHmrCache to false in your next.config.js file:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    serverComponentsHmrCache: false, // defaults to true\n  },\n}\n \nexport default nextConfig\n\nGood to know: For better observability, we recommend using the logging.fetches option which logs fetch cache hits and misses in the console during development.\n\nPrevious\nserverActions\nNext\nserverExternalPackages\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: staleTimes | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/staleTimes",
    "html": "Configuration\nnext.config.js\nstaleTimes\nCopy page\nstaleTimes\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nstaleTimes is an experimental feature that enables caching of page segments in the client-side router cache.\n\nYou can enable this experimental feature and provide custom revalidation times by setting the experimental staleTimes flag:\n\nnext.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    staleTimes: {\n      dynamic: 30,\n      static: 180,\n    },\n  },\n}\n \nmodule.exports = nextConfig\n\nThe static and dynamic properties correspond with the time period (in seconds) based on different types of link prefetching.\n\nThe dynamic property is used when the page is neither statically generated nor fully prefetched (e.g. with prefetch={true}).\nDefault: 0 seconds (not cached)\nThe static property is used for statically generated pages, or when the prefetch prop on Link is set to true, or when calling router.prefetch.\nDefault: 5 minutes\n\nGood to know:\n\nLoading boundaries are considered reusable for the static period defined in this configuration.\nThis doesn't affect partial rendering, meaning shared layouts won't automatically be refetched on every navigation, only the page segment that changes.\nThis doesn't change back/forward caching behavior to prevent layout shift and to prevent losing the browser scroll position.\n\nYou can learn more about the Client Router Cache here.\n\nVersion History\nVersion\tChanges\nv15.0.0\tThe dynamic staleTimes default changed from 30s to 0s.\nv14.2.0\tExperimental staleTimes introduced.\nPrevious\nserverExternalPackages\nNext\nstaticGeneration*\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: serverExternalPackages | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/serverExternalPackages",
    "html": "Configuration\nnext.config.js\nserverExternalPackages\nCopy page\nserverExternalPackages\n\nDependencies used inside Server Components and Route Handlers will automatically be bundled by Next.js.\n\nIf a dependency is using Node.js specific features, you can choose to opt-out specific dependencies from the Server Components bundling and use native Node.js require.\n\nnext.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  serverExternalPackages: ['@acme/ui'],\n}\n \nmodule.exports = nextConfig\n\nNext.js includes a short list of popular packages\n that currently are working on compatibility and automatically opt-ed out:\n\n@appsignal/nodejs\n@aws-sdk/client-s3\n@aws-sdk/s3-presigned-post\n@blockfrost/blockfrost-js\n@highlight-run/node\n@huggingface/transformers\n@jpg-store/lucid-cardano\n@libsql/client\n@mikro-orm/core\n@mikro-orm/knex\n@node-rs/argon2\n@node-rs/bcrypt\n@prisma/client\n@react-pdf/renderer\n@sentry/profiling-node\n@sparticuz/chromium\n@sparticuz/chromium-min\n@statsig/statsig-node-core\n@swc/core\n@xenova/transformers\nargon2\nautoprefixer\naws-crt\nbcrypt\nbetter-sqlite3\ncanvas\nchromadb-default-embed\nconfig\ncpu-features\ncypress\ndd-trace\neslint\nexpress\nfirebase-admin\nhtmlrewriter\nimport-in-the-middle\nisolated-vm\njest\njsdom\nkeyv\nlibsql\nmdx-bundler\nmongodb\nmongoose\nnewrelic\nnext-mdx-remote\nnext-seo\nnode-cron\nnode-pty\nnode-web-audio-api\nonnxruntime-node\noslo\npg\nplaywright\nplaywright-core\npostcss\nprettier\nprisma\npuppeteer-core\npuppeteer\nravendb\nrequire-in-the-middle\nrimraf\nsharp\nshiki\nsqlite3\nts-node\nts-morph\ntypescript\nvscode-oniguruma\nwebpack\nwebsocket\nzeromq\nVersion\tChanges\nv15.0.0\tMoved from experimental to stable. Renamed from serverComponentsExternalPackages to serverExternalPackages\nPrevious\nserverComponentsHmrCache\nNext\nstaleTimes\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: staticGeneration* | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/staticGeneration",
    "html": "Configuration\nnext.config.js\nstaticGeneration*\nCopy page\nstaticGeneration*\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nThe staticGeneration* options allow you to configure the Static Generation process for advanced use cases.\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    staticGenerationRetryCount: 1,\n    staticGenerationMaxConcurrency: 8,\n    staticGenerationMinPagesPerWorker: 25,\n  },\n}\n \nexport default nextConfig\nConfig Options\n\nThe following options are available:\n\nstaticGenerationRetryCount: The number of times to retry a failed page generation before failing the build.\nstaticGenerationMaxConcurrency: The maximum number of pages to be processed per worker.\nstaticGenerationMinPagesPerWorker: The minimum number of pages to be processed before starting a new worker.\nPrevious\nstaleTimes\nNext\ntaint\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: taint | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/taint",
    "html": "Configuration\nnext.config.js\ntaint\nCopy page\ntaint\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\nUsage\n\nThe taint option enables support for experimental React APIs for tainting objects and values. This feature helps prevent sensitive data from being accidentally passed to the client. When enabled, you can use:\n\nexperimental_taintObjectReference\n taint objects references.\nexperimental_taintUniqueValue\n to taint unique values.\n\nGood to know: Activating this flag also enables the React experimental channel for app directory.\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    taint: true,\n  },\n}\n \nexport default nextConfig\n\nWarning: Do not rely on the taint API as your only mechanism to prevent exposing sensitive data to the client. See our security recommendations.\n\nThe taint APIs allows you to be defensive, by declaratively and explicitly marking data that is not allowed to pass through the Server-Client boundary. When an object or value, is passed through the Server-Client boundary, React throws an error.\n\nThis is helpful for cases where:\n\nThe methods to read data are out of your control\nYou have to work with sensitive data shapes not defined by you\nSensitive data is accessed during Server Component rendering\n\nIt is recommended to model your data and APIs so that sensitive data is not returned to contexts where it is not needed.\n\nCaveats\nTainting can only keep track of objects by reference. Copying an object creates an untainted version, which loses all guarantees given by the API. You'll need to taint the copy.\nTainting cannot keep track of data derived from a tainted value. You also need to taint the derived value.\nValues are tainted for as long as their lifetime reference is within scope. See the experimental_taintUniqueValue parameters reference\n, for more information.\nExamples\nTainting an object reference\n\nIn this case, the getUserDetails function returns data about a given user. We taint the user object reference, so that it cannot cross a Server-Client boundary. For example, assuming UserCard is a Client Component.\n\nimport { experimental_taintObjectReference } from 'react'\n \nfunction getUserDetails(id: string): UserDetails {\n  const user = await db.queryUserById(id)\n \n  experimental_taintObjectReference(\n    'Do not use the entire user info object. Instead, select only the fields you need.',\n    user\n  )\n \n  return user\n}\n\nWe can still access individual fields from the tainted userDetails object.\n\nexport async function ContactPage({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n  const userDetails = await getUserDetails(id)\n \n  return (\n    <UserCard\n      firstName={userDetails.firstName}\n      lastName={userDetails.lastName}\n    />\n  )\n}\n\nNow, passing the entire object to the Client Component will throw an error.\n\nexport async function ContactPage({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const userDetails = await getUserDetails(id)\n \n  // Throws an error\n  return <UserCard user={userDetails} />\n}\nTainting a unique value\n\nIn this case, we can access the server configuration by awaiting calls to config.getConfigDetails. However, the system configuration contains the SERVICE_API_KEY that we don't want to expose to clients.\n\nWe can taint the config.SERVICE_API_KEY value.\n\nimport { experimental_taintUniqueValue } from 'react'\n \nfunction getSystemConfig(): SystemConfig {\n  const config = await config.getConfigDetails()\n \n  experimental_taintUniqueValue(\n    'Do not pass configuration tokens to the client',\n    config,\n    config.SERVICE_API_KEY\n  )\n \n  return config\n}\n\nWe can still access other properties of the systemConfig object.\n\nexport async function Dashboard() {\n  const systemConfig = await getSystemConfig()\n \n  return <ClientDashboard version={systemConfig.SERVICE_API_VERSION} />\n}\n\nHowever, passing SERVICE_API_KEY to ClientDashboard throws an error.\n\nexport async function Dashboard() {\n  const systemConfig = await getSystemConfig()\n  // Someone makes a mistake in a PR\n  const version = systemConfig.SERVICE_API_KEY\n \n  return <ClientDashboard version={version} />\n}\n\nNote that, even though, systemConfig.SERVICE_API_KEY is reassigned to a new variable. Passing it to a Client Component still throws an error.\n\nWhereas, a value derived from a tainted unique value, will be exposed to the client.\n\nexport async function Dashboard() {\n  const systemConfig = await getSystemConfig()\n  // Someone makes a mistake in a PR\n  const version = `version::${systemConfig.SERVICE_API_KEY}`\n \n  return <ClientDashboard version={version} />\n}\n\nA better approach is to remove SERVICE_API_KEY from the data returned by getSystemConfig.\n\nPrevious\nstaticGeneration*\nNext\ntrailingSlash\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: trailingSlash | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/trailingSlash",
    "html": "Configuration\nnext.config.js\ntrailingSlash\nCopy page\ntrailingSlash\n\nBy default Next.js will redirect URLs with trailing slashes to their counterpart without a trailing slash. For example /about/ will redirect to /about. You can configure this behavior to act the opposite way, where URLs without trailing slashes are redirected to their counterparts with trailing slashes.\n\nOpen next.config.js and add the trailingSlash config:\n\nnext.config.js\nmodule.exports = {\n  trailingSlash: true,\n}\n\nWith this option set, URLs like /about will redirect to /about/.\n\nWhen using trailingSlash: true, certain URLs are exceptions and will not have a trailing slash appended:\n\nStatic file URLs, such as files with extensions.\nAny paths under .well-known/.\n\nFor example, the following URLs will remain unchanged: /file.txt, images/photos/picture.png, and .well-known/subfolder/config.json.\n\nWhen used with output: \"export\" configuration, the /about page will output /about/index.html (instead of the default /about.html).\n\nVersion History\nVersion\tChanges\nv9.5.0\ttrailingSlash added.\nPrevious\ntaint\nNext\ntranspilePackages\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: transpilePackages | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/transpilePackages",
    "html": "Configuration\nnext.config.js\ntranspilePackages\nCopy page\ntranspilePackages\n\nNext.js can automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (node_modules). This replaces the next-transpile-modules package.\n\nnext.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  transpilePackages: ['package-name'],\n}\n \nmodule.exports = nextConfig\nVersion History\nVersion\tChanges\nv13.0.0\ttranspilePackages added.\nPrevious\ntrailingSlash\nNext\nturbopack\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: turbopack | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/turbopack",
    "html": "Configuration\nnext.config.js\nturbopack\nCopy page\nturbopack\n\nThe turbopack option lets you customize Turbopack to transform different files and change how modules are resolved.\n\nGood to know: The turbopack option was previously named experimental.turbo in Next.js versions 13.0.0 to 15.2.x. The experimental.turbo option will be removed in Next.js 16.\n\nIf you are using an older version of Next.js, run npx @next/codemod@latest next-experimental-turbo-to-turbopack . to automatically migrate your configuration.\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  turbopack: {\n    // ...\n  },\n}\n \nexport default nextConfig\n\nGood to know:\n\nTurbopack for Next.js does not require loaders or loader configuration for built-in functionality. Turbopack has built-in support for CSS and compiling modern JavaScript, so there's no need for css-loader, postcss-loader, or babel-loader if you're using @babel/preset-env.\nReference\nOptions\n\nThe following options are available for the turbopack configuration:\n\nOption\tDescription\nroot\tSets the application root directory. Should be an absolute path.\nrules\tList of supported webpack loaders to apply when running with Turbopack.\nresolveAlias\tMap aliased imports to modules to load in their place.\nresolveExtensions\tList of extensions to resolve when importing files.\ndebugIds\tEnable generation of debug IDs\n in JavaScript bundles and source maps.\nSupported loaders\n\nThe following loaders have been tested to work with Turbopack's webpack loader implementation, but many other webpack loaders should work as well even if not listed here:\n\nbabel-loader\n (Configured automatically if a Babel configuration file is found)\n@svgr/webpack\nsvg-inline-loader\nyaml-loader\nstring-replace-loader\nraw-loader\nsass-loader\n (Configured automatically)\ngraphql-tag/loader\nMissing Webpack loader features\n\nTurbopack uses the loader-runner\n library to execute webpack loaders, which provides most of the standard loader API. However, some features are not supported:\n\nModule loading:\n\nimportModule\n - No support\nloadModule\n - No support\n\nFile system and output:\n\nfs\n - Partial support: only fs.readFile is currently implemented.\nemitFile\n - No support\n\nContext properties:\n\nversion\n - No support\nmode\n - No support\ntarget\n - No support\n\nUtilities:\n\nutils\n - No support\nresolve\n - No support (use getResolve\n instead)\n\nIf you have a loader that is critically dependent upon one of these features please file an issue.\n\nExamples\nRoot directory\n\nTurbopack uses the root directory to resolve modules. Files outside of the project root are not resolved.\n\nNext.js automatically detects the root directory of your project. It does so by looking for one of these files:\n\npnpm-lock.yaml\npackage-lock.json\nyarn.lock\nbun.lock\nbun.lockb\n\nIf you have a different project structure, for example if you don't use workspaces, you can manually set the root option:\n\nnext.config.js\nconst path = require('path')\nmodule.exports = {\n  turbopack: {\n    root: path.join(__dirname, '..'),\n  },\n}\nConfiguring webpack loaders\n\nIf you need loader support beyond what's built in, many webpack loaders already work with Turbopack. There are currently some limitations:\n\nOnly a core subset of the webpack loader API is implemented. Currently, there is enough coverage for some popular loaders, and we'll expand our API support in the future.\nOnly loaders that return JavaScript code are supported. Loaders that transform files like stylesheets or images are not currently supported.\nOptions passed to webpack loaders must be plain JavaScript primitives, objects, and arrays. For example, it's not possible to pass require() plugin modules as option values.\n\nTo configure loaders, add the names of the loaders you've installed and any options in next.config.js, mapping file extensions to a list of loaders. Rules are evaluated in order.\n\nHere is an example below using the @svgr/webpack\n loader, which enables importing .svg files and rendering them as React components.\n\nnext.config.js\nmodule.exports = {\n  turbopack: {\n    rules: {\n      '*.svg': {\n        loaders: ['@svgr/webpack'],\n        as: '*.js',\n      },\n    },\n  },\n}\n\nGood to know: Globs used in the rules object match based on file name, unless the glob contains a / character, which will cause it to match based on the full project-relative file path. Windows file paths are normalized to use unix-style / path separators.\n\nTurbopack uses a modified version of the Rust globset library\n.\n\nFor loaders that require configuration options, you can use an object format instead of a string:\n\nnext.config.js\nmodule.exports = {\n  turbopack: {\n    rules: {\n      '*.svg': {\n        loaders: [\n          {\n            loader: '@svgr/webpack',\n            options: {\n              icon: true,\n            },\n          },\n        ],\n        as: '*.js',\n      },\n    },\n  },\n}\n\nGood to know: Prior to Next.js version 13.4.4, turbopack.rules was named turbo.loaders and only accepted file extensions like .mdx instead of *.mdx.\n\nAdvanced webpack loader conditions\n\nYou can further restrict where a loader runs using the advanced condition syntax:\n\nnext.config.js\nmodule.exports = {\n  turbopack: {\n    rules: {\n      // '*' will match all file paths, but we restrict where our\n      // rule runs with a condition.\n      '*': {\n        condition: {\n          all: [\n            // 'foreign' is a built-in condition.\n            { not: 'foreign' },\n            // 'path' can be a RegExp or a glob string. A RegExp matches\n            // anywhere in the full project-relative file path.\n            { path: /^img\\/[0-9]{3}\\// },\n            {\n              any: [\n                { path: '*.svg' },\n                // 'content' is always a RegExp, and can match\n                // anywhere in the file.\n                { content: /\\<svg\\W/ },\n              ],\n            },\n          ],\n        },\n        loaders: ['@svgr/webpack'],\n        as: '*.js',\n      },\n    },\n  },\n}\nSupported boolean operators are {all: [...]}, {any: [...]} and {not: ...}.\nSupported customizable operators are {path: string | RegExp} and {content: RegExp}. If path and content are specified in the same object, it acts as an implicit and.\n\nIn addition, a number of built-in conditions are supported:\n\nbrowser: Matches code that will execute on the client. Server code can be matched using {not: 'browser'}.\nforeign: Matches code in node_modules, as well as some Next.js internals. Usually you'll want to restrict loaders to {not: 'foreign'}. This can improve performance by reducing the number of files the loader is invoked on.\ndevelopment: Matches when using next dev.\nproduction: Matches when using next build.\nnode: Matches code that will run on the default Node.js runtime.\nedge-light: Matches code that will run on the Edge runtime.\n\nRules can be an object or an array of objects. An array is often useful for modeling disjoint conditions:\n\nnext.config.js\nmodule.exports = {\n  turbopack: {\n    rules: {\n      '*.svg': [\n        {\n          condition: 'browser',\n          loaders: ['@svgr/webpack'],\n          as: '*.js',\n        },\n        {\n          condition: { not: 'browser' },\n          loaders: [require.resolve('./custom-svg-loader.js')],\n          as: '*.js',\n        },\n      ],\n    },\n  },\n}\n\nGood to know: All matching rules are executed in order.\n\nResolving aliases\n\nTurbopack can be configured to modify module resolution through aliases, similar to webpack's resolve.alias\n configuration.\n\nTo configure resolve aliases, map imported patterns to their new destination in next.config.js:\n\nnext.config.js\nmodule.exports = {\n  turbopack: {\n    resolveAlias: {\n      underscore: 'lodash',\n      mocha: { browser: 'mocha/browser-entry.js' },\n    },\n  },\n}\n\nThis aliases imports of the underscore package to the lodash package. In other words, import underscore from 'underscore' will load the lodash module instead of underscore.\n\nTurbopack also supports conditional aliasing through this field, similar to Node.js' conditional exports\n. At the moment only the browser condition is supported. In the case above, imports of the mocha module will be aliased to mocha/browser-entry.js when Turbopack targets browser environments.\n\nResolving custom extensions\n\nTurbopack can be configured to resolve modules with custom extensions, similar to webpack's resolve.extensions\n configuration.\n\nTo configure resolve extensions, use the resolveExtensions field in next.config.js:\n\nnext.config.js\nmodule.exports = {\n  turbopack: {\n    resolveExtensions: ['.mdx', '.tsx', '.ts', '.jsx', '.js', '.mjs', '.json'],\n  },\n}\n\nThis overwrites the original resolve extensions with the provided list. Make sure to include the default extensions.\n\nFor more information and guidance for how to migrate your app to Turbopack from webpack, see Turbopack's documentation on webpack compatibility\n.\n\nDebug IDs\n\nTurbopack can be configured to generate debug IDs\n in JavaScript bundles and source maps.\n\nTo configure debug IDs, use the debugIds field in next.config.js:\n\nnext.config.js\nmodule.exports = {\n  turbopack: {\n    debugIds: true,\n  },\n}\n\nThe option automatically adds a polyfill for debug IDs to the JavaScript bundle to ensure compatibility. The debug IDs are available in the globalThis._debugIds global variable.\n\nVersion History\nVersion\tChanges\n16.0.0\tturbopack.debugIds was added.\n16.0.0\tturbopack.rules.*.condition was added.\n15.3.0\texperimental.turbo is changed to turbopack.\n13.0.0\texperimental.turbo introduced.\nPrevious\ntranspilePackages\nNext\nturbopackFileSystemCache\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: turbopackFileSystemCache | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/turbopackFileSystemCache",
    "html": "Configuration\nnext.config.js\nturbopackFileSystemCache\nCopy page\nTurbopack FileSystem Caching\nUsage\n\nTurbopack FileSystem Cache enables Turbopack to reduce work across next dev or next build commands. When enabled, Turbopack will save and restore data to the .next folder between builds, which can greatly speed up subsequent builds and dev sessions.\n\nGood to know: The FileSystem Cache feature is Beta and is still under development. Users adopting should expect some stability issues. We recommend first adopting it for development.\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    // Enable filesystem caching for `next dev`\n    turbopackFileSystemCacheForDev: true,\n    // Enable filesystem caching for `next build`\n    turbopackFileSystemCacheForBuild: true,\n  },\n}\n \nexport default nextConfig\nVersion Changes\nVersion\tChanges\nv16.0.0\tBeta release with separate flags for build and dev\nv15.5.0\tPersistent caching released as experimental on canary releases\nPrevious\nturbopack\nNext\ntypedRoutes\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: typedRoutes | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/typedRoutes",
    "html": "Configuration\nnext.config.js\ntypedRoutes\nCopy page\ntypedRoutes\n\nNote: This option has been marked as stable, so you should use typedRoutes instead of experimental.typedRoutes.\n\nSupport for statically typed links. This feature requires using TypeScript in your project.\n\nnext.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  typedRoutes: true,\n}\n \nmodule.exports = nextConfig\nPrevious\nturbopackFileSystemCache\nNext\ntypescript\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: typescript | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/typescript",
    "html": "Configuration\nnext.config.js\ntypescript\nCopy page\ntypescript\n\nNext.js fails your production build (next build) when TypeScript errors are present in your project.\n\nIf you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step.\n\nIf disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.\n\nOpen next.config.js and enable the ignoreBuildErrors option in the typescript config:\n\nnext.config.js\nmodule.exports = {\n  typescript: {\n    // !! WARN !!\n    // Dangerously allow production builds to successfully complete even if\n    // your project has type errors.\n    // !! WARN !!\n    ignoreBuildErrors: true,\n  },\n}\nPrevious\ntypedRoutes\nNext\nurlImports\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: urlImports | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/urlImports",
    "html": "Configuration\nnext.config.js\nurlImports\nCopy page\nurlImports\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nURL imports are an experimental feature that allows you to import modules directly from external servers (instead of from the local disk).\n\nWarning: Only use domains that you trust to download and execute on your machine. Please exercise discretion, and caution until the feature is flagged as stable.\n\nTo opt-in, add the allowed URL prefixes inside next.config.js:\n\nnext.config.js\nmodule.exports = {\n  experimental: {\n    urlImports: ['https://example.com/assets/', 'https://cdn.skypack.dev'],\n  },\n}\n\nThen, you can import modules directly from URLs:\n\nimport { a, b, c } from 'https://example.com/assets/some/module.js'\n\nURL Imports can be used everywhere normal package imports can be used.\n\nSecurity Model\n\nThis feature is being designed with security as the top priority. To start, we added an experimental flag forcing you to explicitly allow the domains you accept URL imports from. We're working to take this further by limiting URL imports to execute in the browser sandbox using the Edge Runtime.\n\nLockfile\n\nWhen using URL imports, Next.js will create a next.lock directory containing a lockfile and fetched assets. This directory must be committed to Git, not ignored by .gitignore.\n\nWhen running next dev, Next.js will download and add all newly discovered URL Imports to your lockfile.\nWhen running next build, Next.js will use only the lockfile to build the application for production.\n\nTypically, no network requests are needed and any outdated lockfile will cause the build to fail. One exception is resources that respond with Cache-Control: no-cache. These resources will have a no-cache entry in the lockfile and will always be fetched from the network on each build.\n\nExamples\nSkypack\nimport confetti from 'https://cdn.skypack.dev/canvas-confetti'\nimport { useEffect } from 'react'\n \nexport default () => {\n  useEffect(() => {\n    confetti()\n  })\n  return <p>Hello</p>\n}\nStatic Image Imports\nimport Image from 'next/image'\nimport logo from 'https://example.com/assets/logo.png'\n \nexport default () => (\n  <div>\n    <Image src={logo} placeholder=\"blur\" />\n  </div>\n)\nURLs in CSS\n.className {\n  background: url('https://example.com/assets/hero.jpg');\n}\nAsset Imports\nconst logo = new URL('https://example.com/assets/file.txt', import.meta.url)\n \nconsole.log(logo.pathname)\n \n// prints \"/_next/static/media/file.a9727b5d.txt\"\nPrevious\ntypescript\nNext\nuseLightningcss\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: useLightningcss | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/useLightningcss",
    "html": "Configuration\nnext.config.js\nuseLightningcss\nCopy page\nuseLightningcss\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nExperimental support for using Lightning CSS\n with webpack. Lightning CSS is a fast CSS transformer and minifier, written in Rust.\n\nIf this option is not set, Next.js on webpack uses PostCSS\n with postcss-preset-env\n by default.\n\nTurbopack uses Lightning CSS by default since Next 14.2. This configuration option has no effect on Turbopack. Turbopack always uses Lightning CSS.\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    useLightningcss: false, // default, ignored on Turbopack\n  },\n}\n \nexport default nextConfig\nVersion History\nVersion\tChanges\n15.1.0\tSupport for useSwcCss was removed from Turbopack.\n14.2.0\tTurbopack's default CSS processor was changed from @swc/css to Lightning CSS. useLightningcss became ignored on Turbopack, and a legacy experimental.turbo.useSwcCss option was added.\nPrevious\nurlImports\nNext\nviewTransition\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: viewTransition | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/viewTransition",
    "html": "Configuration\nnext.config.js\nviewTransition\nCopy page\nviewTransition\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nviewTransition is an experimental flag that enables the new View Transitions API\n in React. This API allows you to leverage the native View Transitions browser API to create seamless transitions between UI states.\n\nTo enable this feature, you need to set the viewTransition property to true in your next.config.js file.\n\nnext.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    viewTransition: true,\n  },\n}\n \nmodule.exports = nextConfig\n\nImportant Notice: The <ViewTransition> Component is already available in React's Canary release channel. experimental.viewTransition is only required to enable deeper integration with Next.js features e.g. automatically adding Transition types\n for navigations. Next.js specific transition types are not implemented yet.\n\nUsage\n\nYou can import the <ViewTransition> Component\n from React in your application:\n\nimport { ViewTransition } from 'react'\nLive Demo\n\nCheck out our Next.js View Transition Demo\n to see this feature in action.\n\nAs this API evolves, we will update our documentation and share more examples. However, for now, we strongly advise against using this feature in production.\n\nPrevious\nuseLightningcss\nNext\nwebpack\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: webpack | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/webpack",
    "html": "Configuration\nnext.config.js\nwebpack\nCopy page\nCustom Webpack Config\n\nGood to know: changes to webpack config are not covered by semver so proceed at your own risk\n\nBefore continuing to add custom webpack configuration to your application make sure Next.js doesn't already support your use-case:\n\nCSS imports\nCSS modules\nSass/SCSS imports\nSass/SCSS modules\n\nSome commonly asked for features are available as plugins:\n\n@next/mdx\n@next/bundle-analyzer\n\nIn order to extend our usage of webpack, you can define a function that extends its config inside next.config.js, like so:\n\nnext.config.js\nmodule.exports = {\n  webpack: (\n    config,\n    { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack }\n  ) => {\n    // Important: return the modified config\n    return config\n  },\n}\n\nThe webpack function is executed three times, twice for the server (nodejs / edge runtime) and once for the client. This allows you to distinguish between client and server configuration using the isServer property.\n\nThe second argument to the webpack function is an object with the following properties:\n\nbuildId: String - The build id, used as a unique identifier between builds.\ndev: Boolean - Indicates if the compilation will be done in development.\nisServer: Boolean - It's true for server-side compilation, and false for client-side compilation.\nnextRuntime: String | undefined - The target runtime for server-side compilation; either \"edge\" or \"nodejs\", it's undefined for client-side compilation.\ndefaultLoaders: Object - Default loaders used internally by Next.js:\nbabel: Object - Default babel-loader configuration.\n\nExample usage of defaultLoaders.babel:\n\n// Example config for adding a loader that depends on babel-loader\n// This source was taken from the @next/mdx plugin source:\n// https://github.com/vercel/next.js/tree/canary/packages/next-mdx\nmodule.exports = {\n  webpack: (config, options) => {\n    config.module.rules.push({\n      test: /\\.mdx/,\n      use: [\n        options.defaultLoaders.babel,\n        {\n          loader: '@mdx-js/loader',\n          options: pluginOptions.options,\n        },\n      ],\n    })\n \n    return config\n  },\n}\nnextRuntime\n\nNotice that isServer is true when nextRuntime is \"edge\" or \"nodejs\", nextRuntime \"edge\" is currently for proxy and Server Components in edge runtime only.\n\nPrevious\nviewTransition\nNext\nwebVitalsAttribution\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Configuration: TypeScript | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/typescript",
    "html": "API Reference\nConfiguration\nTypeScript\nCopy page\nTypeScript\n\nNext.js comes with built-in TypeScript, automatically installing the necessary packages and configuring the proper settings when you create a new project with create-next-app.\n\nTo add TypeScript to an existing project, rename a file to .ts / .tsx. Run next dev and next build to automatically install the necessary dependencies and add a tsconfig.json file with the recommended config options.\n\nGood to know: If you already have a jsconfig.json file, copy the paths compiler option from the old jsconfig.json into the new tsconfig.json file, and delete the old jsconfig.json file.\n\nIDE Plugin\n\nNext.js includes a custom TypeScript plugin and type checker, which VSCode and other code editors can use for advanced type-checking and auto-completion.\n\nYou can enable the plugin in VS Code by:\n\nOpening the command palette (Ctrl/⌘ + Shift + P)\nSearching for \"TypeScript: Select TypeScript Version\"\nSelecting \"Use Workspace Version\"\n\nNow, when editing files, the custom plugin will be enabled. When running next build, the custom type checker will be used.\n\nThe TypeScript plugin can help with:\n\nWarning if the invalid values for segment config options are passed.\nShowing available options and in-context documentation.\nEnsuring the 'use client' directive is used correctly.\nEnsuring client hooks (like useState) are only used in Client Components.\n\n🎥 Watch: Learn about the built-in TypeScript plugin → YouTube (3 minutes)\n\nEnd-to-End Type Safety\n\nThe Next.js App Router has enhanced type safety. This includes:\n\nNo serialization of data between fetching function and page: You can fetch directly in components, layouts, and pages on the server. This data does not need to be serialized (converted to a string) to be passed to the client side for consumption in React. Instead, since app uses Server Components by default, we can use values like Date, Map, Set, and more without any extra steps. Previously, you needed to manually type the boundary between server and client with Next.js-specific types.\nStreamlined data flow between components: With the removal of _app in favor of root layouts, it is now easier to visualize the data flow between components and pages. Previously, data flowing between individual pages and _app were difficult to type and could introduce confusing bugs. With colocated data fetching in the App Router, this is no longer an issue.\n\nData Fetching in Next.js now provides as close to end-to-end type safety as possible without being prescriptive about your database or content provider selection.\n\nWe're able to type the response data as you would expect with normal TypeScript. For example:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nasync function getData() {\n  const res = await fetch('https://api.example.com/...')\n  // The return value is *not* serialized\n  // You can return Date, Map, Set, etc.\n  return res.json()\n}\n \nexport default async function Page() {\n  const name = await getData()\n \n  return '...'\n}\n\nFor complete end-to-end type safety, this also requires your database or content provider to support TypeScript. This could be through using an ORM\n or type-safe query builder.\n\nRoute-Aware Type Helpers\n\nNext.js generates global helpers for App Router route types. These are available without imports and are generated during next dev, next build, or via next typegen:\n\nPageProps\nLayoutProps\nRouteContext\nExamples\nType Checking Next.js Configuration Files\n\nYou can use TypeScript and import types in your Next.js configuration by using next.config.ts.\n\nnext.config.ts\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  /* config options here */\n}\n \nexport default nextConfig\n\nModule resolution in next.config.ts is currently limited to CommonJS. However, ECMAScript Modules (ESM) syntax is available when using Node.js native TypeScript resolver for Node.js v22.10.0 and higher.\n\nWhen using the next.config.js file, you can add some type checking in your IDE using JSDoc as below:\n\nnext.config.js\n// @ts-check\n \n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  /* config options here */\n}\n \nmodule.exports = nextConfig\nUsing Node.js Native TypeScript Resolver for next.config.ts\n\nNote: Available on Node.js v22.10.0+ and only when the feature is enabled. Next.js does not enable it.\n\nNext.js detects the Node.js native TypeScript resolver\n via process.features.typescript\n, added in v22.10.0. When present, next.config.ts can use native ESM, including top‑level await and dynamic import(). This mechanism inherits the capabilities and limitations of Node's resolver.\n\nIn Node.js versions v22.18.0+, process.features.typescript is enabled by default. For versions between v22.10.0 and 22.17.x, opt in with NODE_OPTIONS=--experimental-transform-types:\n\nTerminal\nNODE_OPTIONS=--experimental-transform-types next <command>\nFor CommonJS Projects (Default)\n\nAlthough next.config.ts supports native ESM syntax on CommonJS projects, Node.js will still assume next.config.ts is a CommonJS file by default, resulting in Node.js reparsing the file as ESM when module syntax is detected. Therefore, we recommend using the next.config.mts file for CommonJS projects to explicitly indicate it's an ESM module:\n\nnext.config.mts\nimport type { NextConfig } from 'next'\n \n// Top-level await and dynamic import are supported\nconst flags = await import('./flags.js').then((m) => m.default ?? m)\n \nconst nextConfig: NextConfig = {\n  /* config options here */\n  typedRoutes: Boolean(flags?.typedRoutes),\n}\n \nexport default nextConfig\nFor ESM Projects\n\nWhen \"type\" is set to \"module\" in package.json, your project uses ESM. Learn more about this setting in the Node.js docs\n. In this case, you can write next.config.ts directly with ESM syntax.\n\nGood to know: When using \"type\": \"module\" in your package.json, all .js and .ts files in your project are treated as ESM modules by default. You may need to rename files with CommonJS syntax to .cjs or .cts extensions if needed.\n\nStatically Typed Links\n\nNext.js can statically type links to prevent typos and other errors when using next/link, improving type safety when navigating between pages.\n\nWorks in both the Pages and App Router for the href prop in next/link. In the App Router, it also types next/navigation methods like push, replace, and prefetch. It does not type next/router methods in Pages Router.\n\nLiteral href strings are validated, while non-literal hrefs may require a cast with as Route.\n\nTo opt-into this feature, typedRoutes need to be enabled and the project needs to be using TypeScript.\n\nnext.config.ts\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  typedRoutes: true,\n}\n \nexport default nextConfig\n\nNext.js will generate a link definition in .next/types that contains information about all existing routes in your application, which TypeScript can then use to provide feedback in your editor about invalid links.\n\nGood to know: If you set up your project without create-next-app, ensure the generated Next.js types are included by adding .next/types/**/*.ts to the include array in your tsconfig.json:\n\ntsconfig.json\n{\n  \"include\": [\n    \"next-env.d.ts\",\n    \".next/types/**/*.ts\",\n    \"**/*.ts\",\n    \"**/*.tsx\"\n  ],\n  \"exclude\": [\"node_modules\"]\n}\n\nCurrently, support includes any string literal, including dynamic segments. For non-literal strings, you need to manually cast with as Route. The example below shows both next/link and next/navigation usage:\n\napp/example-client.tsx\n'use client'\n \nimport type { Route } from 'next'\nimport Link from 'next/link'\nimport { useRouter } from 'next/navigation'\n \nexport default function Example() {\n  const router = useRouter()\n  const slug = 'nextjs'\n \n  return (\n    <>\n      {/* Link: literal and dynamic */}\n      <Link href=\"/about\" />\n      <Link href={`/blog/${slug}`} />\n      <Link href={('/blog/' + slug) as Route} />\n      {/* TypeScript error if href is not a valid route */}\n      <Link href=\"/aboot\" />\n \n      {/* Router: literal and dynamic strings are validated */}\n      <button onClick={() => router.push('/about')}>Push About</button>\n      <button onClick={() => router.replace(`/blog/${slug}`)}>\n        Replace Blog\n      </button>\n      <button onClick={() => router.prefetch('/contact')}>\n        Prefetch Contact\n      </button>\n \n      {/* For non-literal strings, cast to Route */}\n      <button onClick={() => router.push(('/blog/' + slug) as Route)}>\n        Push Non-literal Blog\n      </button>\n    </>\n  )\n}\n\nThe same applies for redirecting routes defined by proxy:\n\nproxy.ts\nimport { NextRequest, NextResponse } from 'next/server'\n \nexport function proxy(request: NextRequest) {\n  if (request.nextUrl.pathname === '/proxy-redirect') {\n    return NextResponse.redirect(new URL('/', request.url))\n  }\n \n  return NextResponse.next()\n}\napp/some/page.tsx\nimport type { Route } from 'next'\n \nexport default function Page() {\n  return <Link href={'/proxy-redirect' as Route}>Link Text</Link>\n}\n\nTo accept href in a custom component wrapping next/link, use a generic:\n\nimport type { Route } from 'next'\nimport Link from 'next/link'\n \nfunction Card<T extends string>({ href }: { href: Route<T> | URL }) {\n  return (\n    <Link href={href}>\n      <div>My Card</div>\n    </Link>\n  )\n}\n\nYou can also type a simple data structure and iterate to render links:\n\ncomponents/nav-items.ts\nimport type { Route } from 'next'\n \ntype NavItem<T extends string = string> = {\n  href: T\n  label: string\n}\n \nexport const navItems: NavItem<Route>[] = [\n  { href: '/', label: 'Home' },\n  { href: '/about', label: 'About' },\n  { href: '/blog', label: 'Blog' },\n]\n\nThen, map over the items to render Links:\n\ncomponents/nav.tsx\nimport Link from 'next/link'\nimport { navItems } from './nav-items'\n \nexport function Nav() {\n  return (\n    <nav>\n      {navItems.map((item) => (\n        <Link key={item.href} href={item.href}>\n          {item.label}\n        </Link>\n      ))}\n    </nav>\n  )\n}\n\nHow does it work?\n\nWhen running next dev or next build, Next.js generates a hidden .d.ts file inside .next that contains information about all existing routes in your application (all valid routes as the href type of Link). This .d.ts file is included in tsconfig.json and the TypeScript compiler will check that .d.ts and provide feedback in your editor about invalid links.\n\nType IntelliSense for Environment Variables\n\nDuring development, Next.js generates a .d.ts file in .next/types that contains information about the loaded environment variables for your editor's IntelliSense. If the same environment variable key is defined in multiple files, it is deduplicated according to the Environment Variable Load Order.\n\nTo opt-into this feature, experimental.typedEnv needs to be enabled and the project needs to be using TypeScript.\n\nnext.config.ts\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    typedEnv: true,\n  },\n}\n \nexport default nextConfig\n\nGood to know: Types are generated based on the environment variables loaded at development runtime, which excludes variables from .env.production* files by default. To include production-specific variables, run next dev with NODE_ENV=production.\n\nWith Async Server Components\n\nTo use an async Server Component with TypeScript, ensure you are using TypeScript 5.1.3 or higher and @types/react 18.2.8 or higher.\n\nIf you are using an older version of TypeScript, you may see a 'Promise<Element>' is not a valid JSX element type error. Updating to the latest version of TypeScript and @types/react should resolve this issue.\n\nIncremental type checking\n\nSince v10.2.1 Next.js supports incremental type checking\n when enabled in your tsconfig.json, this can help speed up type checking in larger applications.\n\nCustom tsconfig path\n\nIn some cases, you might want to use a different TypeScript configuration for builds or tooling. To do that, set typescript.tsconfigPath in next.config.ts to point Next.js to another tsconfig file.\n\nnext.config.ts\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  typescript: {\n    tsconfigPath: 'tsconfig.build.json',\n  },\n}\n \nexport default nextConfig\n\nFor example, switch to a different config for production builds:\n\nnext.config.ts\nimport type { NextConfig } from 'next'\n \nconst isProd = process.env.NODE_ENV === 'production'\n \nconst nextConfig: NextConfig = {\n  typescript: {\n    tsconfigPath: isProd ? 'tsconfig.build.json' : 'tsconfig.json',\n  },\n}\n \nexport default nextConfig\nWhy you might use a separate tsconfig for builds\n\nGood to know:\n\nIDEs typically read tsconfig.json for diagnostics and IntelliSense, so you can still see IDE warnings while production builds use the alternate config. Mirror critical options if you want parity in the editor.\nIn development, only tsconfig.json is watched for changes. If you edit a different file name via typescript.tsconfigPath, restart the dev server to apply changes.\nThe configured file is used in next dev, next build, and next typegen.\nDisabling TypeScript errors in production\n\nNext.js fails your production build (next build) when TypeScript errors are present in your project.\n\nIf you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step.\n\nIf disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.\n\nOpen next.config.ts and enable the ignoreBuildErrors option in the typescript config:\n\nnext.config.ts\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  typescript: {\n    // !! WARN !!\n    // Dangerously allow production builds to successfully complete even if\n    // your project has type errors.\n    // !! WARN !!\n    ignoreBuildErrors: true,\n  },\n}\n \nexport default nextConfig\n\nGood to know: You can run tsc --noEmit to check for TypeScript errors yourself before building. This is useful for CI/CD pipelines where you'd like to check for TypeScript errors before deploying.\n\nCustom type declarations\n\nWhen you need to declare custom types, you might be tempted to modify next-env.d.ts. However, this file is automatically generated, so any changes you make will be overwritten. Instead, you should create a new file, let's call it new-types.d.ts, and reference it in your tsconfig.json:\n\ntsconfig.json\n{\n  \"compilerOptions\": {\n    \"skipLibCheck\": true\n    //...truncated...\n  },\n  \"include\": [\n    \"new-types.d.ts\",\n    \"next-env.d.ts\",\n    \".next/types/**/*.ts\",\n    \"**/*.ts\",\n    \"**/*.tsx\"\n  ],\n  \"exclude\": [\"node_modules\"]\n}\nVersion Changes\nVersion\tChanges\nv15.0.0\tnext.config.ts support added for TypeScript projects.\nv13.2.0\tStatically typed links are available in beta.\nv12.0.0\tSWC is now used by default to compile TypeScript and TSX for faster builds.\nv10.2.1\tIncremental type checking\n support added when enabled in your tsconfig.json.\nPrevious\nwebVitalsAttribution\nNext\nESLint\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "next.config.js: webVitalsAttribution | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/webVitalsAttribution",
    "html": "Configuration\nnext.config.js\nwebVitalsAttribution\nCopy page\nwebVitalsAttribution\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\n\nWhen debugging issues related to Web Vitals, it is often helpful if we can pinpoint the source of the problem. For example, in the case of Cumulative Layout Shift (CLS), we might want to know the first element that shifted when the single largest layout shift occurred. Or, in the case of Largest Contentful Paint (LCP), we might want to identify the element corresponding to the LCP for the page. If the LCP element is an image, knowing the URL of the image resource can help us locate the asset we need to optimize.\n\nPinpointing the biggest contributor to the Web Vitals score, aka attribution\n, allows us to obtain more in-depth information like entries for PerformanceEventTiming\n, PerformanceNavigationTiming\n and PerformanceResourceTiming\n.\n\nAttribution is disabled by default in Next.js but can be enabled per metric by specifying the following in next.config.js.\n\nnext.config.js\nmodule.exports = {\n  experimental: {\n    webVitalsAttribution: ['CLS', 'LCP'],\n  },\n}\n\nValid attribution values are all web-vitals metrics specified in the NextWebVitalsMetric\n type.\n\nPrevious\nwebpack\nNext\nTypeScript\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Configuration: ESLint | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/config/eslint",
    "html": "API Reference\nConfiguration\nESLint\nCopy page\nESLint Plugin\n\nNext.js provides an ESLint plugin, @next/eslint-plugin-next\n, already bundled within the base configuration that makes it possible to catch common issues and problems in a Next.js application.\n\nSetup ESLint\n\nGet linting working quickly with the ESLint CLI (flat config):\n\nInstall ESLint and the Next.js config:\n\npnpm\nnpm\nyarn\nbun\nTerminal\npnpm add -D eslint eslint-config-next\n\nCreate eslint.config.mjs with the Next.js config:\n\neslint.config.mjs\nimport { defineConfig, globalIgnores } from 'eslint/config'\nimport nextVitals from 'eslint-config-next/core-web-vitals'\n \nconst eslintConfig = defineConfig([\n  ...nextVitals,\n  // Override default ignores of eslint-config-next.\n  globalIgnores([\n    // Default ignores of eslint-config-next:\n    '.next/**',\n    'out/**',\n    'build/**',\n    'next-env.d.ts',\n  ]),\n])\n \nexport default eslintConfig\n\nRun ESLint:\n\npnpm\nnpm\nyarn\nbun\nTerminal\npnpm exec eslint .\nReference\n\nRecommended rule-sets from the following ESLint plugins are all used within eslint-config-next:\n\neslint-plugin-react\neslint-plugin-react-hooks\n@next/eslint-plugin-next\nRules\n\nThe full set of rules is as follows:\n\nEnabled in recommended config\tRule\tDescription\n\n\t@next/next/google-font-display\tEnforce font-display behavior with Google Fonts.\n\n\t@next/next/google-font-preconnect\tEnsure preconnect is used with Google Fonts.\n\n\t@next/next/inline-script-id\tEnforce id attribute on next/script components with inline content.\n\n\t@next/next/next-script-for-ga\tPrefer next/script component when using the inline script for Google Analytics.\n\n\t@next/next/no-assign-module-variable\tPrevent assignment to the module variable.\n\n\t@next/next/no-async-client-component\tPrevent Client Components from being async functions.\n\n\t@next/next/no-before-interactive-script-outside-document\tPrevent usage of next/script's beforeInteractive strategy outside of pages/_document.js.\n\n\t@next/next/no-css-tags\tPrevent manual stylesheet tags.\n\n\t@next/next/no-document-import-in-page\tPrevent importing next/document outside of pages/_document.js.\n\n\t@next/next/no-duplicate-head\tPrevent duplicate usage of <Head> in pages/_document.js.\n\n\t@next/next/no-head-element\tPrevent usage of <head> element.\n\n\t@next/next/no-head-import-in-document\tPrevent usage of next/head in pages/_document.js.\n\n\t@next/next/no-html-link-for-pages\tPrevent usage of <a> elements to navigate to internal Next.js pages.\n\n\t@next/next/no-img-element\tPrevent usage of <img> element due to slower LCP and higher bandwidth.\n\n\t@next/next/no-page-custom-font\tPrevent page-only custom fonts.\n\n\t@next/next/no-script-component-in-head\tPrevent usage of next/script in next/head component.\n\n\t@next/next/no-styled-jsx-in-document\tPrevent usage of styled-jsx in pages/_document.js.\n\n\t@next/next/no-sync-scripts\tPrevent synchronous scripts.\n\n\t@next/next/no-title-in-document-head\tPrevent usage of <title> with Head component from next/document.\n\n\t@next/next/no-typos\tPrevent common typos in Next.js's data fetching functions\n\n\t@next/next/no-unwanted-polyfillio\tPrevent duplicate polyfills from Polyfill.io.\n\nWe recommend using an appropriate integration\n to view warnings and errors directly in your code editor during development.\n\nnext lint removal\nExamples\nSpecifying a root directory within a monorepo\n\nIf you're using @next/eslint-plugin-next in a project where Next.js isn't installed in your root directory (such as a monorepo), you can tell @next/eslint-plugin-next where to find your Next.js application using the settings property in your eslint.config.mjs:\n\neslint.config.mjs\nimport { defineConfig } from 'eslint/config'\nimport eslintNextPlugin from '@next/eslint-plugin-next'\n \nconst eslintConfig = defineConfig([\n  {\n    plugins: {\n      next: eslintNextPlugin,\n    },\n    settings: {\n      next: {\n        rootDir: 'packages/my-app/',\n      },\n    },\n    files: [\n      // ...files\n    ],\n    ignores: [\n      // ...ignores\n    ],\n  },\n])\n \nexport default eslintConfig\n\nrootDir can be a path (relative or absolute), a glob (i.e. \"packages/*/\"), or an array of paths and/or globs.\n\nDisabling rules\n\nIf you would like to modify or disable any rules provided by the supported plugins (react, react-hooks, next), you can directly change them using the rules property in your eslint.config.mjs:\n\neslint.config.mjs\nimport { defineConfig, globalIgnores } from 'eslint/config'\nimport nextVitals from 'eslint-config-next/core-web-vitals'\n \nconst eslintConfig = defineConfig([\n  ...nextVitals,\n  {\n    rules: {\n      'react/no-unescaped-entities': 'off',\n      '@next/next/no-page-custom-font': 'off',\n    },\n  },\n  // Override default ignores of eslint-config-next.\n  globalIgnores([\n    // Default ignores of eslint-config-next:\n    '.next/**',\n    'out/**',\n    'build/**',\n    'next-env.d.ts',\n  ]),\n])\n \nexport default eslintConfig\nWith Core Web Vitals\n\nEnable the next/core-web-vitals rule set by extending it in your ESLint config.\n\neslint.config.mjs\nimport { defineConfig, globalIgnores } from 'eslint/config'\nimport nextVitals from 'eslint-config-next/core-web-vitals'\n \nconst eslintConfig = defineConfig([\n  ...nextVitals,\n  // Override default ignores of eslint-config-next.\n  globalIgnores([\n    // Default ignores of eslint-config-next:\n    '.next/**',\n    'out/**',\n    'build/**',\n    'next-env.d.ts',\n  ]),\n])\n \nexport default eslintConfig\n\nnext/core-web-vitals updates @next/eslint-plugin-next to error on a number of rules that are warnings by default if they affect Core Web Vitals\n.\n\nThe next/core-web-vitals entry point is automatically included for new applications built with Create Next App.\n\nWith TypeScript\n\nIn addition to the Next.js ESLint rules, create-next-app --typescript will also add TypeScript-specific lint rules with next/typescript to your config:\n\neslint.config.mjs\nimport { defineConfig, globalIgnores } from 'eslint/config'\nimport nextVitals from 'eslint-config-next/core-web-vitals'\nimport nextTs from 'eslint-config-next/typescript'\n \nconst eslintConfig = defineConfig([\n  ...nextVitals,\n  ...nextTs,\n  // Override default ignores of eslint-config-next.\n  globalIgnores([\n    // Default ignores of eslint-config-next:\n    '.next/**',\n    'out/**',\n    'build/**',\n    'next-env.d.ts',\n  ]),\n])\n \nexport default eslintConfig\n\nThose rules are based on plugin:@typescript-eslint/recommended\n. See typescript-eslint > Configs\n for more details.\n\nWith Prettier\n\nESLint also contains code formatting rules, which can conflict with your existing Prettier\n setup. We recommend including eslint-config-prettier\n in your ESLint config to make ESLint and Prettier work together.\n\nFirst, install the dependency:\n\npnpm\nnpm\nyarn\nbun\nTerminal\npnpm add -D eslint-config-prettier\n\nThen, add prettier to your existing ESLint config:\n\neslint.config.mjs\nimport { defineConfig, globalIgnores } from 'eslint/config'\nimport nextVitals from 'eslint-config-next/core-web-vitals'\nimport prettier from 'eslint-config-prettier/flat'\n \nconst eslintConfig = defineConfig([\n  ...nextVitals,\n  prettier,\n  // Override default ignores of eslint-config-next.\n  globalIgnores([\n    // Default ignores of eslint-config-next:\n    '.next/**',\n    'out/**',\n    'build/**',\n    'next-env.d.ts',\n  ]),\n])\n \nexport default eslintConfig\nRunning lint on staged files\n\nIf you would like to use ESLint with lint-staged\n to run the linter on staged git files, add the following to the .lintstagedrc.js file in the root of your project:\n\n.lintstagedrc.js\nconst path = require('path')\n \nconst buildEslintCommand = (filenames) =>\n  `eslint --fix ${filenames\n    .map((f) => `\"${path.relative(process.cwd(), f)}\"`)\n    .join(' ')}`\n \nmodule.exports = {\n  '*.{js,jsx,ts,tsx}': [buildEslintCommand],\n}\nMigrating existing config\n\nIf you already have ESLint configured in your application, we recommend extending from this plugin directly instead of including eslint-config-next unless a few conditions are met.\n\nRecommended plugin ruleset\n\nIf the following conditions are true:\n\nYou have one or more of the following plugins already installed (either separately or through a different config such as airbnb or react-app):\nreact\nreact-hooks\njsx-a11y\nimport\nYou've defined specific parserOptions that are different from how Babel is configured within Next.js (this is not recommended unless you have customized your Babel configuration)\nYou have eslint-plugin-import installed with Node.js and/or TypeScript resolvers\n defined to handle imports\n\nThen we recommend either removing these settings if you prefer how these properties have been configured within eslint-config-next\n or extending directly from the Next.js ESLint plugin instead:\n\nmodule.exports = {\n  extends: [\n    //...\n    'plugin:@next/next/recommended',\n  ],\n}\n\nThe plugin can be installed normally in your project:\n\npnpm\nnpm\nyarn\nbun\nTerminal\npnpm add -D @next/eslint-plugin-next\n\nThis eliminates the risk of collisions or errors that can occur due to importing the same plugin or parser across multiple configurations.\n\nAdditional configurations\n\nIf you already use a separate ESLint configuration and want to include eslint-config-next, ensure that it is extended last after other configurations. For example:\n\neslint.config.mjs\nimport { defineConfig, globalIgnores } from 'eslint/config'\nimport nextPlugin from '@next/eslint-plugin-next'\n \nconst eslintConfig = defineConfig([\n  nextPlugin.configs['core-web-vitals'],\n  // List of ignore patterns.\n  globalIgnores([]),\n])\n \nexport default eslintConfig\n\nThe next configuration already handles setting default values for the parser, plugins and settings properties. There is no need to manually re-declare any of these properties unless you need a different configuration for your use case.\n\nIf you include any other shareable configurations, you will need to make sure that these properties are not overwritten or modified. Otherwise, we recommend removing any configurations that share behavior with the next configuration or extending directly from the Next.js ESLint plugin as mentioned above.\n\nVersion\tChanges\nv16.0.0\tnext lint and the eslint next.config.js option were removed in favor of the ESLint CLI. A codemod is available to help you migrate.\nPrevious\nTypeScript\nNext\nCLI\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "API Reference: CLI | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/cli",
    "html": "App Router\nAPI Reference\nCLI\nCopy page\nCLI\n\nNext.js comes with two Command Line Interface (CLI) tools:\n\ncreate-next-app: Quickly create a new Next.js application using the default template or an example\n from a public GitHub repository.\nnext: Run the Next.js development server, build your application, and more.\ncreate-next-app\nCreate Next.js apps using one command with the create-next-app CLI.\nnext CLI\nLearn how to run and build your application with the Next.js CLI.\nPrevious\nESLint\nNext\ncreate-next-app\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "CLI: create-next-app | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/cli/create-next-app",
    "html": "API Reference\nCLI\ncreate-next-app\nCopy page\ncreate-next-app\n\nThe create-next-app CLI allow you to create a new Next.js application using the default template or an example\n from a public GitHub repository. It is the easiest way to get started with Next.js.\n\nBasic usage:\n\nTerminal\nnpx create-next-app@latest [project-name] [options]\nReference\n\nThe following options are available:\n\nOptions\tDescription\n-h or --help\tShow all available options\n-v or --version\tOutput the version number\n--no-*\tNegate default options. E.g. --no-ts\n--ts or --typescript\tInitialize as a TypeScript project (default)\n--js or --javascript\tInitialize as a JavaScript project\n--tailwind\tInitialize with Tailwind CSS config (default)\n--react-compiler\tInitialize with React Compiler enabled\n--eslint\tInitialize with ESLint config\n--biome\tInitialize with Biome config\n--no-linter\tSkip linter configuration\n--app\tInitialize as an App Router project\n--api\tInitialize a project with only route handlers\n--src-dir\tInitialize inside a src/ directory\n--turbopack\tForce enable Turbopack in generated package.json (enabled by default)\n--webpack\tForce enable Webpack in generated package.json\n--import-alias <alias-to-configure>\tSpecify import alias to use (default \"@/*\")\n--empty\tInitialize an empty project\n--use-npm\tExplicitly tell the CLI to bootstrap the application using npm\n--use-pnpm\tExplicitly tell the CLI to bootstrap the application using pnpm\n--use-yarn\tExplicitly tell the CLI to bootstrap the application using Yarn\n--use-bun\tExplicitly tell the CLI to bootstrap the application using Bun\n-e or --example [name] [github-url]\tAn example to bootstrap the app with\n--example-path <path-to-example>\tSpecify the path to the example separately\n--reset-preferences\tExplicitly tell the CLI to reset any stored preferences\n--skip-install\tExplicitly tell the CLI to skip installing packages\n--disable-git\tExplicitly tell the CLI to disable git initialization\n--yes\tUse previous preferences or defaults for all options\nExamples\nWith the default template\n\nTo create a new app using the default template, run the following command in your terminal:\n\nTerminal\nnpx create-next-app@latest\n\nOn installation, you'll see the following prompts:\n\nTerminal\nWhat is your project named? my-app\nWould you like to use the recommended Next.js defaults?\n    Yes, use recommended defaults - TypeScript, ESLint, Tailwind CSS, App Router, Turbopack\n    No, reuse previous settings\n    No, customize settings - Choose your own preferences\n\nIf you choose to customize settings, you'll see the following prompts:\n\nTerminal\nWould you like to use TypeScript? No / Yes\nWhich linter would you like to use? ESLint / Biome / None\nWould you like to use React Compiler? No / Yes\nWould you like to use Tailwind CSS? No / Yes\nWould you like your code inside a `src/` directory? No / Yes\nWould you like to use App Router? (recommended) No / Yes\nWould you like to use Turbopack? (recommended) No / Yes\nWould you like to customize the import alias (`@/*` by default)? No / Yes\nWhat import alias would you like configured? @/*\n\nAfter the prompts, create-next-app will create a folder with your project name and install the required dependencies.\n\nLinter Options\n\nESLint: The traditional and most popular JavaScript linter. Includes Next.js-specific rules from @next/eslint-plugin-next.\n\nBiome: A fast, modern linter and formatter that combines the functionality of ESLint and Prettier. Includes built-in Next.js and React domain support for optimal performance.\n\nNone: Skip linter configuration entirely. You can always add a linter later.\n\nOnce you've answered the prompts, a new project will be created with your chosen configuration.\n\nWith an official Next.js example\n\nTo create a new app using an official Next.js example, use the --example flag. For example:\n\nTerminal\nnpx create-next-app@latest --example [example-name] [your-project-name]\n\nYou can view a list of all available examples along with setup instructions in the Next.js repository\n.\n\nWith any public GitHub example\n\nTo create a new app using any public GitHub example, use the --example option with the GitHub repo's URL. For example:\n\nTerminal\nnpx create-next-app@latest --example \"https://github.com/.../\" [your-project-name]\nPrevious\nCLI\nNext\nnext CLI\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "CLI: next CLI | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/cli/next",
    "html": "API Reference\nCLI\nnext CLI\nCopy page\nnext CLI\n\nThe Next.js CLI allows you to develop, build, start your application, and more.\n\nBasic usage:\n\nTerminal\nnpx next [command] [options]\nReference\n\nThe following options are available:\n\nOptions\tDescription\n-h or --help\tShows all available options\n-v or --version\tOutputs the Next.js version number\nCommands\n\nThe following commands are available:\n\nCommand\tDescription\ndev\tStarts Next.js in development mode with Hot Module Reloading, error reporting, and more.\nbuild\tCreates an optimized production build of your application. Displaying information about each route.\nstart\tStarts Next.js in production mode. The application should be compiled with next build first.\ninfo\tPrints relevant details about the current system which can be used to report Next.js bugs.\ntelemetry\tAllows you to enable or disable Next.js' completely anonymous telemetry collection.\ntypegen\tGenerates TypeScript definitions for routes, pages, layouts, and route handlers without running a full build.\n\nGood to know: Running next without a command is an alias for next dev.\n\nnext dev options\n\nnext dev starts the application in development mode with Hot Module Reloading (HMR), error reporting, and more. The following options are available when running next dev:\n\nOption\tDescription\n-h, --help\tShow all available options.\n[directory]\tA directory in which to build the application. If not provided, current directory is used.\n--turbopack\tForce enable Turbopack (enabled by default). Also available as --turbo.\n--webpack\tUse Webpack instead of the default Turbopack bundler for development.\n-p or --port <port>\tSpecify a port number on which to start the application. Default: 3000, env: PORT\n-Hor --hostname <hostname>\tSpecify a hostname on which to start the application. Useful for making the application available for other devices on the network. Default: 0.0.0.0\n--experimental-https\tStarts the server with HTTPS and generates a self-signed certificate.\n--experimental-https-key <path>\tPath to a HTTPS key file.\n--experimental-https-cert <path>\tPath to a HTTPS certificate file.\n--experimental-https-ca <path>\tPath to a HTTPS certificate authority file.\n--experimental-upload-trace <traceUrl>\tReports a subset of the debugging trace to a remote HTTP URL.\nnext build options\n\nnext build creates an optimized production build of your application. The output displays information about each route. For example:\n\nTerminal\nRoute (app)\n┌ ○ /_not-found\n└ ƒ /products/[id]\n \n○  (Static)   prerendered as static content\nƒ  (Dynamic)  server-rendered on demand\n\nThe following options are available for the next build command:\n\nOption\tDescription\n-h, --help\tShow all available options.\n[directory]\tA directory on which to build the application. If not provided, the current directory will be used.\n--turbopack\tForce enable Turbopack (enabled by default). Also available as --turbo.\n--webpack\tBuild using Webpack.\n-d or --debug\tEnables a more verbose build output. With this flag enabled additional build output like rewrites, redirects, and headers will be shown.\n\t\n--profile\tEnables production profiling for React\n.\n--no-lint\tDisables linting. Note: linting will be removed from next build in Next 16. If you're using Next 15.5+ with a linter other than eslint, linting during build will not occur.\n--no-mangling\tDisables mangling\n. This may affect performance and should only be used for debugging purposes.\n--experimental-app-only\tBuilds only App Router routes.\n--experimental-build-mode [mode]\tUses an experimental build mode. (choices: \"compile\", \"generate\", default: \"default\")\n--debug-prerender\tDebug prerender errors in development.\n--debug-build-paths=<patterns>\tBuild only specific routes for debugging.\nnext start options\n\nnext start starts the application in production mode. The application should be compiled with next build first.\n\nThe following options are available for the next start command:\n\nOption\tDescription\n-h or --help\tShow all available options.\n[directory]\tA directory on which to start the application. If no directory is provided, the current directory will be used.\n-p or --port <port>\tSpecify a port number on which to start the application. (default: 3000, env: PORT)\n-H or --hostname <hostname>\tSpecify a hostname on which to start the application (default: 0.0.0.0).\n--keepAliveTimeout <keepAliveTimeout>\tSpecify the maximum amount of milliseconds to wait before closing the inactive connections.\nnext info options\n\nnext info prints relevant details about the current system which can be used to report Next.js bugs when opening a GitHub issue\n. This information includes Operating System platform/arch/version, Binaries (Node.js, npm, Yarn, pnpm), package versions (next, react, react-dom), and more.\n\nThe output should look like this:\n\nTerminal\nOperating System:\n  Platform: darwin\n  Arch: arm64\n  Version: Darwin Kernel Version 23.6.0\n  Available memory (MB): 65536\n  Available CPU cores: 10\nBinaries:\n  Node: 20.12.0\n  npm: 10.5.0\n  Yarn: 1.22.19\n  pnpm: 9.6.0\nRelevant Packages:\n  next: 15.0.0-canary.115 // Latest available version is detected (15.0.0-canary.115).\n  eslint-config-next: 14.2.5\n  react: 19.0.0-rc\n  react-dom: 19.0.0\n  typescript: 5.5.4\nNext.js Config:\n  output: N/A\n\nThe following options are available for the next info command:\n\nOption\tDescription\n-h or --help\tShow all available options\n--verbose\tCollects additional information for debugging.\nnext telemetry options\n\nNext.js collects completely anonymous telemetry data about general usage. Participation in this anonymous program is optional, and you can opt-out if you prefer not to share information.\n\nThe following options are available for the next telemetry command:\n\nOption\tDescription\n-h, --help\tShow all available options.\n--enable\tEnables Next.js' telemetry collection.\n--disable\tDisables Next.js' telemetry collection.\n\nLearn more about Telemetry.\n\nnext typegen Options\n\nnext typegen generates TypeScript definitions for your application's routes without performing a full build. This is useful for IDE autocomplete and CI type-checking of route usage.\n\nPreviously, route types were only generated during next dev or next build, which meant running tsc --noEmit directly wouldn't validate your route types. Now you can generate types independently and validate them externally:\n\nTerminal\n# Generate route types first, then validate with TypeScript\nnext typegen && tsc --noEmit\n \n# Or in CI workflows for type checking without building\nnext typegen && npm run type-check\n\nThe following options are available for the next typegen command:\n\nOption\tDescription\n-h, --help\tShow all available options.\n[directory]\tA directory on which to generate types. If not provided, the current directory will be used.\n\nOutput files are written to <distDir>/types (typically: .next/dev/types or .next/types, see isolatedDevBuild):\n\nTerminal\nnext typegen\n# or for a specific app\nnext typegen ./apps/web\n\nAdditionally, next typegen generates a next-env.d.ts file. We recommend adding next-env.d.ts to your .gitignore file.\n\nThe next-env.d.ts file is included into your tsconfig.json file, to make Next.js types available to your project.\n\nTo ensure next-env.d.ts is present before type-checking run next typegen. The commands next dev and next build also generate the next-env.d.ts file, but it is often undesirable to run these just to type-check, for example in CI/CD environments.\n\nGood to know: next typegen loads your Next.js config (next.config.js, next.config.mjs, or next.config.ts) using the production build phase. Ensure any required environment variables and dependencies are available so the config can load correctly.\n\nExamples\nDebugging prerender errors\n\nIf you encounter prerendering errors during next build, you can pass the --debug-prerender flag to get more detailed output:\n\nTerminal\nnext build --debug-prerender\n\nThis enables several experimental options to make debugging easier:\n\nDisables server code minification:\nexperimental.serverMinification = false\nexperimental.turbopackMinify = false\nGenerates source maps for server bundles:\nexperimental.serverSourceMaps = true\nEnables source map consumption in child processes used for prerendering:\nenablePrerenderSourceMaps = true\nContinues building even after the first prerender error, so you can see all issues at once:\nexperimental.prerenderEarlyExit = false\n\nThis helps surface more readable stack traces and code frames in the build output.\n\nWarning: --debug-prerender is for debugging in development only. Do not deploy builds generated with --debug-prerender to production, as it may impact performance.\n\nBuilding specific routes\n\nYou can build only specific routes in the App and Pages Routers using the --debug-build-paths option. This is useful for faster debugging when working with large applications. The --debug-build-paths option accepts comma-separated file paths and supports glob patterns:\n\nTerminal\n# Build a specific route\nnext build --debug-build-paths=\"app/page.tsx\"\n \n# Build more than one route\nnext build --debug-build-paths=\"app/page.tsx,pages/index.tsx\"\n \n# Use glob patterns\nnext build --debug-build-paths=\"app/**/page.tsx\"\nnext build --debug-build-paths=\"pages/*.tsx\"\nChanging the default port\n\nBy default, Next.js uses http://localhost:3000 during development and with next start. The default port can be changed with the -p option, like so:\n\nTerminal\nnext dev -p 4000\n\nOr using the PORT environment variable:\n\nTerminal\nPORT=4000 next dev\n\nGood to know: PORT cannot be set in .env as booting up the HTTP server happens before any other code is initialized.\n\nUsing HTTPS during development\n\nFor certain use cases like webhooks or authentication, you can use HTTPS\n to have a secure environment on localhost. Next.js can generate a self-signed certificate with next dev using the --experimental-https flag:\n\nTerminal\nnext dev --experimental-https\n\nWith the generated certificate, the Next.js development server will exist at https://localhost:3000. The default port 3000 is used unless a port is specified with -p, --port, or PORT.\n\nYou can also provide a custom certificate and key with --experimental-https-key and --experimental-https-cert. Optionally, you can provide a custom CA certificate with --experimental-https-ca as well.\n\nTerminal\nnext dev --experimental-https --experimental-https-key ./certificates/localhost-key.pem --experimental-https-cert ./certificates/localhost.pem\n\nnext dev --experimental-https is only intended for development and creates a locally trusted certificate with mkcert\n. In production, use properly issued certificates from trusted authorities.\n\nConfiguring a timeout for downstream proxies\n\nWhen deploying Next.js behind a downstream proxy (e.g. a load-balancer like AWS ELB/ALB), it's important to configure Next's underlying HTTP server with keep-alive timeouts\n that are larger than the downstream proxy's timeouts. Otherwise, once a keep-alive timeout is reached for a given TCP connection, Node.js will immediately terminate that connection without notifying the downstream proxy. This results in a proxy error whenever it attempts to reuse a connection that Node.js has already terminated.\n\nTo configure the timeout values for the production Next.js server, pass --keepAliveTimeout (in milliseconds) to next start, like so:\n\nTerminal\nnext start --keepAliveTimeout 70000\nPassing Node.js arguments\n\nYou can pass any node arguments\n to next commands. For example:\n\nTerminal\nNODE_OPTIONS='--throw-deprecation' next\nNODE_OPTIONS='-r esm' next\nNODE_OPTIONS='--inspect' next\nVersion\tChanges\nv16.0.0\tThe JS bundle size metrics have been removed from next build\nv15.5.0\tAdd the next typegen command\nv15.4.0\tAdd --debug-prerender option for next build to help debug prerender errors.\nPrevious\ncreate-next-app\nNext\nEdge Runtime\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "API Reference: Edge Runtime | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/edge",
    "html": "App Router\nAPI Reference\nEdge Runtime\nCopy page\nEdge Runtime\n\nNext.js has two server runtimes you can use in your application:\n\nThe Node.js Runtime (default), which has access to all Node.js APIs and is used for rendering your application.\nThe Edge Runtime which contains a more limited set of APIs, used in Proxy.\nCaveats\nThe Edge Runtime does not support all Node.js APIs. Some packages may not work as expected.\nThe Edge Runtime does not support Incremental Static Regeneration (ISR).\nBoth runtimes can support streaming depending on your deployment adapter.\nReference\n\nThe Edge Runtime supports the following APIs:\n\nNetwork APIs\nAPI\tDescription\nBlob\n\tRepresents a blob\nfetch\n\tFetches a resource\nFetchEvent\n\tRepresents a fetch event\nFile\n\tRepresents a file\nFormData\n\tRepresents form data\nHeaders\n\tRepresents HTTP headers\nRequest\n\tRepresents an HTTP request\nResponse\n\tRepresents an HTTP response\nURLSearchParams\n\tRepresents URL search parameters\nWebSocket\n\tRepresents a websocket connection\nEncoding APIs\nAPI\tDescription\natob\n\tDecodes a base-64 encoded string\nbtoa\n\tEncodes a string in base-64\nTextDecoder\n\tDecodes a Uint8Array into a string\nTextDecoderStream\n\tChainable decoder for streams\nTextEncoder\n\tEncodes a string into a Uint8Array\nTextEncoderStream\n\tChainable encoder for streams\nStream APIs\nAPI\tDescription\nReadableStream\n\tRepresents a readable stream\nReadableStreamBYOBReader\n\tRepresents a reader of a ReadableStream\nReadableStreamDefaultReader\n\tRepresents a reader of a ReadableStream\nTransformStream\n\tRepresents a transform stream\nWritableStream\n\tRepresents a writable stream\nWritableStreamDefaultWriter\n\tRepresents a writer of a WritableStream\nCrypto APIs\nAPI\tDescription\ncrypto\n\tProvides access to the cryptographic functionality of the platform\nCryptoKey\n\tRepresents a cryptographic key\nSubtleCrypto\n\tProvides access to common cryptographic primitives, like hashing, signing, encryption or decryption\nWeb Standard APIs\nAPI\tDescription\nAbortController\n\tAllows you to abort one or more DOM requests as and when desired\nArray\n\tRepresents an array of values\nArrayBuffer\n\tRepresents a generic, fixed-length raw binary data buffer\nAtomics\n\tProvides atomic operations as static methods\nBigInt\n\tRepresents a whole number with arbitrary precision\nBigInt64Array\n\tRepresents a typed array of 64-bit signed integers\nBigUint64Array\n\tRepresents a typed array of 64-bit unsigned integers\nBoolean\n\tRepresents a logical entity and can have two values: true and false\nclearInterval\n\tCancels a timed, repeating action which was previously established by a call to setInterval()\nclearTimeout\n\tCancels a timed, repeating action which was previously established by a call to setTimeout()\nconsole\n\tProvides access to the browser's debugging console\nDataView\n\tRepresents a generic view of an ArrayBuffer\nDate\n\tRepresents a single moment in time in a platform-independent format\ndecodeURI\n\tDecodes a Uniform Resource Identifier (URI) previously created by encodeURI or by a similar routine\ndecodeURIComponent\n\tDecodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent or by a similar routine\nDOMException\n\tRepresents an error that occurs in the DOM\nencodeURI\n\tEncodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character\nencodeURIComponent\n\tEncodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character\nError\n\tRepresents an error when trying to execute a statement or accessing a property\nEvalError\n\tRepresents an error that occurs regarding the global function eval()\nFloat32Array\n\tRepresents a typed array of 32-bit floating point numbers\nFloat64Array\n\tRepresents a typed array of 64-bit floating point numbers\nFunction\n\tRepresents a function\nInfinity\n\tRepresents the mathematical Infinity value\nInt8Array\n\tRepresents a typed array of 8-bit signed integers\nInt16Array\n\tRepresents a typed array of 16-bit signed integers\nInt32Array\n\tRepresents a typed array of 32-bit signed integers\nIntl\n\tProvides access to internationalization and localization functionality\nisFinite\n\tDetermines whether a value is a finite number\nisNaN\n\tDetermines whether a value is NaN or not\nJSON\n\tProvides functionality to convert JavaScript values to and from the JSON format\nMap\n\tRepresents a collection of values, where each value may occur only once\nMath\n\tProvides access to mathematical functions and constants\nNumber\n\tRepresents a numeric value\nObject\n\tRepresents the object that is the base of all JavaScript objects\nparseFloat\n\tParses a string argument and returns a floating point number\nparseInt\n\tParses a string argument and returns an integer of the specified radix\nPromise\n\tRepresents the eventual completion (or failure) of an asynchronous operation, and its resulting value\nProxy\n\tRepresents an object that is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc)\nqueueMicrotask\n\tQueues a microtask to be executed\nRangeError\n\tRepresents an error when a value is not in the set or range of allowed values\nReferenceError\n\tRepresents an error when a non-existent variable is referenced\nReflect\n\tProvides methods for interceptable JavaScript operations\nRegExp\n\tRepresents a regular expression, allowing you to match combinations of characters\nSet\n\tRepresents a collection of values, where each value may occur only once\nsetInterval\n\tRepeatedly calls a function, with a fixed time delay between each call\nsetTimeout\n\tCalls a function or evaluates an expression after a specified number of milliseconds\nSharedArrayBuffer\n\tRepresents a generic, fixed-length raw binary data buffer\nString\n\tRepresents a sequence of characters\nstructuredClone\n\tCreates a deep copy of a value\nSymbol\n\tRepresents a unique and immutable data type that is used as the key of an object property\nSyntaxError\n\tRepresents an error when trying to interpret syntactically invalid code\nTypeError\n\tRepresents an error when a value is not of the expected type\nUint8Array\n\tRepresents a typed array of 8-bit unsigned integers\nUint8ClampedArray\n\tRepresents a typed array of 8-bit unsigned integers clamped to 0-255\nUint32Array\n\tRepresents a typed array of 32-bit unsigned integers\nURIError\n\tRepresents an error when a global URI handling function was used in a wrong way\nURL\n\tRepresents an object providing static methods used for creating object URLs\nURLPattern\n\tRepresents a URL pattern\nURLSearchParams\n\tRepresents a collection of key/value pairs\nWeakMap\n\tRepresents a collection of key/value pairs in which the keys are weakly referenced\nWeakSet\n\tRepresents a collection of objects in which each object may occur only once\nWebAssembly\n\tProvides access to WebAssembly\nNext.js Specific Polyfills\nAsyncLocalStorage\nEnvironment Variables\n\nYou can use process.env to access Environment Variables for both next dev and next build.\n\nUnsupported APIs\n\nThe Edge Runtime has some restrictions including:\n\nNative Node.js APIs are not supported. For example, you can't read or write to the filesystem.\nnode_modules can be used, as long as they implement ES Modules and do not use native Node.js APIs.\nCalling require directly is not allowed. Use ES Modules instead.\n\nThe following JavaScript language features are disabled, and will not work:\n\nAPI\tDescription\neval\n\tEvaluates JavaScript code represented as a string\nnew Function(evalString)\n\tCreates a new function with the code provided as an argument\nWebAssembly.compile\n\tCompiles a WebAssembly module from a buffer source\nWebAssembly.instantiate\n\tCompiles and instantiates a WebAssembly module from a buffer source\n\nIn rare cases, your code could contain (or import) some dynamic code evaluation statements which can not be reached at runtime and which can not be removed by treeshaking. You can relax the check to allow specific files with your Proxy configuration:\n\nproxy.ts\nexport const config = {\n  unstable_allowDynamic: [\n    // allows a single file\n    '/lib/utilities.js',\n    // use a glob to allow anything in the function-bind 3rd party module\n    '**/node_modules/function-bind/**',\n  ],\n}\n\nunstable_allowDynamic is a glob\n, or an array of globs, ignoring dynamic code evaluation for specific files. The globs are relative to your application root folder.\n\nBe warned that if these statements are executed on the Edge, they will throw and cause a runtime error.\n\nPrevious\nnext CLI\nNext\nTurbopack\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "API Reference: Turbopack | Next.js",
    "url": "https://nextjs.org/docs/app/api-reference/turbopack",
    "html": "App Router\nAPI Reference\nTurbopack\nCopy page\nTurbopack\n\nTurbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. You can use Turbopack with both the Pages and App Router for a much faster local development experience.\n\nWhy Turbopack?\n\nWe built Turbopack to push the performance of Next.js, including:\n\nUnified Graph: Next.js supports multiple output environments (e.g., client and server). Managing multiple compilers and stitching bundles together can be tedious. Turbopack uses a single, unified graph for all environments.\nBundling vs Native ESM: Some tools skip bundling in development and rely on the browser's native ESM. This works well for small apps but can slow down large apps due to excessive network requests. Turbopack bundles in dev, but in an optimized way to keep large apps fast.\nIncremental Computation: Turbopack parallelizes work across cores and caches results down to the function level. Once a piece of work is done, Turbopack won’t repeat it.\nLazy Bundling: Turbopack only bundles what is actually requested by the dev server. This lazy approach can reduce initial compile times and memory usage.\nGetting started\n\nTurbopack is now the default bundler in Next.js. No configuration is needed to use Turbopack:\n\npackage.json\n{\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\"\n  }\n}\nUsing Webpack instead\n\nIf you need to use Webpack instead of Turbopack, you can opt-in with the --webpack flag:\n\npackage.json\n{\n  \"scripts\": {\n    \"dev\": \"next dev --webpack\",\n    \"build\": \"next build --webpack\",\n    \"start\": \"next start\"\n  }\n}\nSupported features\n\nTurbopack in Next.js has zero-configuration for the common use cases. Below is a summary of what is supported out of the box, plus some references to how you can configure Turbopack further when needed.\n\nLanguage features\nFeature\tStatus\tNotes\nJavaScript & TypeScript\tSupported\tUses SWC under the hood. Type-checking is not done by Turbopack (run tsc --watch or rely on your IDE for type checks).\nECMAScript (ESNext)\tSupported\tTurbopack supports the latest ECMAScript features, matching SWC’s coverage.\nCommonJS\tSupported\trequire() syntax is handled out of the box.\nESM\tSupported\tStatic and dynamic import are fully supported.\nBabel\tSupported\tStarting in Next.js 16, Turbopack uses Babel automatically if it detects a configuration file\n. Unlike in webpack, SWC is always used for Next.js's internal transforms and downleveling to older ECMAScript revisions. Next.js with webpack disables SWC if a Babel configuration file is present. Files in node_modules are excluded, unless you manually configure babel-loader.\nFramework and React features\nFeature\tStatus\tNotes\nJSX / TSX\tSupported\tSWC handles JSX/TSX compilation.\nFast Refresh\tSupported\tNo configuration needed.\nReact Server Components (RSC)\tSupported\tFor the Next.js App Router. Turbopack ensures correct server/client bundling.\nRoot layout creation\tUnsupported\tAutomatic creation of a root layout in App Router is not supported. Turbopack will instruct you to create it manually.\nCSS and styling\nFeature\tStatus\tNotes\nGlobal CSS\tSupported\tImport .css files directly in your application.\nCSS Modules\tSupported\t.module.css files work natively (Lightning CSS).\nCSS Nesting\tSupported\tLightning CSS supports modern CSS nesting\n.\n@import syntax\tSupported\tCombine multiple CSS files.\nPostCSS\tSupported\tAutomatically processes postcss.config.js in a Node.js worker pool. Useful for Tailwind, Autoprefixer, etc.\nSass / SCSS\tSupported (Next.js)\tFor Next.js, Sass is supported out of the box. Custom Sass functions (sassOptions.functions) are not supported because Turbopack's Rust-based architecture cannot directly execute JavaScript functions, unlike webpack's Node.js environment. Use webpack if you need this feature. In the future, Turbopack standalone usage will likely require a loader config.\nLess\tPlanned via plugins\tNot yet supported by default. Will likely require a loader config once custom loaders are stable.\nLightning CSS\tIn Use\tHandles CSS transformations. Some low-usage CSS Modules features (like :local/:global as standalone pseudo-classes) are not yet supported. See below for more details.\nAssets\nFeature\tStatus\tNotes\nStatic Assets (images, fonts)\tSupported\tImporting import img from './img.png' works out of the box. In Next.js, returns an object for the <Image /> component.\nJSON Imports\tSupported\tNamed or default imports from .json are supported.\nModule resolution\nFeature\tStatus\tNotes\nPath Aliases\tSupported\tReads tsconfig.json's paths and baseUrl, matching Next.js behavior.\nManual Aliases\tSupported\tConfigure resolveAlias in next.config.js (similar to webpack.resolve.alias).\nCustom Extensions\tSupported\tConfigure resolveExtensions in next.config.js.\nAMD\tPartially Supported\tBasic transforms work; advanced AMD usage is limited.\nPerformance and Fast Refresh\nFeature\tStatus\tNotes\nFast Refresh\tSupported\tUpdates JavaScript, TypeScript, and CSS without a full refresh.\nIncremental Bundling\tSupported\tTurbopack lazily builds only what’s requested by the dev server, speeding up large apps.\nKnown gaps with webpack\n\nThere are a number of non-trivial behavior differences between webpack and Turbopack that are important to be aware of when migrating an application. Generally, these are less of a concern for new applications.\n\nCSS Module Ordering\n\nTurbopack will follow JS import order to order CSS modules which are not otherwise ordered. For example:\n\ncomponents/BlogPost.jsx\nimport utilStyles from './utils.module.css'\nimport buttonStyles from './button.module.css'\nexport default function BlogPost() {\n  return (\n    <div className={utilStyles.container}>\n      <button className={buttonStyles.primary}>Click me</button>\n    </div>\n  )\n}\n\nIn this example, Turbopack will ensure that utils.module.css will appear before button.module.css in the produced CSS chunk, following the import order\n\nWebpack generally does this as well, but there are cases where it will ignore JS inferred ordering, for example if it infers the JS file is side-effect-free.\n\nThis can lead to subtle rendering changes when adopting Turbopack, if applications have come to rely on an arbitrary ordering. Generally, the solution is easy, e.g. have button.module.css @import utils.module.css to force the ordering, or identify the conflicting rules and change them to not target the same properties.\n\nSass node_modules imports\n\nTurbopack supports importing node_modules Sass files out of the box. Webpack supports a legacy tilde ~ syntax for this, which is not supported by Turbopack.\n\nFrom:\n\nstyles/globals.scss\n@import '~bootstrap/dist/css/bootstrap.min.css';\n\nTo:\n\nstyles/globals.scss\n@import 'bootstrap/dist/css/bootstrap.min.css';\n\nIf you can't update the imports, you can add a turbopack.resolveAlias configuration to map the ~ syntax to the actual path:\n\nnext.config.js\nmodule.exports = {\n  turbopack: {\n    resolveAlias: {\n      '~*': '*',\n    },\n  },\n}\nBundle Sizes\n\nFrom our testing on production applications, we observed that Turbopack generally produces bundles that are similar in size to Webpack. However, the comparison can be difficult since turbopack tends to produce fewer but larger chunks. Our advice is to focus on higher level metrics like Core Web Vitals\n or your own application level metrics to compare performance across the two bundlers. We are however aware of one gap that can occasionally cause a large regression.\n\nTurbopack does not yet have an equivalent to the Inner Graph Optimization\n in webpack which is enabled by default. This optimization is useful to tree shake large modules. For example:\n\nimport heavy from 'some-heavy-dependency.js'\n \nexport function usesHeavy() {\n  return heavy.run()\n}\n \nexport const CONSTANT_VALUE = 3\n\nIf an application only uses CONSTANT_VALUE Turbopack will detect this and delete the usesHeavy export but not the corresponding import. However, with the Inner Graph Optimization, webpack can delete the import too which can drop the dependency as well.\n\nWe are planning to offer an equivalent to the Inner Graph Optimization in Turbopack but it is still under development. If you are affected by this gap, consider manually splitting modules.\n\nBuild Caching\n\nWebpack supports disk build caching\n to improve build performance. Turbopack provides a similar opt-in feature, currently in beta. Starting with Next 16, you can enable Turbopack’s filesystem cache by setting the following experimental flags:\n\nexperimental.turbopackFileSystemCacheForDev\nexperimental.turbopackFileSystemCacheForBuild\n\nGood to know: For this reason, when comparing webpack and Turbopack performance, make sure to delete the .next folder between builds to see a fair comparison or enable the turbopack filesystem cache feature.\n\nWebpack plugins\n\nTurbopack does not support webpack plugins. This affects third-party tools that rely on webpack's plugin system for integration. We do support webpack loaders. If you depend on webpack plugins, you'll need to find Turbopack-compatible alternatives or continue using webpack until equivalent functionality is available.\n\nUnsupported and unplanned features\n\nSome features are not yet implemented or not planned:\n\nLegacy CSS Modules features\nStandalone :local and :global pseudo-classes (only the function variant :global(...) is supported).\nThe @value rule (superseded by CSS variables).\n:import and :export ICSS rules.\ncomposes in .module.css composing a .css file. In webpack this would treat the .css file as a CSS Module, with Turbopack the .css file will always be global. This means that if you want to use composes in a CSS Module, you need to change the .css file to a .module.css file.\n@import in CSS Modules importing .css as a CSS Module. In webpack this would treat the .css file as a CSS Module, with Turbopack the .css file will always be global. This means that if you want to use @import in a CSS Module, you need to change the .css file to a .module.css file.\nsassOptions.functions Custom Sass functions defined in sassOptions.functions are not supported. This feature allows defining JavaScript functions that can be called from Sass code during compilation. Turbopack's Rust-based architecture cannot directly execute JavaScript functions passed through sassOptions.functions, unlike webpack's Node.js-based sass-loader which runs entirely in JavaScript. If you're using custom Sass functions, you'll need to use webpack instead of Turbopack.\nwebpack() configuration in next.config.js Turbopack replaces webpack, so webpack() configs are not recognized. Use the turbopack config instead.\nYarn PnP Not planned for Turbopack support in Next.js.\nexperimental.urlImports Not planned for Turbopack.\nexperimental.esmExternals Not planned. Turbopack does not support the legacy esmExternals configuration in Next.js.\nSome Next.js Experimental Flags\nexperimental.nextScriptWorkers\nexperimental.sri.algorithm\nexperimental.fallbackNodePolyfills We plan to implement these in the future.\n\nFor a full, detailed breakdown of each feature flag and its status, see the Turbopack API Reference.\n\nConfiguration\n\nTurbopack can be configured via next.config.js (or next.config.ts) under the turbopack key. Configuration options include:\n\nrules Define additional webpack loaders for file transformations.\nresolveAlias Create manual aliases (like resolve.alias in webpack).\nresolveExtensions Change or extend file extensions for module resolution.\nnext.config.js\nmodule.exports = {\n  turbopack: {\n    // Example: adding an alias and custom file extension\n    resolveAlias: {\n      underscore: 'lodash',\n    },\n    resolveExtensions: ['.mdx', '.tsx', '.ts', '.jsx', '.js', '.json'],\n  },\n}\n\nFor more in-depth configuration examples, see the Turbopack config documentation.\n\nGenerating trace files for performance debugging\n\nIf you encounter performance or memory issues and want to help the Next.js team diagnose them, you can generate a trace file by appending NEXT_TURBOPACK_TRACING=1 to your dev command:\n\nNEXT_TURBOPACK_TRACING=1 next dev\n\nThis will produce a .next/dev/trace-turbopack file. Include that file when creating a GitHub issue on the Next.js repo\n to help us investigate.\n\nBy default the development server outputs to .next/dev. Read more about isolatedDevBuild.\n\nSummary\n\nTurbopack is a Rust-based, incremental bundler designed to make local development and builds fast—especially for large applications. It is integrated into Next.js, offering zero-config CSS, React, and TypeScript support.\n\nVersion Changes\nVersion\tChanges\nv16.0.0\tTurbopack becomes the default bundler for Next.js. Automatic support for Babel when a configuration file is found.\nv15.5.0\tTurbopack support for build beta\nv15.3.0\tExperimental support for build\nv15.0.0\tTurbopack for dev stable\nPrevious\nEdge Runtime\nNext\nPages Router\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Metadata and OG images | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/metadata-and-og-images",
    "html": "App Router\nGetting Started\nMetadata and OG images\nCopy page\nMetadata and OG images\n\nThe Metadata APIs can be used to define your application metadata for improved SEO and web shareability and include:\n\nThe static metadata object\nThe dynamic generateMetadata function\nSpecial file conventions that can be used to add static or dynamically generated favicons and OG images.\n\nWith all the options above, Next.js will automatically generate the relevant <head> tags for your page, which can be inspected in the browser's developer tools.\n\nThe metadata object and generateMetadata function exports are only supported in Server Components.\n\nDefault fields\n\nThere are two default meta tags that are always added even if a route doesn't define metadata:\n\nThe meta charset tag\n sets the character encoding for the website.\nThe meta viewport tag\n sets the viewport width and scale for the website to adjust for different devices.\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\nThe other metadata fields can be defined with the Metadata object (for static metadata) or the generateMetadata function (for generated metadata).\n\nStatic metadata\n\nTo define static metadata, export a Metadata object from a static layout.js or page.js file. For example, to add a title and description to the blog route:\n\napp/blog/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  title: 'My Blog',\n  description: '...',\n}\n \nexport default function Layout() {}\n\nYou can view a full list of available options, in the generateMetadata documentation.\n\nGenerated metadata\n\nYou can use generateMetadata function to fetch metadata that depends on data. For example, to fetch the title and description for a specific blog post:\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata, ResolvingMetadata } from 'next'\n \ntype Props = {\n  params: Promise<{ slug: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}\n \nexport async function generateMetadata(\n  { params, searchParams }: Props,\n  parent: ResolvingMetadata\n): Promise<Metadata> {\n  const slug = (await params).slug\n \n  // fetch post information\n  const post = await fetch(`https://api.vercel.app/blog/${slug}`).then((res) =>\n    res.json()\n  )\n \n  return {\n    title: post.title,\n    description: post.description,\n  }\n}\n \nexport default function Page({ params, searchParams }: Props) {}\nStreaming metadata\n\nFor dynamically rendered pages, Next.js streams metadata separately, injecting it into the HTML once generateMetadata resolves, without blocking UI rendering.\n\nStreaming metadata improves perceived performance by allowing visual content to stream first.\n\nStreaming metadata is disabled for bots and crawlers that expect metadata to be in the <head> tag (e.g. Twitterbot, Slackbot, Bingbot). These are detected by using the User Agent header from the incoming request.\n\nYou can customize or disable streaming metadata completely, with the htmlLimitedBots option in your Next.js config file.\n\nStatically rendered pages don’t use streaming since metadata is resolved at build time.\n\nLearn more about streaming metadata.\n\nMemoizing data requests\n\nThere may be cases where you need to fetch the same data for metadata and the page itself. To avoid duplicate requests, you can use React's cache function\n to memoize the return value and only fetch the data once. For example, to fetch the blog post information for both the metadata and the page:\n\napp/lib/data.ts\nTypeScript\nJavaScript\nTypeScript\nimport { cache } from 'react'\nimport { db } from '@/app/lib/db'\n \n// getPost will be used twice, but execute only once\nexport const getPost = cache(async (slug: string) => {\n  const res = await db.query.posts.findFirst({ where: eq(posts.slug, slug) })\n  return res\n})\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { getPost } from '@/app/lib/data'\n \nexport async function generateMetadata({\n  params,\n}: {\n  params: { slug: string }\n}) {\n  const post = await getPost(params.slug)\n  return {\n    title: post.title,\n    description: post.description,\n  }\n}\n \nexport default async function Page({ params }: { params: { slug: string } }) {\n  const post = await getPost(params.slug)\n  return <div>{post.title}</div>\n}\nFile-based metadata\n\nThe following special files are available for metadata:\n\nfavicon.ico, apple-icon.jpg, and icon.jpg\nopengraph-image.jpg and twitter-image.jpg\nrobots.txt\nsitemap.xml\n\nYou can use these for static metadata, or you can programmatically generate these files with code.\n\nFavicons\n\nFavicons are small icons that represent your site in bookmarks and search results. To add a favicon to your application, create a favicon.ico and add to the root of the app folder.\n\nYou can also programmatically generate favicons using code. See the favicon docs for more information.\n\nStatic Open Graph images\n\nOpen Graph (OG) images are images that represent your site in social media. To add a static OG image to your application, create a opengraph-image.png file in the root of the app folder.\n\nYou can also add OG images for specific routes by creating a opengraph-image.png deeper down the folder structure. For example, to create an OG image specific to the /blog route, add a opengraph-image.jpg file inside the blog folder.\n\nThe more specific image will take precedence over any OG images above it in the folder structure.\n\nOther image formats such as jpeg, png, and gif are also supported. See the Open Graph Image docs for more information.\n\nGenerated Open Graph images\n\nThe ImageResponse constructor allows you to generate dynamic images using JSX and CSS. This is useful for OG images that depend on data.\n\nFor example, to generate a unique OG image for each blog post, add a opengraph-image.tsx file inside the blog folder, and import the ImageResponse constructor from next/og:\n\napp/blog/[slug]/opengraph-image.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { ImageResponse } from 'next/og'\nimport { getPost } from '@/app/lib/data'\n \n// Image metadata\nexport const size = {\n  width: 1200,\n  height: 630,\n}\n \nexport const contentType = 'image/png'\n \n// Image generation\nexport default async function Image({ params }: { params: { slug: string } }) {\n  const post = await getPost(params.slug)\n \n  return new ImageResponse(\n    (\n      // ImageResponse JSX element\n      <div\n        style={{\n          fontSize: 128,\n          background: 'white',\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n        }}\n      >\n        {post.title}\n      </div>\n    )\n  )\n}\n\nImageResponse supports common CSS properties including flexbox and absolute positioning, custom fonts, text wrapping, centering, and nested images. See the full list of supported CSS properties.\n\nGood to know:\n\nExamples are available in the Vercel OG Playground\n.\nImageResponse uses @vercel/og\n, satori\n, and resvg to convert HTML and CSS into PNG.\nOnly flexbox and a subset of CSS properties are supported. Advanced layouts (e.g. display: grid) will not work.\nAPI Reference\nLearn more about the Metadata APIs mentioned in this page.\ngenerateMetadata\nLearn how to add Metadata to your Next.js application for improved search engine optimization (SEO) and web shareability.\ngenerateViewport\nAPI Reference for the generateViewport function.\nImageResponse\nAPI Reference for the ImageResponse constructor.\nMetadata Files\nAPI documentation for the metadata file conventions.\nfavicon, icon, and apple-icon\nAPI Reference for the Favicon, Icon and Apple Icon file conventions.\nopengraph-image and twitter-image\nAPI Reference for the Open Graph Image and Twitter Image file conventions.\nrobots.txt\nAPI Reference for robots.txt file.\nsitemap.xml\nAPI Reference for the sitemap.xml file.\nhtmlLimitedBots\nSpecify a list of user agents that should receive blocking metadata.\nPrevious\nFont Optimization\nNext\nRoute Handlers\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Architecture: Accessibility | Next.js",
    "url": "https://nextjs.org/docs/architecture/accessibility",
    "html": "Next.js Docs\nArchitecture\nAccessibility\nCopy page\nAccessibility\n\nThe Next.js team is committed to making Next.js accessible to all developers (and their end-users). By adding accessibility features to Next.js by default, we aim to make the Web more inclusive for everyone.\n\nRoute Announcements\n\nWhen transitioning between pages rendered on the server (e.g. using the <a href> tag) screen readers and other assistive technology announce the page title when the page loads so that users understand that the page has changed.\n\nIn addition to traditional page navigations, Next.js also supports client-side transitions for improved performance (using next/link). To ensure that client-side transitions are also announced to assistive technology, Next.js includes a route announcer by default.\n\nThe Next.js route announcer looks for the page name to announce by first inspecting document.title, then the <h1> element, and finally the URL pathname. For the most accessible user experience, ensure that each page in your application has a unique and descriptive title.\n\nLinting\n\nNext.js provides an integrated ESLint experience out of the box, including custom rules for Next.js. By default, Next.js includes eslint-plugin-jsx-a11y to help catch accessibility issues early, including warning on:\n\naria-props\naria-proptypes\naria-unsupported-elements\nrole-has-required-aria-props\nrole-supports-aria-props\n\nFor example, this plugin helps ensure you add alt text to img tags, use correct aria-* attributes, use correct role attributes, and more.\n\nAccessibility Resources\nWebAIM WCAG checklist\nWCAG 2.2 Guidelines\nThe A11y Project\nCheck color contrast ratios\n between foreground and background elements\nUse prefers-reduced-motion\n when working with animations\nPrevious\nArchitecture\nNext\nFast Refresh\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Proxy | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/proxy",
    "html": "App Router\nGetting Started\nProxy\nCopy page\nProxy\nProxy\n\nProxy allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.\n\nUse cases\n\nSome common scenarios where Proxy is effective include:\n\nQuick redirects after reading parts of the incoming request\nRewriting to different pages based on A/B tests or experiments\nModifying headers for all pages or a subset of pages\n\nProxy is not a good fit for:\n\nSlow data fetching\nSession management\n\nUsing fetch with options.cache, options.next.revalidate, or options.next.tags, has no effect in Proxy.\n\nConvention\n\nCreate a proxy.ts (or .js) file in the project root, or inside src if applicable, so that it is located at the same level as pages or app.\n\nNote: While only one proxy.ts file is supported per project, you can still organize your proxy logic into modules. Break out proxy functionalities into separate .ts or .js files and import them into your main proxy.ts file. This allows for cleaner management of route-specific proxy, aggregated in the proxy.ts for centralized control. By enforcing a single proxy file, it simplifies configuration, prevents potential conflicts, and optimizes performance by avoiding multiple proxy layers.\n\nExample\nproxy.ts\nTypeScript\nJavaScript\nTypeScript\nimport { NextResponse } from 'next/server'\nimport type { NextRequest } from 'next/server'\n \n// This function can be marked `async` if using `await` inside\nexport function proxy(request: NextRequest) {\n  return NextResponse.redirect(new URL('/home', request.url))\n}\n \n// See \"Matching Paths\" below to learn more\nexport const config = {\n  matcher: '/about/:path*',\n}\n\nRead more about using proxy, or refer to the proxy API reference.\n\nAPI Reference\nLearn more about Proxy\nproxy.js\nAPI reference for the proxy.js file.\nBackend for Frontend\nLearn how to use Next.js as a backend framework\nPrevious\nRoute Handlers\nNext\nDeploying\n\nWas this helpful?\n\nsupported.\nSend"
  }
]
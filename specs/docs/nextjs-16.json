[
  {
    "title": "App Router: Getting Started | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started",
    "html": "Next.js Docs\nApp Router\nGetting Started\nCopy page\nGetting Started\n\nWelcome to the Next.js documentation!\n\nThis Getting Started section will help you create your first Next.js app and learn the core features you'll use in every project.\n\nPre-requisite knowledge\n\nOur documentation assumes some familiarity with web development. Before getting started, it'll help if you're comfortable with:\n\nHTML\nCSS\nJavaScript\nReact\n\nIf you're new to React or need a refresher, we recommend starting with our React Foundations course, and the Next.js Foundations course that has you building an application as you learn.\n\nNext Steps\nInstallation\nLearn how to create a new Next.js application with the `create-next-app` CLI, and set up TypeScript, ESLint, and Module Path Aliases.\nProject Structure\nLearn the folder and file conventions in Next.js, and how to organize your project.\nLayouts and Pages\nLearn how to create your first pages and layouts, and link between them with the Link component.\nLinking and Navigating\nLearn how the built-in navigation optimizations work, including prefetching, prerendering, and client-side navigation, and how to optimize navigation for dynamic routes and slow networks.\nServer and Client Components\nLearn how you can use React Server and Client Components to render parts of your application on the server or the client.\nCache Components\nLearn how to use Cache Components and combine the benefits of static and dynamic rendering.\nFetching Data\nLearn how to fetch data and stream content that depends on data.\nUpdating Data\nLearn how to mutate data using Server Functions.\nCaching and Revalidating\nLearn how to cache and revalidate data in your application.\nError Handling\nLearn how to display expected errors and handle uncaught exceptions.\nCSS\nLearn about the different ways to add CSS to your application, including Tailwind CSS, CSS Modules, Global CSS, and more.\nImage Optimization\nLearn how to optimize images in Next.js\nFont Optimization\nLearn how to optimize fonts in Next.js\nMetadata and OG images\nLearn how to add metadata to your pages and create dynamic OG images.\nRoute Handlers\nLearn how to use Route Handlers\nProxy\nLearn how to use Proxy\nDeploying\nLearn how to deploy your Next.js application.\nUpgrading\nLearn how to upgrade your Next.js application to the latest version or canary.\nPrevious\nApp Router\nNext\nInstallation\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Project Structure | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/project-structure",
    "html": "App Router\nGetting Started\nProject Structure\nCopy page\nProject structure and organization\n\nThis page provides an overview of all the folder and file conventions in Next.js, and recommendations for organizing your project.\n\nFolder and file conventions\nTop-level folders\n\nTop-level folders are used to organize your application's code and static assets.\n\n\t\napp\tApp Router\npages\tPages Router\npublic\tStatic assets to be served\nsrc\tOptional application source folder\nTop-level files\n\nTop-level files are used to configure your application, manage dependencies, run proxy, integrate monitoring tools, and define environment variables.\n\n\t\nNext.js\t\nnext.config.js\tConfiguration file for Next.js\npackage.json\tProject dependencies and scripts\ninstrumentation.ts\tOpenTelemetry and Instrumentation file\nproxy.ts\tNext.js request proxy\n.env\tEnvironment variables\n.env.local\tLocal environment variables\n.env.production\tProduction environment variables\n.env.development\tDevelopment environment variables\neslint.config.mjs\tConfiguration file for ESLint\n.gitignore\tGit files and folders to ignore\nnext-env.d.ts\tTypeScript declaration file for Next.js\ntsconfig.json\tConfiguration file for TypeScript\njsconfig.json\tConfiguration file for JavaScript\nRouting Files\n\nAdd page to expose a route, layout for shared UI such as header, nav, or footer, loading for skeletons, error for error boundaries, and route for APIs.\n\n\t\t\nlayout\t.js .jsx .tsx\tLayout\npage\t.js .jsx .tsx\tPage\nloading\t.js .jsx .tsx\tLoading UI\nnot-found\t.js .jsx .tsx\tNot found UI\nerror\t.js .jsx .tsx\tError UI\nglobal-error\t.js .jsx .tsx\tGlobal error UI\nroute\t.js .ts\tAPI endpoint\ntemplate\t.js .jsx .tsx\tRe-rendered layout\ndefault\t.js .jsx .tsx\tParallel route fallback page\nNested routes\n\nFolders define URL segments. Nesting folders nests segments. Layouts at any level wrap their child segments. A route becomes public when a page or route file exists.\n\nPath\tURL pattern\tNotes\napp/layout.tsx\t—\tRoot layout wraps all routes\napp/blog/layout.tsx\t—\tWraps /blog and descendants\napp/page.tsx\t/\tPublic route\napp/blog/page.tsx\t/blog\tPublic route\napp/blog/authors/page.tsx\t/blog/authors\tPublic route\nDynamic routes\n\nParameterize segments with square brackets. Use [segment] for a single param, [...segment] for catch‑all, and [[...segment]] for optional catch‑all. Access values via the params prop.\n\nPath\tURL pattern\napp/blog/[slug]/page.tsx\t/blog/my-first-post\napp/shop/[...slug]/page.tsx\t/shop/clothing, /shop/clothing/shirts\napp/docs/[[...slug]]/page.tsx\t/docs, /docs/layouts-and-pages, /docs/api-reference/use-router\nRoute groups and private folders\n\nOrganize code without changing URLs with route groups (group), and colocate non-routable files with private folders _folder.\n\nPath\tURL pattern\tNotes\napp/(marketing)/page.tsx\t/\tGroup omitted from URL\napp/(shop)/cart/page.tsx\t/cart\tShare layouts within (shop)\napp/blog/_components/Post.tsx\t—\tNot routable; safe place for UI utilities\napp/blog/_lib/data.ts\t—\tNot routable; safe place for utils\nParallel and Intercepted Routes\n\nThese features fit specific UI patterns, such as slot-based layouts or modal routing.\n\nUse @slot for named slots rendered by a parent layout. Use intercept patterns to render another route inside the current layout without changing the URL, for example, to show a details view as a modal over a list.\n\nPattern (docs)\tMeaning\tTypical use case\n@folder\tNamed slot\tSidebar + main content\n(.)folder\tIntercept same level\tPreview sibling route in a modal\n(..)folder\tIntercept parent\tOpen a child of the parent as an overlay\n(..)(..)folder\tIntercept two levels\tDeeply nested overlay\n(...)folder\tIntercept from root\tShow arbitrary route in current view\nMetadata file conventions\nApp icons\n\t\t\nfavicon\t.ico\tFavicon file\nicon\t.ico .jpg .jpeg .png .svg\tApp Icon file\nicon\t.js .ts .tsx\tGenerated App Icon\napple-icon\t.jpg .jpeg, .png\tApple App Icon file\napple-icon\t.js .ts .tsx\tGenerated Apple App Icon\nOpen Graph and Twitter images\n\t\t\nopengraph-image\t.jpg .jpeg .png .gif\tOpen Graph image file\nopengraph-image\t.js .ts .tsx\tGenerated Open Graph image\ntwitter-image\t.jpg .jpeg .png .gif\tTwitter image file\ntwitter-image\t.js .ts .tsx\tGenerated Twitter image\nSEO\n\t\t\nsitemap\t.xml\tSitemap file\nsitemap\t.js .ts\tGenerated Sitemap\nrobots\t.txt\tRobots file\nrobots\t.js .ts\tGenerated Robots file\nOrganizing your project\n\nNext.js is unopinionated about how you organize and colocate your project files. But it does provide several features to help you organize your project.\n\nComponent hierarchy\n\nThe components defined in special files are rendered in a specific hierarchy:\n\nlayout.js\ntemplate.js\nerror.js (React error boundary)\nloading.js (React suspense boundary)\nnot-found.js (React error boundary for \"not found\" UI)\npage.js or nested layout.js\n\nThe components are rendered recursively in nested routes, meaning the components of a route segment will be nested inside the components of its parent segment.\n\nColocation\n\nIn the app directory, nested folders define route structure. Each folder represents a route segment that is mapped to a corresponding segment in a URL path.\n\nHowever, even though route structure is defined through folders, a route is not publicly accessible until a page.js or route.js file is added to a route segment.\n\nAnd, even when a route is made publicly accessible, only the content returned by page.js or route.js is sent to the client.\n\nThis means that project files can be safely colocated inside route segments in the app directory without accidentally being routable.\n\nGood to know: While you can colocate your project files in app you don't have to. If you prefer, you can keep them outside the app directory.\n\nPrivate folders\n\nPrivate folders can be created by prefixing a folder with an underscore: _folderName\n\nThis indicates the folder is a private implementation detail and should not be considered by the routing system, thereby opting the folder and all its subfolders out of routing.\n\nSince files in the app directory can be safely colocated by default, private folders are not required for colocation. However, they can be useful for:\n\nSeparating UI logic from routing logic.\nConsistently organizing internal files across a project and the Next.js ecosystem.\nSorting and grouping files in code editors.\nAvoiding potential naming conflicts with future Next.js file conventions.\n\nGood to know:\n\nWhile not a framework convention, you might also consider marking files outside private folders as \"private\" using the same underscore pattern.\nYou can create URL segments that start with an underscore by prefixing the folder name with %5F (the URL-encoded form of an underscore): %5FfolderName.\nIf you don't use private folders, it would be helpful to know Next.js special file conventions to prevent unexpected naming conflicts.\nRoute groups\n\nRoute groups can be created by wrapping a folder in parenthesis: (folderName)\n\nThis indicates the folder is for organizational purposes and should not be included in the route's URL path.\n\nRoute groups are useful for:\n\nOrganizing routes by site section, intent, or team. e.g. marketing pages, admin pages, etc.\nEnabling nested layouts in the same route segment level:\nCreating multiple nested layouts in the same segment, including multiple root layouts\nAdding a layout to a subset of routes in a common segment\nsrc folder\n\nNext.js supports storing application code (including app) inside an optional src folder. This separates application code from project configuration files which mostly live in the root of a project.\n\nExamples\n\nThe following section lists a very high-level overview of common strategies. The simplest takeaway is to choose a strategy that works for you and your team and be consistent across the project.\n\nGood to know: In our examples below, we're using components and lib folders as generalized placeholders, their naming has no special framework significance and your projects might use other folders like ui, utils, hooks, styles, etc.\n\nStore project files outside of app\n\nThis strategy stores all application code in shared folders in the root of your project and keeps the app directory purely for routing purposes.\n\nStore project files in top-level folders inside of app\n\nThis strategy stores all application code in shared folders in the root of the app directory.\n\nSplit project files by feature or route\n\nThis strategy stores globally shared application code in the root app directory and splits more specific application code into the route segments that use them.\n\nOrganize routes without affecting the URL path\n\nTo organize routes without affecting the URL, create a group to keep related routes together. The folders in parenthesis will be omitted from the URL (e.g. (marketing) or (shop)).\n\nEven though routes inside (marketing) and (shop) share the same URL hierarchy, you can create a different layout for each group by adding a layout.js file inside their folders.\n\nOpting specific segments into a layout\n\nTo opt specific routes into a layout, create a new route group (e.g. (shop)) and move the routes that share the same layout into the group (e.g. account and cart). The routes outside of the group will not share the layout (e.g. checkout).\n\nOpting for loading skeletons on a specific route\n\nTo apply a loading skeleton via a loading.js file to a specific route, create a new route group (e.g., /(overview)) and then move your loading.tsx inside that route group.\n\nNow, the loading.tsx file will only apply to your dashboard → overview page instead of all your dashboard pages without affecting the URL path structure.\n\nCreating multiple root layouts\n\nTo create multiple root layouts, remove the top-level layout.js file, and add a layout.js file inside each route group. This is useful for partitioning an application into sections that have a completely different UI or experience. The <html> and <body> tags need to be added to each root layout.\n\nIn the example above, both (marketing) and (shop) have their own root layout.\n\nPrevious\nInstallation\nNext\nLayouts and Pages\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Installation | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/installation",
    "html": "App Router\nGetting Started\nInstallation\nCopy page\nInstallation\n\nCreate a new Next.js app and run it locally.\n\nQuick start\nCreate a new Next.js app named my-app\ncd my-app and start the dev server.\nVisit http://localhost:3000.\npnpm\nnpm\nyarn\nbun\nTerminal\npnpm create next-app@latest my-app --yes\ncd my-app\npnpm dev\n--yes skips prompts using saved preferences or defaults. The default setup enables TypeScript, Tailwind, App Router, and Turbopack, with import alias @/*.\nSystem requirements\n\nBefore you begin, make sure your system meets the following requirements:\n\nNode.js 20.9\n or later.\nmacOS, Windows (including WSL), or Linux.\nCreate with the CLI\n\nThe quickest way to create a new Next.js app is using create-next-app, which sets up everything automatically for you. To create a project, run:\n\nTerminal\nnpx create-next-app@latest\n\nOn installation, you'll see the following prompts:\n\nTerminal\nWhat is your project named? my-app\nWould you like to use the recommended Next.js defaults?\n    Yes, use recommended defaults - TypeScript, ESLint, Tailwind CSS, App Router, Turbopack\n    No, reuse previous settings\n    No, customize settings - Choose your own preferences\n\nIf you choose to customize settings, you'll see the following prompts:\n\nTerminal\nWould you like to use TypeScript? No / Yes\nWhich linter would you like to use? ESLint / Biome / None\nWould you like to use React Compiler? No / Yes\nWould you like to use Tailwind CSS? No / Yes\nWould you like your code inside a `src/` directory? No / Yes\nWould you like to use App Router? (recommended) No / Yes\nWould you like to use Turbopack? (recommended) No / Yes\nWould you like to customize the import alias (`@/*` by default)? No / Yes\nWhat import alias would you like configured? @/*\n\nAfter the prompts, create-next-app will create a folder with your project name and install the required dependencies.\n\nManual installation\n\nTo manually create a new Next.js app, install the required packages:\n\npnpm\nnpm\nyarn\nbun\nTerminal\npnpm i next@latest react@latest react-dom@latest\n\nGood to know: The App Router uses React canary releases\n built-in, which include all the stable React 19 changes, as well as newer features being validated in frameworks. The Pages Router uses the React version you install in package.json.\n\nThen, add the following scripts to your package.json file:\n\npackage.json\n{\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"lint\": \"eslint\",\n    \"lint:fix\": \"eslint --fix\"\n  }\n}\n\nThese scripts refer to the different stages of developing an application:\n\nnext dev: Starts the development server using Turbopack (default bundler).\nnext build: Builds the application for production.\nnext start: Starts the production server.\neslint: Runs ESLint.\n\nTurbopack is now the default bundler. To use Webpack run next dev --webpack or next build --webpack. See the Turbopack docs for configuration details.\n\nCreate the app directory\n\nNext.js uses file-system routing, which means the routes in your application are determined by how you structure your files.\n\nCreate an app folder. Then, inside app, create a layout.tsx file. This file is the root layout. It's required and must contain the <html> and <body> tags.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  )\n}\n\nCreate a home page app/page.tsx with some initial content:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Page() {\n  return <h1>Hello, Next.js!</h1>\n}\n\nBoth layout.tsx and page.tsx will be rendered when the user visits the root of your application (/).\n\nGood to know:\n\nIf you forget to create the root layout, Next.js will automatically create this file when running the development server with next dev.\nYou can optionally use a src folder in the root of your project to separate your application's code from configuration files.\nCreate the public folder (optional)\n\nCreate a public folder at the root of your project to store static assets such as images, fonts, etc. Files inside public can then be referenced by your code starting from the base URL (/).\n\nYou can then reference these assets using the root path (/). For example, public/profile.png can be referenced as /profile.png:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Image from 'next/image'\n \nexport default function Page() {\n  return <Image src=\"/profile.png\" alt=\"Profile\" width={100} height={100} />\n}\nRun the development server\nRun npm run dev to start the development server.\nVisit http://localhost:3000 to view your application.\nEdit the app/page.tsx file and save it to see the updated result in your browser.\nSet up TypeScript\n\nMinimum TypeScript version: v5.1.0\n\nNext.js comes with built-in TypeScript support. To add TypeScript to your project, rename a file to .ts / .tsx and run next dev. Next.js will automatically install the necessary dependencies and add a tsconfig.json file with the recommended config options.\n\nIDE Plugin\n\nNext.js includes a custom TypeScript plugin and type checker, which VSCode and other code editors can use for advanced type-checking and auto-completion.\n\nYou can enable the plugin in VS Code by:\n\nOpening the command palette (Ctrl/⌘ + Shift + P)\nSearching for \"TypeScript: Select TypeScript Version\"\nSelecting \"Use Workspace Version\"\n\nSee the TypeScript reference page for more information.\n\nSet up linting\n\nNext.js supports linting with either ESLint or Biome. Choose a linter and run it directly via package.json scripts.\n\nUse ESLint (comprehensive rules):\npackage.json\n{\n  \"scripts\": {\n    \"lint\": \"eslint\",\n    \"lint:fix\": \"eslint --fix\"\n  }\n}\nOr use Biome (fast linter + formatter):\npackage.json\n{\n  \"scripts\": {\n    \"lint\": \"biome check\",\n    \"format\": \"biome format --write\"\n  }\n}\n\nIf your project previously used next lint, migrate your scripts to the ESLint CLI with the codemod:\n\nTerminal\nnpx @next/codemod@canary next-lint-to-eslint-cli .\n\nIf you use ESLint, create an explicit config (recommended eslint.config.mjs). ESLint supports both the legacy .eslintrc.* and the newer eslint.config.mjs formats\n. See the ESLint API reference for a recommended setup.\n\nGood to know: Starting with Next.js 16, next build no longer runs the linter automatically. Instead, you can run your linter through NPM scripts.\n\nSee the ESLint Plugin page for more information.\n\nSet up Absolute Imports and Module Path Aliases\n\nNext.js has in-built support for the \"paths\" and \"baseUrl\" options of tsconfig.json and jsconfig.json files.\n\nThese options allow you to alias project directories to absolute paths, making it easier and cleaner to import modules. For example:\n\n// Before\nimport { Button } from '../../../components/button'\n \n// After\nimport { Button } from '@/components/button'\n\nTo configure absolute imports, add the baseUrl configuration option to your tsconfig.json or jsconfig.json file. For example:\n\ntsconfig.json or jsconfig.json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src/\"\n  }\n}\n\nIn addition to configuring the baseUrl path, you can use the \"paths\" option to \"alias\" module paths.\n\nFor example, the following configuration maps @/components/* to components/*:\n\ntsconfig.json or jsconfig.json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src/\",\n    \"paths\": {\n      \"@/styles/*\": [\"styles/*\"],\n      \"@/components/*\": [\"components/*\"]\n    }\n  }\n}\n\nEach of the \"paths\" are relative to the baseUrl location.\n\nPrevious\nGetting Started\nNext\nProject Structure\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Layouts and Pages | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/layouts-and-pages",
    "html": "App Router\nGetting Started\nLayouts and Pages\nCopy page\nLayouts and Pages\n\nNext.js uses file-system based routing, meaning you can use folders and files to define routes. This page will guide you through how to create layouts and pages, and link between them.\n\nCreating a page\n\nA page is UI that is rendered on a specific route. To create a page, add a page file inside the app directory and default export a React component. For example, to create an index page (/):\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Page() {\n  return <h1>Hello Next.js!</h1>\n}\nCreating a layout\n\nA layout is UI that is shared between multiple pages. On navigation, layouts preserve state, remain interactive, and do not rerender.\n\nYou can define a layout by default exporting a React component from a layout file. The component should accept a children prop which can be a page or another layout.\n\nFor example, to create a layout that accepts your index page as child, add a layout file inside the app directory:\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function DashboardLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        {/* Layout UI */}\n        {/* Place children where you want to render a page or nested layout */}\n        <main>{children}</main>\n      </body>\n    </html>\n  )\n}\n\nThe layout above is called a root layout because it's defined at the root of the app directory. The root layout is required and must contain html and body tags.\n\nCreating a nested route\n\nA nested route is a route composed of multiple URL segments. For example, the /blog/[slug] route is composed of three segments:\n\n/ (Root Segment)\nblog (Segment)\n[slug] (Leaf Segment)\n\nIn Next.js:\n\nFolders are used to define the route segments that map to URL segments.\nFiles (like page and layout) are used to create UI that is shown for a segment.\n\nTo create nested routes, you can nest folders inside each other. For example, to add a route for /blog, create a folder called blog in the app directory. Then, to make /blog publicly accessible, add a page.tsx file:\n\napp/blog/page.tsx\nTypeScript\nJavaScript\nTypeScript\n// Dummy imports\nimport { getPosts } from '@/lib/posts'\nimport { Post } from '@/ui/post'\n \nexport default async function Page() {\n  const posts = await getPosts()\n \n  return (\n    <ul>\n      {posts.map((post) => (\n        <Post key={post.id} post={post} />\n      ))}\n    </ul>\n  )\n}\n\nYou can continue nesting folders to create nested routes. For example, to create a route for a specific blog post, create a new [slug] folder inside blog and add a page file:\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nfunction generateStaticParams() {}\n \nexport default function Page() {\n  return <h1>Hello, Blog Post Page!</h1>\n}\n\nWrapping a folder name in square brackets (e.g. [slug]) creates a dynamic route segment which is used to generate multiple pages from data. e.g. blog posts, product pages, etc.\n\nNesting layouts\n\nBy default, layouts in the folder hierarchy are also nested, which means they wrap child layouts via their children prop. You can nest layouts by adding layout inside specific route segments (folders).\n\nFor example, to create a layout for the /blog route, add a new layout file inside the blog folder.\n\napp/blog/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function BlogLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return <section>{children}</section>\n}\n\nIf you were to combine the two layouts above, the root layout (app/layout.js) would wrap the blog layout (app/blog/layout.js), which would wrap the blog (app/blog/page.js) and blog post page (app/blog/[slug]/page.js).\n\nCreating a dynamic segment\n\nDynamic segments allow you to create routes that are generated from data. For example, instead of manually creating a route for each individual blog post, you can create a dynamic segment to generate the routes based on blog post data.\n\nTo create a dynamic segment, wrap the segment (folder) name in square brackets: [segmentName]. For example, in the app/blog/[slug]/page.tsx route, the [slug] is the dynamic segment.\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function BlogPostPage({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  const post = await getPost(slug)\n \n  return (\n    <div>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </div>\n  )\n}\n\nLearn more about Dynamic Segments and the params props.\n\nNested layouts within Dynamic Segments, can also access the params props.\n\nRendering with search params\n\nIn a Server Component page, you can access search parameters using the searchParams prop:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Page({\n  searchParams,\n}: {\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  const filters = (await searchParams).filters\n}\n\nUsing searchParams opts your page into dynamic rendering because it requires a incoming request to read the search parameters from.\n\nClient Components can read search params using the useSearchParams hook.\n\nLearn more about useSearchParams in statically rendered and dynamically rendered routes.\n\nWhat to use and when\nUse the searchParams prop when you need search parameters to load data for the page (e.g. pagination, filtering from a database).\nUse useSearchParams when search parameters are used only on the client (e.g. filtering a list already loaded via props).\nAs a small optimization, you can use new URLSearchParams(window.location.search) in callbacks or event handlers to read search params without triggering re-renders.\nLinking between pages\n\nYou can use the <Link> component to navigate between routes. <Link> is a built-in Next.js component that extends the HTML <a> tag to provide prefetching and client-side navigation.\n\nFor example, to generate a list of blog posts, import <Link> from next/link and pass a href prop to the component:\n\napp/ui/post.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \nexport default async function Post({ post }) {\n  const posts = await getPosts()\n \n  return (\n    <ul>\n      {posts.map((post) => (\n        <li key={post.slug}>\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\n        </li>\n      ))}\n    </ul>\n  )\n}\n\nGood to know: <Link> is the primary way to navigate between routes in Next.js. You can also use the useRouter hook for more advanced navigation.\n\nRoute Props Helpers\n\nNext.js exposes utility types that infer params and named slots from your route structure:\n\nPageProps: Props for page components, including params and searchParams.\nLayoutProps: Props for layout components, including children and any named slots (e.g. folders like @analytics).\n\nThese are globally available helpers, generated when running either next dev, next build or next typegen.\n\napp/blog/[slug]/page.tsx\nexport default async function Page(props: PageProps<'/blog/[slug]'>) {\n  const { slug } = await props.params\n  return <h1>Blog post: {slug}</h1>\n}\napp/dashboard/layout.tsx\nexport default function Layout(props: LayoutProps<'/dashboard'>) {\n  return (\n    <section>\n      {props.children}\n      {/* If you have app/dashboard/@analytics, it appears as a typed slot: */}\n      {/* {props.analytics} */}\n    </section>\n  )\n}\n\nGood to know\n\nStatic routes resolve params to {}.\nPageProps, LayoutProps are global helpers — no imports required.\nTypes are generated during next dev, next build or next typegen.\nAPI Reference\nLearn more about the features mentioned in this page by reading the API Reference.\nLinking and Navigating\nLearn how the built-in navigation optimizations work, including prefetching, prerendering, and client-side navigation, and how to optimize navigation for dynamic routes and slow networks.\nlayout.js\nAPI reference for the layout.js file.\npage.js\nAPI reference for the page.js file.\nLink Component\nEnable fast client-side navigation with the built-in `next/link` component.\nDynamic Segments\nDynamic Route Segments can be used to programmatically generate route segments from dynamic data.\nPrevious\nProject Structure\nNext\nLinking and Navigating\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Linking and Navigating | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/linking-and-navigating",
    "html": "App Router\nGetting Started\nLinking and Navigating\nCopy page\nLinking and Navigating\n\nIn Next.js, routes are rendered on the server by default. This often means the client has to wait for a server response before a new route can be shown. Next.js comes with built-in prefetching, streaming, and client-side transitions ensuring navigation stays fast and responsive.\n\nThis guide explains how navigation works in Next.js and how you can optimize it for dynamic routes and slow networks.\n\nHow navigation works\n\nTo understand how navigation works in Next.js, it helps to be familiar with the following concepts:\n\nServer Rendering\nPrefetching\nStreaming\nClient-side transitions\nServer Rendering\n\nIn Next.js, Layouts and Pages are React Server Components\n by default. On initial and subsequent navigations, the Server Component Payload is generated on the server before being sent to the client.\n\nThere are two types of server rendering, based on when it happens:\n\nStatic Rendering (or Prerendering) happens at build time or during revalidation and the result is cached.\nDynamic Rendering happens at request time in response to a client request.\n\nThe trade-off of server rendering is that the client must wait for the server to respond before the new route can be shown. Next.js addresses this delay by prefetching routes the user is likely to visit and performing client-side transitions.\n\nGood to know: HTML is also generated for the initial visit.\n\nPrefetching\n\nPrefetching is the process of loading a route in the background before the user navigates to it. This makes navigation between routes in your application feel instant, because by the time a user clicks on a link, the data to render the next route is already available client side.\n\nNext.js automatically prefetches routes linked with the <Link> component when they enter the user's viewport.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Link from 'next/link'\n \nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <html>\n      <body>\n        <nav>\n          {/* Prefetched when the link is hovered or enters the viewport */}\n          <Link href=\"/blog\">Blog</Link>\n          {/* No prefetching */}\n          <a href=\"/contact\">Contact</a>\n        </nav>\n        {children}\n      </body>\n    </html>\n  )\n}\n\nHow much of the route is prefetched depends on whether it's static or dynamic:\n\nStatic Route: the full route is prefetched.\nDynamic Route: prefetching is skipped, or the route is partially prefetched if loading.tsx is present.\n\nBy skipping or partially prefetching dynamic routes, Next.js avoids unnecessary work on the server for routes the users may never visit. However, waiting for a server response before navigation can give the users the impression that the app is not responding.\n\nTo improve the navigation experience to dynamic routes, you can use streaming.\n\nStreaming\n\nStreaming allows the server to send parts of a dynamic route to the client as soon as they're ready, rather than waiting for the entire route to be rendered. This means users see something sooner, even if parts of the page are still loading.\n\nFor dynamic routes, it means they can be partially prefetched. That is, shared layouts and loading skeletons can be requested ahead of time.\n\nTo use streaming, create a loading.tsx in your route folder:\n\napp/dashboard/loading.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Loading() {\n  // Add fallback UI that will be shown while the route is loading.\n  return <LoadingSkeleton />\n}\n\nBehind the scenes, Next.js will automatically wrap the page.tsx contents in a <Suspense> boundary. The prefetched fallback UI will be shown while the route is loading, and swapped for the actual content once ready.\n\nGood to know: You can also use <Suspense>\n to create loading UI for nested components.\n\nBenefits of loading.tsx:\n\nImmediate navigation and visual feedback for the user.\nShared layouts remain interactive and navigation is interruptible.\nImproved Core Web Vitals: TTFB\n, FCP\n, and TTI\n.\n\nTo further improve the navigation experience, Next.js performs a client-side transition with the <Link> component.\n\nClient-side transitions\n\nTraditionally, navigation to a server-rendered page triggers a full page load. This clears state, resets scroll position, and blocks interactivity.\n\nNext.js avoids this with client-side transitions using the <Link> component. Instead of reloading the page, it updates the content dynamically by:\n\nKeeping any shared layouts and UI.\nReplacing the current page with the prefetched loading state or a new page if available.\n\nClient-side transitions are what makes a server-rendered apps feel like client-rendered apps. And when paired with prefetching and streaming, it enables fast transitions, even for dynamic routes.\n\nWhat can make transitions slow?\n\nThese Next.js optimizations make navigation fast and responsive. However, under certain conditions, transitions can still feel slow. Here are some common causes and how to improve the user experience:\n\nDynamic routes without loading.tsx\n\nWhen navigating to a dynamic route, the client must wait for the server response before showing the result. This can give the users the impression that the app is not responding.\n\nWe recommend adding loading.tsx to dynamic routes to enable partial prefetching, trigger immediate navigation, and display a loading UI while the route renders.\n\napp/blog/[slug]/loading.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Loading() {\n  return <LoadingSkeleton />\n}\n\nGood to know: In development mode, you can use the Next.js Devtools to identify if the route is static or dynamic. See devIndicators for more information.\n\nDynamic segments without generateStaticParams\n\nIf a dynamic segment could be prerendered but isn't because it's missing generateStaticParams, the route will fallback to dynamic rendering at request time.\n\nEnsure the route is statically generated at build time by adding generateStaticParams:\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) => res.json())\n \n  return posts.map((post) => ({\n    slug: post.slug,\n  }))\n}\n \nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  // ...\n}\nSlow networks\n\nOn slow or unstable networks, prefetching may not finish before the user clicks a link. This can affect both static and dynamic routes. In these cases, the loading.js fallback may not appear immediately because it hasn't been prefetched yet.\n\nTo improve perceived performance, you can use the useLinkStatus hook to show immediate feedback while the transition is in progress.\n\napp/ui/loading-indicator.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useLinkStatus } from 'next/link'\n \nexport default function LoadingIndicator() {\n  const { pending } = useLinkStatus()\n  return (\n    <span aria-hidden className={`link-hint ${pending ? 'is-pending' : ''}`} />\n  )\n}\n\nYou can \"debounce\" the hint by adding an initial animation delay (e.g. 100ms) and starting as invisible (e.g. opacity: 0). This means the loading indicator will only be shown if the navigation takes longer than the specified delay. See the useLinkStatus reference for a CSS example.\n\nGood to know: You can use other visual feedback patterns like a progress bar. View an example here\n.\n\nDisabling prefetching\n\nYou can opt out of prefetching by setting the prefetch prop to false on the <Link> component. This is useful to avoid unnecessary usage of resources when rendering large lists of links (e.g. an infinite scroll table).\n\n<Link prefetch={false} href=\"/blog\">\n  Blog\n</Link>\n\nHowever, disabling prefetching comes with trade-offs:\n\nStatic routes will only be fetched when the user clicks the link.\nDynamic routes will need to be rendered on the server first before the client can navigate to it.\n\nTo reduce resource usage without fully disabling prefetch, you can prefetch only on hover. This limits prefetching to routes the user is more likely to visit, rather than all links in the viewport.\n\napp/ui/hover-prefetch-link.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport Link from 'next/link'\nimport { useState } from 'react'\n \nfunction HoverPrefetchLink({\n  href,\n  children,\n}: {\n  href: string\n  children: React.ReactNode\n}) {\n  const [active, setActive] = useState(false)\n \n  return (\n    <Link\n      href={href}\n      prefetch={active ? null : false}\n      onMouseEnter={() => setActive(true)}\n    >\n      {children}\n    </Link>\n  )\n}\nHydration not completed\n\n<Link> is a Client Component and must be hydrated before it can prefetch routes. On the initial visit, large JavaScript bundles can delay hydration, preventing prefetching from starting right away.\n\nReact mitigates this with Selective Hydration and you can further improve this by:\n\nUsing the @next/bundle-analyzer plugin to identify and reduce bundle size by removing large dependencies.\nMoving logic from the client to the server where possible. See the Server and Client Components docs for guidance.\nExamples\nNative History API\n\nNext.js allows you to use the native window.history.pushState\n and window.history.replaceState\n methods to update the browser's history stack without reloading the page.\n\npushState and replaceState calls integrate into the Next.js Router, allowing you to sync with usePathname and useSearchParams.\n\nwindow.history.pushState\n\nUse it to add a new entry to the browser's history stack. The user can navigate back to the previous state. For example, to sort a list of products:\n\n'use client'\n \nimport { useSearchParams } from 'next/navigation'\n \nexport default function SortProducts() {\n  const searchParams = useSearchParams()\n \n  function updateSorting(sortOrder: string) {\n    const params = new URLSearchParams(searchParams.toString())\n    params.set('sort', sortOrder)\n    window.history.pushState(null, '', `?${params.toString()}`)\n  }\n \n  return (\n    <>\n      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>\n      <button onClick={() => updateSorting('desc')}>Sort Descending</button>\n    </>\n  )\n}\nwindow.history.replaceState\n\nUse it to replace the current entry on the browser's history stack. The user is not able to navigate back to the previous state. For example, to switch the application's locale:\n\n'use client'\n \nimport { usePathname } from 'next/navigation'\n \nexport function LocaleSwitcher() {\n  const pathname = usePathname()\n \n  function switchLocale(locale: string) {\n    // e.g. '/en/about' or '/fr/contact'\n    const newPath = `/${locale}${pathname}`\n    window.history.replaceState(null, '', newPath)\n  }\n \n  return (\n    <>\n      <button onClick={() => switchLocale('en')}>English</button>\n      <button onClick={() => switchLocale('fr')}>French</button>\n    </>\n  )\n}\nNext Steps\nLink Component\nEnable fast client-side navigation with the built-in `next/link` component.\nloading.js\nAPI reference for the loading.js file.\nPrefetching\nLearn how to configure prefetching in Next.js\nPrevious\nLayouts and Pages\nNext\nServer and Client Components\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Server and Client Components | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/server-and-client-components",
    "html": "App Router\nGetting Started\nServer and Client Components\nCopy page\nServer and Client Components\n\nBy default, layouts and pages are Server Components\n, which lets you fetch data and render parts of your UI on the server, optionally cache the result, and stream it to the client. When you need interactivity or browser APIs, you can use Client Components\n to layer in functionality.\n\nThis page explains how Server and Client Components work in Next.js and when to use them, with examples of how to compose them together in your application.\n\nWhen to use Server and Client Components?\n\nThe client and server environments have different capabilities. Server and Client components allow you to run logic in each environment depending on your use case.\n\nUse Client Components when you need:\n\nState\n and event handlers\n. E.g. onClick, onChange.\nLifecycle logic\n. E.g. useEffect.\nBrowser-only APIs. E.g. localStorage, window, Navigator.geolocation, etc.\nCustom hooks\n.\n\nUse Server Components when you need:\n\nFetch data from databases or APIs close to the source.\nUse API keys, tokens, and other secrets without exposing them to the client.\nReduce the amount of JavaScript sent to the browser.\nImprove the First Contentful Paint (FCP)\n, and stream content progressively to the client.\n\nFor example, the <Page> component is a Server Component that fetches data about a post, and passes it as props to the <LikeButton> which handles client-side interactivity.\n\napp/[id]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport LikeButton from '@/app/ui/like-button'\nimport { getPost } from '@/lib/data'\n \nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n  const post = await getPost(id)\n \n  return (\n    <div>\n      <main>\n        <h1>{post.title}</h1>\n        {/* ... */}\n        <LikeButton likes={post.likes} />\n      </main>\n    </div>\n  )\n}\napp/ui/like-button.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useState } from 'react'\n \nexport default function LikeButton({ likes }: { likes: number }) {\n  // ...\n}\nHow do Server and Client Components work in Next.js?\nOn the server\n\nOn the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks, by individual route segments (layouts and pages):\n\nServer Components are rendered into a special data format called the React Server Component Payload (RSC Payload).\nClient Components and the RSC Payload are used to pre-render HTML.\n\nWhat is the React Server Component Payload (RSC)?\n\nThe RSC Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The RSC Payload contains:\n\nThe rendered result of Server Components\nPlaceholders for where Client Components should be rendered and references to their JavaScript files\nAny props passed from a Server Component to a Client Component\nOn the client (first load)\n\nThen, on the client:\n\nHTML is used to immediately show a fast non-interactive preview of the route to the user.\nRSC Payload is used to reconcile the Client and Server Component trees.\nJavaScript is used to hydrate Client Components and make the application interactive.\n\nWhat is hydration?\n\nHydration is React's process for attaching event handlers\n to the DOM, to make the static HTML interactive.\n\nSubsequent Navigations\n\nOn subsequent navigations:\n\nThe RSC Payload is prefetched and cached for instant navigation.\nClient Components are rendered entirely on the client, without the server-rendered HTML.\nExamples\nUsing Client Components\n\nYou can create a Client Component by adding the \"use client\"\n directive at the top of the file, above your imports.\n\napp/ui/counter.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useState } from 'react'\n \nexport default function Counter() {\n  const [count, setCount] = useState(0)\n \n  return (\n    <div>\n      <p>{count} likes</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  )\n}\n\n\"use client\" is used to declare a boundary between the Server and Client module graphs (trees).\n\nOnce a file is marked with \"use client\", all its imports and child components are considered part of the client bundle. This means you don't need to add the directive to every component that is intended for the client.\n\nReducing JS bundle size\n\nTo reduce the size of your client JavaScript bundles, add 'use client' to specific interactive components instead of marking large parts of your UI as Client Components.\n\nFor example, the <Layout> component contains mostly static elements like a logo and navigation links, but includes an interactive search bar. <Search /> is interactive and needs to be a Client Component, however, the rest of the layout can remain a Server Component.\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\n// Client Component\nimport Search from './search'\n// Server Component\nimport Logo from './logo'\n \n// Layout is a Server Component by default\nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <>\n      <nav>\n        <Logo />\n        <Search />\n      </nav>\n      <main>{children}</main>\n    </>\n  )\n}\napp/ui/search.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nexport default function Search() {\n  // ...\n}\nPassing data from Server to Client Components\n\nYou can pass data from Server Components to Client Components using props.\n\napp/[id]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport LikeButton from '@/app/ui/like-button'\nimport { getPost } from '@/lib/data'\n \nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n  const post = await getPost(id)\n \n  return <LikeButton likes={post.likes} />\n}\napp/ui/like-button.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nexport default function LikeButton({ likes }: { likes: number }) {\n  // ...\n}\n\nAlternatively, you can stream data from a Server Component to a Client Component with the use Hook\n. See an example.\n\nGood to know: Props passed to Client Components need to be serializable\n by React.\n\nInterleaving Server and Client Components\n\nYou can pass Server Components as a prop to a Client Component. This allows you to visually nest server-rendered UI within Client components.\n\nA common pattern is to use children to create a slot in a <ClientComponent>. For example, a <Cart> component that fetches data on the server, inside a <Modal> component that uses client state to toggle visibility.\n\napp/ui/modal.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nexport default function Modal({ children }: { children: React.ReactNode }) {\n  return <div>{children}</div>\n}\n\nThen, in a parent Server Component (e.g.<Page>), you can pass a <Cart> as the child of the <Modal>:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Modal from './ui/modal'\nimport Cart from './ui/cart'\n \nexport default function Page() {\n  return (\n    <Modal>\n      <Cart />\n    </Modal>\n  )\n}\n\nIn this pattern, all Server Components will be rendered on the server ahead of time, including those as props. The resulting RSC payload will contain references of where Client Components should be rendered within the component tree.\n\nContext providers\n\nReact context\n is commonly used to share global state like the current theme. However, React context is not supported in Server Components.\n\nTo use context, create a Client Component that accepts children:\n\napp/theme-provider.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { createContext } from 'react'\n \nexport const ThemeContext = createContext({})\n \nexport default function ThemeProvider({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return <ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider>\n}\n\nThen, import it into a Server Component (e.g. layout):\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport ThemeProvider from './theme-provider'\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html>\n      <body>\n        <ThemeProvider>{children}</ThemeProvider>\n      </body>\n    </html>\n  )\n}\n\nYour Server Component will now be able to directly render your provider, and all other Client Components throughout your app will be able to consume this context.\n\nGood to know: You should render providers as deep as possible in the tree – notice how ThemeProvider only wraps {children} instead of the entire <html> document. This makes it easier for Next.js to optimize the static parts of your Server Components.\n\nThird-party components\n\nWhen using a third-party component that relies on client-only features, you can wrap it in a Client Component to ensure it works as expected.\n\nFor example, the <Carousel /> can be imported from the acme-carousel package. This component uses useState, but it doesn't yet have the \"use client\" directive.\n\nIf you use <Carousel /> within a Client Component, it will work as expected:\n\napp/gallery.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useState } from 'react'\nimport { Carousel } from 'acme-carousel'\n \nexport default function Gallery() {\n  const [isOpen, setIsOpen] = useState(false)\n \n  return (\n    <div>\n      <button onClick={() => setIsOpen(true)}>View pictures</button>\n      {/* Works, since Carousel is used within a Client Component */}\n      {isOpen && <Carousel />}\n    </div>\n  )\n}\n\nHowever, if you try to use it directly within a Server Component, you'll see an error. This is because Next.js doesn't know <Carousel /> is using client-only features.\n\nTo fix this, you can wrap third-party components that rely on client-only features in your own Client Components:\n\napp/carousel.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { Carousel } from 'acme-carousel'\n \nexport default Carousel\n\nNow, you can use <Carousel /> directly within a Server Component:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Carousel from './carousel'\n \nexport default function Page() {\n  return (\n    <div>\n      <p>View pictures</p>\n      {/*  Works, since Carousel is a Client Component */}\n      <Carousel />\n    </div>\n  )\n}\n\nAdvice for Library Authors\n\nIf you’re building a component library, add the \"use client\" directive to entry points that rely on client-only features. This lets your users import components into Server Components without needing to create wrappers.\n\nIt's worth noting some bundlers might strip out \"use client\" directives. You can find an example of how to configure esbuild to include the \"use client\" directive in the React Wrap Balancer\n and Vercel Analytics\n repositories.\n\nPreventing environment poisoning\n\nJavaScript modules can be shared between both Server and Client Components modules. This means it's possible to accidentally import server-only code into the client. For example, consider the following function:\n\nlib/data.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function getData() {\n  const res = await fetch('https://external-service.com/data', {\n    headers: {\n      authorization: process.env.API_KEY,\n    },\n  })\n \n  return res.json()\n}\n\nThis function contains an API_KEY that should never be exposed to the client.\n\nIn Next.js, only environment variables prefixed with NEXT_PUBLIC_ are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string.\n\nAs a result, even though getData() can be imported and executed on the client, it won't work as expected.\n\nTo prevent accidental usage in Client Components, you can use the server-only package\n.\n\nThen, import the package into a file that contains server-only code:\n\nlib/data.js\nimport 'server-only'\n \nexport async function getData() {\n  const res = await fetch('https://external-service.com/data', {\n    headers: {\n      authorization: process.env.API_KEY,\n    },\n  })\n \n  return res.json()\n}\n\nNow, if you try to import the module into a Client Component, there will be a build-time error.\n\nThe corresponding client-only package\n can be used to mark modules that contain client-only logic like code that accesses the window object.\n\nIn Next.js, installing server-only or client-only is optional. However, if your linting rules flag extraneous dependencies, you may install them to avoid issues.\n\npnpm\nnpm\nyarn\nbun\nTerminal\npnpm add server-only\n\nNext.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js.\n\nNext.js also provides its own type declarations for server-only and client-only, for TypeScript configurations where noUncheckedSideEffectImports\n is active.\n\nNext Steps\nLearn more about the APIs mentioned in this page.\nuse client\nLearn how to use the use client directive to render a component on the client.\nPrevious\nLinking and Navigating\nNext\nCache Components\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Cache Components | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/cache-components",
    "html": "App Router\nGetting Started\nCache Components\nCopy page\nCache Components\n\nCache Components is a new approach to rendering and caching in Next.js that provides fine-grained control over what gets cached and when, while ensuring a great user experience through Partial Prerendering (PPR).\n\nCache Components\n\nWhen developing dynamic applications, you have to balance two primary approaches:\n\nFully static pages load fast but can't show personalized or real-time data\nFully dynamic pages can show fresh data but require rendering everything on each request, leading to slower initial loads\n\nWith Cache Components enabled, Next.js treats all routes as dynamic by default. Every request renders with the latest available data. However, most pages are made up of both static and dynamic parts, and not all dynamic data needs to be resolved from source on every request.\n\nCache Components allows you to mark data, and even parts of your UI as cacheable, which includes them in the pre-render pass alongside static parts of the page.\n\nBefore Cache Components, Next.js tried to statically optimize entire pages automatically, which could lead to unexpected behavior when adding dynamic code.\n\nCache Components implements Partial Prerendering (PPR), and use cache to give you the best of both worlds:\n\nWhen a user visits a route:\n\nThe server sends a static shell containing cached content, ensuring a fast initial load\nDynamic sections wrapped in Suspense boundaries display fallback UI in the shell\nOnly the dynamic parts render to replace their fallbacks, streaming in parallel as they become ready\nYou can include otherwise-dynamic data in the initial shell by caching it with use cache\n\n🎥 Watch: Why PPR and how it works → YouTube (10 minutes)\n.\n\nHow it works\n\nGood to know: Cache Components is an opt-in feature. Enable it by setting the cacheComponents flag to true in your Next config file. See Enabling Cache Components for more details.\n\nCache Components gives you three key tools to control rendering:\n\n1. Suspense for runtime data\n\nSome data is only available at runtime when an actual user makes a request. APIs like cookies, headers, and searchParams access request-specific information. Wrap components using these APIs in Suspense boundaries so the rest of the page can be pre-rendered as a static shell.\n\nRuntime APIs include:\n\ncookies\nheaders\nsearchParams prop\nparams prop - This is runtime data unless you provide at least one example value through generateStaticParams. When provided, those specific param values are treated as static for prerendered paths, while other values remain runtime\n2. Suspense for dynamic data\n\nDynamic data like fetch calls or database queries (db.query(...)) can change between requests but isn't user-specific. The connection API is meta-dynamic—it represents waiting for a user navigation even though there's no actual data to return. Wrap components that use these in Suspense boundaries to enable streaming.\n\nDynamic data patterns include:\n\nfetch requests\nDatabase queries\nconnection\n3. Cached data with use cache\n\nAdd use cache to any Server Component to make it cached and include it in the pre-rendered shell. You cannot use runtime APIs from inside a cached component. You can also mark utility functions as use cache and call them from Server Components.\n\nexport async function getProducts() {\n  'use cache'\n  const data = await db.query('SELECT * FROM products')\n  return data\n}\nUsing Suspense boundaries\n\nReact Suspense\n boundaries let you define what fallback UI to use when it wraps dynamic or runtime data.\n\nContent outside the boundary, including the fallback UI, is pre-rendered as a static shell, while content inside the boundary streams in when ready.\n\nHere's how to use Suspense with Cache Components:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Suspense } from 'react'\n \nexport default function Page() {\n  return (\n    <>\n      <h1>This will be pre-rendered</h1>\n      <Suspense fallback={<Skeleton />}>\n        <DynamicContent />\n      </Suspense>\n    </>\n  )\n}\n \nasync function DynamicContent() {\n  const res = await fetch('http://api.cms.com/posts')\n  const { posts } = await res.json()\n  return <div>{/* ... */}</div>\n}\n\nAt build time, Next.js pre-renders the static content and the fallback UI, while the dynamic content is postponed until a user requests the route.\n\nGood to know: Wrapping a component in Suspense doesn't make it dynamic; your API usage does. Suspense acts as a boundary that encapsulates dynamic content and enables streaming.\n\nMissing Suspense boundaries\n\nCache Components enforces that dynamic code must be wrapped in a Suspense boundary. If you forget, you'll see the Uncached data was accessed outside of <Suspense>\n error:\n\nUncached data was accessed outside of <Suspense>\n\nThis delays the entire page from rendering, resulting in a slow user experience. Next.js uses this error to ensure your app loads instantly on every navigation.\n\nTo fix this, you can either:\n\nWrap the component in a <Suspense> boundary. This allows Next.js to stream its contents to the user as soon as it's ready, without blocking the rest of the app.\n\nor\n\nMove the asynchronous await into a Cache Component(\"use cache\"). This allows Next.js to statically prerender the component as part of the HTML document, so it's instantly visible to the user.\n\nNote that request-specific information, such as params, cookies, and headers, is not available during static prerendering, so it must be wrapped in <Suspense>.\n\nThis error helps prevent a situation where, instead of getting a static shell instantly, users would hit a blocking runtime render with nothing to show. To fix it, add a Suspense boundary or use use cache to cache the work instead.\n\nHow streaming works\n\nStreaming splits the route into chunks and progressively streams them to the client as they become ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering.\n\nWith partial pre-rendering, the initial UI can be sent immediately to the browser while the dynamic parts render. This decreases time to UI and may decrease total request time depending on how much of your UI is pre-rendered.\n\nTo reduce network overhead, the full response, including static HTML and streamed dynamic parts, is sent in a single HTTP request. This avoids extra round-trips and improves both initial load and overall performance.\n\nUsing use cache\n\nWhile Suspense boundaries manage dynamic content, the use cache directive is available for caching data or computations that don't change often.\n\nBasic usage\n\nAdd use cache to cache a page, component, or async function, and define a lifetime with cacheLife:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { cacheLife } from 'next/cache'\n \nexport default async function Page() {\n  'use cache'\n  cacheLife('hours')\n  // fetch or compute\n  return <div>...</div>\n}\nCaveats\n\nWhen using use cache, keep these constraints in mind:\n\nArguments must be serializable\n\nLike Server Actions, arguments to cached functions must be serializable. This means you can pass primitives, plain objects, and arrays, but not class instances, functions, or other complex types.\n\nAccepting unserializable values without introspection\n\nYou can accept unserializable values as arguments as long as you don't introspect them. However, you can return them. This allows patterns like cached components that accept Server or Client Components as children:\n\napp/cached-wrapper.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { ReactNode } from 'react'\n \nexport async function CachedWrapper({ children }: { children: ReactNode }) {\n  'use cache'\n  // Don't introspect children, just pass it through\n  return (\n    <div className=\"wrapper\">\n      <header>Cached Header</header>\n      {children}\n    </div>\n  )\n}\nAvoid passing dynamic inputs\n\nYou must not pass dynamic or runtime data into use cache functions unless you avoid introspecting them. Passing values from cookies(), headers(), or other runtime APIs as arguments will cause errors, as the cache key cannot be determined at pre-render time.\n\nTagging and revalidating\n\nTag cached data with cacheTag and revalidate it after mutations using updateTag in Server Actions for immediate updates, or revalidateTag delay in updates are acceptable.\n\nWith updateTag\n\nUse updateTag when you need to expire and immediately refresh cached data within the same request:\n\napp/actions.ts\nimport { cacheTag, updateTag } from 'next/cache'\n \nexport async function getCart() {\n  'use cache'\n  cacheTag('cart')\n  // fetch data\n}\n \nexport async function updateCart(itemId: string) {\n  'use server'\n  // write data using the itemId\n  // update the user cart\n  updateTag('cart')\n}\nWith revalidateTag\n\nUse revalidateTag when you want to invalidate only properly tagged cached entries with stale-while-revalidate behavior. This is ideal for static content that can tolerate eventual consistency.\n\napp/actions.ts\nimport { cacheTag, revalidateTag } from 'next/cache'\n \nexport async function getPosts() {\n  'use cache'\n  cacheTag('posts')\n  // fetch data\n}\n \nexport async function createPost(post: FormData) {\n  'use server'\n  // write data using the FormData\n  revalidateTag('posts', 'max')\n}\n\nFor more detailed explanation and usage examples, see the use cache API reference.\n\nEnabling Cache Components\n\nYou can enable Cache Components (which includes PPR) by adding the cacheComponents option to your Next config file:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  cacheComponents: true,\n}\n \nexport default nextConfig\nEffect on route segment config\n\nWhen Cache Components is enabled, several route segment config options are no longer needed or supported. Here's what changes and how to migrate:\n\ndynamic = \"force-dynamic\"\n\nNot needed. All pages are dynamic by default with Cache Components enabled, so this configuration is unnecessary.\n\n// Before - No longer needed\nexport const dynamic = 'force-dynamic'\n \nexport default function Page() {\n  return <div>...</div>\n}\n// After - Just remove it, pages are dynamic by default\nexport default function Page() {\n  return <div>...</div>\n}\ndynamic = \"force-static\"\n\nReplace with use cache. You must add use cache to each Layout and Page for the associated route instead.\n\nNote: force-static previously allowed the use of runtime APIs like cookies(), but this is no longer supported. If you add use cache and see an error related to runtime data, you must remove the use of runtime APIs.\n\n// Before\nexport const dynamic = 'force-static'\n \nexport default async function Page() {\n  const data = await fetch('https://api.example.com/data')\n  return <div>...</div>\n}\n// After - Use 'use cache' instead\nexport default async function Page() {\n  'use cache'\n  const data = await fetch('https://api.example.com/data')\n  return <div>...</div>\n}\nrevalidate\n\nReplace with cacheLife. Use the cacheLife function to define cache duration instead of the route segment config.\n\n// Before\nexport const revalidate = 3600 // 1 hour\n \nexport default async function Page() {\n  return <div>...</div>\n}\n// After - Use cacheLife\nimport { cacheLife } from 'next/cache'\n \nexport default async function Page() {\n  'use cache'\n  cacheLife('hours')\n  return <div>...</div>\n}\nfetchCache\n\nNot needed. With use cache, all data fetching within a cached scope is automatically cached, making fetchCache unnecessary.\n\n// Before\nexport const fetchCache = 'force-cache'\n// After - Use 'use cache' to control caching behavior\nexport default async function Page() {\n  'use cache'\n  // All fetches here are cached\n  return <div>...</div>\n}\nruntime = 'edge'\n\nNot supported. Cache Components requires Node.js runtime and will throw errors with Edge Runtime.\n\nBefore vs. after Cache Components\n\nUnderstanding how Cache Components changes your mental model:\n\nBefore Cache Components\nStatic by default: Next.js tried to pre-render and cache as much as possible for you unless you opted out\nRoute-level controls: Switches like dynamic, revalidate, fetchCache controlled caching for the whole page\nLimits of fetch: Using fetch alone was incomplete, as it didn't cover direct database clients or other server-side IO. A nested fetch switching to dynamic (e.g., { cache: 'no-store' }) could unintentionally change the entire route behavior\nWith Cache Components\nDynamic by default: Everything is dynamic by default. You decide which parts to cache by adding use cache where it helps\nFine-grained control: File/component/function-level use cache and cacheLife control caching exactly where you need it\nStreaming stays: Use <Suspense> or a loading.(js|tsx) file to stream dynamic parts while the shell shows immediately\nBeyond fetch: Using the use cache directive caching can be applied to all server IO (database calls, APIs, computations), not just fetch. Nested fetch calls won't silently flip an entire route because behavior is governed by explicit cache boundaries and Suspense\nExamples\nDynamic APIs\n\nWhen accessing runtime APIs like cookies(), Next.js will only pre-render the fallback UI above this component.\n\nIn this example, we have no fallback defined, so Next.js shows an error instructing us to provide one. The <User /> component needs to be wrapped in Suspense because it uses the cookies API:\n\napp/user.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { cookies } from 'next/headers'\n \nexport async function User() {\n  const session = (await cookies()).get('session')?.value\n  return '...'\n}\n\nNow we have a Suspense boundary around our User component we can pre-render the Page with a Skeleton UI and stream in the <User /> UI when a specific user makes a request\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Suspense } from 'react'\nimport { User, AvatarSkeleton } from './user'\n \nexport default function Page() {\n  return (\n    <section>\n      <h1>This will be pre-rendered</h1>\n      <Suspense fallback={<AvatarSkeleton />}>\n        <User />\n      </Suspense>\n    </section>\n  )\n}\nPassing dynamic props\n\nComponents only opt into dynamic rendering when the value is accessed. For example, if you are reading searchParams from a <Page /> component, you can forward this value to another component as a prop:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Table, TableSkeleton } from './table'\nimport { Suspense } from 'react'\n \nexport default function Page({\n  searchParams,\n}: {\n  searchParams: Promise<{ sort: string }>\n}) {\n  return (\n    <section>\n      <h1>This will be pre-rendered</h1>\n      <Suspense fallback={<TableSkeleton />}>\n        <Table searchParams={searchParams.then((search) => search.sort)} />\n      </Suspense>\n    </section>\n  )\n}\n\nInside of the table component, accessing the value from searchParams will make the component dynamic while the rest of the page will be pre-rendered.\n\napp/table.tsx\nTypeScript\nJavaScript\nTypeScript\nexport async function Table({ sortPromise }: { sortPromise: Promise<string> }) {\n  const sort = (await sortPromise) === 'true'\n  return '...'\n}\nFrequently Asked Questions\nDoes this replace Partial Prerendering (PPR)?\n\nNo. Cache Components implements PPR as a feature. The old experimental PPR flag has been removed but PPR is here to stay.\n\nPPR provides the static shell and streaming infrastructure; use cache lets you include optimized dynamic output in that shell when beneficial.\n\nWhat should I cache first?\n\nWhat you cache should be a function of what you want your UI loading states to be. If data doesn't depend on runtime data and you're okay with a cached value being served for multiple requests over a period of time, use use cache with cacheLife to describe that behavior.\n\nFor content management systems with update mechanisms, consider using tags with longer cache durations and rely on revalidateTag to mark static initial UI as ready for revalidation. This pattern allows you to serve fast, cached responses while still updating content when it actually changes, rather than expiring the cache preemptively.\n\nHow do I update cached content quickly?\n\nUse cacheTag to tag your cached data, then trigger updateTag or revalidateTag.\n\nNext Steps\nLearn more about the config option for Cache Components.\ncacheComponents\nLearn how to enable the cacheComponents flag in Next.js.\nuse cache\nLearn how to use the use cache directive to cache data in your Next.js application.\ncacheLife\nLearn how to use the cacheLife function to set the cache expiration time for a cached function or component.\ncacheTag\nLearn how to use the cacheTag function to manage cache invalidation in your Next.js application.\nrevalidateTag\nAPI Reference for the revalidateTag function.\nupdateTag\nAPI Reference for the updateTag function.\nPrevious\nServer and Client Components\nNext\nFetching Data\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Updating Data | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/updating-data",
    "html": "App Router\nGetting Started\nUpdating Data\nCopy page\nUpdating Data\n\nYou can update data in Next.js using React's Server Functions\n. This page will go through how you can create and invoke Server Functions.\n\nWhat are Server Functions?\n\nA Server Function is an asynchronous function that runs on the server. They can be called from client through a network request, which is why they must be asynchronous.\n\nIn an action or mutation context, they are also called Server Actions.\n\nBy convention, a Server Action is an async function used with startTransition\n. This happens automatically when the function is:\n\nPassed to a <form> using the action prop.\nPassed to a <button> using the formAction prop.\n\nIn Next.js, Server Actions integrate with the framework's caching architecture. When an action is invoked, Next.js can return both the updated UI and new data in a single server roundtrip.\n\nBehind the scenes, actions use the POST method, and only this HTTP method can invoke them.\n\nCreating Server Functions\n\nA Server Function can be defined by using the use server\n directive. You can place the directive at the top of an asynchronous function to mark the function as a Server Function, or at the top of a separate file to mark all exports of that file.\n\napp/lib/actions.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function createPost(formData: FormData) {\n  'use server'\n  const title = formData.get('title')\n  const content = formData.get('content')\n \n  // Update data\n  // Revalidate cache\n}\n \nexport async function deletePost(formData: FormData) {\n  'use server'\n  const id = formData.get('id')\n \n  // Update data\n  // Revalidate cache\n}\nServer Components\n\nServer Functions can be inlined in Server Components by adding the \"use server\" directive to the top of the function body:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Page() {\n  // Server Action\n  async function createPost(formData: FormData) {\n    'use server'\n    // ...\n  }\n \n  return <></>\n}\n\nGood to know: Server Components support progressive enhancement by default, meaning forms that call Server Actions will be submitted even if JavaScript hasn't loaded yet or is disabled.\n\nClient Components\n\nIt's not possible to define Server Functions in Client Components. However, you can invoke them in Client Components by importing them from a file that has the \"use server\" directive at the top of it:\n\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nexport async function createPost() {}\napp/ui/button.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { createPost } from '@/app/actions'\n \nexport function Button() {\n  return <button formAction={createPost}>Create</button>\n}\n\nGood to know: In Client Components, forms invoking Server Actions will queue submissions if JavaScript isn't loaded yet, and will be prioritized for hydration. After hydration, the browser does not refresh on form submission.\n\nPassing actions as props\n\nYou can also pass an action to a Client Component as a prop:\n\n<ClientComponent updateItemAction={updateItem} />\napp/client-component.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nexport default function ClientComponent({\n  updateItemAction,\n}: {\n  updateItemAction: (formData: FormData) => void\n}) {\n  return <form action={updateItemAction}>{/* ... */}</form>\n}\nInvoking Server Functions\n\nThere are two main ways you can invoke a Server Function:\n\nForms in Server and Client Components\nEvent Handlers and useEffect in Client Components\n\nGood to know: Server Functions are designed for server-side mutations. The client currently dispatches and awaits them one at a time. This is an implementation detail and may change. If you need parallel data fetching, use data fetching in Server Components, or perform parallel work inside a single Server Function or Route Handler.\n\nForms\n\nReact extends the HTML <form>\n element to allow Server Function to be invoked with the HTML action prop.\n\nWhen invoked in a form, the function automatically receives the FormData\n object. You can extract the data using the native FormData methods\n:\n\napp/ui/form.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { createPost } from '@/app/actions'\n \nexport function Form() {\n  return (\n    <form action={createPost}>\n      <input type=\"text\" name=\"title\" />\n      <input type=\"text\" name=\"content\" />\n      <button type=\"submit\">Create</button>\n    </form>\n  )\n}\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nexport async function createPost(formData: FormData) {\n  const title = formData.get('title')\n  const content = formData.get('content')\n \n  // Update data\n  // Revalidate cache\n}\nEvent Handlers\n\nYou can invoke a Server Function in a Client Component by using event handlers such as onClick.\n\napp/like-button.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { incrementLike } from './actions'\nimport { useState } from 'react'\n \nexport default function LikeButton({ initialLikes }: { initialLikes: number }) {\n  const [likes, setLikes] = useState(initialLikes)\n \n  return (\n    <>\n      <p>Total Likes: {likes}</p>\n      <button\n        onClick={async () => {\n          const updatedLikes = await incrementLike()\n          setLikes(updatedLikes)\n        }}\n      >\n        Like\n      </button>\n    </>\n  )\n}\nExamples\nShowing a pending state\n\nWhile executing a Server Function, you can show a loading indicator with React's useActionState\n hook. This hook returns a pending boolean:\n\napp/ui/button.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useActionState, startTransition } from 'react'\nimport { createPost } from '@/app/actions'\nimport { LoadingSpinner } from '@/app/ui/loading-spinner'\n \nexport function Button() {\n  const [state, action, pending] = useActionState(createPost, false)\n \n  return (\n    <button onClick={() => startTransition(action)}>\n      {pending ? <LoadingSpinner /> : 'Create Post'}\n    </button>\n  )\n}\nRevalidating\n\nAfter performing an update, you can revalidate the Next.js cache and show the updated data by calling revalidatePath or revalidateTag within the Server Function:\n\napp/lib/actions.ts\nTypeScript\nJavaScript\nTypeScript\nimport { revalidatePath } from 'next/cache'\n \nexport async function createPost(formData: FormData) {\n  'use server'\n  // Update data\n  // ...\n \n  revalidatePath('/posts')\n}\nRedirecting\n\nYou may want to redirect the user to a different page after performing an update. You can do this by calling redirect within the Server Function.\n\napp/lib/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { revalidatePath } from 'next/cache'\nimport { redirect } from 'next/navigation'\n \nexport async function createPost(formData: FormData) {\n  // Update data\n  // ...\n \n  revalidatePath('/posts')\n  redirect('/posts')\n}\n\nCalling redirect throws a framework handled control-flow exception. Any code after it won't execute. If you need fresh data, call revalidatePath or revalidateTag beforehand.\n\nCookies\n\nYou can get, set, and delete cookies inside a Server Action using the cookies API.\n\nWhen you set or delete a cookie in a Server Action, Next.js re-renders the current page and its layouts on the server so the UI reflects the new cookie value.\n\nGood to know: The server update applies to the current React tree, re-rendering, mounting, or unmounting components, as needed. Client state is preserved for re-rendered components, and effects re-run if their dependencies changed.\n\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nimport { cookies } from 'next/headers'\n \nexport async function exampleAction() {\n  const cookieStore = await cookies()\n \n  // Get cookie\n  cookieStore.get('name')?.value\n \n  // Set cookie\n  cookieStore.set('name', 'Delba')\n \n  // Delete cookie\n  cookieStore.delete('name')\n}\nuseEffect\n\nYou can use the React useEffect\n hook to invoke a Server Action when the component mounts or a dependency changes. This is useful for mutations that depend on global events or need to be triggered automatically. For example, onKeyDown for app shortcuts, an intersection observer hook for infinite scrolling, or when the component mounts to update a view count:\n\napp/view-count.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { incrementViews } from './actions'\nimport { useState, useEffect, useTransition } from 'react'\n \nexport default function ViewCount({ initialViews }: { initialViews: number }) {\n  const [views, setViews] = useState(initialViews)\n  const [isPending, startTransition] = useTransition()\n \n  useEffect(() => {\n    startTransition(async () => {\n      const updatedViews = await incrementViews()\n      setViews(updatedViews)\n    })\n  }, [])\n \n  // You can use `isPending` to give users feedback\n  return <p>Total Views: {views}</p>\n}\nAPI Reference\nLearn more about the features mentioned in this page by reading the API Reference.\nrevalidatePath\nAPI Reference for the revalidatePath function.\nrevalidateTag\nAPI Reference for the revalidateTag function.\nredirect\nAPI Reference for the redirect function.\nPrevious\nFetching Data\nNext\nCaching and Revalidating\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Fetching Data | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/fetching-data",
    "html": "App Router\nGetting Started\nFetching Data\nCopy page\nFetching Data\n\nThis page will walk you through how you can fetch data in Server and Client Components, and how to stream components that depend on data.\n\nFetching data\nServer Components\n\nYou can fetch data in Server Components using:\n\nThe fetch API\nAn ORM or database\nWith the fetch API\n\nTo fetch data with the fetch API, turn your component into an asynchronous function, and await the fetch call. For example:\n\napp/blog/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Page() {\n  const data = await fetch('https://api.vercel.app/blog')\n  const posts = await data.json()\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\n\nGood to know:\n\nfetch responses are not cached by default. However, Next.js will pre-render the route and the output will be cached for improved performance. If you'd like to opt into dynamic rendering, use the { cache: 'no-store' } option. See the fetch API Reference.\nDuring development, you can log fetch calls for better visibility and debugging. See the logging API reference.\nWith an ORM or database\n\nSince Server Components are rendered on the server, you can safely make database queries using an ORM or database client. Turn your component into an asynchronous function, and await the call:\n\napp/blog/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { db, posts } from '@/lib/db'\n \nexport default async function Page() {\n  const allPosts = await db.select().from(posts)\n  return (\n    <ul>\n      {allPosts.map((post) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\nClient Components\n\nThere are two ways to fetch data in Client Components, using:\n\nReact's use hook\nA community library like SWR\n or React Query\nStreaming data with the use hook\n\nYou can use React's use hook\n to stream data from the server to client. Start by fetching data in your Server component, and pass the promise to your Client Component as prop:\n\napp/blog/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Posts from '@/app/ui/posts'\nimport { Suspense } from 'react'\n \nexport default function Page() {\n  // Don't await the data fetching function\n  const posts = getPosts()\n \n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Posts posts={posts} />\n    </Suspense>\n  )\n}\n\nThen, in your Client Component, use the use hook to read the promise:\n\napp/ui/posts.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\nimport { use } from 'react'\n \nexport default function Posts({\n  posts,\n}: {\n  posts: Promise<{ id: string; title: string }[]>\n}) {\n  const allPosts = use(posts)\n \n  return (\n    <ul>\n      {allPosts.map((post) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\n\nIn the example above, the <Posts> component is wrapped in a <Suspense> boundary\n. This means the fallback will be shown while the promise is being resolved. Learn more about streaming.\n\nCommunity libraries\n\nYou can use a community library like SWR\n or React Query\n to fetch data in Client Components. These libraries have their own semantics for caching, streaming, and other features. For example, with SWR:\n\napp/blog/page.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\nimport useSWR from 'swr'\n \nconst fetcher = (url) => fetch(url).then((r) => r.json())\n \nexport default function BlogPage() {\n  const { data, error, isLoading } = useSWR(\n    'https://api.vercel.app/blog',\n    fetcher\n  )\n \n  if (isLoading) return <div>Loading...</div>\n  if (error) return <div>Error: {error.message}</div>\n \n  return (\n    <ul>\n      {data.map((post: { id: string; title: string }) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\nDeduplicate requests and cache data\n\nOne way to deduplicate fetch requests is with request memoization. With this mechanism, fetch calls using GET or HEAD with the same URL and options in a single render pass are combined into one request. This happens automatically, and you can opt out by passing an Abort signal to fetch.\n\nRequest memoization is scoped to the lifetime of a request.\n\nYou can also deduplicate fetch requests by using Next.js’ Data Cache, for example by setting cache: 'force-cache' in your fetch options.\n\nData Cache allows sharing data across the current render pass and incoming requests.\n\nIf you are not using fetch, and instead using an ORM or database directly, you can wrap your data access with the React cache\n function.\n\napp/lib/data.ts\nTypeScript\nJavaScript\nTypeScript\nimport { cache } from 'react'\nimport { db, posts, eq } from '@/lib/db'\n \nexport const getPost = cache(async (id: string) => {\n  const post = await db.query.posts.findFirst({\n    where: eq(posts.id, parseInt(id)),\n  })\n})\nStreaming\n\nWarning: The content below assumes the cacheComponents config option is enabled in your application. The flag was introduced in Next.js 15 canary.\n\nWhen you fetch data in Server Components, the data is fetched and rendered on the server for each request. If you have any slow data requests, the whole route will be blocked from rendering until all the data is fetched.\n\nTo improve the initial load time and user experience, you can use streaming to break up the page's HTML into smaller chunks and progressively send those chunks from the server to the client.\n\nThere are two ways you can implement streaming in your application:\n\nWrapping a page with a loading.js file\nWrapping a component with <Suspense>\nWith loading.js\n\nYou can create a loading.js file in the same folder as your page to stream the entire page while the data is being fetched. For example, to stream app/blog/page.js, add the file inside the app/blog folder.\n\napp/blog/loading.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Loading() {\n  // Define the Loading UI here\n  return <div>Loading...</div>\n}\n\nOn navigation, the user will immediately see the layout and a loading state while the page is being rendered. The new content will then be automatically swapped in once rendering is complete.\n\nBehind-the-scenes, loading.js will be nested inside layout.js, and will automatically wrap the page.js file and any children below in a <Suspense> boundary.\n\nThis approach works well for route segments (layouts and pages), but for more granular streaming, you can use <Suspense>.\n\nWith <Suspense>\n\n<Suspense> allows you to be more granular about what parts of the page to stream. For example, you can immediately show any page content that falls outside of the <Suspense> boundary, and stream in the list of blog posts inside the boundary.\n\napp/blog/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Suspense } from 'react'\nimport BlogList from '@/components/BlogList'\nimport BlogListSkeleton from '@/components/BlogListSkeleton'\n \nexport default function BlogPage() {\n  return (\n    <div>\n      {/* This content will be sent to the client immediately */}\n      <header>\n        <h1>Welcome to the Blog</h1>\n        <p>Read the latest posts below.</p>\n      </header>\n      <main>\n        {/* Any content wrapped in a <Suspense> boundary will be streamed */}\n        <Suspense fallback={<BlogListSkeleton />}>\n          <BlogList />\n        </Suspense>\n      </main>\n    </div>\n  )\n}\nCreating meaningful loading states\n\nAn instant loading state is fallback UI that is shown immediately to the user after navigation. For the best user experience, we recommend designing loading states that are meaningful and help users understand the app is responding. For example, you can use skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc.\n\nIn development, you can preview and inspect the loading state of your components using the React Devtools\n.\n\nExamples\nSequential data fetching\n\nSequential data fetching happens when nested components in a tree each fetch their own data and the requests are not deduplicated, leading to longer response times.\n\nThere may be cases where you want this pattern because one fetch depends on the result of the other.\n\nFor example, the <Playlists> component will only start fetching data once the <Artist> component has finished fetching data because <Playlists> depends on the artistID prop:\n\napp/artist/[username]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ username: string }>\n}) {\n  const { username } = await params\n  // Get artist information\n  const artist = await getArtist(username)\n \n  return (\n    <>\n      <h1>{artist.name}</h1>\n      {/* Show fallback UI while the Playlists component is loading */}\n      <Suspense fallback={<div>Loading...</div>}>\n        {/* Pass the artist ID to the Playlists component */}\n        <Playlists artistID={artist.id} />\n      </Suspense>\n    </>\n  )\n}\n \nasync function Playlists({ artistID }: { artistID: string }) {\n  // Use the artist ID to fetch playlists\n  const playlists = await getArtistPlaylists(artistID)\n \n  return (\n    <ul>\n      {playlists.map((playlist) => (\n        <li key={playlist.id}>{playlist.name}</li>\n      ))}\n    </ul>\n  )\n}\n\nTo improve the user experience, you should use React <Suspense> to show a fallback while data is being fetch. This will enable streaming and prevent the whole route from being blocked by the sequential data requests.\n\nParallel data fetching\n\nParallel data fetching happens when data requests in a route are eagerly initiated and start at the same time.\n\nBy default, layouts and pages are rendered in parallel. So each segment starts fetching data as soon as possible.\n\nHowever, within any component, multiple async/await requests can still be sequential if placed after the other. For example, getAlbums will be blocked until getArtist is resolved:\n\napp/artist/[username]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { getArtist, getAlbums } from '@/app/lib/data'\n \nexport default async function Page({ params }) {\n  // These requests will be sequential\n  const { username } = await params\n  const artist = await getArtist(username)\n  const albums = await getAlbums(username)\n  return <div>{artist.name}</div>\n}\n\nStart multiple requests by calling fetch, then await them with Promise.all\n. Requests begin as soon as fetch is called.\n\napp/artist/[username]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Albums from './albums'\n \nasync function getArtist(username: string) {\n  const res = await fetch(`https://api.example.com/artist/${username}`)\n  return res.json()\n}\n \nasync function getAlbums(username: string) {\n  const res = await fetch(`https://api.example.com/artist/${username}/albums`)\n  return res.json()\n}\n \nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ username: string }>\n}) {\n  const { username } = await params\n \n  // Initiate requests\n  const artistData = getArtist(username)\n  const albumsData = getAlbums(username)\n \n  const [artist, albums] = await Promise.all([artistData, albumsData])\n \n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Albums list={albums} />\n    </>\n  )\n}\n\nGood to know: If one request fails when using Promise.all, the entire operation will fail. To handle this, you can use the Promise.allSettled\n method instead.\n\nPreloading data\n\nYou can preload data by creating an utility function that you eagerly call above blocking requests. <Item> conditionally renders based on the checkIsAvailable() function.\n\nYou can call preload() before checkIsAvailable() to eagerly initiate <Item/> data dependencies. By the time <Item/> is rendered, its data has already been fetched.\n\napp/item/[id]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { getItem, checkIsAvailable } from '@/lib/data'\n \nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n  // starting loading item data\n  preload(id)\n  // perform another asynchronous task\n  const isAvailable = await checkIsAvailable()\n \n  return isAvailable ? <Item id={id} /> : null\n}\n \nexport const preload = (id: string) => {\n  // void evaluates the given expression and returns undefined\n  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\n  void getItem(id)\n}\nexport async function Item({ id }: { id: string }) {\n  const result = await getItem(id)\n  // ...\n}\n\nAdditionally, you can use React's cache function\n and the server-only package\n to create a reusable utility function. This approach allows you to cache the data fetching function and ensure that it's only executed on the server.\n\nutils/get-item.ts\nTypeScript\nJavaScript\nTypeScript\nimport { cache } from 'react'\nimport 'server-only'\nimport { getItem } from '@/lib/data'\n \nexport const preload = (id: string) => {\n  void getItem(id)\n}\n \nexport const getItem = cache(async (id: string) => {\n  // ...\n})\nAPI Reference\nLearn more about the features mentioned in this page by reading the API Reference.\nData Security\nLearn the built-in data security features in Next.js and learn best practices for protecting your application's data.\nfetch\nAPI reference for the extended fetch function.\nloading.js\nAPI reference for the loading.js file.\nlogging\nConfigure how data fetches are logged to the console when running Next.js in development mode.\ntaint\nEnable tainting Objects and Values.\nPrevious\nCache Components\nNext\nUpdating Data\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Caching and Revalidating | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/caching-and-revalidating",
    "html": "App Router\nGetting Started\nCaching and Revalidating\nCopy page\nCaching and Revalidating\n\nCaching is a technique for storing the result of data fetching and other computations so that future requests for the same data can be served faster, without doing the work again. While revalidation allows you to update cache entries without having to rebuild your entire application.\n\nNext.js provides a few APIs to handle caching and revalidation. This guide will walk you through when and how to use them.\n\nfetch\nunstable_cache\nrevalidatePath\nrevalidateTag\nupdateTag\nfetch\n\nBy default, fetch requests are not cached. You can cache individual requests by setting the cache option to 'force-cache'.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Page() {\n  const data = await fetch('https://...', { cache: 'force-cache' })\n}\n\nGood to know: Although fetch requests are not cached by default, Next.js will pre-render routes that have fetch requests and cache the HTML. If you want to guarantee a route is dynamic, use the connection API.\n\nTo revalidate the data returned by a fetch request, you can use the next.revalidate option.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Page() {\n  const data = await fetch('https://...', { next: { revalidate: 3600 } })\n}\n\nThis will revalidate the data after a specified amount of seconds.\n\nSee the fetch API reference to learn more.\n\nunstable_cache\n\nunstable_cache allows you to cache the result of database queries and other async functions. To use it, wrap unstable_cache around the function. For example:\n\napp/lib/data.ts\nTypeScript\nJavaScript\nTypeScript\nimport { db } from '@/lib/db'\nexport async function getUserById(id: string) {\n  return db\n    .select()\n    .from(users)\n    .where(eq(users.id, id))\n    .then((res) => res[0])\n}\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { unstable_cache } from 'next/cache'\nimport { getUserById } from '@/app/lib/data'\n \nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ userId: string }>\n}) {\n  const { userId } = await params\n \n  const getCachedUser = unstable_cache(\n    async () => {\n      return getUserById(userId)\n    },\n    [userId] // add the user ID to the cache key\n  )\n}\n\nThe function accepts a third optional object to define how the cache should be revalidated. It accepts:\n\ntags: an array of tags used by Next.js to revalidate the cache.\nrevalidate: the number of seconds after cache should be revalidated.\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nconst getCachedUser = unstable_cache(\n  async () => {\n    return getUserById(userId)\n  },\n  [userId],\n  {\n    tags: ['user'],\n    revalidate: 3600,\n  }\n)\n\nSee the unstable_cache API reference to learn more.\n\nrevalidateTag\n\nrevalidateTag is used to revalidate cache entries based on a tag and following an event. The function now supports two behaviors:\n\nWith profile=\"max\": Uses stale-while-revalidate semantics, serving stale content while fetching fresh content in the background\nWithout the second argument: Legacy behavior that immediately expires the cache (deprecated)\n\nTo use it with fetch, start by tagging the function with the next.tags option:\n\napp/lib/data.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function getUserById(id: string) {\n  const data = await fetch(`https://...`, {\n    next: {\n      tags: ['user'],\n    },\n  })\n}\n\nAlternatively, you can mark an unstable_cache function with the tags option:\n\napp/lib/data.ts\nTypeScript\nJavaScript\nTypeScript\nexport const getUserById = unstable_cache(\n  async (id: string) => {\n    return db.query.users.findFirst({ where: eq(users.id, id) })\n  },\n  ['user'], // Needed if variables are not passed as parameters\n  {\n    tags: ['user'],\n  }\n)\n\nThen, call revalidateTag in a Route Handler or Server Action:\n\napp/lib/actions.ts\nTypeScript\nJavaScript\nTypeScript\nimport { revalidateTag } from 'next/cache'\n \nexport async function updateUser(id: string) {\n  // Mutate data\n  revalidateTag('user', 'max') // Recommended: Uses stale-while-revalidate\n}\n\nYou can reuse the same tag in multiple functions to revalidate them all at once.\n\nSee the revalidateTag API reference to learn more.\n\nrevalidatePath\n\nrevalidatePath is used to revalidate a route and following an event. To use it, call it in a Route Handler or Server Action:\n\napp/lib/actions.ts\nTypeScript\nJavaScript\nTypeScript\nimport { revalidatePath } from 'next/cache'\n \nexport async function updateUser(id: string) {\n  // Mutate data\n  revalidatePath('/profile')\n\nSee the revalidatePath API reference to learn more.\n\nupdateTag\n\nupdateTag is specifically designed for Server Actions to immediately expire cached data for read-your-own-writes scenarios. Unlike revalidateTag, it can only be used within Server Actions and immediately expires the cache entry.\n\napp/lib/actions.ts\nTypeScript\nJavaScript\nTypeScript\nimport { updateTag } from 'next/cache'\nimport { redirect } from 'next/navigation'\n \nexport async function createPost(formData: FormData) {\n  // Create post in database\n  const post = await db.post.create({\n    data: {\n      title: formData.get('title'),\n      content: formData.get('content'),\n    },\n  })\n \n  // Immediately expire cache so the new post is visible\n  updateTag('posts')\n  updateTag(`post-${post.id}`)\n \n  redirect(`/posts/${post.id}`)\n}\n\nThe key differences between revalidateTag and updateTag:\n\nupdateTag: Only in Server Actions, immediately expires cache, for read-your-own-writes\nrevalidateTag: In Server Actions and Route Handlers, supports stale-while-revalidate with profile=\"max\"\n\nSee the updateTag API reference to learn more.\n\nAPI Reference\nLearn more about the features mentioned in this page by reading the API Reference.\nfetch\nAPI reference for the extended fetch function.\nunstable_cache\nAPI Reference for the unstable_cache function.\nrevalidatePath\nAPI Reference for the revalidatePath function.\nrevalidateTag\nAPI Reference for the revalidateTag function.\nupdateTag\nAPI Reference for the updateTag function.\nPrevious\nUpdating Data\nNext\nError Handling\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Error Handling | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/error-handling",
    "html": "App Router\nGetting Started\nError Handling\nCopy page\nError Handling\n\nErrors can be divided into two categories: expected errors and uncaught exceptions. This page will walk you through how you can handle these errors in your Next.js application.\n\nHandling expected errors\n\nExpected errors are those that can occur during the normal operation of the application, such as those from server-side form validation or failed requests. These errors should be handled explicitly and returned to the client.\n\nServer Functions\n\nYou can use the useActionState\n hook to handle expected errors in Server Functions\n.\n\nFor these errors, avoid using try/catch blocks and throw errors. Instead, model expected errors as return values.\n\napp/actions.ts\nTypeScript\nJavaScript\nTypeScript\n'use server'\n \nexport async function createPost(prevState: any, formData: FormData) {\n  const title = formData.get('title')\n  const content = formData.get('content')\n \n  const res = await fetch('https://api.vercel.app/posts', {\n    method: 'POST',\n    body: { title, content },\n  })\n  const json = await res.json()\n \n  if (!res.ok) {\n    return { message: 'Failed to create post' }\n  }\n}\n\nYou can pass your action to the useActionState hook and use the returned state to display an error message.\n\napp/ui/form.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\n \nimport { useActionState } from 'react'\nimport { createPost } from '@/app/actions'\n \nconst initialState = {\n  message: '',\n}\n \nexport function Form() {\n  const [state, formAction, pending] = useActionState(createPost, initialState)\n \n  return (\n    <form action={formAction}>\n      <label htmlFor=\"title\">Title</label>\n      <input type=\"text\" id=\"title\" name=\"title\" required />\n      <label htmlFor=\"content\">Content</label>\n      <textarea id=\"content\" name=\"content\" required />\n      {state?.message && <p aria-live=\"polite\">{state.message}</p>}\n      <button disabled={pending}>Create Post</button>\n    </form>\n  )\n}\nServer Components\n\nWhen fetching data inside of a Server Component, you can use the response to conditionally render an error message or redirect.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default async function Page() {\n  const res = await fetch(`https://...`)\n  const data = await res.json()\n \n  if (!res.ok) {\n    return 'There was an error.'\n  }\n \n  return '...'\n}\nNot found\n\nYou can call the notFound function within a route segment and use the not-found.js file to show a 404 UI.\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { getPostBySlug } from '@/lib/posts'\n \nexport default async function Page({ params }: { params: { slug: string } }) {\n  const { slug } = await params\n  const post = getPostBySlug(slug)\n \n  if (!post) {\n    notFound()\n  }\n \n  return <div>{post.title}</div>\n}\napp/blog/[slug]/not-found.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function NotFound() {\n  return <div>404 - Page Not Found</div>\n}\nHandling uncaught exceptions\n\nUncaught exceptions are unexpected errors that indicate bugs or issues that should not occur during the normal flow of your application. These should be handled by throwing errors, which will then be caught by error boundaries.\n\nNested error boundaries\n\nNext.js uses error boundaries to handle uncaught exceptions. Error boundaries catch errors in their child components and display a fallback UI instead of the component tree that crashed.\n\nCreate an error boundary by adding an error.js file inside a route segment and exporting a React component:\n\napp/dashboard/error.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client' // Error boundaries must be Client Components\n \nimport { useEffect } from 'react'\n \nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string }\n  reset: () => void\n}) {\n  useEffect(() => {\n    // Log the error to an error reporting service\n    console.error(error)\n  }, [error])\n \n  return (\n    <div>\n      <h2>Something went wrong!</h2>\n      <button\n        onClick={\n          // Attempt to recover by trying to re-render the segment\n          () => reset()\n        }\n      >\n        Try again\n      </button>\n    </div>\n  )\n}\n\nErrors will bubble up to the nearest parent error boundary. This allows for granular error handling by placing error.tsx files at different levels in the route hierarchy.\n\nError boundaries don’t catch errors inside event handlers. They’re designed to catch errors during rendering\n to show a fallback UI instead of crashing the whole app.\n\nIn general, errors in event handlers or async code aren’t handled by error boundaries because they run after rendering.\n\nTo handle these cases, catch the error manually and store it using useState or useReducer, then update the UI to inform the user.\n\n'use client'\n \nimport { useState } from 'react'\n \nexport function Button() {\n  const [error, setError] = useState(null)\n \n  const handleClick = () => {\n    try {\n      // do some work that might fail\n      throw new Error('Exception')\n    } catch (reason) {\n      setError(reason)\n    }\n  }\n \n  if (error) {\n    /* render fallback UI */\n  }\n \n  return (\n    <button type=\"button\" onClick={handleClick}>\n      Click me\n    </button>\n  )\n}\n\nNote that unhandled errors inside startTransition from useTransition, will bubble up to the nearest error boundary.\n\n'use client'\n \nimport { useTransition } from 'react'\n \nexport function Button() {\n  const [pending, startTransition] = useTransition()\n \n  const handleClick = () =>\n    startTransition(() => {\n      throw new Error('Exception')\n    })\n \n  return (\n    <button type=\"button\" onClick={handleClick}>\n      Click me\n    </button>\n  )\n}\nGlobal errors\n\nWhile less common, you can handle errors in the root layout using the global-error.js file, located in the root app directory, even when leveraging internationalization. Global error UI must define its own <html> and <body> tags, since it is replacing the root layout or template when active.\n\napp/global-error.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client' // Error boundaries must be Client Components\n \nexport default function GlobalError({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string }\n  reset: () => void\n}) {\n  return (\n    // global-error must include html and body tags\n    <html>\n      <body>\n        <h2>Something went wrong!</h2>\n        <button onClick={() => reset()}>Try again</button>\n      </body>\n    </html>\n  )\n}\nAPI Reference\nLearn more about the features mentioned in this page by reading the API Reference.\nredirect\nAPI Reference for the redirect function.\nerror.js\nAPI reference for the error.js special file.\nnotFound\nAPI Reference for the notFound function.\nnot-found.js\nAPI reference for the not-found.js file.\nPrevious\nCaching and Revalidating\nNext\nCSS\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Image Optimization | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/images",
    "html": "App Router\nGetting Started\nImage Optimization\nCopy page\nImage Optimization\n\nThe Next.js <Image> component extends the HTML <img> element to provide:\n\nSize optimization: Automatically serving correctly sized images for each device, using modern image formats like WebP.\nVisual stability: Preventing layout shift\n automatically when images are loading.\nFaster page loads: Only loading images when they enter the viewport using native browser lazy loading, with optional blur-up placeholders.\nAsset flexibility: Resizing images on-demand, even images stored on remote servers.\n\nTo start using <Image>, import it from next/image and render it within your component.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Image from 'next/image'\n \nexport default function Page() {\n  return <Image src=\"\" alt=\"\" />\n}\n\nThe src property can be a local or remote image.\n\n🎥 Watch: Learn more about how to use next/image → YouTube (9 minutes)\n.\n\nLocal images\n\nYou can store static files, like images and fonts, under a folder called public in the root directory. Files inside public can then be referenced by your code starting from the base URL (/).\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Image from 'next/image'\n \nexport default function Page() {\n  return (\n    <Image\n      src=\"/profile.png\"\n      alt=\"Picture of the author\"\n      width={500}\n      height={500}\n    />\n  )\n}\n\nIf the image is statically imported, Next.js will automatically determine the intrinsic width and height. These values are used to determine the image ratio and prevent Cumulative Layout Shift\n while your image is loading.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Image from 'next/image'\nimport ProfileImage from './profile.png'\n \nexport default function Page() {\n  return (\n    <Image\n      src={ProfileImage}\n      alt=\"Picture of the author\"\n      // width={500} automatically provided\n      // height={500} automatically provided\n      // blurDataURL=\"data:...\" automatically provided\n      // placeholder=\"blur\" // Optional blur-up while loading\n    />\n  )\n}\nRemote images\n\nTo use a remote image, you can provide a URL string for the src property.\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport Image from 'next/image'\n \nexport default function Page() {\n  return (\n    <Image\n      src=\"https://s3.amazonaws.com/my-bucket/profile.png\"\n      alt=\"Picture of the author\"\n      width={500}\n      height={500}\n    />\n  )\n}\n\nSince Next.js does not have access to remote files during the build process, you'll need to provide the width, height and optional blurDataURL props manually. The width and height are used to infer the correct aspect ratio of image and avoid layout shift from the image loading in. Alternatively, you can use the fill property to make the image fill the size of the parent element.\n\nTo safely allow images from remote servers, you need to define a list of supported URL patterns in next.config.js. Be as specific as possible to prevent malicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket:\n\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextConfig } from 'next'\n \nconst config: NextConfig = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 's3.amazonaws.com',\n        port: '',\n        pathname: '/my-bucket/**',\n        search: '',\n      },\n    ],\n  },\n}\n \nexport default config\nAPI Reference\nSee the API Reference for the full feature set of Next.js Image.\nImage Component\nOptimize Images in your Next.js Application using the built-in `next/image` Component.\nPrevious\nCSS\nNext\nFont Optimization\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: CSS | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/css",
    "html": "App Router\nGetting Started\nCSS\nCopy page\nCSS\n\nNext.js provides several ways to style your application using CSS, including:\n\nTailwind CSS\nCSS Modules\nGlobal CSS\nExternal Stylesheets\nSass\nCSS-in-JS\nTailwind CSS\n\nTailwind CSS\n is a utility-first CSS framework that provides low-level utility classes to build custom designs.\n\nInstall Tailwind CSS:\n\npnpm\nnpm\nyarn\nbun\nTerminal\npnpm add -D tailwindcss @tailwindcss/postcss\n\nAdd the PostCSS plugin to your postcss.config.mjs file:\n\npostcss.config.mjs\nexport default {\n  plugins: {\n    '@tailwindcss/postcss': {},\n  },\n}\n\nImport Tailwind in your global CSS file:\n\napp/globals.css\n@import 'tailwindcss';\n\nImport the CSS file in your root layout:\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport './globals.css'\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  )\n}\n\nNow you can start using Tailwind's utility classes in your application:\n\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport default function Page() {\n  return (\n    <main className=\"flex min-h-screen flex-col items-center justify-between p-24\">\n      <h1 className=\"text-4xl font-bold\">Welcome to Next.js!</h1>\n    </main>\n  )\n}\n\nGood to know: If you need broader browser support for very old browsers, see the Tailwind CSS v3 setup instructions.\n\nCSS Modules\n\nCSS Modules locally scope CSS by generating unique class names. This allows you to use the same class in different files without worrying about naming collisions.\n\nTo start using CSS Modules, create a new file with the extension .module.css and import it into any component inside the app directory:\n\napp/blog/blog.module.css\n.blog {\n  padding: 24px;\n}\napp/blog/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport styles from './blog.module.css'\n \nexport default function Page() {\n  return <main className={styles.blog}></main>\n}\nGlobal CSS\n\nYou can use global CSS to apply styles across your application.\n\nCreate a app/global.css file and import it in the root layout to apply the styles to every route in your application:\n\napp/global.css\nbody {\n  padding: 20px 20px 60px;\n  max-width: 680px;\n  margin: 0 auto;\n}\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\n// These styles apply to every route in the application\nimport './global.css'\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  )\n}\n\nGood to know: Global styles can be imported into any layout, page, or component inside the app directory. However, since Next.js uses React's built-in support for stylesheets to integrate with Suspense, this currently does not remove stylesheets as you navigate between routes which can lead to conflicts. We recommend using global styles for truly global CSS (like Tailwind's base styles), Tailwind CSS for component styling, and CSS Modules for custom scoped CSS when needed.\n\nExternal stylesheets\n\nStylesheets published by external packages can be imported anywhere in the app directory, including colocated components:\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport 'bootstrap/dist/css/bootstrap.css'\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body className=\"container\">{children}</body>\n    </html>\n  )\n}\n\nGood to know: In React 19, <link rel=\"stylesheet\" href=\"...\" /> can also be used. See the React link documentation\n for more information.\n\nOrdering and Merging\n\nNext.js optimizes CSS during production builds by automatically chunking (merging) stylesheets. The order of your CSS depends on the order you import styles in your code.\n\nFor example, base-button.module.css will be ordered before page.module.css since <BaseButton> is imported before page.module.css:\n\npage.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { BaseButton } from './base-button'\nimport styles from './page.module.css'\n \nexport default function Page() {\n  return <BaseButton className={styles.primary} />\n}\nbase-button.tsx\nTypeScript\nJavaScript\nTypeScript\nimport styles from './base-button.module.css'\n \nexport function BaseButton() {\n  return <button className={styles.primary} />\n}\nRecommendations\n\nTo keep CSS ordering predictable:\n\nTry to contain CSS imports to a single JavaScript or TypeScript entry file\nImport global styles and Tailwind stylesheets in the root of your application.\nUse Tailwind CSS for most styling needs as it covers common design patterns with utility classes.\nUse CSS Modules for component-specific styles when Tailwind utilities aren't sufficient.\nUse a consistent naming convention for your CSS modules. For example, using <name>.module.css over <name>.tsx.\nExtract shared styles into shared components to avoid duplicate imports.\nTurn off linters or formatters that auto-sort imports like ESLint’s sort-imports\n.\nYou can use the cssChunking option in next.config.js to control how CSS is chunked.\nDevelopment vs Production\nIn development (next dev), CSS updates apply instantly with Fast Refresh.\nIn production (next build), all CSS files are automatically concatenated into many minified and code-split .css files, ensuring the minimal amount of CSS is loaded for a route.\nCSS still loads with JavaScript disabled in production, but JavaScript is required in development for Fast Refresh.\nCSS ordering can behave differently in development, always ensure to check the build (next build) to verify the final CSS order.\nNext Steps\nLearn more about the alternatives ways you can use CSS in your application.\nTailwind CSS v3\nStyle your Next.js Application using Tailwind CSS v3 for broader browser support.\nSass\nStyle your Next.js application using Sass.\nCSS-in-JS\nUse CSS-in-JS libraries with Next.js\nPrevious\nError Handling\nNext\nImage Optimization\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Font Optimization | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/fonts",
    "html": "App Router\nGetting Started\nFont Optimization\nCopy page\nFont Optimization\n\nThe next/font module automatically optimizes your fonts and removes external network requests for improved privacy and performance.\n\nIt includes built-in self-hosting for any font file. This means you can optimally load web fonts with no layout shift.\n\nTo start using next/font, import it from next/font/local or next/font/google, call it as a function with the appropriate options, and set the className of the element you want to apply the font to. For example:\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Geist } from 'next/font/google'\n \nconst geist = Geist({\n  subsets: ['latin'],\n})\n \nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\" className={geist.className}>\n      <body>{children}</body>\n    </html>\n  )\n}\n\nFonts are scoped to the component they're used in. To apply a font to your entire application, add it to the Root Layout.\n\nGoogle fonts\n\nYou can automatically self-host any Google Font. Fonts are included stored as static assets and served from the same domain as your deployment, meaning no requests are sent to Google by the browser when the user visits your site.\n\nTo start using a Google Font, import your chosen font from next/font/google:\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Geist } from 'next/font/google'\n \nconst geist = Geist({\n  subsets: ['latin'],\n})\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\" className={geist.className}>\n      <body>{children}</body>\n    </html>\n  )\n}\n\nWe recommend using variable fonts\n for the best performance and flexibility. But if you can't use a variable font, you will need to specify a weight:\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { Roboto } from 'next/font/google'\n \nconst roboto = Roboto({\n  weight: '400',\n  subsets: ['latin'],\n})\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\" className={roboto.className}>\n      <body>{children}</body>\n    </html>\n  )\n}\nLocal fonts\n\nTo use a local font, import your font from next/font/local and specify the src of your local font file. Fonts can be stored in the public folder or co-located inside the app folder. For example:\n\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport localFont from 'next/font/local'\n \nconst myFont = localFont({\n  src: './my-font.woff2',\n})\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\" className={myFont.className}>\n      <body>{children}</body>\n    </html>\n  )\n}\n\nIf you want to use multiple files for a single font family, src can be an array:\n\nconst roboto = localFont({\n  src: [\n    {\n      path: './Roboto-Regular.woff2',\n      weight: '400',\n      style: 'normal',\n    },\n    {\n      path: './Roboto-Italic.woff2',\n      weight: '400',\n      style: 'italic',\n    },\n    {\n      path: './Roboto-Bold.woff2',\n      weight: '700',\n      style: 'normal',\n    },\n    {\n      path: './Roboto-BoldItalic.woff2',\n      weight: '700',\n      style: 'italic',\n    },\n  ],\n})\nAPI Reference\nSee the API Reference for the full feature set of Next.js Font\nFont\nOptimizing loading web fonts with the built-in `next/font` loaders.\nPrevious\nImage Optimization\nNext\nMetadata and OG images\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Metadata and OG images | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/metadata-and-og-images",
    "html": "App Router\nGetting Started\nMetadata and OG images\nCopy page\nMetadata and OG images\n\nThe Metadata APIs can be used to define your application metadata for improved SEO and web shareability and include:\n\nThe static metadata object\nThe dynamic generateMetadata function\nSpecial file conventions that can be used to add static or dynamically generated favicons and OG images.\n\nWith all the options above, Next.js will automatically generate the relevant <head> tags for your page, which can be inspected in the browser's developer tools.\n\nThe metadata object and generateMetadata function exports are only supported in Server Components.\n\nDefault fields\n\nThere are two default meta tags that are always added even if a route doesn't define metadata:\n\nThe meta charset tag\n sets the character encoding for the website.\nThe meta viewport tag\n sets the viewport width and scale for the website to adjust for different devices.\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\nThe other metadata fields can be defined with the Metadata object (for static metadata) or the generateMetadata function (for generated metadata).\n\nStatic metadata\n\nTo define static metadata, export a Metadata object from a static layout.js or page.js file. For example, to add a title and description to the blog route:\n\napp/blog/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  title: 'My Blog',\n  description: '...',\n}\n \nexport default function Layout() {}\n\nYou can view a full list of available options, in the generateMetadata documentation.\n\nGenerated metadata\n\nYou can use generateMetadata function to fetch metadata that depends on data. For example, to fetch the title and description for a specific blog post:\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata, ResolvingMetadata } from 'next'\n \ntype Props = {\n  params: Promise<{ slug: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}\n \nexport async function generateMetadata(\n  { params, searchParams }: Props,\n  parent: ResolvingMetadata\n): Promise<Metadata> {\n  const slug = (await params).slug\n \n  // fetch post information\n  const post = await fetch(`https://api.vercel.app/blog/${slug}`).then((res) =>\n    res.json()\n  )\n \n  return {\n    title: post.title,\n    description: post.description,\n  }\n}\n \nexport default function Page({ params, searchParams }: Props) {}\nStreaming metadata\n\nFor dynamically rendered pages, Next.js streams metadata separately, injecting it into the HTML once generateMetadata resolves, without blocking UI rendering.\n\nStreaming metadata improves perceived performance by allowing visual content to stream first.\n\nStreaming metadata is disabled for bots and crawlers that expect metadata to be in the <head> tag (e.g. Twitterbot, Slackbot, Bingbot). These are detected by using the User Agent header from the incoming request.\n\nYou can customize or disable streaming metadata completely, with the htmlLimitedBots option in your Next.js config file.\n\nStatically rendered pages don’t use streaming since metadata is resolved at build time.\n\nLearn more about streaming metadata.\n\nMemoizing data requests\n\nThere may be cases where you need to fetch the same data for metadata and the page itself. To avoid duplicate requests, you can use React's cache function\n to memoize the return value and only fetch the data once. For example, to fetch the blog post information for both the metadata and the page:\n\napp/lib/data.ts\nTypeScript\nJavaScript\nTypeScript\nimport { cache } from 'react'\nimport { db } from '@/app/lib/db'\n \n// getPost will be used twice, but execute only once\nexport const getPost = cache(async (slug: string) => {\n  const res = await db.query.posts.findFirst({ where: eq(posts.slug, slug) })\n  return res\n})\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { getPost } from '@/app/lib/data'\n \nexport async function generateMetadata({\n  params,\n}: {\n  params: { slug: string }\n}) {\n  const post = await getPost(params.slug)\n  return {\n    title: post.title,\n    description: post.description,\n  }\n}\n \nexport default async function Page({ params }: { params: { slug: string } }) {\n  const post = await getPost(params.slug)\n  return <div>{post.title}</div>\n}\nFile-based metadata\n\nThe following special files are available for metadata:\n\nfavicon.ico, apple-icon.jpg, and icon.jpg\nopengraph-image.jpg and twitter-image.jpg\nrobots.txt\nsitemap.xml\n\nYou can use these for static metadata, or you can programmatically generate these files with code.\n\nFavicons\n\nFavicons are small icons that represent your site in bookmarks and search results. To add a favicon to your application, create a favicon.ico and add to the root of the app folder.\n\nYou can also programmatically generate favicons using code. See the favicon docs for more information.\n\nStatic Open Graph images\n\nOpen Graph (OG) images are images that represent your site in social media. To add a static OG image to your application, create a opengraph-image.png file in the root of the app folder.\n\nYou can also add OG images for specific routes by creating a opengraph-image.png deeper down the folder structure. For example, to create an OG image specific to the /blog route, add a opengraph-image.jpg file inside the blog folder.\n\nThe more specific image will take precedence over any OG images above it in the folder structure.\n\nOther image formats such as jpeg, png, and gif are also supported. See the Open Graph Image docs for more information.\n\nGenerated Open Graph images\n\nThe ImageResponse constructor allows you to generate dynamic images using JSX and CSS. This is useful for OG images that depend on data.\n\nFor example, to generate a unique OG image for each blog post, add a opengraph-image.tsx file inside the blog folder, and import the ImageResponse constructor from next/og:\n\napp/blog/[slug]/opengraph-image.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { ImageResponse } from 'next/og'\nimport { getPost } from '@/app/lib/data'\n \n// Image metadata\nexport const size = {\n  width: 1200,\n  height: 630,\n}\n \nexport const contentType = 'image/png'\n \n// Image generation\nexport default async function Image({ params }: { params: { slug: string } }) {\n  const post = await getPost(params.slug)\n \n  return new ImageResponse(\n    (\n      // ImageResponse JSX element\n      <div\n        style={{\n          fontSize: 128,\n          background: 'white',\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n        }}\n      >\n        {post.title}\n      </div>\n    )\n  )\n}\n\nImageResponse supports common CSS properties including flexbox and absolute positioning, custom fonts, text wrapping, centering, and nested images. See the full list of supported CSS properties.\n\nGood to know:\n\nExamples are available in the Vercel OG Playground\n.\nImageResponse uses @vercel/og\n, satori\n, and resvg to convert HTML and CSS into PNG.\nOnly flexbox and a subset of CSS properties are supported. Advanced layouts (e.g. display: grid) will not work.\nAPI Reference\nLearn more about the Metadata APIs mentioned in this page.\ngenerateMetadata\nLearn how to add Metadata to your Next.js application for improved search engine optimization (SEO) and web shareability.\ngenerateViewport\nAPI Reference for the generateViewport function.\nImageResponse\nAPI Reference for the ImageResponse constructor.\nMetadata Files\nAPI documentation for the metadata file conventions.\nfavicon, icon, and apple-icon\nAPI Reference for the Favicon, Icon and Apple Icon file conventions.\nopengraph-image and twitter-image\nAPI Reference for the Open Graph Image and Twitter Image file conventions.\nrobots.txt\nAPI Reference for robots.txt file.\nsitemap.xml\nAPI Reference for the sitemap.xml file.\nhtmlLimitedBots\nSpecify a list of user agents that should receive blocking metadata.\nPrevious\nFont Optimization\nNext\nRoute Handlers\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Proxy | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/proxy",
    "html": "App Router\nGetting Started\nProxy\nCopy page\nProxy\nProxy\n\nProxy allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.\n\nUse cases\n\nSome common scenarios where Proxy is effective include:\n\nQuick redirects after reading parts of the incoming request\nRewriting to different pages based on A/B tests or experiments\nModifying headers for all pages or a subset of pages\n\nProxy is not a good fit for:\n\nSlow data fetching\nSession management\n\nUsing fetch with options.cache, options.next.revalidate, or options.next.tags, has no effect in Proxy.\n\nConvention\n\nCreate a proxy.ts (or .js) file in the project root, or inside src if applicable, so that it is located at the same level as pages or app.\n\nNote: While only one proxy.ts file is supported per project, you can still organize your proxy logic into modules. Break out proxy functionalities into separate .ts or .js files and import them into your main proxy.ts file. This allows for cleaner management of route-specific proxy, aggregated in the proxy.ts for centralized control. By enforcing a single proxy file, it simplifies configuration, prevents potential conflicts, and optimizes performance by avoiding multiple proxy layers.\n\nExample\nproxy.ts\nTypeScript\nJavaScript\nTypeScript\nimport { NextResponse } from 'next/server'\nimport type { NextRequest } from 'next/server'\n \n// This function can be marked `async` if using `await` inside\nexport function proxy(request: NextRequest) {\n  return NextResponse.redirect(new URL('/home', request.url))\n}\n \n// See \"Matching Paths\" below to learn more\nexport const config = {\n  matcher: '/about/:path*',\n}\n\nRead more about using proxy, or refer to the proxy API reference.\n\nAPI Reference\nLearn more about Proxy\nproxy.js\nAPI reference for the proxy.js file.\nBackend for Frontend\nLearn how to use Next.js as a backend framework\nPrevious\nRoute Handlers\nNext\nDeploying\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Route Handlers | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/route-handlers",
    "html": "App Router\nGetting Started\nRoute Handlers\nCopy page\nRoute Handlers\nRoute Handlers\n\nRoute Handlers allow you to create custom request handlers for a given route using the Web Request\n and Response\n APIs.\n\nGood to know: Route Handlers are only available inside the app directory. They are the equivalent of API Routes inside the pages directory meaning you do not need to use API Routes and Route Handlers together.\n\nConvention\n\nRoute Handlers are defined in a route.js|ts file inside the app directory:\n\napp/api/route.ts\nTypeScript\nJavaScript\nTypeScript\nexport async function GET(request: Request) {}\n\nRoute Handlers can be nested anywhere inside the app directory, similar to page.js and layout.js. But there cannot be a route.js file at the same route segment level as page.js.\n\nSupported HTTP Methods\n\nThe following HTTP methods\n are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. If an unsupported method is called, Next.js will return a 405 Method Not Allowed response.\n\nExtended NextRequest and NextResponse APIs\n\nIn addition to supporting the native Request\n and Response\n APIs, Next.js extends them with NextRequest and NextResponse to provide convenient helpers for advanced use cases.\n\nCaching\n\nRoute Handlers are not cached by default. You can, however, opt into caching for GET methods. Other supported HTTP methods are not cached. To cache a GET method, use a route config option such as export const dynamic = 'force-static' in your Route Handler file.\n\napp/items/route.ts\nTypeScript\nJavaScript\nTypeScript\nexport const dynamic = 'force-static'\n \nexport async function GET() {\n  const res = await fetch('https://data.mongodb-api.com/...', {\n    headers: {\n      'Content-Type': 'application/json',\n      'API-Key': process.env.DATA_API_KEY,\n    },\n  })\n  const data = await res.json()\n \n  return Response.json({ data })\n}\n\nGood to know: Other supported HTTP methods are not cached, even if they are placed alongside a GET method that is cached, in the same file.\n\nSpecial Route Handlers\n\nSpecial Route Handlers like sitemap.ts, opengraph-image.tsx, and icon.tsx, and other metadata files remain static by default unless they use Dynamic APIs or dynamic config options.\n\nRoute Resolution\n\nYou can consider a route the lowest level routing primitive.\n\nThey do not participate in layouts or client-side navigations like page.\nThere cannot be a route.js file at the same route as page.js.\nPage\tRoute\tResult\napp/page.js\tapp/route.js\t\n Conflict\napp/page.js\tapp/api/route.js\t\n Valid\napp/[user]/page.js\tapp/api/route.js\t\n Valid\n\nEach route.js or page.js file takes over all HTTP verbs for that route.\n\napp/page.ts\nTypeScript\nJavaScript\nTypeScript\nexport default function Page() {\n  return <h1>Hello, Next.js!</h1>\n}\n \n// Conflict\n// `app/route.ts`\nexport async function POST(request: Request) {}\n\nRead more about how Route Handlers complement your frontend application, or explore the Route Handlers API Reference.\n\nRoute Context Helper\n\nIn TypeScript, you can type the context parameter for Route Handlers with the globally available RouteContext helper:\n\napp/users/[id]/route.ts\nTypeScript\nJavaScript\nTypeScript\nimport type { NextRequest } from 'next/server'\n \nexport async function GET(_req: NextRequest, ctx: RouteContext<'/users/[id]'>) {\n  const { id } = await ctx.params\n  return Response.json({ id })\n}\n\nGood to know\n\nTypes are generated during next dev, next build or next typegen.\nAPI Reference\nLearn more about Route Handlers\nroute.js\nAPI reference for the route.js special file.\nBackend for Frontend\nLearn how to use Next.js as a backend framework\nPrevious\nMetadata and OG images\nNext\nProxy\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Deploying | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/deploying",
    "html": "App Router\nGetting Started\nDeploying\nCopy page\nDeploying\n\nNext.js can be deployed as a Node.js server, Docker container, static export, or adapted to run on different platforms.\n\nDeployment Option\tFeature Support\nNode.js server\tAll\nDocker container\tAll\nStatic export\tLimited\nAdapters\tPlatform-specific\nNode.js server\n\nNext.js can be deployed to any provider that supports Node.js. Ensure your package.json has the \"build\" and \"start\" scripts:\n\npackage.json\n{\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\"\n  }\n}\n\nThen, run npm run build to build your application and npm run start to start the Node.js server. This server supports all Next.js features. If needed, you can also eject to a custom server.\n\nNode.js deployments support all Next.js features. Learn how to configure them for your infrastructure.\n\nTemplates\nFlightcontrol\nRailway\nReplit\nDocker\n\nNext.js can be deployed to any provider that supports Docker\n containers. This includes container orchestrators like Kubernetes or a cloud provider that runs Docker.\n\nDocker deployments support all Next.js features. Learn how to configure them for your infrastructure.\n\nNote for development: While Docker is excellent for production deployments, consider using local development (npm run dev) instead of Docker during development on Mac and Windows for better performance. Learn more about optimizing local development.\n\nTemplates\nDocker\nDocker Multi-Environment\nDigitalOcean\nFly.io\nGoogle Cloud Run\nRender\nSST\nStatic export\n\nNext.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server.\n\nSince Next.js supports static exports, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets. This includes tools like AWS S3, Nginx, or Apache.\n\nRunning as a static export does not support Next.js features that require a server. Learn more.\n\nTemplates\nGitHub Pages\nAdapters\n\nNext.js can be adapted to run on different platforms to support their infrastructure capabilities.\n\nRefer to each provider's documentation for information on supported Next.js features:\n\nAWS Amplify Hosting\nCloudflare\nDeno Deploy\nNetlify\nVercel\n\nNote: We are working on a Deployment Adapters API\n for all platforms to adopt. After completion, we will add documentation on how to write your own adapters.\n\nPrevious\nProxy\nNext\nUpgrading\n\nWas this helpful?\n\nsupported.\nSend"
  },
  {
    "title": "Getting Started: Upgrading | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/upgrading",
    "html": "App Router\nGetting Started\nUpgrading\nCopy page\nUpgrading\nLatest version\n\nTo update to the latest version of Next.js, you can use the upgrade codemod:\n\nTerminal\nnpx @next/codemod@latest upgrade latest\n\nIf you prefer to upgrade manually, install the latest Next.js and React versions:\n\npnpm\nnpm\nyarn\nbun\nTerminal\npnpm i next@latest react@latest react-dom@latest eslint-config-next@latest\nCanary version\n\nTo update to the latest canary, make sure you're on the latest version of Next.js and everything is working as expected. Then, run the following command:\n\nTerminal\nnpm i next@canary\nFeatures available in canary\n\nThe following features are currently available in canary:\n\nCaching:\n\n\"use cache\"\ncacheLife\ncacheTag\ncacheComponents\n\nAuthentication:\n\nforbidden\nunauthorized\nforbidden.js\nunauthorized.js\nauthInterrupts\nVersion guides\nSee the version guides for in-depth upgrade instructions.\nVersion 16\nUpgrade your Next.js Application from Version 15 to 16.\nVersion 15\nUpgrade your Next.js Application from Version 14 to 15.\nVersion 14\nUpgrade your Next.js Application from Version 13 to 14.\nPrevious\nDeploying\nNext\nGuides\n\nWas this helpful?\n\nsupported.\nSend"
  }
]
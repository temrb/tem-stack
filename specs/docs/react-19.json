[
  {
    "title": "React Reference Overview ‚Äì React",
    "url": "https://react.dev/reference/react",
    "html": "API REFERENCE\nReact Reference Overview\n\nThis section provides detailed reference documentation for working with React. For an introduction to React, please visit the Learn section.\n\nThe React reference documentation is broken down into functional subsections:\n\nReact \n\nProgrammatic React features:\n\nHooks - Use different React features from your components.\nComponents - Built-in components that you can use in your JSX.\nAPIs - APIs that are useful for defining components.\nDirectives - Provide instructions to bundlers compatible with React Server Components.\nReact DOM \n\nReact-dom contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following:\n\nHooks - Hooks for web applications which run in the browser DOM environment.\nComponents - React supports all of the browser built-in HTML and SVG components.\nAPIs - The react-dom package contains methods supported only in web applications.\nClient APIs - The react-dom/client APIs let you render React components on the client (in the browser).\nServer APIs - The react-dom/server APIs let you render React components to HTML on the server.\nReact Compiler \n\nThe React Compiler is a build-time optimization tool that automatically memoizes your React components and values:\n\nConfiguration - Configuration options for React Compiler.\nDirectives - Function-level directives to control compilation.\nCompiling Libraries - Guide for shipping pre-compiled library code.\nESLint Plugin React Hooks \n\nThe ESLint plugin for React Hooks helps enforce the Rules of React:\n\nLints - Detailed documentation for each lint with examples.\nRules of React \n\nReact has idioms ‚Äî or rules ‚Äî for how to express patterns in a way that is easy to understand and yields high-quality applications:\n\nComponents and Hooks must be pure ‚Äì Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly.\nReact calls Components and Hooks ‚Äì React is responsible for rendering components and hooks when necessary to optimize the user experience.\nRules of Hooks ‚Äì Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.\nLegacy APIs \nLegacy APIs - Exported from the react package, but not recommended for use in newly written code.\nNEXT\nHooks"
  },
  {
    "title": "Built-in React Hooks ‚Äì React",
    "url": "https://react.dev/reference/react/hooks",
    "html": "API REFERENCE\nBuilt-in React Hooks\n\nHooks let you use different React features from your components. You can either use the built-in Hooks or combine them to build your own. This page lists all built-in Hooks in React.\n\nState Hooks \n\nState lets a component ‚Äúremember‚Äù information like user input. For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index.\n\nTo add state to a component, use one of these Hooks:\n\nuseState declares a state variable that you can update directly.\nuseReducer declares a state variable with the update logic inside a reducer function.\nfunction ImageGallery() {\n\n  const [index, setIndex] = useState(0);\n\n  // ...\nContext Hooks \n\nContext lets a component receive information from distant parents without passing it as props. For example, your app‚Äôs top-level component can pass the current UI theme to all components below, no matter how deep.\n\nuseContext reads and subscribes to a context.\nfunction Button() {\n\n  const theme = useContext(ThemeContext);\n\n  // ...\nRef Hooks \n\nRefs let a component hold some information that isn‚Äôt used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an ‚Äúescape hatch‚Äù from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs.\n\nuseRef declares a ref. You can hold any value in it, but most often it‚Äôs used to hold a DOM node.\nuseImperativeHandle lets you customize the ref exposed by your component. This is rarely used.\nfunction Form() {\n\n  const inputRef = useRef(null);\n\n  // ...\nEffect Hooks \n\nEffects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.\n\nuseEffect connects a component to an external system.\nfunction ChatRoom({ roomId }) {\n\n  useEffect(() => {\n\n    const connection = createConnection(roomId);\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [roomId]);\n\n  // ...\n\nEffects are an ‚Äúescape hatch‚Äù from the React paradigm. Don‚Äôt use Effects to orchestrate the data flow of your application. If you‚Äôre not interacting with an external system, you might not need an Effect.\n\nThere are two rarely used variations of useEffect with differences in timing:\n\nuseLayoutEffect fires before the browser repaints the screen. You can measure layout here.\nuseInsertionEffect fires before React makes changes to the DOM. Libraries can insert dynamic CSS here.\nPerformance Hooks \n\nA common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.\n\nTo skip calculations and unnecessary re-rendering, use one of these Hooks:\n\nuseMemo lets you cache the result of an expensive calculation.\nuseCallback lets you cache a function definition before passing it down to an optimized component.\nfunction TodoList({ todos, tab, theme }) {\n\n  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n\n  // ...\n\n}\n\nSometimes, you can‚Äôt skip re-rendering because the screen actually needs to update. In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which don‚Äôt need to block the user interface (like updating a chart).\n\nTo prioritize rendering, use one of these Hooks:\n\nuseTransition lets you mark a state transition as non-blocking and allow other updates to interrupt it.\nuseDeferredValue lets you defer updating a non-critical part of the UI and let other parts update first.\nOther Hooks \n\nThese Hooks are mostly useful to library authors and aren‚Äôt commonly used in the application code.\n\nuseDebugValue lets you customize the label React DevTools displays for your custom Hook.\nuseId lets a component associate a unique ID with itself. Typically used with accessibility APIs.\nuseSyncExternalStore lets a component subscribe to an external store.\nuseActionState allows you to manage state of actions.\nYour own Hooks \n\nYou can also define your own custom Hooks as JavaScript functions.\n\nPREVIOUS\nOverview\nNEXT\nuseActionState"
  },
  {
    "title": "useActionState ‚Äì React",
    "url": "https://react.dev/reference/react/useActionState",
    "html": "API REFERENCE\nHOOKS\nuseActionState\n\nuseActionState is a Hook that allows you to update state based on the result of a form action.\n\nconst [state, formAction, isPending] = useActionState(fn, initialState, permalink?);\nNote\n\nIn earlier React Canary versions, this API was part of React DOM and called useFormState.\n\nReference\nuseActionState(action, initialState, permalink?)\nUsage\nUsing information returned by a form action\nTroubleshooting\nMy action can no longer read the submitted form data\nReference \nuseActionState(action, initialState, permalink?) \n\nCall useActionState at the top level of your component to create component state that is updated when a form action is invoked. You pass useActionState an existing form action function as well as an initial state, and it returns a new action that you use in your form, along with the latest form state and whether the Action is still pending. The latest form state is also passed to the function that you provided.\n\nimport { useActionState } from \"react\";\n\n\n\nasync function increment(previousState, formData) {\n\n  return previousState + 1;\n\n}\n\n\n\nfunction StatefulForm({}) {\n\n  const [state, formAction] = useActionState(increment, 0);\n\n  return (\n\n    <form>\n\n      {state}\n\n      <button formAction={formAction}>Increment</button>\n\n    </form>\n\n  )\n\n}\n\nThe form state is the value returned by the action when the form was last submitted. If the form has not yet been submitted, it is the initial state that you pass.\n\nIf used with a Server Function, useActionState allows the server‚Äôs response from submitting the form to be shown even before hydration has completed.\n\nSee more examples below.\n\nParameters \nfn: The function to be called when the form is submitted or button pressed. When the function is called, it will receive the previous state of the form (initially the initialState that you pass, subsequently its previous return value) as its initial argument, followed by the arguments that a form action normally receives.\ninitialState: The value you want the state to be initially. It can be any serializable value. This argument is ignored after the action is first invoked.\noptional permalink: A string containing the unique page URL that this form modifies. For use on pages with dynamic content (eg: feeds) in conjunction with progressive enhancement: if fn is a server function and the form is submitted before the JavaScript bundle loads, the browser will navigate to the specified permalink URL, rather than the current page‚Äôs URL. Ensure that the same form component is rendered on the destination page (including the same action fn and permalink) so that React knows how to pass the state through. Once the form has been hydrated, this parameter has no effect.\nReturns \n\nuseActionState returns an array with the following values:\n\nThe current state. During the first render, it will match the initialState you have passed. After the action is invoked, it will match the value returned by the action.\nA new action that you can pass as the action prop to your form component or formAction prop to any button component within the form. The action can also be called manually within startTransition.\nThe isPending flag that tells you whether there is a pending Transition.\nCaveats \nWhen used with a framework that supports React Server Components, useActionState lets you make forms interactive before JavaScript has executed on the client. When used without Server Components, it is equivalent to component local state.\nThe function passed to useActionState receives an extra argument, the previous or initial state, as its first argument. This makes its signature different than if it were used directly as a form action without using useActionState.\nUsage \nUsing information returned by a form action \n\nCall useActionState at the top level of your component to access the return value of an action from the last time a form was submitted.\n\nimport { useActionState } from 'react';\n\nimport { action } from './actions.js';\n\n\n\nfunction MyComponent() {\n\n  const [state, formAction] = useActionState(action, null);\n\n  // ...\n\n  return (\n\n    <form action={formAction}>\n\n      {/* ... */}\n\n    </form>\n\n  );\n\n}\n\nuseActionState returns an array with the following items:\n\nThe current state of the form, which is initially set to the initial state you provided, and after the form is submitted is set to the return value of the action you provided.\nA new action that you pass to <form> as its action prop or call manually within startTransition.\nA pending state that you can utilise while your action is processing.\n\nWhen the form is submitted, the action function that you provided will be called. Its return value will become the new current state of the form.\n\nThe action that you provide will also receive a new first argument, namely the current state of the form. The first time the form is submitted, this will be the initial state you provided, while with subsequent submissions, it will be the return value from the last time the action was called. The rest of the arguments are the same as if useActionState had not been used.\n\nfunction action(currentState, formData) {\n\n  // ...\n\n  return 'next state';\n\n}\nDisplay information after submitting a form\n1. Display form errors\n2. Display structured information after submitting a form\nExample 1 of 2: Display form errors \n\nTo display messages such as an error message or toast that‚Äôs returned by a Server Function, wrap the action in a call to useActionState.\n\nApp.js\nactions.js\nReload\nClear\nFork\nimport { useActionState, useState } from \"react\";\nimport { addToCart } from \"./actions.js\";\n\nfunction AddToCartForm({itemID, itemTitle}) {\n  const [message, formAction, isPending] = useActionState(addToCart, null);\n  return (\n    <form action={formAction}>\n      <h2>{itemTitle}</h2>\n      <input type=\"hidden\" name=\"itemID\" value={itemID} />\n      <button type=\"submit\">Add to Cart</button>\n      {isPending ? \"Loading...\" : message}\n    </form>\n  );\n}\n\nexport default function App() {\n  return (\n    <>\n      <AddToCartForm itemID=\"1\" itemTitle=\"JavaScript: The Definitive Guide\" />\n      <AddToCartForm itemID=\"2\" itemTitle=\"JavaScript: The Good Parts\" />\n    </>\n  )\n}\n\n\nShow more\nNext Example\nTroubleshooting \nMy action can no longer read the submitted form data \n\nWhen you wrap an action with useActionState, it gets an extra argument as its first argument. The submitted form data is therefore its second argument instead of its first as it would usually be. The new first argument that gets added is the current state of the form.\n\nfunction action(currentState, formData) {\n\n  // ...\n\n}\nPREVIOUS\nHooks\nNEXT\nuseCallback"
  },
  {
    "title": "useCallback ‚Äì React",
    "url": "https://react.dev/reference/react/useCallback",
    "html": "API REFERENCE\nHOOKS\nuseCallback\n\nuseCallback is a React Hook that lets you cache a function definition between re-renders.\n\nconst cachedFn = useCallback(fn, dependencies)\nNote\n\nReact Compiler automatically memoizes values and functions, reducing the need for manual useCallback calls. You can use the compiler to handle memoization automatically.\n\nReference\nuseCallback(fn, dependencies)\nUsage\nSkipping re-rendering of components\nUpdating state from a memoized callback\nPreventing an Effect from firing too often\nOptimizing a custom Hook\nTroubleshooting\nEvery time my component renders, useCallback returns a different function\nI need to call useCallback for each list item in a loop, but it‚Äôs not allowed\nReference \nuseCallback(fn, dependencies) \n\nCall useCallback at the top level of your component to cache a function definition between re-renders:\n\nimport { useCallback } from 'react';\n\n\n\nexport default function ProductPage({ productId, referrer, theme }) {\n\n  const handleSubmit = useCallback((orderDetails) => {\n\n    post('/product/' + productId + '/buy', {\n\n      referrer,\n\n      orderDetails,\n\n    });\n\n  }, [productId, referrer]);\n\nSee more examples below.\n\nParameters \n\nfn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.\n\ndependencies: The list of all reactive values referenced inside of the fn code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm.\n\nReturns \n\nOn the initial render, useCallback returns the fn function you have passed.\n\nDuring subsequent renders, it will either return an already stored fn function from the last render (if the dependencies haven‚Äôt changed), or return the fn function you have passed during this render.\n\nCaveats \nuseCallback is a Hook, so you can only call it at the top level of your component or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.\nReact will not throw away the cached function unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache‚Äîfor example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on useCallback as a performance optimization. Otherwise, a state variable or a ref may be more appropriate.\nUsage \nSkipping re-rendering of components \n\nWhen you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Let‚Äôs first look at the syntax for how to do this, and then see in which cases it‚Äôs useful.\n\nTo cache a function between re-renders of your component, wrap its definition into the useCallback Hook:\n\nimport { useCallback } from 'react';\n\n\n\nfunction ProductPage({ productId, referrer, theme }) {\n\n  const handleSubmit = useCallback((orderDetails) => {\n\n    post('/product/' + productId + '/buy', {\n\n      referrer,\n\n      orderDetails,\n\n    });\n\n  }, [productId, referrer]);\n\n  // ...\n\nYou need to pass two things to useCallback:\n\nA function definition that you want to cache between re-renders.\nA list of dependencies including every value within your component that‚Äôs used inside your function.\n\nOn the initial render, the returned function you‚Äôll get from useCallback will be the function you passed.\n\nOn the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with Object.is), useCallback will return the same function as before. Otherwise, useCallback will return the function you passed on this render.\n\nIn other words, useCallback caches a function between re-renders until its dependencies change.\n\nLet‚Äôs walk through an example to see when this is useful.\n\nSay you‚Äôre passing a handleSubmit function down from the ProductPage to the ShippingForm component:\n\nfunction ProductPage({ productId, referrer, theme }) {\n\n  // ...\n\n  return (\n\n    <div className={theme}>\n\n      <ShippingForm onSubmit={handleSubmit} />\n\n    </div>\n\n  );\n\nYou‚Äôve noticed that toggling the theme prop freezes the app for a moment, but if you remove <ShippingForm /> from your JSX, it feels fast. This tells you that it‚Äôs worth trying to optimize the ShippingForm component.\n\nBy default, when a component re-renders, React re-renders all of its children recursively. This is why, when ProductPage re-renders with a different theme, the ShippingForm component also re-renders. This is fine for components that don‚Äôt require much calculation to re-render. But if you verified a re-render is slow, you can tell ShippingForm to skip re-rendering when its props are the same as on last render by wrapping it in memo:\n\nimport { memo } from 'react';\n\n\n\nconst ShippingForm = memo(function ShippingForm({ onSubmit }) {\n\n  // ...\n\n});\n\nWith this change, ShippingForm will skip re-rendering if all of its props are the same as on the last render. This is when caching a function becomes important! Let‚Äôs say you defined handleSubmit without useCallback:\n\nfunction ProductPage({ productId, referrer, theme }) {\n\n  // Every time the theme changes, this will be a different function...\n\n  function handleSubmit(orderDetails) {\n\n    post('/product/' + productId + '/buy', {\n\n      referrer,\n\n      orderDetails,\n\n    });\n\n  }\n\n\n\n  return (\n\n    <div className={theme}>\n\n      {/* ... so ShippingForm's props will never be the same, and it will re-render every time */}\n\n      <ShippingForm onSubmit={handleSubmit} />\n\n    </div>\n\n  );\n\n}\n\nIn JavaScript, a function () {} or () => {} always creates a different function, similar to how the {} object literal always creates a new object. Normally, this wouldn‚Äôt be a problem, but it means that ShippingForm props will never be the same, and your memo optimization won‚Äôt work. This is where useCallback comes in handy:\n\nfunction ProductPage({ productId, referrer, theme }) {\n\n  // Tell React to cache your function between re-renders...\n\n  const handleSubmit = useCallback((orderDetails) => {\n\n    post('/product/' + productId + '/buy', {\n\n      referrer,\n\n      orderDetails,\n\n    });\n\n  }, [productId, referrer]); // ...so as long as these dependencies don't change...\n\n\n\n  return (\n\n    <div className={theme}>\n\n      {/* ...ShippingForm will receive the same props and can skip re-rendering */}\n\n      <ShippingForm onSubmit={handleSubmit} />\n\n    </div>\n\n  );\n\n}\n\nBy wrapping handleSubmit in useCallback, you ensure that it‚Äôs the same function between the re-renders (until dependencies change). You don‚Äôt have to wrap a function in useCallback unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo, and this lets it skip re-rendering. There are other reasons you might need useCallback which are described further on this page.\n\nNote\n\nYou should only rely on useCallback as a performance optimization. If your code doesn‚Äôt work without it, find the underlying problem and fix it first. Then you may add useCallback back.\n\nDEEP DIVE\nHow is useCallback related to useMemo? \nShow Details\nDEEP DIVE\nShould you add useCallback everywhere? \nShow Details\nThe difference between useCallback and declaring a function directly\n1. Skipping re-rendering with useCallback and memo\n2. Always re-rendering a component\nExample 1 of 2: Skipping re-rendering with useCallback and memo \n\nIn this example, the ShippingForm component is artificially slowed down so that you can see what happens when a React component you‚Äôre rendering is genuinely slow. Try incrementing the counter and toggling the theme.\n\nIncrementing the counter feels slow because it forces the slowed down ShippingForm to re-render. That‚Äôs expected because the counter has changed, and so you need to reflect the user‚Äôs new choice on the screen.\n\nNext, try toggling the theme. Thanks to useCallback together with memo, it‚Äôs fast despite the artificial slowdown! ShippingForm skipped re-rendering because the handleSubmit function has not changed. The handleSubmit function has not changed because both productId and referrer (your useCallback dependencies) haven‚Äôt changed since last render.\n\nApp.js\nProductPage.js\nShippingForm.js\nReload\nClear\nFork\nimport { useCallback } from 'react';\nimport ShippingForm from './ShippingForm.js';\n\nexport default function ProductPage({ productId, referrer, theme }) {\n  const handleSubmit = useCallback((orderDetails) => {\n    post('/product/' + productId + '/buy', {\n      referrer,\n      orderDetails,\n    });\n  }, [productId, referrer]);\n\n  return (\n    <div className={theme}>\n      <ShippingForm onSubmit={handleSubmit} />\n    </div>\n  );\n}\n\nfunction post(url, data) {\n  // Imagine this sends a request...\n  console.log('POST /' + url);\n  console.log(data);\n}\n\n\nShow more\nNext Example\nUpdating state from a memoized callback \n\nSometimes, you might need to update state based on previous state from a memoized callback.\n\nThis handleAddTodo function specifies todos as a dependency because it computes the next todos from it:\n\nfunction TodoList() {\n\n  const [todos, setTodos] = useState([]);\n\n\n\n  const handleAddTodo = useCallback((text) => {\n\n    const newTodo = { id: nextId++, text };\n\n    setTodos([...todos, newTodo]);\n\n  }, [todos]);\n\n  // ...\n\nYou‚Äôll usually want memoized functions to have as few dependencies as possible. When you read some state only to calculate the next state, you can remove that dependency by passing an updater function instead:\n\nfunction TodoList() {\n\n  const [todos, setTodos] = useState([]);\n\n\n\n  const handleAddTodo = useCallback((text) => {\n\n    const newTodo = { id: nextId++, text };\n\n    setTodos(todos => [...todos, newTodo]);\n\n  }, []); // ‚úÖ No need for the todos dependency\n\n  // ...\n\nHere, instead of making todos a dependency and reading it inside, you pass an instruction about how to update the state (todos => [...todos, newTodo]) to React. Read more about updater functions.\n\nPreventing an Effect from firing too often \n\nSometimes, you might want to call a function from inside an Effect:\n\nfunction ChatRoom({ roomId }) {\n\n  const [message, setMessage] = useState('');\n\n\n\n  function createOptions() {\n\n    return {\n\n      serverUrl: 'https://localhost:1234',\n\n      roomId: roomId\n\n    };\n\n  }\n\n\n\n  useEffect(() => {\n\n    const options = createOptions();\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    // ...\n\nThis creates a problem. Every reactive value must be declared as a dependency of your Effect. However, if you declare createOptions as a dependency, it will cause your Effect to constantly reconnect to the chat room:\n\n  useEffect(() => {\n\n    const options = createOptions();\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [createOptions]); // üî¥ Problem: This dependency changes on every render\n\n  // ...\n\nTo solve this, you can wrap the function you need to call from an Effect into useCallback:\n\nfunction ChatRoom({ roomId }) {\n\n  const [message, setMessage] = useState('');\n\n\n\n  const createOptions = useCallback(() => {\n\n    return {\n\n      serverUrl: 'https://localhost:1234',\n\n      roomId: roomId\n\n    };\n\n  }, [roomId]); // ‚úÖ Only changes when roomId changes\n\n\n\n  useEffect(() => {\n\n    const options = createOptions();\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [createOptions]); // ‚úÖ Only changes when createOptions changes\n\n  // ...\n\nThis ensures that the createOptions function is the same between re-renders if the roomId is the same. However, it‚Äôs even better to remove the need for a function dependency. Move your function inside the Effect:\n\nfunction ChatRoom({ roomId }) {\n\n  const [message, setMessage] = useState('');\n\n\n\n  useEffect(() => {\n\n    function createOptions() { // ‚úÖ No need for useCallback or function dependencies!\n\n      return {\n\n        serverUrl: 'https://localhost:1234',\n\n        roomId: roomId\n\n      };\n\n    }\n\n\n\n    const options = createOptions();\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [roomId]); // ‚úÖ Only changes when roomId changes\n\n  // ...\n\nNow your code is simpler and doesn‚Äôt need useCallback. Learn more about removing Effect dependencies.\n\nOptimizing a custom Hook \n\nIf you‚Äôre writing a custom Hook, it‚Äôs recommended to wrap any functions that it returns into useCallback:\n\nfunction useRouter() {\n\n  const { dispatch } = useContext(RouterStateContext);\n\n\n\n  const navigate = useCallback((url) => {\n\n    dispatch({ type: 'navigate', url });\n\n  }, [dispatch]);\n\n\n\n  const goBack = useCallback(() => {\n\n    dispatch({ type: 'back' });\n\n  }, [dispatch]);\n\n\n\n  return {\n\n    navigate,\n\n    goBack,\n\n  };\n\n}\n\nThis ensures that the consumers of your Hook can optimize their own code when needed.\n\nTroubleshooting \nEvery time my component renders, useCallback returns a different function \n\nMake sure you‚Äôve specified the dependency array as a second argument!\n\nIf you forget the dependency array, useCallback will return a new function every time:\n\nfunction ProductPage({ productId, referrer }) {\n\n  const handleSubmit = useCallback((orderDetails) => {\n\n    post('/product/' + productId + '/buy', {\n\n      referrer,\n\n      orderDetails,\n\n    });\n\n  }); // üî¥ Returns a new function every time: no dependency array\n\n  // ...\n\nThis is the corrected version passing the dependency array as a second argument:\n\nfunction ProductPage({ productId, referrer }) {\n\n  const handleSubmit = useCallback((orderDetails) => {\n\n    post('/product/' + productId + '/buy', {\n\n      referrer,\n\n      orderDetails,\n\n    });\n\n  }, [productId, referrer]); // ‚úÖ Does not return a new function unnecessarily\n\n  // ...\n\nIf this doesn‚Äôt help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:\n\n  const handleSubmit = useCallback((orderDetails) => {\n\n    // ..\n\n  }, [productId, referrer]);\n\n\n\n  console.log([productId, referrer]);\n\nYou can then right-click on the arrays from different re-renders in the console and select ‚ÄúStore as a global variable‚Äù for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same:\n\nObject.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?\n\nObject.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?\n\nObject.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\n\nWhen you find which dependency is breaking memoization, either find a way to remove it, or memoize it as well.\n\nI need to call useCallback for each list item in a loop, but it‚Äôs not allowed \n\nSuppose the Chart component is wrapped in memo. You want to skip re-rendering every Chart in the list when the ReportList component re-renders. However, you can‚Äôt call useCallback in a loop:\n\nfunction ReportList({ items }) {\n\n  return (\n\n    <article>\n\n      {items.map(item => {\n\n        // üî¥ You can't call useCallback in a loop like this:\n\n        const handleClick = useCallback(() => {\n\n          sendReport(item)\n\n        }, [item]);\n\n\n\n        return (\n\n          <figure key={item.id}>\n\n            <Chart onClick={handleClick} />\n\n          </figure>\n\n        );\n\n      })}\n\n    </article>\n\n  );\n\n}\n\nInstead, extract a component for an individual item, and put useCallback there:\n\nfunction ReportList({ items }) {\n\n  return (\n\n    <article>\n\n      {items.map(item =>\n\n        <Report key={item.id} item={item} />\n\n      )}\n\n    </article>\n\n  );\n\n}\n\n\n\nfunction Report({ item }) {\n\n  // ‚úÖ Call useCallback at the top level:\n\n  const handleClick = useCallback(() => {\n\n    sendReport(item)\n\n  }, [item]);\n\n\n\n  return (\n\n    <figure>\n\n      <Chart onClick={handleClick} />\n\n    </figure>\n\n  );\n\n}\n\nAlternatively, you could remove useCallback in the last snippet and instead wrap Report itself in memo. If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too:\n\nfunction ReportList({ items }) {\n\n  // ...\n\n}\n\n\n\nconst Report = memo(function Report({ item }) {\n\n  function handleClick() {\n\n    sendReport(item);\n\n  }\n\n\n\n  return (\n\n    <figure>\n\n      <Chart onClick={handleClick} />\n\n    </figure>\n\n  );\n\n});\nPREVIOUS\nuseActionState\nNEXT\nuseContext"
  },
  {
    "title": "useContext ‚Äì React",
    "url": "https://react.dev/reference/react/useContext",
    "html": "API REFERENCE\nHOOKS\nuseContext\n\nuseContext is a React Hook that lets you read and subscribe to context from your component.\n\nconst value = useContext(SomeContext)\nReference\nuseContext(SomeContext)\nUsage\nPassing data deeply into the tree\nUpdating data passed via context\nSpecifying a fallback default value\nOverriding context for a part of the tree\nOptimizing re-renders when passing objects and functions\nTroubleshooting\nMy component doesn‚Äôt see the value from my provider\nI am always getting undefined from my context although the default value is different\nReference \nuseContext(SomeContext) \n\nCall useContext at the top level of your component to read and subscribe to context.\n\nimport { useContext } from 'react';\n\n\n\nfunction MyComponent() {\n\n  const theme = useContext(ThemeContext);\n\n  // ...\n\nSee more examples below.\n\nParameters \nSomeContext: The context that you‚Äôve previously created with createContext. The context itself does not hold the information, it only represents the kind of information you can provide or read from components.\nReturns \n\nuseContext returns the context value for the calling component. It is determined as the value passed to the closest SomeContext above the calling component in the tree. If there is no such provider, then the returned value will be the defaultValue you have passed to createContext for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes.\n\nCaveats \nuseContext() call in a component is not affected by providers returned from the same component. The corresponding <Context> needs to be above the component doing the useContext() call.\nReact automatically re-renders all the children that use a particular context starting from the provider that receives a different value. The previous and the next values are compared with the Object.is comparison. Skipping re-renders with memo does not prevent the children receiving fresh context values.\nIf your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works if SomeContext that you use to provide context and SomeContext that you use to read it are exactly the same object, as determined by a === comparison.\nUsage \nPassing data deeply into the tree \n\nCall useContext at the top level of your component to read and subscribe to context.\n\nimport { useContext } from 'react';\n\n\n\nfunction Button() {\n\n  const theme = useContext(ThemeContext);\n\n  // ...\n\nuseContext returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context.\n\nTo pass context to a Button, wrap it or one of its parent components into the corresponding context provider:\n\nfunction MyPage() {\n\n  return (\n\n    <ThemeContext value=\"dark\">\n\n      <Form />\n\n    </ThemeContext>\n\n  );\n\n}\n\n\n\nfunction Form() {\n\n  // ... renders buttons inside ...\n\n}\n\nIt doesn‚Äôt matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls useContext(ThemeContext), it will receive \"dark\" as the value.\n\nPitfall\n\nuseContext() always looks for the closest provider above the component that calls it. It searches upwards and does not consider providers in the component from which you‚Äôre calling useContext().\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  return (\n    <ThemeContext value=\"dark\">\n      <Form />\n    </ThemeContext>\n  )\n}\n\nfunction Form() {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n    </Panel>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      <h1>{title}</h1>\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className}>\n      {children}\n    </button>\n  );\n}\n\n\nShow more\nUpdating data passed via context \n\nOften, you‚Äôll want the context to change over time. To update context, combine it with state. Declare a state variable in the parent component, and pass the current state down as the context value to the provider.\n\nfunction MyPage() {\n\n  const [theme, setTheme] = useState('dark');\n\n  return (\n\n    <ThemeContext value={theme}>\n\n      <Form />\n\n      <Button onClick={() => {\n\n        setTheme('light');\n\n      }}>\n\n        Switch to light theme\n\n      </Button>\n\n    </ThemeContext>\n\n  );\n\n}\n\nNow any Button inside of the provider will receive the current theme value. If you call setTheme to update the theme value that you pass to the provider, all Button components will re-render with the new 'light' value.\n\nExamples of updating context\n1. Updating a value via context\n2. Updating an object via context\n3. Multiple contexts\n4. Extracting providers to a component\n5. Scaling up with context and a reducer\nExample 1 of 5: Updating a value via context \n\nIn this example, the MyApp component holds a state variable which is then passed to the ThemeContext provider. Checking the ‚ÄúDark mode‚Äù checkbox updates the state. Changing the provided value re-renders all the components using that context.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  const [theme, setTheme] = useState('light');\n  return (\n    <ThemeContext value={theme}>\n      <Form />\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={theme === 'dark'}\n          onChange={(e) => {\n            setTheme(e.target.checked ? 'dark' : 'light')\n          }}\n        />\n        Use dark mode\n      </label>\n    </ThemeContext>\n  )\n}\n\nfunction Form({ children }) {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n    </Panel>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      <h1>{title}</h1>\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className}>\n      {children}\n    </button>\n  );\n}\n\n\nShow more\n\nNote that value=\"dark\" passes the \"dark\" string, but value={theme} passes the value of the JavaScript theme variable with JSX curly braces. Curly braces also let you pass context values that aren‚Äôt strings.\n\nNext Example\nSpecifying a fallback default value \n\nIf React can‚Äôt find any providers of that particular context in the parent tree, the context value returned by useContext() will be equal to the default value that you specified when you created that context:\n\nconst ThemeContext = createContext(null);\n\nThe default value never changes. If you want to update context, use it with state as described above.\n\nOften, instead of null, there is some more meaningful value you can use as a default, for example:\n\nconst ThemeContext = createContext('light');\n\nThis way, if you accidentally render some component without a corresponding provider, it won‚Äôt break. This also helps your components work well in a test environment without setting up a lot of providers in the tests.\n\nIn the example below, the ‚ÄúToggle theme‚Äù button is always light because it‚Äôs outside any theme context provider and the default context theme value is 'light'. Try editing the default theme to be 'dark'.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext('light');\n\nexport default function MyApp() {\n  const [theme, setTheme] = useState('light');\n  return (\n    <>\n      <ThemeContext value={theme}>\n        <Form />\n      </ThemeContext>\n      <Button onClick={() => {\n        setTheme(theme === 'dark' ? 'light' : 'dark');\n      }}>\n        Toggle theme\n      </Button>\n    </>\n  )\n}\n\nfunction Form({ children }) {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n    </Panel>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      <h1>{title}</h1>\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children, onClick }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className} onClick={onClick}>\n      {children}\n    </button>\n  );\n}\n\n\nShow more\nOverriding context for a part of the tree \n\nYou can override the context for a part of the tree by wrapping that part in a provider with a different value.\n\n<ThemeContext value=\"dark\">\n\n  ...\n\n  <ThemeContext value=\"light\">\n\n    <Footer />\n\n  </ThemeContext>\n\n  ...\n\n</ThemeContext>\n\nYou can nest and override providers as many times as you need.\n\nExamples of overriding context\n1. Overriding a theme\n2. Automatically nested headings\nExample 1 of 2: Overriding a theme \n\nHere, the button inside the Footer receives a different context value (\"light\") than the buttons outside (\"dark\").\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  return (\n    <ThemeContext value=\"dark\">\n      <Form />\n    </ThemeContext>\n  )\n}\n\nfunction Form() {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n      <ThemeContext value=\"light\">\n        <Footer />\n      </ThemeContext>\n    </Panel>\n  );\n}\n\nfunction Footer() {\n  return (\n    <footer>\n      <Button>Settings</Button>\n    </footer>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      {title && <h1>{title}</h1>}\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className}>\n      {children}\n    </button>\n  );\n}\n\n\nShow more\nNext Example\nOptimizing re-renders when passing objects and functions \n\nYou can pass any values via context, including objects and functions.\n\nfunction MyApp() {\n\n  const [currentUser, setCurrentUser] = useState(null);\n\n\n\n  function login(response) {\n\n    storeCredentials(response.credentials);\n\n    setCurrentUser(response.user);\n\n  }\n\n\n\n  return (\n\n    <AuthContext value={{ currentUser, login }}>\n\n      <Page />\n\n    </AuthContext>\n\n  );\n\n}\n\nHere, the context value is a JavaScript object with two properties, one of which is a function. Whenever MyApp re-renders (for example, on a route update), this will be a different object pointing at a different function, so React will also have to re-render all components deep in the tree that call useContext(AuthContext).\n\nIn smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like currentUser, has not changed. To help React take advantage of that fact, you may wrap the login function with useCallback and wrap the object creation into useMemo. This is a performance optimization:\n\nimport { useCallback, useMemo } from 'react';\n\n\n\nfunction MyApp() {\n\n  const [currentUser, setCurrentUser] = useState(null);\n\n\n\n  const login = useCallback((response) => {\n\n    storeCredentials(response.credentials);\n\n    setCurrentUser(response.user);\n\n  }, []);\n\n\n\n  const contextValue = useMemo(() => ({\n\n    currentUser,\n\n    login\n\n  }), [currentUser, login]);\n\n\n\n  return (\n\n    <AuthContext value={contextValue}>\n\n      <Page />\n\n    </AuthContext>\n\n  );\n\n}\n\nAs a result of this change, even if MyApp needs to re-render, the components calling useContext(AuthContext) won‚Äôt need to re-render unless currentUser has changed.\n\nRead more about useMemo and useCallback.\n\nTroubleshooting \nMy component doesn‚Äôt see the value from my provider \n\nThere are a few common ways that this can happen:\n\nYou‚Äôre rendering <SomeContext> in the same component (or below) as where you‚Äôre calling useContext(). Move <SomeContext> above and outside the component calling useContext().\nYou may have forgotten to wrap your component with <SomeContext>, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right using React DevTools.\nYou might be running into some build issue with your tooling that causes SomeContext as seen from the providing component and SomeContext as seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals like window.SomeContext1 and window.SomeContext2 and then checking whether window.SomeContext1 === window.SomeContext2 in the console. If they‚Äôre not the same, fix that issue on the build tool level.\nI am always getting undefined from my context although the default value is different \n\nYou might have a provider without a value in the tree:\n\n// üö© Doesn't work: no value prop\n\n<ThemeContext>\n\n   <Button />\n\n</ThemeContext>\n\nIf you forget to specify value, it‚Äôs like passing value={undefined}.\n\nYou may have also mistakingly used a different prop name by mistake:\n\n// üö© Doesn't work: prop should be called \"value\"\n\n<ThemeContext theme={theme}>\n\n   <Button />\n\n</ThemeContext>\n\nIn both of these cases you should see a warning from React in the console. To fix them, call the prop value:\n\n// ‚úÖ Passing the value prop\n\n<ThemeContext value={theme}>\n\n   <Button />\n\n</ThemeContext>\n\nNote that the default value from your createContext(defaultValue) call is only used if there is no matching provider above at all. If there is a <SomeContext value={undefined}> component somewhere in the parent tree, the component calling useContext(SomeContext) will receive undefined as the context value.\n\nPREVIOUS\nuseCallback\nNEXT\nuseDebugValue"
  },
  {
    "title": "useDebugValue ‚Äì React",
    "url": "https://react.dev/reference/react/useDebugValue",
    "html": "API REFERENCE\nHOOKS\nuseDebugValue\n\nuseDebugValue is a React Hook that lets you add a label to a custom Hook in React DevTools.\n\nuseDebugValue(value, format?)\nReference\nuseDebugValue(value, format?)\nUsage\nAdding a label to a custom Hook\nDeferring formatting of a debug value\nReference \nuseDebugValue(value, format?) \n\nCall useDebugValue at the top level of your custom Hook to display a readable debug value:\n\nimport { useDebugValue } from 'react';\n\n\n\nfunction useOnlineStatus() {\n\n  // ...\n\n  useDebugValue(isOnline ? 'Online' : 'Offline');\n\n  // ...\n\n}\n\nSee more examples below.\n\nParameters \nvalue: The value you want to display in React DevTools. It can have any type.\noptional format: A formatting function. When the component is inspected, React DevTools will call the formatting function with the value as the argument, and then display the returned formatted value (which may have any type). If you don‚Äôt specify the formatting function, the original value itself will be displayed.\nReturns \n\nuseDebugValue does not return anything.\n\nUsage \nAdding a label to a custom Hook \n\nCall useDebugValue at the top level of your custom Hook to display a readable debug value for React DevTools.\n\nimport { useDebugValue } from 'react';\n\n\n\nfunction useOnlineStatus() {\n\n  // ...\n\n  useDebugValue(isOnline ? 'Online' : 'Offline');\n\n  // ...\n\n}\n\nThis gives components calling useOnlineStatus a label like OnlineStatus: \"Online\" when you inspect them:\n\nWithout the useDebugValue call, only the underlying data (in this example, true) would be displayed.\n\nApp.js\nuseOnlineStatus.js\nReload\nClear\nFork\nimport { useSyncExternalStore, useDebugValue } from 'react';\n\nexport function useOnlineStatus() {\n  const isOnline = useSyncExternalStore(subscribe, () => navigator.onLine, () => true);\n  useDebugValue(isOnline ? 'Online' : 'Offline');\n  return isOnline;\n}\n\nfunction subscribe(callback) {\n  window.addEventListener('online', callback);\n  window.addEventListener('offline', callback);\n  return () => {\n    window.removeEventListener('online', callback);\n    window.removeEventListener('offline', callback);\n  };\n}\n\n\nShow more\nNote\n\nDon‚Äôt add debug values to every custom Hook. It‚Äôs most valuable for custom Hooks that are part of shared libraries and that have a complex internal data structure that‚Äôs difficult to inspect.\n\nDeferring formatting of a debug value \n\nYou can also pass a formatting function as the second argument to useDebugValue:\n\nuseDebugValue(date, date => date.toDateString());\n\nYour formatting function will receive the debug value as a parameter and should return a formatted display value. When your component is inspected, React DevTools will call this function and display its result.\n\nThis lets you avoid running potentially expensive formatting logic unless the component is actually inspected. For example, if date is a Date value, this avoids calling toDateString() on it for every render.\n\nPREVIOUS\nuseContext\nNEXT\nuseDeferredValue"
  },
  {
    "title": "useDeferredValue ‚Äì React",
    "url": "https://react.dev/reference/react/useDeferredValue",
    "html": "API REFERENCE\nHOOKS\nuseDeferredValue\n\nuseDeferredValue is a React Hook that lets you defer updating a part of the UI.\n\nconst deferredValue = useDeferredValue(value)\nReference\nuseDeferredValue(value, initialValue?)\nUsage\nShowing stale content while fresh content is loading\nIndicating that the content is stale\nDeferring re-rendering for a part of the UI\nReference \nuseDeferredValue(value, initialValue?) \n\nCall useDeferredValue at the top level of your component to get a deferred version of that value.\n\nimport { useState, useDeferredValue } from 'react';\n\n\n\nfunction SearchPage() {\n\n  const [query, setQuery] = useState('');\n\n  const deferredQuery = useDeferredValue(query);\n\n  // ...\n\n}\n\nSee more examples below.\n\nParameters \nvalue: The value you want to defer. It can have any type.\noptional initialValue: A value to use during the initial render of a component. If this option is omitted, useDeferredValue will not defer during the initial render, because there‚Äôs no previous version of value that it can render instead.\nReturns \ncurrentValue: During the initial render, the returned deferred value will be the initialValue, or the same as the value you provided. During updates, React will first attempt a re-render with the old value (so it will return the old value), and then try another re-render in the background with the new value (so it will return the updated value).\nCaveats \n\nWhen an update is inside a Transition, useDeferredValue always returns the new value and does not spawn a deferred render, since the update is already deferred.\n\nThe values you pass to useDeferredValue should either be primitive values (like strings and numbers) or objects created outside of rendering. If you create a new object during rendering and immediately pass it to useDeferredValue, it will be different on every render, causing unnecessary background re-renders.\n\nWhen useDeferredValue receives a different value (compared with Object.is), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value. The background re-render is interruptible: if there‚Äôs another update to the value, React will restart the background re-render from scratch. For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing.\n\nuseDeferredValue is integrated with <Suspense>. If the background update caused by a new value suspends the UI, the user will not see the fallback. They will see the old deferred value until the data loads.\n\nuseDeferredValue does not by itself prevent extra network requests.\n\nThere is no fixed delay caused by useDeferredValue itself. As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value. Any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it.\n\nThe background re-render caused by useDeferredValue does not fire Effects until it‚Äôs committed to the screen. If the background re-render suspends, its Effects will run after the data loads and the UI updates.\n\nUsage \nShowing stale content while fresh content is loading \n\nCall useDeferredValue at the top level of your component to defer updating some part of your UI.\n\nimport { useState, useDeferredValue } from 'react';\n\n\n\nfunction SearchPage() {\n\n  const [query, setQuery] = useState('');\n\n  const deferredQuery = useDeferredValue(query);\n\n  // ...\n\n}\n\nDuring the initial render, the deferred value will be the same as the value you provided.\n\nDuring updates, the deferred value will ‚Äúlag behind‚Äù the latest value. In particular, React will first re-render without updating the deferred value, and then try to re-render with the newly received value in the background.\n\nLet‚Äôs walk through an example to see when this is useful.\n\nNote\n\nThis example assumes you use a Suspense-enabled data source:\n\nData fetching with Suspense-enabled frameworks like Relay and Next.js\nLazy-loading component code with lazy\nReading the value of a Promise with use\n\nLearn more about Suspense and its limitations.\n\nIn this example, the SearchResults component suspends while fetching the search results. Try typing \"a\", waiting for the results, and then editing it to \"ab\". The results for \"a\" get replaced by the loading fallback.\n\nApp.js\nSearchResults.js\nReload\nClear\nFork\nimport { Suspense, useState } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const [query, setQuery] = useState('');\n  return (\n    <>\n      <label>\n        Search albums:\n        <input value={query} onChange={e => setQuery(e.target.value)} />\n      </label>\n      <Suspense fallback={<h2>Loading...</h2>}>\n        <SearchResults query={query} />\n      </Suspense>\n    </>\n  );\n}\n\n\nShow more\n\nA common alternative UI pattern is to defer updating the list of results and to keep showing the previous results until the new results are ready. Call useDeferredValue to pass a deferred version of the query down:\n\nexport default function App() {\n\n  const [query, setQuery] = useState('');\n\n  const deferredQuery = useDeferredValue(query);\n\n  return (\n\n    <>\n\n      <label>\n\n        Search albums:\n\n        <input value={query} onChange={e => setQuery(e.target.value)} />\n\n      </label>\n\n      <Suspense fallback={<h2>Loading...</h2>}>\n\n        <SearchResults query={deferredQuery} />\n\n      </Suspense>\n\n    </>\n\n  );\n\n}\n\nThe query will update immediately, so the input will display the new value. However, the deferredQuery will keep its previous value until the data has loaded, so SearchResults will show the stale results for a bit.\n\nEnter \"a\" in the example below, wait for the results to load, and then edit the input to \"ab\". Notice how instead of the Suspense fallback, you now see the stale result list until the new results have loaded:\n\nApp.js\nSearchResults.js\nReload\nClear\nFork\nimport { Suspense, useState, useDeferredValue } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  return (\n    <>\n      <label>\n        Search albums:\n        <input value={query} onChange={e => setQuery(e.target.value)} />\n      </label>\n      <Suspense fallback={<h2>Loading...</h2>}>\n        <SearchResults query={deferredQuery} />\n      </Suspense>\n    </>\n  );\n}\n\n\nShow more\nDEEP DIVE\nHow does deferring a value work under the hood? \nShow Details\nIndicating that the content is stale \n\nIn the example above, there is no indication that the result list for the latest query is still loading. This can be confusing to the user if the new results take a while to load. To make it more obvious to the user that the result list does not match the latest query, you can add a visual indication when the stale result list is displayed:\n\n<div style={{\n\n  opacity: query !== deferredQuery ? 0.5 : 1,\n\n}}>\n\n  <SearchResults query={deferredQuery} />\n\n</div>\n\nWith this change, as soon as you start typing, the stale result list gets slightly dimmed until the new result list loads. You can also add a CSS transition to delay dimming so that it feels gradual, like in the example below:\n\nApp.js\nSearchResults.js\nReload\nClear\nFork\nimport { Suspense, useState, useDeferredValue } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  const isStale = query !== deferredQuery;\n  return (\n    <>\n      <label>\n        Search albums:\n        <input value={query} onChange={e => setQuery(e.target.value)} />\n      </label>\n      <Suspense fallback={<h2>Loading...</h2>}>\n        <div style={{\n          opacity: isStale ? 0.5 : 1,\n          transition: isStale ? 'opacity 0.2s 0.2s linear' : 'opacity 0s 0s linear'\n        }}>\n          <SearchResults query={deferredQuery} />\n        </div>\n      </Suspense>\n    </>\n  );\n}\n\n\nShow more\nDeferring re-rendering for a part of the UI \n\nYou can also apply useDeferredValue as a performance optimization. It is useful when a part of your UI is slow to re-render, there‚Äôs no easy way to optimize it, and you want to prevent it from blocking the rest of the UI.\n\nImagine you have a text field and a component (like a chart or a long list) that re-renders on every keystroke:\n\nfunction App() {\n\n  const [text, setText] = useState('');\n\n  return (\n\n    <>\n\n      <input value={text} onChange={e => setText(e.target.value)} />\n\n      <SlowList text={text} />\n\n    </>\n\n  );\n\n}\n\nFirst, optimize SlowList to skip re-rendering when its props are the same. To do this, wrap it in memo:\n\nconst SlowList = memo(function SlowList({ text }) {\n\n  // ...\n\n});\n\nHowever, this only helps if the SlowList props are the same as during the previous render. The problem you‚Äôre facing now is that it‚Äôs slow when they‚Äôre different, and when you actually need to show different visual output.\n\nConcretely, the main performance problem is that whenever you type into the input, the SlowList receives new props, and re-rendering its entire tree makes the typing feel janky. In this case, useDeferredValue lets you prioritize updating the input (which must be fast) over updating the result list (which is allowed to be slower):\n\nfunction App() {\n\n  const [text, setText] = useState('');\n\n  const deferredText = useDeferredValue(text);\n\n  return (\n\n    <>\n\n      <input value={text} onChange={e => setText(e.target.value)} />\n\n      <SlowList text={deferredText} />\n\n    </>\n\n  );\n\n}\n\nThis does not make re-rendering of the SlowList faster. However, it tells React that re-rendering the list can be deprioritized so that it doesn‚Äôt block the keystrokes. The list will ‚Äúlag behind‚Äù the input and then ‚Äúcatch up‚Äù. Like before, React will attempt to update the list as soon as possible, but will not block the user from typing.\n\nThe difference between useDeferredValue and unoptimized re-rendering\n1. Deferred re-rendering of the list\n2. Unoptimized re-rendering of the list\nExample 1 of 2: Deferred re-rendering of the list \n\nIn this example, each item in the SlowList component is artificially slowed down so that you can see how useDeferredValue lets you keep the input responsive. Type into the input and notice that typing feels snappy while the list ‚Äúlags behind‚Äù it.\n\nApp.js\nSlowList.js\nReload\nClear\nFork\nimport { useState, useDeferredValue } from 'react';\nimport SlowList from './SlowList.js';\n\nexport default function App() {\n  const [text, setText] = useState('');\n  const deferredText = useDeferredValue(text);\n  return (\n    <>\n      <input value={text} onChange={e => setText(e.target.value)} />\n      <SlowList text={deferredText} />\n    </>\n  );\n}\n\n\nNext Example\nPitfall\n\nThis optimization requires SlowList to be wrapped in memo. This is because whenever the text changes, React needs to be able to re-render the parent component quickly. During that re-render, deferredText still has its previous value, so SlowList is able to skip re-rendering (its props have not changed). Without memo, it would have to re-render anyway, defeating the point of the optimization.\n\nDEEP DIVE\nHow is deferring a value different from debouncing and throttling? \nShow Details\nPREVIOUS\nuseDebugValue\nNEXT\nuseEffect"
  },
  {
    "title": "useEffect ‚Äì React",
    "url": "https://react.dev/reference/react/useEffect",
    "html": "API REFERENCE\nHOOKS\nuseEffect\n\nuseEffect is a React Hook that lets you synchronize a component with an external system.\n\nuseEffect(setup, dependencies?)\nReference\nuseEffect(setup, dependencies?)\nUsage\nConnecting to an external system\nWrapping Effects in custom Hooks\nControlling a non-React widget\nFetching data with Effects\nSpecifying reactive dependencies\nUpdating state based on previous state from an Effect\nRemoving unnecessary object dependencies\nRemoving unnecessary function dependencies\nReading the latest props and state from an Effect\nDisplaying different content on the server and the client\nTroubleshooting\nMy Effect runs twice when the component mounts\nMy Effect runs after every re-render\nMy Effect keeps re-running in an infinite cycle\nMy cleanup logic runs even though my component didn‚Äôt unmount\nMy Effect does something visual, and I see a flicker before it runs\nReference \nuseEffect(setup, dependencies?) \n\nCall useEffect at the top level of your component to declare an Effect:\n\nimport { useState, useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\n\n\nfunction ChatRoom({ roomId }) {\n\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.connect();\n\n    return () => {\n\n      connection.disconnect();\n\n    };\n\n  }, [serverUrl, roomId]);\n\n  // ...\n\n}\n\nSee more examples below.\n\nParameters \n\nsetup: The function with your Effect‚Äôs logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function.\n\noptional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If you omit this argument, your Effect will re-run after every re-render of the component. See the difference between passing an array of dependencies, an empty array, and no dependencies at all.\n\nReturns \n\nuseEffect returns undefined.\n\nCaveats \n\nuseEffect is a Hook, so you can only call it at the top level of your component or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.\n\nIf you‚Äôre not trying to synchronize with some external system, you probably don‚Äôt need an Effect.\n\nWhen Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic ‚Äúmirrors‚Äù your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.\n\nIf some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect.\n\nIf your Effect wasn‚Äôt caused by an interaction (like a click), React will generally let the browser paint the updated screen first before running your Effect. If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace useEffect with useLayoutEffect.\n\nIf your Effect is caused by an interaction (like a click), React may run your Effect before the browser paints the updated screen. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as an alert(), you can use setTimeout. See reactwg/react-18/128 for more information.\n\nEven if your Effect was caused by an interaction (like a click), React may allow the browser to repaint the screen before processing the state updates inside your Effect. Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replace useEffect with useLayoutEffect.\n\nEffects only run on the client. They don‚Äôt run during server rendering.\n\nUsage \nConnecting to an external system \n\nSome components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren‚Äôt controlled by React, so they are called external.\n\nTo connect your component to some external system, call useEffect at the top level of your component:\n\nimport { useState, useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\n\n\nfunction ChatRoom({ roomId }) {\n\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n\n\n  useEffect(() => {\n\n  \tconst connection = createConnection(serverUrl, roomId);\n\n    connection.connect();\n\n  \treturn () => {\n\n      connection.disconnect();\n\n  \t};\n\n  }, [serverUrl, roomId]);\n\n  // ...\n\n}\n\nYou need to pass two arguments to useEffect:\n\nA setup function with setup code that connects to that system.\nIt should return a cleanup function with cleanup code that disconnects from that system.\nA list of dependencies including every value from your component used inside of those functions.\n\nReact calls your setup and cleanup functions whenever it‚Äôs necessary, which may happen multiple times:\n\nYour setup code runs when your component is added to the page (mounts).\nAfter every re-render of your component where the dependencies have changed:\nFirst, your cleanup code runs with the old props and state.\nThen, your setup code runs with the new props and state.\nYour cleanup code runs one final time after your component is removed from the page (unmounts).\n\nLet‚Äôs illustrate this sequence for the example above.\n\nWhen the ChatRoom component above gets added to the page, it will connect to the chat room with the initial serverUrl and roomId. If either serverUrl or roomId change as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will disconnect from the previous room, and connect to the next one. When the ChatRoom component is removed from the page, your Effect will disconnect one last time.\n\nTo help you find bugs, in development React runs setup and cleanup one extra time before the setup. This is a stress-test that verifies your Effect‚Äôs logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn‚Äôt be able to distinguish between the setup being called once (as in production) and a setup ‚Üí cleanup ‚Üí setup sequence (as in development). See common solutions.\n\nTry to write every Effect as an independent process and think about a single setup/cleanup cycle at a time. It shouldn‚Äôt matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly ‚Äúmirrors‚Äù the setup logic, your Effect is resilient to running setup and cleanup as often as needed.\n\nNote\n\nAn Effect lets you keep your component synchronized with some external system (like a chat service). Here, external system means any piece of code that‚Äôs not controlled by React, such as:\n\nA timer managed with setInterval() and clearInterval().\nAn event subscription using window.addEventListener() and window.removeEventListener().\nA third-party animation library with an API like animation.start() and animation.reset().\n\nIf you‚Äôre not connecting to any external system, you probably don‚Äôt need an Effect.\n\nExamples of connecting to an external system\n1. Connecting to a chat server\n2. Listening to a global browser event\n3. Triggering an animation\n4. Controlling a modal dialog\n5. Tracking element visibility\nExample 1 of 5: Connecting to a chat server \n\nIn this example, the ChatRoom component uses an Effect to stay connected to an external system defined in chat.js. Press ‚ÄúOpen chat‚Äù to make the ChatRoom component appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as explained here. Try changing the roomId and serverUrl using the dropdown and the input, and see how the Effect re-connects to the chat. Press ‚ÄúClose chat‚Äù to see the Effect disconnect one last time.\n\nApp.js\nchat.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.connect();\n    return () => {\n      connection.disconnect();\n    };\n  }, [roomId, serverUrl]);\n\n  return (\n    <>\n      <label>\n        Server URL:{' '}\n        <input\n          value={serverUrl}\n          onChange={e => setServerUrl(e.target.value)}\n        />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [show, setShow] = useState(false);\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <button onClick={() => setShow(!show)}>\n        {show ? 'Close chat' : 'Open chat'}\n      </button>\n      {show && <hr />}\n      {show && <ChatRoom roomId={roomId} />}\n    </>\n  );\n}\n\n\nShow more\nNext Example\nWrapping Effects in custom Hooks \n\nEffects are an ‚Äúescape hatch‚Äù: you use them when you need to ‚Äústep outside React‚Äù and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it‚Äôs usually a sign that you need to extract some custom Hooks for common behaviors your components rely on.\n\nFor example, this useChatRoom custom Hook ‚Äúhides‚Äù the logic of your Effect behind a more declarative API:\n\nfunction useChatRoom({ serverUrl, roomId }) {\n\n  useEffect(() => {\n\n    const options = {\n\n      serverUrl: serverUrl,\n\n      roomId: roomId\n\n    };\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [roomId, serverUrl]);\n\n}\n\nThen you can use it from any component like this:\n\nfunction ChatRoom({ roomId }) {\n\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n\n\n  useChatRoom({\n\n    roomId: roomId,\n\n    serverUrl: serverUrl\n\n  });\n\n  // ...\n\nThere are also many excellent custom Hooks for every purpose available in the React ecosystem.\n\nLearn more about wrapping Effects in custom Hooks.\n\nExamples of wrapping Effects in custom Hooks\n1. Custom useChatRoom Hook\n2. Custom useWindowListener Hook\n3. Custom useIntersectionObserver Hook\nExample 1 of 3: Custom useChatRoom Hook \n\nThis example is identical to one of the earlier examples, but the logic is extracted to a custom Hook.\n\nApp.js\nuseChatRoom.js\nchat.js\nReload\nClear\nFork\nimport { useState } from 'react';\nimport { useChatRoom } from './useChatRoom.js';\n\nfunction ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n  useChatRoom({\n    roomId: roomId,\n    serverUrl: serverUrl\n  });\n\n  return (\n    <>\n      <label>\n        Server URL:{' '}\n        <input\n          value={serverUrl}\n          onChange={e => setServerUrl(e.target.value)}\n        />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [show, setShow] = useState(false);\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <button onClick={() => setShow(!show)}>\n        {show ? 'Close chat' : 'Open chat'}\n      </button>\n      {show && <hr />}\n      {show && <ChatRoom roomId={roomId} />}\n    </>\n  );\n}\n\n\nShow more\nNext Example\nControlling a non-React widget \n\nSometimes, you want to keep an external system synchronized to some prop or state of your component.\n\nFor example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a MapWidget class defined in map-widget.js. When you change the zoomLevel prop of the Map component, the Effect calls the setZoom() on the class instance to keep it synchronized:\n\nApp.js\nMap.js\nmap-widget.js\nReload\nClear\nFork\nimport { useRef, useEffect } from 'react';\nimport { MapWidget } from './map-widget.js';\n\nexport default function Map({ zoomLevel }) {\n  const containerRef = useRef(null);\n  const mapRef = useRef(null);\n\n  useEffect(() => {\n    if (mapRef.current === null) {\n      mapRef.current = new MapWidget(containerRef.current);\n    }\n\n    const map = mapRef.current;\n    map.setZoom(zoomLevel);\n  }, [zoomLevel]);\n\n  return (\n    <div\n      style={{ width: 200, height: 200 }}\n      ref={containerRef}\n    />\n  );\n}\n\n\nShow more\n\nIn this example, a cleanup function is not needed because the MapWidget class manages only the DOM node that was passed to it. After the Map React component is removed from the tree, both the DOM node and the MapWidget class instance will be automatically garbage-collected by the browser JavaScript engine.\n\nFetching data with Effects \n\nYou can use an Effect to fetch data for your component. Note that if you use a framework, using your framework‚Äôs data fetching mechanism will be a lot more efficient than writing Effects manually.\n\nIf you want to fetch data from an Effect manually, your code might look like this:\n\nimport { useState, useEffect } from 'react';\n\nimport { fetchBio } from './api.js';\n\n\n\nexport default function Page() {\n\n  const [person, setPerson] = useState('Alice');\n\n  const [bio, setBio] = useState(null);\n\n\n\n  useEffect(() => {\n\n    let ignore = false;\n\n    setBio(null);\n\n    fetchBio(person).then(result => {\n\n      if (!ignore) {\n\n        setBio(result);\n\n      }\n\n    });\n\n    return () => {\n\n      ignore = true;\n\n    };\n\n  }, [person]);\n\n\n\n  // ...\n\nNote the ignore variable which is initialized to false, and is set to true during cleanup. This ensures your code doesn‚Äôt suffer from ‚Äúrace conditions‚Äù: network responses may arrive in a different order than you sent them.\n\nApp.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\n  const [person, setPerson] = useState('Alice');\n  const [bio, setBio] = useState(null);\n  useEffect(() => {\n    let ignore = false;\n    setBio(null);\n    fetchBio(person).then(result => {\n      if (!ignore) {\n        setBio(result);\n      }\n    });\n    return () => {\n      ignore = true;\n    }\n  }, [person]);\n\n  return (\n    <>\n      <select value={person} onChange={e => {\n        setPerson(e.target.value);\n      }}>\n        <option value=\"Alice\">Alice</option>\n        <option value=\"Bob\">Bob</option>\n        <option value=\"Taylor\">Taylor</option>\n      </select>\n      <hr />\n      <p><i>{bio ?? 'Loading...'}</i></p>\n    </>\n  );\n}\n\n\nShow more\n\nYou can also rewrite using the async / await syntax, but you still need to provide a cleanup function:\n\nApp.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\n  const [person, setPerson] = useState('Alice');\n  const [bio, setBio] = useState(null);\n  useEffect(() => {\n    async function startFetching() {\n      setBio(null);\n      const result = await fetchBio(person);\n      if (!ignore) {\n        setBio(result);\n      }\n    }\n\n    let ignore = false;\n    startFetching();\n    return () => {\n      ignore = true;\n    }\n  }, [person]);\n\n  return (\n    <>\n      <select value={person} onChange={e => {\n        setPerson(e.target.value);\n      }}>\n        <option value=\"Alice\">Alice</option>\n        <option value=\"Bob\">Bob</option>\n        <option value=\"Taylor\">Taylor</option>\n      </select>\n      <hr />\n      <p><i>{bio ?? 'Loading...'}</i></p>\n    </>\n  );\n}\n\n\nShow more\n\nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It‚Äôs easier to use a custom Hook‚Äîeither your own or maintained by the community.\n\nDEEP DIVE\nWhat are good alternatives to data fetching in Effects? \nShow Details\nSpecifying reactive dependencies \n\nNotice that you can‚Äôt ‚Äúchoose‚Äù the dependencies of your Effect. Every reactive value used by your Effect‚Äôs code must be declared as a dependency. Your Effect‚Äôs dependency list is determined by the surrounding code:\n\nfunction ChatRoom({ roomId }) { // This is a reactive value\n\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too\n\n\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [serverUrl, roomId]); // ‚úÖ So you must specify them as dependencies of your Effect\n\n  // ...\n\n}\n\nIf either serverUrl or roomId change, your Effect will reconnect to the chat using the new values.\n\nReactive values include props and all variables and functions declared directly inside of your component. Since roomId and serverUrl are reactive values, you can‚Äôt remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix:\n\nfunction ChatRoom({ roomId }) {\n\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n  \n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, []); // üî¥ React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'\n\n  // ...\n\n}\n\nTo remove a dependency, you need to ‚Äúprove‚Äù to the linter that it doesn‚Äôt need to be a dependency. For example, you can move serverUrl out of your component to prove that it‚Äôs not reactive and won‚Äôt change on re-renders:\n\nconst serverUrl = 'https://localhost:1234'; // Not a reactive value anymore\n\n\n\nfunction ChatRoom({ roomId }) {\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [roomId]); // ‚úÖ All dependencies declared\n\n  // ...\n\n}\n\nNow that serverUrl is not a reactive value (and can‚Äôt change on a re-render), it doesn‚Äôt need to be a dependency. If your Effect‚Äôs code doesn‚Äôt use any reactive values, its dependency list should be empty ([]):\n\nconst serverUrl = 'https://localhost:1234'; // Not a reactive value anymore\n\nconst roomId = 'music'; // Not a reactive value anymore\n\n\n\nfunction ChatRoom() {\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, []); // ‚úÖ All dependencies declared\n\n  // ...\n\n}\n\nAn Effect with empty dependencies doesn‚Äôt re-run when any of your component‚Äôs props or state change.\n\nPitfall\n\nIf you have an existing codebase, you might have some Effects that suppress the linter like this:\n\nuseEffect(() => {\n\n  // ...\n\n  // üî¥ Avoid suppressing the linter like this:\n\n  // eslint-ignore-next-line react-hooks/exhaustive-deps\n\n}, []);\n\nWhen dependencies don‚Äôt match the code, there is a high risk of introducing bugs. By suppressing the linter, you ‚Äúlie‚Äù to React about the values your Effect depends on. Instead, prove they‚Äôre unnecessary.\n\nExamples of passing reactive dependencies\n1. Passing a dependency array\n2. Passing an empty dependency array\n3. Passing no dependency array at all\nExample 1 of 3: Passing a dependency array \n\nIf you specify the dependencies, your Effect runs after the initial render and after re-renders with changed dependencies.\n\nuseEffect(() => {\n\n  // ...\n\n}, [a, b]); // Runs again if a or b are different\n\nIn the below example, serverUrl and roomId are reactive values, so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, since message isn‚Äôt used in the Effect (and so it isn‚Äôt a dependency), editing the message doesn‚Äôt re-connect to the chat.\n\nApp.js\nchat.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.connect();\n    return () => {\n      connection.disconnect();\n    };\n  }, [serverUrl, roomId]);\n\n  return (\n    <>\n      <label>\n        Server URL:{' '}\n        <input\n          value={serverUrl}\n          onChange={e => setServerUrl(e.target.value)}\n        />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n      <label>\n        Your message:{' '}\n        <input value={message} onChange={e => setMessage(e.target.value)} />\n      </label>\n    </>\n  );\n}\n\nexport default function App() {\n  const [show, setShow] = useState(false);\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n        <button onClick={() => setShow(!show)}>\n          {show ? 'Close chat' : 'Open chat'}\n        </button>\n      </label>\n      {show && <hr />}\n      {show && <ChatRoom roomId={roomId}/>}\n    </>\n  );\n}\n\n\nShow more\nNext Example\nUpdating state based on previous state from an Effect \n\nWhen you want to update state based on previous state from an Effect, you might run into a problem:\n\nfunction Counter() {\n\n  const [count, setCount] = useState(0);\n\n\n\n  useEffect(() => {\n\n    const intervalId = setInterval(() => {\n\n      setCount(count + 1); // You want to increment the counter every second...\n\n    }, 1000)\n\n    return () => clearInterval(intervalId);\n\n  }, [count]); // üö© ... but specifying `count` as a dependency always resets the interval.\n\n  // ...\n\n}\n\nSince count is a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the count changes. This is not ideal.\n\nTo fix this, pass the c => c + 1 state updater to setCount:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setCount(c => c + 1); // ‚úÖ Pass a state updater\n    }, 1000);\n    return () => clearInterval(intervalId);\n  }, []); // ‚úÖ Now count is not a dependency\n\n  return <h1>{count}</h1>;\n}\n\n\n\nNow that you‚Äôre passing c => c + 1 instead of count + 1, your Effect no longer needs to depend on count. As a result of this fix, it won‚Äôt need to cleanup and setup the interval again every time the count changes.\n\nRemoving unnecessary object dependencies \n\nIf your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the options object is different for every render:\n\nconst serverUrl = 'https://localhost:1234';\n\n\n\nfunction ChatRoom({ roomId }) {\n\n  const [message, setMessage] = useState('');\n\n\n\n  const options = { // üö© This object is created from scratch on every re-render\n\n    serverUrl: serverUrl,\n\n    roomId: roomId\n\n  };\n\n\n\n  useEffect(() => {\n\n    const connection = createConnection(options); // It's used inside the Effect\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [options]); // üö© As a result, these dependencies are always different on a re-render\n\n  // ...\n\nAvoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:\n\nApp.js\nchat.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    const options = {\n      serverUrl: serverUrl,\n      roomId: roomId\n    };\n    const connection = createConnection(options);\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId]);\n\n  return (\n    <>\n      <h1>Welcome to the {roomId} room!</h1>\n      <input value={message} onChange={e => setMessage(e.target.value)} />\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <hr />\n      <ChatRoom roomId={roomId} />\n    </>\n  );\n}\n\n\nShow more\n\nNow that you create the options object inside the Effect, the Effect itself only depends on the roomId string.\n\nWith this fix, typing into the input doesn‚Äôt reconnect the chat. Unlike an object which gets re-created, a string like roomId doesn‚Äôt change unless you set it to another value. Read more about removing dependencies.\n\nRemoving unnecessary function dependencies \n\nIf your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the createOptions function is different for every render:\n\nfunction ChatRoom({ roomId }) {\n\n  const [message, setMessage] = useState('');\n\n\n\n  function createOptions() { // üö© This function is created from scratch on every re-render\n\n    return {\n\n      serverUrl: serverUrl,\n\n      roomId: roomId\n\n    };\n\n  }\n\n\n\n  useEffect(() => {\n\n    const options = createOptions(); // It's used inside the Effect\n\n    const connection = createConnection();\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [createOptions]); // üö© As a result, these dependencies are always different on a re-render\n\n  // ...\n\nBy itself, creating a function from scratch on every re-render is not a problem. You don‚Äôt need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render.\n\nAvoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:\n\nApp.js\nchat.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    function createOptions() {\n      return {\n        serverUrl: serverUrl,\n        roomId: roomId\n      };\n    }\n\n    const options = createOptions();\n    const connection = createConnection(options);\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId]);\n\n  return (\n    <>\n      <h1>Welcome to the {roomId} room!</h1>\n      <input value={message} onChange={e => setMessage(e.target.value)} />\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <hr />\n      <ChatRoom roomId={roomId} />\n    </>\n  );\n}\n\n\nShow more\n\nNow that you define the createOptions function inside the Effect, the Effect itself only depends on the roomId string. With this fix, typing into the input doesn‚Äôt reconnect the chat. Unlike a function which gets re-created, a string like roomId doesn‚Äôt change unless you set it to another value. Read more about removing dependencies.\n\nReading the latest props and state from an Effect \n\nBy default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect ‚Äúreacts‚Äù to every change of that value. For most dependencies, that‚Äôs the behavior you want.\n\nHowever, sometimes you‚Äôll want to read the latest props and state from an Effect without ‚Äúreacting‚Äù to them. For example, imagine you want to log the number of the items in the shopping cart for every page visit:\n\nfunction Page({ url, shoppingCart }) {\n\n  useEffect(() => {\n\n    logVisit(url, shoppingCart.length);\n\n  }, [url, shoppingCart]); // ‚úÖ All dependencies declared\n\n  // ...\n\n}\n\nWhat if you want to log a new page visit after every url change, but not if only the shoppingCart changes? You can‚Äôt exclude shoppingCart from dependencies without breaking the reactivity rules. However, you can express that you don‚Äôt want a piece of code to ‚Äúreact‚Äù to changes even though it is called from inside an Effect. Declare an Effect Event with the useEffectEvent Hook, and move the code reading shoppingCart inside of it:\n\nfunction Page({ url, shoppingCart }) {\n\n  const onVisit = useEffectEvent(visitedUrl => {\n\n    logVisit(visitedUrl, shoppingCart.length)\n\n  });\n\n\n\n  useEffect(() => {\n\n    onVisit(url);\n\n  }, [url]); // ‚úÖ All dependencies declared\n\n  // ...\n\n}\n\nEffect Events are not reactive and must always be omitted from dependencies of your Effect. This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By reading shoppingCart inside of onVisit, you ensure that shoppingCart won‚Äôt re-run your Effect.\n\nRead more about how Effect Events let you separate reactive and non-reactive code.\n\nDisplaying different content on the server and the client \n\nIf your app uses server rendering (either directly or via a framework), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for hydration to work, your initial render output must be identical on the client and the server.\n\nIn rare cases, you might need to display different content on the client. For example, if your app reads some data from localStorage, it can‚Äôt possibly do that on the server. Here is how you could implement this:\n\nfunction MyComponent() {\n\n  const [didMount, setDidMount] = useState(false);\n\n\n\n  useEffect(() => {\n\n    setDidMount(true);\n\n  }, []);\n\n\n\n  if (didMount) {\n\n    // ... return client-only JSX ...\n\n  }  else {\n\n    // ... return initial JSX ...\n\n  }\n\n}\n\nWhile the app is loading, the user will see the initial render output. Then, when it‚Äôs loaded and hydrated, your Effect will run and set didMount to true, triggering a re-render. This will switch to the client-only render output. Effects don‚Äôt run on the server, so this is why didMount was false during the initial server render.\n\nUse this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time‚Äîpotentially, many seconds‚Äîso you don‚Äôt want to make jarring changes to your component‚Äôs appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS.\n\nTroubleshooting \nMy Effect runs twice when the component mounts \n\nWhen Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.\n\nThis is a stress-test that verifies your Effect‚Äôs logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn‚Äôt be able to distinguish between the setup being called once (as in production) and a setup ‚Üí cleanup ‚Üí setup sequence (as in development).\n\nRead more about how this helps find bugs and how to fix your logic.\n\nMy Effect runs after every re-render \n\nFirst, check that you haven‚Äôt forgotten to specify the dependency array:\n\nuseEffect(() => {\n\n  // ...\n\n}); // üö© No dependency array: re-runs after every render!\n\nIf you‚Äôve specified the dependency array but your Effect still re-runs in a loop, it‚Äôs because one of your dependencies is different on every re-render.\n\nYou can debug this problem by manually logging your dependencies to the console:\n\n  useEffect(() => {\n\n    // ..\n\n  }, [serverUrl, roomId]);\n\n\n\n  console.log([serverUrl, roomId]);\n\nYou can then right-click on the arrays from different re-renders in the console and select ‚ÄúStore as a global variable‚Äù for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same:\n\nObject.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?\n\nObject.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?\n\nObject.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\n\nWhen you find the dependency that is different on every re-render, you can usually fix it in one of these ways:\n\nUpdating state based on previous state from an Effect\nRemoving unnecessary object dependencies\nRemoving unnecessary function dependencies\nReading the latest props and state from an Effect\n\nAs a last resort (if these methods didn‚Äôt help), wrap its creation with useMemo or useCallback (for functions).\n\nMy Effect keeps re-running in an infinite cycle \n\nIf your Effect runs in an infinite cycle, these two things must be true:\n\nYour Effect is updating some state.\nThat state leads to a re-render, which causes the Effect‚Äôs dependencies to change.\n\nBefore you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application‚Äôs data flow with it?\n\nIf there is no external system, consider whether removing the Effect altogether would simplify your logic.\n\nIf you‚Äôre genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component‚Äôs visual output? If you need to keep track of some data that isn‚Äôt used by rendering, a ref (which doesn‚Äôt trigger re-renders) might be more appropriate. Verify your Effect doesn‚Äôt update the state (and trigger re-renders) more than needed.\n\nFinally, if your Effect is updating the state at the right time, but there is still a loop, it‚Äôs because that state update leads to one of the Effect‚Äôs dependencies changing. Read how to debug dependency changes.\n\nMy cleanup logic runs even though my component didn‚Äôt unmount \n\nThe cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React runs setup+cleanup one extra time immediately after component mounts.\n\nIf you have cleanup code without corresponding setup code, it‚Äôs usually a code smell:\n\nuseEffect(() => {\n\n  // üî¥ Avoid: Cleanup logic without corresponding setup logic\n\n  return () => {\n\n    doSomething();\n\n  };\n\n}, []);\n\nYour cleanup logic should be ‚Äúsymmetrical‚Äù to the setup logic, and should stop or undo whatever setup did:\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.connect();\n\n    return () => {\n\n      connection.disconnect();\n\n    };\n\n  }, [serverUrl, roomId]);\n\nLearn how the Effect lifecycle is different from the component‚Äôs lifecycle.\n\nMy Effect does something visual, and I see a flicker before it runs \n\nIf your Effect must block the browser from painting the screen, replace useEffect with useLayoutEffect. Note that this shouldn‚Äôt be needed for the vast majority of Effects. You‚Äôll only need this if it‚Äôs crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it.\n\nPREVIOUS\nuseDeferredValue\nNEXT\nuseEffectEvent"
  },
  {
    "title": "useEffectEvent ‚Äì React",
    "url": "https://react.dev/reference/react/useEffectEvent",
    "html": "API REFERENCE\nHOOKS\nuseEffectEvent\n\nuseEffectEvent is a React Hook that lets you extract non-reactive logic from your Effects into a reusable function called an Effect Event.\n\nconst onSomething = useEffectEvent(callback)\nReference\nuseEffectEvent(callback)\nUsage\nReading the latest props and state\nReference \nuseEffectEvent(callback) \n\nCall useEffectEvent at the top level of your component to declare an Effect Event. Effect Events are functions you can call inside Effects, such as useEffect:\n\nimport { useEffectEvent, useEffect } from 'react';\n\n\n\nfunction ChatRoom({ roomId, theme }) {\n\n  const onConnected = useEffectEvent(() => {\n\n    showNotification('Connected!', theme);\n\n  });\n\n\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.on('connected', () => {\n\n      onConnected();\n\n    });\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [roomId]);\n\n\n\n  // ...\n\n}\n\nSee more examples below.\n\nParameters \ncallback: A function containing the logic for your Effect Event. When you define an Effect Event with useEffectEvent, the callback always accesses the latest values from props and state when it is invoked. This helps avoid issues with stale closures.\nReturns \n\nReturns an Effect Event function. You can call this function inside useEffect, useLayoutEffect, or useInsertionEffect.\n\nCaveats \nOnly call inside Effects: Effect Events should only be called within Effects. Define them just before the Effect that uses them. Do not pass them to other components or hooks. The eslint-plugin-react-hooks linter (version 6.1.1 or higher) will enforce this restriction to prevent calling Effect Events in the wrong context.\nNot a dependency shortcut: Do not use useEffectEvent to avoid specifying dependencies in your Effect‚Äôs dependency array. This can hide bugs and make your code harder to understand. Prefer explicit dependencies or use refs to compare previous values if needed.\nUse for non-reactive logic: Only use useEffectEvent to extract logic that does not depend on changing values.\nUsage \nReading the latest props and state \n\nTypically, when you access a reactive value inside an Effect, you must include it in the dependency array. This makes sure your Effect runs again whenever that value changes, which is usually the desired behavior.\n\nBut in some cases, you may want to read the most recent props or state inside an Effect without causing the Effect to re-run when those values change.\n\nTo read the latest props or state in your Effect, without making those values reactive, include them in an Effect Event.\n\nimport { useEffect, useContext, useEffectEvent } from 'react';\n\n\n\nfunction Page({ url }) {\n\n  const { items } = useContext(ShoppingCartContext);\n\n  const numberOfItems = items.length;\n\n\n\n  const onNavigate = useEffectEvent((visitedUrl) => {\n\n    logVisit(visitedUrl, numberOfItems);\n\n  });\n\n\n\n  useEffect(() => {\n\n    onNavigate(url);\n\n  }, [url]);\n\n\n\n  // ...\n\n}\n\nIn this example, the Effect should re-run after a render when url changes (to log the new page visit), but it should not re-run when numberOfItems changes. By wrapping the logging logic in an Effect Event, numberOfItems becomes non-reactive. It‚Äôs always read from the latest value without triggering the Effect.\n\nYou can pass reactive values like url as arguments to the Effect Event to keep them reactive while accessing the latest non-reactive values inside the event.\n\nPREVIOUS\nuseEffect\nNEXT\nuseId"
  },
  {
    "title": "useId ‚Äì React",
    "url": "https://react.dev/reference/react/useId",
    "html": "API REFERENCE\nHOOKS\nuseId\n\nuseId is a React Hook for generating unique IDs that can be passed to accessibility attributes.\n\nconst id = useId()\nReference\nuseId()\nUsage\nGenerating unique IDs for accessibility attributes\nGenerating IDs for several related elements\nSpecifying a shared prefix for all generated IDs\nUsing the same ID prefix on the client and the server\nReference \nuseId() \n\nCall useId at the top level of your component to generate a unique ID:\n\nimport { useId } from 'react';\n\n\n\nfunction PasswordField() {\n\n  const passwordHintId = useId();\n\n  // ...\n\nSee more examples below.\n\nParameters \n\nuseId does not take any parameters.\n\nReturns \n\nuseId returns a unique ID string associated with this particular useId call in this particular component.\n\nCaveats \n\nuseId is a Hook, so you can only call it at the top level of your component or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.\n\nuseId should not be used to generate keys in a list. Keys should be generated from your data.\n\nuseId currently cannot be used in async Server Components.\n\nUsage \nPitfall\n\nDo not call useId to generate keys in a list. Keys should be generated from your data.\n\nGenerating unique IDs for accessibility attributes \n\nCall useId at the top level of your component to generate a unique ID:\n\nimport { useId } from 'react';\n\n\n\nfunction PasswordField() {\n\n  const passwordHintId = useId();\n\n  // ...\n\nYou can then pass the generated ID to different attributes:\n\n<>\n\n  <input type=\"password\" aria-describedby={passwordHintId} />\n\n  <p id={passwordHintId}>\n\n</>\n\nLet‚Äôs walk through an example to see when this is useful.\n\nHTML accessibility attributes like aria-describedby let you specify that two tags are related to each other. For example, you can specify that an element (like an input) is described by another element (like a paragraph).\n\nIn regular HTML, you would write it like this:\n\n<label>\n\n  Password:\n\n  <input\n\n    type=\"password\"\n\n    aria-describedby=\"password-hint\"\n\n  />\n\n</label>\n\n<p id=\"password-hint\">\n\n  The password should contain at least 18 characters\n\n</p>\n\nHowever, hardcoding IDs like this is not a good practice in React. A component may be rendered more than once on the page‚Äîbut IDs have to be unique! Instead of hardcoding an ID, generate a unique ID with useId:\n\nimport { useId } from 'react';\n\n\n\nfunction PasswordField() {\n\n  const passwordHintId = useId();\n\n  return (\n\n    <>\n\n      <label>\n\n        Password:\n\n        <input\n\n          type=\"password\"\n\n          aria-describedby={passwordHintId}\n\n        />\n\n      </label>\n\n      <p id={passwordHintId}>\n\n        The password should contain at least 18 characters\n\n      </p>\n\n    </>\n\n  );\n\n}\n\nNow, even if PasswordField appears multiple times on the screen, the generated IDs won‚Äôt clash.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useId } from 'react';\n\nfunction PasswordField() {\n  const passwordHintId = useId();\n  return (\n    <>\n      <label>\n        Password:\n        <input\n          type=\"password\"\n          aria-describedby={passwordHintId}\n        />\n      </label>\n      <p id={passwordHintId}>\n        The password should contain at least 18 characters\n      </p>\n    </>\n  );\n}\n\nexport default function App() {\n  return (\n    <>\n      <h2>Choose password</h2>\n      <PasswordField />\n      <h2>Confirm password</h2>\n      <PasswordField />\n    </>\n  );\n}\n\n\nShow more\n\nWatch this video to see the difference in the user experience with assistive technologies.\n\nPitfall\n\nWith server rendering, useId requires an identical component tree on the server and the client. If the trees you render on the server and the client don‚Äôt match exactly, the generated IDs won‚Äôt match.\n\nDEEP DIVE\nWhy is useId better than an incrementing counter? \nShow Details\nGenerating IDs for several related elements \n\nIf you need to give IDs to multiple related elements, you can call useId to generate a shared prefix for them:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useId } from 'react';\n\nexport default function Form() {\n  const id = useId();\n  return (\n    <form>\n      <label htmlFor={id + '-firstName'}>First Name:</label>\n      <input id={id + '-firstName'} type=\"text\" />\n      <hr />\n      <label htmlFor={id + '-lastName'}>Last Name:</label>\n      <input id={id + '-lastName'} type=\"text\" />\n    </form>\n  );\n}\n\n\n\nThis lets you avoid calling useId for every single element that needs a unique ID.\n\nSpecifying a shared prefix for all generated IDs \n\nIf you render multiple independent React applications on a single page, pass identifierPrefix as an option to your createRoot or hydrateRoot calls. This ensures that the IDs generated by the two different apps never clash because every identifier generated with useId will start with the distinct prefix you‚Äôve specified.\n\nindex.js\nindex.html\nApp.js\nReload\nClear\nFork\nimport { createRoot } from 'react-dom/client';\nimport App from './App.js';\nimport './styles.css';\n\nconst root1 = createRoot(document.getElementById('root1'), {\n  identifierPrefix: 'my-first-app-'\n});\nroot1.render(<App />);\n\nconst root2 = createRoot(document.getElementById('root2'), {\n  identifierPrefix: 'my-second-app-'\n});\nroot2.render(<App />);\n\n\nUsing the same ID prefix on the client and the server \n\nIf you render multiple independent React apps on the same page, and some of these apps are server-rendered, make sure that the identifierPrefix you pass to the hydrateRoot call on the client side is the same as the identifierPrefix you pass to the server APIs such as renderToPipeableStream.\n\n// Server\n\nimport { renderToPipeableStream } from 'react-dom/server';\n\n\n\nconst { pipe } = renderToPipeableStream(\n\n  <App />,\n\n  { identifierPrefix: 'react-app1' }\n\n);\n// Client\n\nimport { hydrateRoot } from 'react-dom/client';\n\n\n\nconst domNode = document.getElementById('root');\n\nconst root = hydrateRoot(\n\n  domNode,\n\n  reactNode,\n\n  { identifierPrefix: 'react-app1' }\n\n);\n\nYou do not need to pass identifierPrefix if you only have one React app on the page.\n\nPREVIOUS\nuseEffectEvent\nNEXT\nuseImperativeHandle"
  },
  {
    "title": "useImperativeHandle ‚Äì React",
    "url": "https://react.dev/reference/react/useImperativeHandle",
    "html": "API REFERENCE\nHOOKS\nuseImperativeHandle\n\nuseImperativeHandle is a React Hook that lets you customize the handle exposed as a ref.\n\nuseImperativeHandle(ref, createHandle, dependencies?)\nReference\nuseImperativeHandle(ref, createHandle, dependencies?)\nUsage\nExposing a custom ref handle to the parent component\nExposing your own imperative methods\nReference \nuseImperativeHandle(ref, createHandle, dependencies?) \n\nCall useImperativeHandle at the top level of your component to customize the ref handle it exposes:\n\nimport { useImperativeHandle } from 'react';\n\n\n\nfunction MyInput({ ref }) {\n\n  useImperativeHandle(ref, () => {\n\n    return {\n\n      // ... your methods ...\n\n    };\n\n  }, []);\n\n  // ...\n\nSee more examples below.\n\nParameters \n\nref: The ref you received as a prop to the MyInput component.\n\ncreateHandle: A function that takes no arguments and returns the ref handle you want to expose. That ref handle can have any type. Usually, you will return an object with the methods you want to expose.\n\noptional dependencies: The list of all reactive values referenced inside of the createHandle code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If a re-render resulted in a change to some dependency, or if you omitted this argument, your createHandle function will re-execute, and the newly created handle will be assigned to the ref.\n\nNote\n\nStarting with React 19, ref is available as a prop. In React 18 and earlier, it was necessary to get the ref from forwardRef.\n\nReturns \n\nuseImperativeHandle returns undefined.\n\nUsage \nExposing a custom ref handle to the parent component \n\nTo expose a DOM node to the parent element, pass in the ref prop to the node.\n\nfunction MyInput({ ref }) {\n\n  return <input ref={ref} />;\n\n};\n\nWith the code above, a ref to MyInput will receive the <input> DOM node. However, you can expose a custom value instead. To customize the exposed handle, call useImperativeHandle at the top level of your component:\n\nimport { useImperativeHandle } from 'react';\n\n\n\nfunction MyInput({ ref }) {\n\n  useImperativeHandle(ref, () => {\n\n    return {\n\n      // ... your methods ...\n\n    };\n\n  }, []);\n\n\n\n  return <input />;\n\n};\n\nNote that in the code above, the ref is no longer passed to the <input>.\n\nFor example, suppose you don‚Äôt want to expose the entire <input> DOM node, but you want to expose two of its methods: focus and scrollIntoView. To do this, keep the real browser DOM in a separate ref. Then use useImperativeHandle to expose a handle with only the methods that you want the parent component to call:\n\nimport { useRef, useImperativeHandle } from 'react';\n\n\n\nfunction MyInput({ ref }) {\n\n  const inputRef = useRef(null);\n\n\n\n  useImperativeHandle(ref, () => {\n\n    return {\n\n      focus() {\n\n        inputRef.current.focus();\n\n      },\n\n      scrollIntoView() {\n\n        inputRef.current.scrollIntoView();\n\n      },\n\n    };\n\n  }, []);\n\n\n\n  return <input ref={inputRef} />;\n\n};\n\nNow, if the parent component gets a ref to MyInput, it will be able to call the focus and scrollIntoView methods on it. However, it will not have full access to the underlying <input> DOM node.\n\nApp.js\nMyInput.js\nReload\nClear\nFork\nimport { useRef } from 'react';\nimport MyInput from './MyInput.js';\n\nexport default function Form() {\n  const ref = useRef(null);\n\n  function handleClick() {\n    ref.current.focus();\n    // This won't work because the DOM node isn't exposed:\n    // ref.current.style.opacity = 0.5;\n  }\n\n  return (\n    <form>\n      <MyInput placeholder=\"Enter your name\" ref={ref} />\n      <button type=\"button\" onClick={handleClick}>\n        Edit\n      </button>\n    </form>\n  );\n}\n\n\nShow more\nExposing your own imperative methods \n\nThe methods you expose via an imperative handle don‚Äôt have to match the DOM methods exactly. For example, this Post component exposes a scrollAndFocusAddComment method via an imperative handle. This lets the parent Page scroll the list of comments and focus the input field when you click the button:\n\nApp.js\nPost.js\nCommentList.js\nAddComment.js\nReload\nClear\nFork\nimport { useRef } from 'react';\nimport Post from './Post.js';\n\nexport default function Page() {\n  const postRef = useRef(null);\n\n  function handleClick() {\n    postRef.current.scrollAndFocusAddComment();\n  }\n\n  return (\n    <>\n      <button onClick={handleClick}>\n        Write a comment\n      </button>\n      <Post ref={postRef} />\n    </>\n  );\n}\n\n\nShow more\nPitfall\n\nDo not overuse refs. You should only use refs for imperative behaviors that you can‚Äôt express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on.\n\nIf you can express something as a prop, you should not use a ref. For example, instead of exposing an imperative handle like { open, close } from a Modal component, it is better to take isOpen as a prop like <Modal isOpen={isOpen} />. Effects can help you expose imperative behaviors via props.\n\nPREVIOUS\nuseId\nNEXT\nuseInsertionEffect"
  },
  {
    "title": "useInsertionEffect ‚Äì React",
    "url": "https://react.dev/reference/react/useInsertionEffect",
    "html": "API REFERENCE\nHOOKS\nuseInsertionEffect\nPitfall\n\nuseInsertionEffect is for CSS-in-JS library authors. Unless you are working on a CSS-in-JS library and need a place to inject the styles, you probably want useEffect or useLayoutEffect instead.\n\nuseInsertionEffect allows inserting elements into the DOM before any layout Effects fire.\n\nuseInsertionEffect(setup, dependencies?)\nReference\nuseInsertionEffect(setup, dependencies?)\nUsage\nInjecting dynamic styles from CSS-in-JS libraries\nReference \nuseInsertionEffect(setup, dependencies?) \n\nCall useInsertionEffect to insert styles before any Effects fire that may need to read layout:\n\nimport { useInsertionEffect } from 'react';\n\n\n\n// Inside your CSS-in-JS library\n\nfunction useCSS(rule) {\n\n  useInsertionEffect(() => {\n\n    // ... inject <style> tags here ...\n\n  });\n\n  return rule;\n\n}\n\nSee more examples below.\n\nParameters \n\nsetup: The function with your Effect‚Äôs logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, but before any layout Effects fire, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. When your component is removed from the DOM, React will run your cleanup function.\n\noptional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm. If you don‚Äôt specify the dependencies at all, your Effect will re-run after every re-render of the component.\n\nReturns \n\nuseInsertionEffect returns undefined.\n\nCaveats \nEffects only run on the client. They don‚Äôt run during server rendering.\nYou can‚Äôt update state from inside useInsertionEffect.\nBy the time useInsertionEffect runs, refs are not attached yet.\nuseInsertionEffect may run either before or after the DOM has been updated. You shouldn‚Äôt rely on the DOM being updated at any particular time.\nUnlike other types of Effects, which fire cleanup for every Effect and then setup for every Effect, useInsertionEffect will fire both cleanup and setup one component at a time. This results in an ‚Äúinterleaving‚Äù of the cleanup and setup functions.\nUsage \nInjecting dynamic styles from CSS-in-JS libraries \n\nTraditionally, you would style React components using plain CSS.\n\n// In your JS file:\n\n<button className=\"success\" />\n\n\n\n// In your CSS file:\n\n.success { color: green; }\n\nSome teams prefer to author styles directly in JavaScript code instead of writing CSS files. This usually requires using a CSS-in-JS library or a tool. There are three common approaches to CSS-in-JS:\n\nStatic extraction to CSS files with a compiler\nInline styles, e.g. <div style={{ opacity: 1 }}>\nRuntime injection of <style> tags\n\nIf you use CSS-in-JS, we recommend a combination of the first two approaches (CSS files for static styles, inline styles for dynamic styles). We don‚Äôt recommend runtime <style> tag injection for two reasons:\n\nRuntime injection forces the browser to recalculate the styles a lot more often.\nRuntime injection can be very slow if it happens at the wrong time in the React lifecycle.\n\nThe first problem is not solvable, but useInsertionEffect helps you solve the second problem.\n\nCall useInsertionEffect to insert the styles before any layout Effects fire:\n\n// Inside your CSS-in-JS library\n\nlet isInserted = new Set();\n\nfunction useCSS(rule) {\n\n  useInsertionEffect(() => {\n\n    // As explained earlier, we don't recommend runtime injection of <style> tags.\n\n    // But if you have to do it, then it's important to do in useInsertionEffect.\n\n    if (!isInserted.has(rule)) {\n\n      isInserted.add(rule);\n\n      document.head.appendChild(getStyleForRule(rule));\n\n    }\n\n  });\n\n  return rule;\n\n}\n\n\n\nfunction Button() {\n\n  const className = useCSS('...');\n\n  return <div className={className} />;\n\n}\n\nSimilarly to useEffect, useInsertionEffect does not run on the server. If you need to collect which CSS rules have been used on the server, you can do it during rendering:\n\nlet collectedRulesSet = new Set();\n\n\n\nfunction useCSS(rule) {\n\n  if (typeof window === 'undefined') {\n\n    collectedRulesSet.add(rule);\n\n  }\n\n  useInsertionEffect(() => {\n\n    // ...\n\n  });\n\n  return rule;\n\n}\n\nRead more about upgrading CSS-in-JS libraries with runtime injection to useInsertionEffect.\n\nDEEP DIVE\nHow is this better than injecting styles during rendering or useLayoutEffect? \nShow Details\nPREVIOUS\nuseImperativeHandle\nNEXT\nuseLayoutEffect"
  },
  {
    "title": "useLayoutEffect ‚Äì React",
    "url": "https://react.dev/reference/react/useLayoutEffect",
    "html": "API REFERENCE\nHOOKS\nuseLayoutEffect\nPitfall\n\nuseLayoutEffect can hurt performance. Prefer useEffect when possible.\n\nuseLayoutEffect is a version of useEffect that fires before the browser repaints the screen.\n\nuseLayoutEffect(setup, dependencies?)\nReference\nuseLayoutEffect(setup, dependencies?)\nUsage\nMeasuring layout before the browser repaints the screen\nTroubleshooting\nI‚Äôm getting an error: ‚ÄúuseLayoutEffect does nothing on the server‚Äù\nReference \nuseLayoutEffect(setup, dependencies?) \n\nCall useLayoutEffect to perform the layout measurements before the browser repaints the screen:\n\nimport { useState, useRef, useLayoutEffect } from 'react';\n\n\n\nfunction Tooltip() {\n\n  const ref = useRef(null);\n\n  const [tooltipHeight, setTooltipHeight] = useState(0);\n\n\n\n  useLayoutEffect(() => {\n\n    const { height } = ref.current.getBoundingClientRect();\n\n    setTooltipHeight(height);\n\n  }, []);\n\n  // ...\n\nSee more examples below.\n\nParameters \n\nsetup: The function with your Effect‚Äôs logic. Your setup function may also optionally return a cleanup function. Before your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. Before your component is removed from the DOM, React will run your cleanup function.\n\noptional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If you omit this argument, your Effect will re-run after every re-render of the component.\n\nReturns \n\nuseLayoutEffect returns undefined.\n\nCaveats \n\nuseLayoutEffect is a Hook, so you can only call it at the top level of your component or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a component and move the Effect there.\n\nWhen Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic ‚Äúmirrors‚Äù your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.\n\nIf some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect.\n\nEffects only run on the client. They don‚Äôt run during server rendering.\n\nThe code inside useLayoutEffect and all state updates scheduled from it block the browser from repainting the screen. When used excessively, this makes your app slow. When possible, prefer useEffect.\n\nIf you trigger a state update inside useLayoutEffect, React will execute all remaining Effects immediately including useEffect.\n\nUsage \nMeasuring layout before the browser repaints the screen \n\nMost components don‚Äôt need to know their position and size on the screen to decide what to render. They only return some JSX. Then the browser calculates their layout (position and size) and repaints the screen.\n\nSometimes, that‚Äôs not enough. Imagine a tooltip that appears next to some element on hover. If there‚Äôs enough space, the tooltip should appear above the element, but if it doesn‚Äôt fit, it should appear below. In order to render the tooltip at the right final position, you need to know its height (i.e. whether it fits at the top).\n\nTo do this, you need to render in two passes:\n\nRender the tooltip anywhere (even with a wrong position).\nMeasure its height and decide where to place the tooltip.\nRender the tooltip again in the correct place.\n\nAll of this needs to happen before the browser repaints the screen. You don‚Äôt want the user to see the tooltip moving. Call useLayoutEffect to perform the layout measurements before the browser repaints the screen:\n\nfunction Tooltip() {\n\n  const ref = useRef(null);\n\n  const [tooltipHeight, setTooltipHeight] = useState(0); // You don't know real height yet\n\n\n\n  useLayoutEffect(() => {\n\n    const { height } = ref.current.getBoundingClientRect();\n\n    setTooltipHeight(height); // Re-render now that you know the real height\n\n  }, []);\n\n\n\n  // ...use tooltipHeight in the rendering logic below...\n\n}\n\nHere‚Äôs how this works step by step:\n\nTooltip renders with the initial tooltipHeight = 0 (so the tooltip may be wrongly positioned).\nReact places it in the DOM and runs the code in useLayoutEffect.\nYour useLayoutEffect measures the height of the tooltip content and triggers an immediate re-render.\nTooltip renders again with the real tooltipHeight (so the tooltip is correctly positioned).\nReact updates it in the DOM, and the browser finally displays the tooltip.\n\nHover over the buttons below and see how the tooltip adjusts its position depending on whether it fits:\n\nApp.js\nButtonWithTooltip.js\nTooltip.js\nTooltipContainer.js\nReload\nClear\nFork\nimport { useRef, useLayoutEffect, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport TooltipContainer from './TooltipContainer.js';\n\nexport default function Tooltip({ children, targetRect }) {\n  const ref = useRef(null);\n  const [tooltipHeight, setTooltipHeight] = useState(0);\n\n  useLayoutEffect(() => {\n    const { height } = ref.current.getBoundingClientRect();\n    setTooltipHeight(height);\n    console.log('Measured tooltip height: ' + height);\n  }, []);\n\n  let tooltipX = 0;\n  let tooltipY = 0;\n  if (targetRect !== null) {\n    tooltipX = targetRect.left;\n    tooltipY = targetRect.top - tooltipHeight;\n    if (tooltipY < 0) {\n      // It doesn't fit above, so place below.\n      tooltipY = targetRect.bottom;\n    }\n  }\n\n  return createPortal(\n    <TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}>\n      {children}\n    </TooltipContainer>,\n    document.body\n  );\n}\n\n\nShow more\n\nNotice that even though the Tooltip component has to render in two passes (first, with tooltipHeight initialized to 0 and then with the real measured height), you only see the final result. This is why you need useLayoutEffect instead of useEffect for this example. Let‚Äôs look at the difference in detail below.\n\nuseLayoutEffect vs useEffect\n1. useLayoutEffect blocks the browser from repainting\n2. useEffect does not block the browser\nExample 1 of 2: useLayoutEffect blocks the browser from repainting \n\nReact guarantees that the code inside useLayoutEffect and any state updates scheduled inside it will be processed before the browser repaints the screen. This lets you render the tooltip, measure it, and re-render the tooltip again without the user noticing the first extra render. In other words, useLayoutEffect blocks the browser from painting.\n\nApp.js\nButtonWithTooltip.js\nTooltip.js\nTooltipContainer.js\nReload\nClear\nFork\nimport { useRef, useLayoutEffect, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport TooltipContainer from './TooltipContainer.js';\n\nexport default function Tooltip({ children, targetRect }) {\n  const ref = useRef(null);\n  const [tooltipHeight, setTooltipHeight] = useState(0);\n\n  useLayoutEffect(() => {\n    const { height } = ref.current.getBoundingClientRect();\n    setTooltipHeight(height);\n  }, []);\n\n  let tooltipX = 0;\n  let tooltipY = 0;\n  if (targetRect !== null) {\n    tooltipX = targetRect.left;\n    tooltipY = targetRect.top - tooltipHeight;\n    if (tooltipY < 0) {\n      // It doesn't fit above, so place below.\n      tooltipY = targetRect.bottom;\n    }\n  }\n\n  return createPortal(\n    <TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}>\n      {children}\n    </TooltipContainer>,\n    document.body\n  );\n}\n\n\nShow more\nNext Example\nNote\n\nRendering in two passes and blocking the browser hurts performance. Try to avoid this when you can.\n\nTroubleshooting \nI‚Äôm getting an error: ‚ÄúuseLayoutEffect does nothing on the server‚Äù \n\nThe purpose of useLayoutEffect is to let your component use layout information for rendering:\n\nRender the initial content.\nMeasure the layout before the browser repaints the screen.\nRender the final content using the layout information you‚Äôve read.\n\nWhen you or your framework uses server rendering, your React app renders to HTML on the server for the initial render. This lets you show the initial HTML before the JavaScript code loads.\n\nThe problem is that on the server, there is no layout information.\n\nIn the earlier example, the useLayoutEffect call in the Tooltip component lets it position itself correctly (either above or below content) depending on the content height. If you tried to render Tooltip as a part of the initial server HTML, this would be impossible to determine. On the server, there is no layout yet! So, even if you rendered it on the server, its position would ‚Äújump‚Äù on the client after the JavaScript loads and runs.\n\nUsually, components that rely on layout information don‚Äôt need to render on the server anyway. For example, it probably doesn‚Äôt make sense to show a Tooltip during the initial render. It is triggered by a client interaction.\n\nHowever, if you‚Äôre running into this problem, you have a few different options:\n\nReplace useLayoutEffect with useEffect. This tells React that it‚Äôs okay to display the initial render result without blocking the paint (because the original HTML will become visible before your Effect runs).\n\nAlternatively, mark your component as client-only. This tells React to replace its content up to the closest <Suspense> boundary with a loading fallback (for example, a spinner or a glimmer) during server rendering.\n\nAlternatively, you can render a component with useLayoutEffect only after hydration. Keep a boolean isMounted state that‚Äôs initialized to false, and set it to true inside a useEffect call. Your rendering logic can then be like return isMounted ? <RealContent /> : <FallbackContent />. On the server and during the hydration, the user will see FallbackContent which should not call useLayoutEffect. Then React will replace it with RealContent which runs on the client only and can include useLayoutEffect calls.\n\nIf you synchronize your component with an external data store and rely on useLayoutEffect for different reasons than measuring layout, consider useSyncExternalStore instead which supports server rendering.\n\nPREVIOUS\nuseInsertionEffect\nNEXT\nuseMemo"
  },
  {
    "title": "useMemo ‚Äì React",
    "url": "https://react.dev/reference/react/useMemo",
    "html": "API REFERENCE\nHOOKS\nuseMemo\n\nuseMemo is a React Hook that lets you cache the result of a calculation between re-renders.\n\nconst cachedValue = useMemo(calculateValue, dependencies)\nNote\n\nReact Compiler automatically memoizes values and functions, reducing the need for manual useMemo calls. You can use the compiler to handle memoization automatically.\n\nReference\nuseMemo(calculateValue, dependencies)\nUsage\nSkipping expensive recalculations\nSkipping re-rendering of components\nPreventing an Effect from firing too often\nMemoizing a dependency of another Hook\nMemoizing a function\nTroubleshooting\nMy calculation runs twice on every re-render\nMy useMemo call is supposed to return an object, but returns undefined\nEvery time my component renders, the calculation in useMemo re-runs\nI need to call useMemo for each list item in a loop, but it‚Äôs not allowed\nReference \nuseMemo(calculateValue, dependencies) \n\nCall useMemo at the top level of your component to cache a calculation between re-renders:\n\nimport { useMemo } from 'react';\n\n\n\nfunction TodoList({ todos, tab }) {\n\n  const visibleTodos = useMemo(\n\n    () => filterTodos(todos, tab),\n\n    [todos, tab]\n\n  );\n\n  // ...\n\n}\n\nSee more examples below.\n\nParameters \n\ncalculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later.\n\ndependencies: The list of all reactive values referenced inside of the calculateValue code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison.\n\nReturns \n\nOn the initial render, useMemo returns the result of calling calculateValue with no arguments.\n\nDuring next renders, it will either return an already stored value from the last render (if the dependencies haven‚Äôt changed), or call calculateValue again, and return the result that calculateValue has returned.\n\nCaveats \nuseMemo is a Hook, so you can only call it at the top level of your component or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.\nIn Strict Mode, React will call your calculation function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your calculation function is pure (as it should be), this should not affect your logic. The result from one of the calls will be ignored.\nReact will not throw away the cached value unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache‚Äîfor example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should be fine if you rely on useMemo solely as a performance optimization. Otherwise, a state variable or a ref may be more appropriate.\nNote\n\nCaching return values like this is also known as memoization, which is why this Hook is called useMemo.\n\nUsage \nSkipping expensive recalculations \n\nTo cache a calculation between re-renders, wrap it in a useMemo call at the top level of your component:\n\nimport { useMemo } from 'react';\n\n\n\nfunction TodoList({ todos, tab, theme }) {\n\n  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n\n  // ...\n\n}\n\nYou need to pass two things to useMemo:\n\nA calculation function that takes no arguments, like () =>, and returns what you wanted to calculate.\nA list of dependencies including every value within your component that‚Äôs used inside your calculation.\n\nOn the initial render, the value you‚Äôll get from useMemo will be the result of calling your calculation.\n\nOn every subsequent render, React will compare the dependencies with the dependencies you passed during the last render. If none of the dependencies have changed (compared with Object.is), useMemo will return the value you already calculated before. Otherwise, React will re-run your calculation and return the new value.\n\nIn other words, useMemo caches a calculation result between re-renders until its dependencies change.\n\nLet‚Äôs walk through an example to see when this is useful.\n\nBy default, React will re-run the entire body of your component every time that it re-renders. For example, if this TodoList updates its state or receives new props from its parent, the filterTodos function will re-run:\n\nfunction TodoList({ todos, tab, theme }) {\n\n  const visibleTodos = filterTodos(todos, tab);\n\n  // ...\n\n}\n\nUsually, this isn‚Äôt a problem because most calculations are very fast. However, if you‚Äôre filtering or transforming a large array, or doing some expensive computation, you might want to skip doing it again if data hasn‚Äôt changed. If both todos and tab are the same as they were during the last render, wrapping the calculation in useMemo like earlier lets you reuse visibleTodos you‚Äôve already calculated before.\n\nThis type of caching is called memoization.\n\nNote\n\nYou should only rely on useMemo as a performance optimization. If your code doesn‚Äôt work without it, find the underlying problem and fix it first. Then you may add useMemo to improve performance.\n\nDEEP DIVE\nHow to tell if a calculation is expensive? \nShow Details\nDEEP DIVE\nShould you add useMemo everywhere? \nShow Details\nThe difference between useMemo and calculating a value directly\n1. Skipping recalculation with useMemo\n2. Always recalculating a value\nExample 1 of 2: Skipping recalculation with useMemo \n\nIn this example, the filterTodos implementation is artificially slowed down so that you can see what happens when some JavaScript function you‚Äôre calling during rendering is genuinely slow. Try switching the tabs and toggling the theme.\n\nSwitching the tabs feels slow because it forces the slowed down filterTodos to re-execute. That‚Äôs expected because the tab has changed, and so the entire calculation needs to re-run. (If you‚Äôre curious why it runs twice, it‚Äôs explained here.)\n\nToggle the theme. Thanks to useMemo, it‚Äôs fast despite the artificial slowdown! The slow filterTodos call was skipped because both todos and tab (which you pass as dependencies to useMemo) haven‚Äôt changed since the last render.\n\nApp.js\nTodoList.js\nutils.js\nReload\nClear\nFork\nimport { useMemo } from 'react';\nimport { filterTodos } from './utils.js'\n\nexport default function TodoList({ todos, theme, tab }) {\n  const visibleTodos = useMemo(\n    () => filterTodos(todos, tab),\n    [todos, tab]\n  );\n  return (\n    <div className={theme}>\n      <p><b>Note: <code>filterTodos</code> is artificially slowed down!</b></p>\n      <ul>\n        {visibleTodos.map(todo => (\n          <li key={todo.id}>\n            {todo.completed ?\n              <s>{todo.text}</s> :\n              todo.text\n            }\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n\nShow more\nNext Example\nSkipping re-rendering of components \n\nIn some cases, useMemo can also help you optimize performance of re-rendering child components. To illustrate this, let‚Äôs say this TodoList component passes the visibleTodos as a prop to the child List component:\n\nexport default function TodoList({ todos, tab, theme }) {\n\n  // ...\n\n  return (\n\n    <div className={theme}>\n\n      <List items={visibleTodos} />\n\n    </div>\n\n  );\n\n}\n\nYou‚Äôve noticed that toggling the theme prop freezes the app for a moment, but if you remove <List /> from your JSX, it feels fast. This tells you that it‚Äôs worth trying to optimize the List component.\n\nBy default, when a component re-renders, React re-renders all of its children recursively. This is why, when TodoList re-renders with a different theme, the List component also re-renders. This is fine for components that don‚Äôt require much calculation to re-render. But if you‚Äôve verified that a re-render is slow, you can tell List to skip re-rendering when its props are the same as on last render by wrapping it in memo:\n\nimport { memo } from 'react';\n\n\n\nconst List = memo(function List({ items }) {\n\n  // ...\n\n});\n\nWith this change, List will skip re-rendering if all of its props are the same as on the last render. This is where caching the calculation becomes important! Imagine that you calculated visibleTodos without useMemo:\n\nexport default function TodoList({ todos, tab, theme }) {\n\n  // Every time the theme changes, this will be a different array...\n\n  const visibleTodos = filterTodos(todos, tab);\n\n  return (\n\n    <div className={theme}>\n\n      {/* ... so List's props will never be the same, and it will re-render every time */}\n\n      <List items={visibleTodos} />\n\n    </div>\n\n  );\n\n}\n\nIn the above example, the filterTodos function always creates a different array, similar to how the {} object literal always creates a new object. Normally, this wouldn‚Äôt be a problem, but it means that List props will never be the same, and your memo optimization won‚Äôt work. This is where useMemo comes in handy:\n\nexport default function TodoList({ todos, tab, theme }) {\n\n  // Tell React to cache your calculation between re-renders...\n\n  const visibleTodos = useMemo(\n\n    () => filterTodos(todos, tab),\n\n    [todos, tab] // ...so as long as these dependencies don't change...\n\n  );\n\n  return (\n\n    <div className={theme}>\n\n      {/* ...List will receive the same props and can skip re-rendering */}\n\n      <List items={visibleTodos} />\n\n    </div>\n\n  );\n\n}\n\nBy wrapping the visibleTodos calculation in useMemo, you ensure that it has the same value between the re-renders (until dependencies change). You don‚Äôt have to wrap a calculation in useMemo unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo, and this lets it skip re-rendering. There are a few other reasons to add useMemo which are described further on this page.\n\nDEEP DIVE\nMemoizing individual JSX nodes \nShow Details\nThe difference between skipping re-renders and always re-rendering\n1. Skipping re-rendering with useMemo and memo\n2. Always re-rendering a component\nExample 1 of 2: Skipping re-rendering with useMemo and memo \n\nIn this example, the List component is artificially slowed down so that you can see what happens when a React component you‚Äôre rendering is genuinely slow. Try switching the tabs and toggling the theme.\n\nSwitching the tabs feels slow because it forces the slowed down List to re-render. That‚Äôs expected because the tab has changed, and so you need to reflect the user‚Äôs new choice on the screen.\n\nNext, try toggling the theme. Thanks to useMemo together with memo, it‚Äôs fast despite the artificial slowdown! The List skipped re-rendering because the visibleTodos array has not changed since the last render. The visibleTodos array has not changed because both todos and tab (which you pass as dependencies to useMemo) haven‚Äôt changed since the last render.\n\nApp.js\nTodoList.js\nList.js\nutils.js\nReload\nClear\nFork\nimport { useMemo } from 'react';\nimport List from './List.js';\nimport { filterTodos } from './utils.js'\n\nexport default function TodoList({ todos, theme, tab }) {\n  const visibleTodos = useMemo(\n    () => filterTodos(todos, tab),\n    [todos, tab]\n  );\n  return (\n    <div className={theme}>\n      <p><b>Note: <code>List</code> is artificially slowed down!</b></p>\n      <List items={visibleTodos} />\n    </div>\n  );\n}\n\n\nShow more\nNext Example\nPreventing an Effect from firing too often \n\nSometimes, you might want to use a value inside an Effect:\n\nfunction ChatRoom({ roomId }) {\n\n  const [message, setMessage] = useState('');\n\n\n\n  const options = {\n\n    serverUrl: 'https://localhost:1234',\n\n    roomId: roomId\n\n  }\n\n\n\n  useEffect(() => {\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    // ...\n\nThis creates a problem. Every reactive value must be declared as a dependency of your Effect. However, if you declare options as a dependency, it will cause your Effect to constantly reconnect to the chat room:\n\n  useEffect(() => {\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [options]); // üî¥ Problem: This dependency changes on every render\n\n  // ...\n\nTo solve this, you can wrap the object you need to call from an Effect in useMemo:\n\nfunction ChatRoom({ roomId }) {\n\n  const [message, setMessage] = useState('');\n\n\n\n  const options = useMemo(() => {\n\n    return {\n\n      serverUrl: 'https://localhost:1234',\n\n      roomId: roomId\n\n    };\n\n  }, [roomId]); // ‚úÖ Only changes when roomId changes\n\n\n\n  useEffect(() => {\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [options]); // ‚úÖ Only changes when options changes\n\n  // ...\n\nThis ensures that the options object is the same between re-renders if useMemo returns the cached object.\n\nHowever, since useMemo is performance optimization, not a semantic guarantee, React may throw away the cached value if there is a specific reason to do that. This will also cause the effect to re-fire, so it‚Äôs even better to remove the need for a function dependency by moving your object inside the Effect:\n\nfunction ChatRoom({ roomId }) {\n\n  const [message, setMessage] = useState('');\n\n\n\n  useEffect(() => {\n\n    const options = { // ‚úÖ No need for useMemo or object dependencies!\n\n      serverUrl: 'https://localhost:1234',\n\n      roomId: roomId\n\n    }\n\n\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [roomId]); // ‚úÖ Only changes when roomId changes\n\n  // ...\n\nNow your code is simpler and doesn‚Äôt need useMemo. Learn more about removing Effect dependencies.\n\nMemoizing a dependency of another Hook \n\nSuppose you have a calculation that depends on an object created directly in the component body:\n\nfunction Dropdown({ allItems, text }) {\n\n  const searchOptions = { matchMode: 'whole-word', text };\n\n\n\n  const visibleItems = useMemo(() => {\n\n    return searchItems(allItems, searchOptions);\n\n  }, [allItems, searchOptions]); // üö© Caution: Dependency on an object created in the component body\n\n  // ...\n\nDepending on an object like this defeats the point of memoization. When a component re-renders, all of the code directly inside the component body runs again. The lines of code creating the searchOptions object will also run on every re-render. Since searchOptions is a dependency of your useMemo call, and it‚Äôs different every time, React knows the dependencies are different, and recalculate searchItems every time.\n\nTo fix this, you could memoize the searchOptions object itself before passing it as a dependency:\n\nfunction Dropdown({ allItems, text }) {\n\n  const searchOptions = useMemo(() => {\n\n    return { matchMode: 'whole-word', text };\n\n  }, [text]); // ‚úÖ Only changes when text changes\n\n\n\n  const visibleItems = useMemo(() => {\n\n    return searchItems(allItems, searchOptions);\n\n  }, [allItems, searchOptions]); // ‚úÖ Only changes when allItems or searchOptions changes\n\n  // ...\n\nIn the example above, if the text did not change, the searchOptions object also won‚Äôt change. However, an even better fix is to move the searchOptions object declaration inside of the useMemo calculation function:\n\nfunction Dropdown({ allItems, text }) {\n\n  const visibleItems = useMemo(() => {\n\n    const searchOptions = { matchMode: 'whole-word', text };\n\n    return searchItems(allItems, searchOptions);\n\n  }, [allItems, text]); // ‚úÖ Only changes when allItems or text changes\n\n  // ...\n\nNow your calculation depends on text directly (which is a string and can‚Äôt ‚Äúaccidentally‚Äù become different).\n\nMemoizing a function \n\nSuppose the Form component is wrapped in memo. You want to pass a function to it as a prop:\n\nexport default function ProductPage({ productId, referrer }) {\n\n  function handleSubmit(orderDetails) {\n\n    post('/product/' + productId + '/buy', {\n\n      referrer,\n\n      orderDetails\n\n    });\n\n  }\n\n\n\n  return <Form onSubmit={handleSubmit} />;\n\n}\n\nJust as {} creates a different object, function declarations like function() {} and expressions like () => {} produce a different function on every re-render. By itself, creating a new function is not a problem. This is not something to avoid! However, if the Form component is memoized, presumably you want to skip re-rendering it when no props have changed. A prop that is always different would defeat the point of memoization.\n\nTo memoize a function with useMemo, your calculation function would have to return another function:\n\nexport default function Page({ productId, referrer }) {\n\n  const handleSubmit = useMemo(() => {\n\n    return (orderDetails) => {\n\n      post('/product/' + productId + '/buy', {\n\n        referrer,\n\n        orderDetails\n\n      });\n\n    };\n\n  }, [productId, referrer]);\n\n\n\n  return <Form onSubmit={handleSubmit} />;\n\n}\n\nThis looks clunky! Memoizing functions is common enough that React has a built-in Hook specifically for that. Wrap your functions into useCallback instead of useMemo to avoid having to write an extra nested function:\n\nexport default function Page({ productId, referrer }) {\n\n  const handleSubmit = useCallback((orderDetails) => {\n\n    post('/product/' + productId + '/buy', {\n\n      referrer,\n\n      orderDetails\n\n    });\n\n  }, [productId, referrer]);\n\n\n\n  return <Form onSubmit={handleSubmit} />;\n\n}\n\nThe two examples above are completely equivalent. The only benefit to useCallback is that it lets you avoid writing an extra nested function inside. It doesn‚Äôt do anything else. Read more about useCallback.\n\nTroubleshooting \nMy calculation runs twice on every re-render \n\nIn Strict Mode, React will call some of your functions twice instead of once:\n\nfunction TodoList({ todos, tab }) {\n\n  // This component function will run twice for every render.\n\n\n\n  const visibleTodos = useMemo(() => {\n\n    // This calculation will run twice if any of the dependencies change.\n\n    return filterTodos(todos, tab);\n\n  }, [todos, tab]);\n\n\n\n  // ...\n\nThis is expected and shouldn‚Äôt break your code.\n\nThis development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component and calculation functions are pure, this shouldn‚Äôt affect your logic. However, if they are accidentally impure, this helps you notice and fix the mistake.\n\nFor example, this impure calculation function mutates an array you received as a prop:\n\n  const visibleTodos = useMemo(() => {\n\n    // üö© Mistake: mutating a prop\n\n    todos.push({ id: 'last', text: 'Go for a walk!' });\n\n    const filtered = filterTodos(todos, tab);\n\n    return filtered;\n\n  }, [todos, tab]);\n\nReact calls your function twice, so you‚Äôd notice the todo is added twice. Your calculation shouldn‚Äôt change any existing objects, but it‚Äôs okay to change any new objects you created during the calculation. For example, if the filterTodos function always returns a different array, you can mutate that array instead:\n\n  const visibleTodos = useMemo(() => {\n\n    const filtered = filterTodos(todos, tab);\n\n    // ‚úÖ Correct: mutating an object you created during the calculation\n\n    filtered.push({ id: 'last', text: 'Go for a walk!' });\n\n    return filtered;\n\n  }, [todos, tab]);\n\nRead keeping components pure to learn more about purity.\n\nAlso, check out the guides on updating objects and updating arrays without mutation.\n\nMy useMemo call is supposed to return an object, but returns undefined \n\nThis code doesn‚Äôt work:\n\n  // üî¥ You can't return an object from an arrow function with () => {\n\n  const searchOptions = useMemo(() => {\n\n    matchMode: 'whole-word',\n\n    text: text\n\n  }, [text]);\n\nIn JavaScript, () => { starts the arrow function body, so the { brace is not a part of your object. This is why it doesn‚Äôt return an object, and leads to mistakes. You could fix it by adding parentheses like ({ and }):\n\n  // This works, but is easy for someone to break again\n\n  const searchOptions = useMemo(() => ({\n\n    matchMode: 'whole-word',\n\n    text: text\n\n  }), [text]);\n\nHowever, this is still confusing and too easy for someone to break by removing the parentheses.\n\nTo avoid this mistake, write a return statement explicitly:\n\n  // ‚úÖ This works and is explicit\n\n  const searchOptions = useMemo(() => {\n\n    return {\n\n      matchMode: 'whole-word',\n\n      text: text\n\n    };\n\n  }, [text]);\nEvery time my component renders, the calculation in useMemo re-runs \n\nMake sure you‚Äôve specified the dependency array as a second argument!\n\nIf you forget the dependency array, useMemo will re-run the calculation every time:\n\nfunction TodoList({ todos, tab }) {\n\n  // üî¥ Recalculates every time: no dependency array\n\n  const visibleTodos = useMemo(() => filterTodos(todos, tab));\n\n  // ...\n\nThis is the corrected version passing the dependency array as a second argument:\n\nfunction TodoList({ todos, tab }) {\n\n  // ‚úÖ Does not recalculate unnecessarily\n\n  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n\n  // ...\n\nIf this doesn‚Äôt help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:\n\n  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n\n  console.log([todos, tab]);\n\nYou can then right-click on the arrays from different re-renders in the console and select ‚ÄúStore as a global variable‚Äù for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same:\n\nObject.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?\n\nObject.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?\n\nObject.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\n\nWhen you find which dependency breaks memoization, either find a way to remove it, or memoize it as well.\n\nI need to call useMemo for each list item in a loop, but it‚Äôs not allowed \n\nSuppose the Chart component is wrapped in memo. You want to skip re-rendering every Chart in the list when the ReportList component re-renders. However, you can‚Äôt call useMemo in a loop:\n\nfunction ReportList({ items }) {\n\n  return (\n\n    <article>\n\n      {items.map(item => {\n\n        // üî¥ You can't call useMemo in a loop like this:\n\n        const data = useMemo(() => calculateReport(item), [item]);\n\n        return (\n\n          <figure key={item.id}>\n\n            <Chart data={data} />\n\n          </figure>\n\n        );\n\n      })}\n\n    </article>\n\n  );\n\n}\n\nInstead, extract a component for each item and memoize data for individual items:\n\nfunction ReportList({ items }) {\n\n  return (\n\n    <article>\n\n      {items.map(item =>\n\n        <Report key={item.id} item={item} />\n\n      )}\n\n    </article>\n\n  );\n\n}\n\n\n\nfunction Report({ item }) {\n\n  // ‚úÖ Call useMemo at the top level:\n\n  const data = useMemo(() => calculateReport(item), [item]);\n\n  return (\n\n    <figure>\n\n      <Chart data={data} />\n\n    </figure>\n\n  );\n\n}\n\nAlternatively, you could remove useMemo and instead wrap Report itself in memo. If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too:\n\nfunction ReportList({ items }) {\n\n  // ...\n\n}\n\n\n\nconst Report = memo(function Report({ item }) {\n\n  const data = calculateReport(item);\n\n  return (\n\n    <figure>\n\n      <Chart data={data} />\n\n    </figure>\n\n  );\n\n});\nPREVIOUS\nuseLayoutEffect\nNEXT\nuseOptimistic"
  },
  {
    "title": "useOptimistic ‚Äì React",
    "url": "https://react.dev/reference/react/useOptimistic",
    "html": "API REFERENCE\nHOOKS\nuseOptimistic\n\nuseOptimistic is a React Hook that lets you optimistically update the UI.\n\n  const [optimisticState, addOptimistic] = useOptimistic(state, updateFn);\nReference\nuseOptimistic(state, updateFn)\nUsage\nOptimistically updating forms\nReference \nuseOptimistic(state, updateFn) \n\nuseOptimistic is a React Hook that lets you show a different state while an async action is underway. It accepts some state as an argument and returns a copy of that state that can be different during the duration of an async action such as a network request. You provide a function that takes the current state and the input to the action, and returns the optimistic state to be used while the action is pending.\n\nThis state is called the ‚Äúoptimistic‚Äù state because it is usually used to immediately present the user with the result of performing an action, even though the action actually takes time to complete.\n\nimport { useOptimistic } from 'react';\n\n\n\nfunction AppContainer() {\n\n  const [optimisticState, addOptimistic] = useOptimistic(\n\n    state,\n\n    // updateFn\n\n    (currentState, optimisticValue) => {\n\n      // merge and return new state\n\n      // with optimistic value\n\n    }\n\n  );\n\n}\n\nSee more examples below.\n\nParameters \nstate: the value to be returned initially and whenever no action is pending.\nupdateFn(currentState, optimisticValue): a function that takes the current state and the optimistic value passed to addOptimistic and returns the resulting optimistic state. It must be a pure function. updateFn takes in two parameters. The currentState and the optimisticValue. The return value will be the merged value of the currentState and optimisticValue.\nReturns \noptimisticState: The resulting optimistic state. It is equal to state unless an action is pending, in which case it is equal to the value returned by updateFn.\naddOptimistic: addOptimistic is the dispatching function to call when you have an optimistic update. It takes one argument, optimisticValue, of any type and will call the updateFn with state and optimisticValue.\nUsage \nOptimistically updating forms \n\nThe useOptimistic Hook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a user submits a form, instead of waiting for the server‚Äôs response to reflect the changes, the interface is immediately updated with the expected outcome.\n\nFor example, when a user types a message into the form and hits the ‚ÄúSend‚Äù button, the useOptimistic Hook allows the message to immediately appear in the list with a ‚ÄúSending‚Ä¶‚Äù label, even before the message is actually sent to a server. This ‚Äúoptimistic‚Äù approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the ‚ÄúSending‚Ä¶‚Äù label is removed.\n\nApp.js\nactions.js\nReload\nClear\nFork\nimport { useOptimistic, useState, useRef, startTransition } from \"react\";\nimport { deliverMessage } from \"./actions.js\";\n\nfunction Thread({ messages, sendMessageAction }) {\n  const formRef = useRef();\n  function formAction(formData) {\n    addOptimisticMessage(formData.get(\"message\"));\n    formRef.current.reset();\n    startTransition(async () => {\n      await sendMessageAction(formData);\n    });\n  }\n  const [optimisticMessages, addOptimisticMessage] = useOptimistic(\n    messages,\n    (state, newMessage) => [\n      {\n        text: newMessage,\n        sending: true\n      },\n      ...state,\n    ]\n  );\n\n  return (\n    <>\n      <form action={formAction} ref={formRef}>\n        <input type=\"text\" name=\"message\" placeholder=\"Hello!\" />\n        <button type=\"submit\">Send</button>\n      </form>\n      {optimisticMessages.map((message, index) => (\n        <div key={index}>\n          {message.text}\n          {!!message.sending && <small> (Sending...)</small>}\n        </div>\n      ))}\n      \n    </>\n  );\n}\n\nexport default function App() {\n  const [messages, setMessages] = useState([\n    { text: \"Hello there!\", sending: false, key: 1 }\n  ]);\n  async function sendMessageAction(formData) {\n    const sentMessage = await deliverMessage(formData.get(\"message\"));\n    startTransition(() => {\n      setMessages((messages) => [{ text: sentMessage }, ...messages]);\n    })\n  }\n  return <Thread messages={messages} sendMessageAction={sendMessageAction} />;\n}\n\n\nShow more\nPREVIOUS\nuseMemo\nNEXT\nuseReducer"
  },
  {
    "title": "useReducer ‚Äì React",
    "url": "https://react.dev/reference/react/useReducer",
    "html": "API REFERENCE\nHOOKS\nuseReducer\n\nuseReducer is a React Hook that lets you add a reducer to your component.\n\nconst [state, dispatch] = useReducer(reducer, initialArg, init?)\nReference\nuseReducer(reducer, initialArg, init?)\ndispatch function\nUsage\nAdding a reducer to a component\nWriting the reducer function\nAvoiding recreating the initial state\nTroubleshooting\nI‚Äôve dispatched an action, but logging gives me the old state value\nI‚Äôve dispatched an action, but the screen doesn‚Äôt update\nA part of my reducer state becomes undefined after dispatching\nMy entire reducer state becomes undefined after dispatching\nI‚Äôm getting an error: ‚ÄúToo many re-renders‚Äù\nMy reducer or initializer function runs twice\nReference \nuseReducer(reducer, initialArg, init?) \n\nCall useReducer at the top level of your component to manage its state with a reducer.\n\nimport { useReducer } from 'react';\n\n\n\nfunction reducer(state, action) {\n\n  // ...\n\n}\n\n\n\nfunction MyComponent() {\n\n  const [state, dispatch] = useReducer(reducer, { age: 42 });\n\n  // ...\n\nSee more examples below.\n\nParameters \nreducer: The reducer function that specifies how the state gets updated. It must be pure, should take the state and action as arguments, and should return the next state. State and action can be of any types.\ninitialArg: The value from which the initial state is calculated. It can be a value of any type. How the initial state is calculated from it depends on the next init argument.\noptional init: The initializer function that should return the initial state. If it‚Äôs not specified, the initial state is set to initialArg. Otherwise, the initial state is set to the result of calling init(initialArg).\nReturns \n\nuseReducer returns an array with exactly two values:\n\nThe current state. During the first render, it‚Äôs set to init(initialArg) or initialArg (if there‚Äôs no init).\nThe dispatch function that lets you update the state to a different value and trigger a re-render.\nCaveats \nuseReducer is a Hook, so you can only call it at the top level of your component or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.\nThe dispatch function has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. Learn more about removing Effect dependencies.\nIn Strict Mode, React will call your reducer and initializer twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your reducer and initializer are pure (as they should be), this should not affect your logic. The result from one of the calls is ignored.\ndispatch function \n\nThe dispatch function returned by useReducer lets you update the state to a different value and trigger a re-render. You need to pass the action as the only argument to the dispatch function:\n\nconst [state, dispatch] = useReducer(reducer, { age: 42 });\n\n\n\nfunction handleClick() {\n\n  dispatch({ type: 'incremented_age' });\n\n  // ...\n\nReact will set the next state to the result of calling the reducer function you‚Äôve provided with the current state and the action you‚Äôve passed to dispatch.\n\nParameters \naction: The action performed by the user. It can be a value of any type. By convention, an action is usually an object with a type property identifying it and, optionally, other properties with additional information.\nReturns \n\ndispatch functions do not have a return value.\n\nCaveats \n\nThe dispatch function only updates the state variable for the next render. If you read the state variable after calling the dispatch function, you will still get the old value that was on the screen before your call.\n\nIf the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. React may still need to call your component before ignoring the result, but it shouldn‚Äôt affect your code.\n\nReact batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync.\n\nUsage \nAdding a reducer to a component \n\nCall useReducer at the top level of your component to manage state with a reducer.\n\nimport { useReducer } from 'react';\n\n\n\nfunction reducer(state, action) {\n\n  // ...\n\n}\n\n\n\nfunction MyComponent() {\n\n  const [state, dispatch] = useReducer(reducer, { age: 42 });\n\n  // ...\n\nuseReducer returns an array with exactly two items:\n\nThe current state of this state variable, initially set to the initial state you provided.\nThe dispatch function that lets you change it in response to interaction.\n\nTo update what‚Äôs on the screen, call dispatch with an object representing what the user did, called an action:\n\nfunction handleClick() {\n\n  dispatch({ type: 'incremented_age' });\n\n}\n\nReact will pass the current state and the action to your reducer function. Your reducer will calculate and return the next state. React will store that next state, render your component with it, and update the UI.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useReducer } from 'react';\n\nfunction reducer(state, action) {\n  if (action.type === 'incremented_age') {\n    return {\n      age: state.age + 1\n    };\n  }\n  throw Error('Unknown action.');\n}\n\nexport default function Counter() {\n  const [state, dispatch] = useReducer(reducer, { age: 42 });\n\n  return (\n    <>\n      <button onClick={() => {\n        dispatch({ type: 'incremented_age' })\n      }}>\n        Increment age\n      </button>\n      <p>Hello! You are {state.age}.</p>\n    </>\n  );\n}\n\n\nShow more\n\nuseReducer is very similar to useState, but it lets you move the state update logic from event handlers into a single function outside of your component. Read more about choosing between useState and useReducer.\n\nWriting the reducer function \n\nA reducer function is declared like this:\n\nfunction reducer(state, action) {\n\n  // ...\n\n}\n\nThen you need to fill in the code that will calculate and return the next state. By convention, it is common to write it as a switch statement. For each case in the switch, calculate and return some next state.\n\nfunction reducer(state, action) {\n\n  switch (action.type) {\n\n    case 'incremented_age': {\n\n      return {\n\n        name: state.name,\n\n        age: state.age + 1\n\n      };\n\n    }\n\n    case 'changed_name': {\n\n      return {\n\n        name: action.nextName,\n\n        age: state.age\n\n      };\n\n    }\n\n  }\n\n  throw Error('Unknown action: ' + action.type);\n\n}\n\nActions can have any shape. By convention, it‚Äôs common to pass objects with a type property identifying the action. It should include the minimal necessary information that the reducer needs to compute the next state.\n\nfunction Form() {\n\n  const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });\n\n  \n\n  function handleButtonClick() {\n\n    dispatch({ type: 'incremented_age' });\n\n  }\n\n\n\n  function handleInputChange(e) {\n\n    dispatch({\n\n      type: 'changed_name',\n\n      nextName: e.target.value\n\n    });\n\n  }\n\n  // ...\n\nThe action type names are local to your component. Each action describes a single interaction, even if that leads to multiple changes in data. The shape of the state is arbitrary, but usually it‚Äôll be an object or an array.\n\nRead extracting state logic into a reducer to learn more.\n\nPitfall\n\nState is read-only. Don‚Äôt modify any objects or arrays in state:\n\nfunction reducer(state, action) {\n\n  switch (action.type) {\n\n    case 'incremented_age': {\n\n      // üö© Don't mutate an object in state like this:\n\n      state.age = state.age + 1;\n\n      return state;\n\n    }\n\nInstead, always return new objects from your reducer:\n\nfunction reducer(state, action) {\n\n  switch (action.type) {\n\n    case 'incremented_age': {\n\n      // ‚úÖ Instead, return a new object\n\n      return {\n\n        ...state,\n\n        age: state.age + 1\n\n      };\n\n    }\n\nRead updating objects in state and updating arrays in state to learn more.\n\nBasic useReducer examples\n1. Form (object)\n2. Todo list (array)\n3. Writing concise update logic with Immer\nExample 1 of 3: Form (object) \n\nIn this example, the reducer manages a state object with two fields: name and age.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useReducer } from 'react';\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'incremented_age': {\n      return {\n        name: state.name,\n        age: state.age + 1\n      };\n    }\n    case 'changed_name': {\n      return {\n        name: action.nextName,\n        age: state.age\n      };\n    }\n  }\n  throw Error('Unknown action: ' + action.type);\n}\n\nconst initialState = { name: 'Taylor', age: 42 };\n\nexport default function Form() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  function handleButtonClick() {\n    dispatch({ type: 'incremented_age' });\n  }\n\n  function handleInputChange(e) {\n    dispatch({\n      type: 'changed_name',\n      nextName: e.target.value\n    }); \n  }\n\n  return (\n    <>\n      <input\n        value={state.name}\n        onChange={handleInputChange}\n      />\n      <button onClick={handleButtonClick}>\n        Increment age\n      </button>\n      <p>Hello, {state.name}. You are {state.age}.</p>\n    </>\n  );\n}\n\n\nShow more\nNext Example\nAvoiding recreating the initial state \n\nReact saves the initial state once and ignores it on the next renders.\n\nfunction createInitialState(username) {\n\n  // ...\n\n}\n\n\n\nfunction TodoList({ username }) {\n\n  const [state, dispatch] = useReducer(reducer, createInitialState(username));\n\n  // ...\n\nAlthough the result of createInitialState(username) is only used for the initial render, you‚Äôre still calling this function on every render. This can be wasteful if it‚Äôs creating large arrays or performing expensive calculations.\n\nTo solve this, you may pass it as an initializer function to useReducer as the third argument instead:\n\nfunction createInitialState(username) {\n\n  // ...\n\n}\n\n\n\nfunction TodoList({ username }) {\n\n  const [state, dispatch] = useReducer(reducer, username, createInitialState);\n\n  // ...\n\nNotice that you‚Äôre passing createInitialState, which is the function itself, and not createInitialState(), which is the result of calling it. This way, the initial state does not get re-created after initialization.\n\nIn the above example, createInitialState takes a username argument. If your initializer doesn‚Äôt need any information to compute the initial state, you may pass null as the second argument to useReducer.\n\nThe difference between passing an initializer and passing the initial state directly\n1. Passing the initializer function\n2. Passing the initial state directly\nExample 1 of 2: Passing the initializer function \n\nThis example passes the initializer function, so the createInitialState function only runs during initialization. It does not run when component re-renders, such as when you type into the input.\n\nTodoList.js\nReload\nClear\nFork\nimport { useReducer } from 'react';\n\nfunction createInitialState(username) {\n  const initialTodos = [];\n  for (let i = 0; i < 50; i++) {\n    initialTodos.push({\n      id: i,\n      text: username + \"'s task #\" + (i + 1)\n    });\n  }\n  return {\n    draft: '',\n    todos: initialTodos,\n  };\n}\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'changed_draft': {\n      return {\n        draft: action.nextDraft,\n        todos: state.todos,\n      };\n    };\n    case 'added_todo': {\n      return {\n        draft: '',\n        todos: [{\n          id: state.todos.length,\n          text: state.draft\n        }, ...state.todos]\n      }\n    }\n  }\n  throw Error('Unknown action: ' + action.type);\n}\n\nexport default function TodoList({ username }) {\n  const [state, dispatch] = useReducer(\n    reducer,\n    username,\n    createInitialState\n  );\n  return (\n    <>\n      <input\n        value={state.draft}\n        onChange={e => {\n          dispatch({\n            type: 'changed_draft',\n            nextDraft: e.target.value\n          })\n        }}\n      />\n      <button onClick={() => {\n        dispatch({ type: 'added_todo' });\n      }}>Add</button>\n      <ul>\n        {state.todos.map(item => (\n          <li key={item.id}>\n            {item.text}\n          </li>\n        ))}\n      </ul>\n    </>\n  );\n}\n\n\nShow more\nNext Example\nTroubleshooting \nI‚Äôve dispatched an action, but logging gives me the old state value \n\nCalling the dispatch function does not change state in the running code:\n\nfunction handleClick() {\n\n  console.log(state.age);  // 42\n\n\n\n  dispatch({ type: 'incremented_age' }); // Request a re-render with 43\n\n  console.log(state.age);  // Still 42!\n\n\n\n  setTimeout(() => {\n\n    console.log(state.age); // Also 42!\n\n  }, 5000);\n\n}\n\nThis is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the state JavaScript variable in your already-running event handler.\n\nIf you need to guess the next state value, you can calculate it manually by calling the reducer yourself:\n\nconst action = { type: 'incremented_age' };\n\ndispatch(action);\n\n\n\nconst nextState = reducer(state, action);\n\nconsole.log(state);     // { age: 42 }\n\nconsole.log(nextState); // { age: 43 }\nI‚Äôve dispatched an action, but the screen doesn‚Äôt update \n\nReact will ignore your update if the next state is equal to the previous state, as determined by an Object.is comparison. This usually happens when you change an object or an array in state directly:\n\nfunction reducer(state, action) {\n\n  switch (action.type) {\n\n    case 'incremented_age': {\n\n      // üö© Wrong: mutating existing object\n\n      state.age++;\n\n      return state;\n\n    }\n\n    case 'changed_name': {\n\n      // üö© Wrong: mutating existing object\n\n      state.name = action.nextName;\n\n      return state;\n\n    }\n\n    // ...\n\n  }\n\n}\n\nYou mutated an existing state object and returned it, so React ignored the update. To fix this, you need to ensure that you‚Äôre always updating objects in state and updating arrays in state instead of mutating them:\n\nfunction reducer(state, action) {\n\n  switch (action.type) {\n\n    case 'incremented_age': {\n\n      // ‚úÖ Correct: creating a new object\n\n      return {\n\n        ...state,\n\n        age: state.age + 1\n\n      };\n\n    }\n\n    case 'changed_name': {\n\n      // ‚úÖ Correct: creating a new object\n\n      return {\n\n        ...state,\n\n        name: action.nextName\n\n      };\n\n    }\n\n    // ...\n\n  }\n\n}\nA part of my reducer state becomes undefined after dispatching \n\nMake sure that every case branch copies all of the existing fields when returning the new state:\n\nfunction reducer(state, action) {\n\n  switch (action.type) {\n\n    case 'incremented_age': {\n\n      return {\n\n        ...state, // Don't forget this!\n\n        age: state.age + 1\n\n      };\n\n    }\n\n    // ...\n\nWithout ...state above, the returned next state would only contain the age field and nothing else.\n\nMy entire reducer state becomes undefined after dispatching \n\nIf your state unexpectedly becomes undefined, you‚Äôre likely forgetting to return state in one of the cases, or your action type doesn‚Äôt match any of the case statements. To find why, throw an error outside the switch:\n\nfunction reducer(state, action) {\n\n  switch (action.type) {\n\n    case 'incremented_age': {\n\n      // ...\n\n    }\n\n    case 'edited_name': {\n\n      // ...\n\n    }\n\n  }\n\n  throw Error('Unknown action: ' + action.type);\n\n}\n\nYou can also use a static type checker like TypeScript to catch such mistakes.\n\nI‚Äôm getting an error: ‚ÄúToo many re-renders‚Äù \n\nYou might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that you‚Äôre unconditionally dispatching an action during render, so your component enters a loop: render, dispatch (which causes a render), render, dispatch (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:\n\n// üö© Wrong: calls the handler during render\n\nreturn <button onClick={handleClick()}>Click me</button>\n\n\n\n// ‚úÖ Correct: passes down the event handler\n\nreturn <button onClick={handleClick}>Click me</button>\n\n\n\n// ‚úÖ Correct: passes down an inline function\n\nreturn <button onClick={(e) => handleClick(e)}>Click me</button>\n\nIf you can‚Äôt find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific dispatch function call responsible for the error.\n\nMy reducer or initializer function runs twice \n\nIn Strict Mode, React will call your reducer and initializer functions twice. This shouldn‚Äôt break your code.\n\nThis development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and reducer functions are pure, this shouldn‚Äôt affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.\n\nFor example, this impure reducer function mutates an array in state:\n\nfunction reducer(state, action) {\n\n  switch (action.type) {\n\n    case 'added_todo': {\n\n      // üö© Mistake: mutating state\n\n      state.todos.push({ id: nextId++, text: action.text });\n\n      return state;\n\n    }\n\n    // ...\n\n  }\n\n}\n\nBecause React calls your reducer function twice, you‚Äôll see the todo was added twice, so you‚Äôll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it:\n\nfunction reducer(state, action) {\n\n  switch (action.type) {\n\n    case 'added_todo': {\n\n      // ‚úÖ Correct: replacing with new state\n\n      return {\n\n        ...state,\n\n        todos: [\n\n          ...state.todos,\n\n          { id: nextId++, text: action.text }\n\n        ]\n\n      };\n\n    }\n\n    // ...\n\n  }\n\n}\n\nNow that this reducer function is pure, calling it an extra time doesn‚Äôt make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and reducer functions need to be pure. Event handlers don‚Äôt need to be pure, so React will never call your event handlers twice.\n\nRead keeping components pure to learn more.\n\nPREVIOUS\nuseOptimistic\nNEXT\nuseRef"
  },
  {
    "title": "useRef ‚Äì React",
    "url": "https://react.dev/reference/react/useRef",
    "html": "API REFERENCE\nHOOKS\nuseRef\n\nuseRef is a React Hook that lets you reference a value that‚Äôs not needed for rendering.\n\nconst ref = useRef(initialValue)\nReference\nuseRef(initialValue)\nUsage\nReferencing a value with a ref\nManipulating the DOM with a ref\nAvoiding recreating the ref contents\nTroubleshooting\nI can‚Äôt get a ref to a custom component\nReference \nuseRef(initialValue) \n\nCall useRef at the top level of your component to declare a ref.\n\nimport { useRef } from 'react';\n\n\n\nfunction MyComponent() {\n\n  const intervalRef = useRef(0);\n\n  const inputRef = useRef(null);\n\n  // ...\n\nSee more examples below.\n\nParameters \ninitialValue: The value you want the ref object‚Äôs current property to be initially. It can be a value of any type. This argument is ignored after the initial render.\nReturns \n\nuseRef returns an object with a single property:\n\ncurrent: Initially, it‚Äôs set to the initialValue you have passed. You can later set it to something else. If you pass the ref object to React as a ref attribute to a JSX node, React will set its current property.\n\nOn the next renders, useRef will return the same object.\n\nCaveats \nYou can mutate the ref.current property. Unlike state, it is mutable. However, if it holds an object that is used for rendering (for example, a piece of your state), then you shouldn‚Äôt mutate that object.\nWhen you change the ref.current property, React does not re-render your component. React is not aware of when you change it because a ref is a plain JavaScript object.\nDo not write or read ref.current during rendering, except for initialization. This makes your component‚Äôs behavior unpredictable.\nIn Strict Mode, React will call your component function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. Each ref object will be created twice, but one of the versions will be discarded. If your component function is pure (as it should be), this should not affect the behavior.\nUsage \nReferencing a value with a ref \n\nCall useRef at the top level of your component to declare one or more refs.\n\nimport { useRef } from 'react';\n\n\n\nfunction Stopwatch() {\n\n  const intervalRef = useRef(0);\n\n  // ...\n\nuseRef returns a ref object with a single current property initially set to the initial value you provided.\n\nOn the next renders, useRef will return the same object. You can change its current property to store information and read it later. This might remind you of state, but there is an important difference.\n\nChanging a ref does not trigger a re-render. This means refs are perfect for storing information that doesn‚Äôt affect the visual output of your component. For example, if you need to store an interval ID and retrieve it later, you can put it in a ref. To update the value inside the ref, you need to manually change its current property:\n\nfunction handleStartClick() {\n\n  const intervalId = setInterval(() => {\n\n    // ...\n\n  }, 1000);\n\n  intervalRef.current = intervalId;\n\n}\n\nLater, you can read that interval ID from the ref so that you can call clear that interval:\n\nfunction handleStopClick() {\n\n  const intervalId = intervalRef.current;\n\n  clearInterval(intervalId);\n\n}\n\nBy using a ref, you ensure that:\n\nYou can store information between re-renders (unlike regular variables, which reset on every render).\nChanging it does not trigger a re-render (unlike state variables, which trigger a re-render).\nThe information is local to each copy of your component (unlike the variables outside, which are shared).\n\nChanging a ref does not trigger a re-render, so refs are not appropriate for storing information you want to display on the screen. Use state for that instead. Read more about choosing between useRef and useState.\n\nExamples of referencing a value with useRef\n1. Click counter\n2. A stopwatch\nExample 1 of 2: Click counter \n\nThis component uses a ref to keep track of how many times the button was clicked. Note that it‚Äôs okay to use a ref instead of state here because the click count is only read and written in an event handler.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useRef } from 'react';\n\nexport default function Counter() {\n  let ref = useRef(0);\n\n  function handleClick() {\n    ref.current = ref.current + 1;\n    alert('You clicked ' + ref.current + ' times!');\n  }\n\n  return (\n    <button onClick={handleClick}>\n      Click me!\n    </button>\n  );\n}\n\n\nShow more\n\nIf you show {ref.current} in the JSX, the number won‚Äôt update on click. This is because setting ref.current does not trigger a re-render. Information that‚Äôs used for rendering should be state instead.\n\nNext Example\nPitfall\n\nDo not write or read ref.current during rendering.\n\nReact expects that the body of your component behaves like a pure function:\n\nIf the inputs (props, state, and context) are the same, it should return exactly the same JSX.\nCalling it in a different order or with different arguments should not affect the results of other calls.\n\nReading or writing a ref during rendering breaks these expectations.\n\nfunction MyComponent() {\n\n  // ...\n\n  // üö© Don't write a ref during rendering\n\n  myRef.current = 123;\n\n  // ...\n\n  // üö© Don't read a ref during rendering\n\n  return <h1>{myOtherRef.current}</h1>;\n\n}\n\nYou can read or write refs from event handlers or effects instead.\n\nfunction MyComponent() {\n\n  // ...\n\n  useEffect(() => {\n\n    // ‚úÖ You can read or write refs in effects\n\n    myRef.current = 123;\n\n  });\n\n  // ...\n\n  function handleClick() {\n\n    // ‚úÖ You can read or write refs in event handlers\n\n    doSomething(myOtherRef.current);\n\n  }\n\n  // ...\n\n}\n\nIf you have to read or write something during rendering, use state instead.\n\nWhen you break these rules, your component might still work, but most of the newer features we‚Äôre adding to React will rely on these expectations. Read more about keeping your components pure.\n\nManipulating the DOM with a ref \n\nIt‚Äôs particularly common to use a ref to manipulate the DOM. React has built-in support for this.\n\nFirst, declare a ref object with an initial value of null:\n\nimport { useRef } from 'react';\n\n\n\nfunction MyComponent() {\n\n  const inputRef = useRef(null);\n\n  // ...\n\nThen pass your ref object as the ref attribute to the JSX of the DOM node you want to manipulate:\n\n  // ...\n\n  return <input ref={inputRef} />;\n\nAfter React creates the DOM node and puts it on the screen, React will set the current property of your ref object to that DOM node. Now you can access the <input>‚Äôs DOM node and call methods like focus():\n\n  function handleClick() {\n\n    inputRef.current.focus();\n\n  }\n\nReact will set the current property back to null when the node is removed from the screen.\n\nRead more about manipulating the DOM with refs.\n\nExamples of manipulating the DOM with useRef\n1. Focusing a text input\n2. Scrolling an image into view\n3. Playing and pausing a video\n4. Exposing a ref to your own component\nExample 1 of 4: Focusing a text input \n\nIn this example, clicking the button will focus the input:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useRef } from 'react';\n\nexport default function Form() {\n  const inputRef = useRef(null);\n\n  function handleClick() {\n    inputRef.current.focus();\n  }\n\n  return (\n    <>\n      <input ref={inputRef} />\n      <button onClick={handleClick}>\n        Focus the input\n      </button>\n    </>\n  );\n}\n\n\nShow more\nNext Example\nAvoiding recreating the ref contents \n\nReact saves the initial ref value once and ignores it on the next renders.\n\nfunction Video() {\n\n  const playerRef = useRef(new VideoPlayer());\n\n  // ...\n\nAlthough the result of new VideoPlayer() is only used for the initial render, you‚Äôre still calling this function on every render. This can be wasteful if it‚Äôs creating expensive objects.\n\nTo solve it, you may initialize the ref like this instead:\n\nfunction Video() {\n\n  const playerRef = useRef(null);\n\n  if (playerRef.current === null) {\n\n    playerRef.current = new VideoPlayer();\n\n  }\n\n  // ...\n\nNormally, writing or reading ref.current during render is not allowed. However, it‚Äôs fine in this case because the result is always the same, and the condition only executes during initialization so it‚Äôs fully predictable.\n\nDEEP DIVE\nHow to avoid null checks when initializing useRef later \nShow Details\nTroubleshooting \nI can‚Äôt get a ref to a custom component \n\nIf you try to pass a ref to your own component like this:\n\nconst inputRef = useRef(null);\n\n\n\nreturn <MyInput ref={inputRef} />;\n\nYou might get an error in the console:\n\nConsole\nTypeError: Cannot read properties of null\n\nBy default, your own components don‚Äôt expose refs to the DOM nodes inside them.\n\nTo fix this, find the component that you want to get a ref to:\n\nexport default function MyInput({ value, onChange }) {\n\n  return (\n\n    <input\n\n      value={value}\n\n      onChange={onChange}\n\n    />\n\n  );\n\n}\n\nAnd then add ref to the list of props your component accepts and pass ref as a prop to the relevant child built-in component like this:\n\nfunction MyInput({ value, onChange, ref }) {\n\n  return (\n\n    <input\n\n      value={value}\n\n      onChange={onChange}\n\n      ref={ref}\n\n    />\n\n  );\n\n};\n\n\n\nexport default MyInput;\n\nThen the parent component can get a ref to it.\n\nRead more about accessing another component‚Äôs DOM nodes.\n\nPREVIOUS\nuseReducer\nNEXT\nuseState"
  },
  {
    "title": "useState ‚Äì React",
    "url": "https://react.dev/reference/react/useState",
    "html": "API REFERENCE\nHOOKS\nuseState\n\nuseState is a React Hook that lets you add a state variable to your component.\n\nconst [state, setState] = useState(initialState)\nReference\nuseState(initialState)\nset functions, like setSomething(nextState)\nUsage\nAdding state to a component\nUpdating state based on the previous state\nUpdating objects and arrays in state\nAvoiding recreating the initial state\nResetting state with a key\nStoring information from previous renders\nTroubleshooting\nI‚Äôve updated the state, but logging gives me the old value\nI‚Äôve updated the state, but the screen doesn‚Äôt update\nI‚Äôm getting an error: ‚ÄúToo many re-renders‚Äù\nMy initializer or updater function runs twice\nI‚Äôm trying to set state to a function, but it gets called instead\nReference \nuseState(initialState) \n\nCall useState at the top level of your component to declare a state variable.\n\nimport { useState } from 'react';\n\n\n\nfunction MyComponent() {\n\n  const [age, setAge] = useState(28);\n\n  const [name, setName] = useState('Taylor');\n\n  const [todos, setTodos] = useState(() => createTodos());\n\n  // ...\n\nThe convention is to name state variables like [something, setSomething] using array destructuring.\n\nSee more examples below.\n\nParameters \ninitialState: The value you want the state to be initially. It can be a value of any type, but there is a special behavior for functions. This argument is ignored after the initial render.\nIf you pass a function as initialState, it will be treated as an initializer function. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state. See an example below.\nReturns \n\nuseState returns an array with exactly two values:\n\nThe current state. During the first render, it will match the initialState you have passed.\nThe set function that lets you update the state to a different value and trigger a re-render.\nCaveats \nuseState is a Hook, so you can only call it at the top level of your component or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.\nIn Strict Mode, React will call your initializer function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.\nset functions, like setSomething(nextState) \n\nThe set function returned by useState lets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state:\n\nconst [name, setName] = useState('Edward');\n\n\n\nfunction handleClick() {\n\n  setName('Taylor');\n\n  setAge(a => a + 1);\n\n  // ...\nParameters \nnextState: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions.\nIf you pass a function as nextState, it will be treated as an updater function. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state. See an example below.\nReturns \n\nset functions do not have a return value.\n\nCaveats \n\nThe set function only updates the state variable for the next render. If you read the state variable after calling the set function, you will still get the old value that was on the screen before your call.\n\nIf the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn‚Äôt affect your code.\n\nReact batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync.\n\nThe set function has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. Learn more about removing Effect dependencies.\n\nCalling the set function during rendering is only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it to store information from the previous renders. See an example below.\n\nIn Strict Mode, React will call your updater function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.\n\nUsage \nAdding state to a component \n\nCall useState at the top level of your component to declare one or more state variables.\n\nimport { useState } from 'react';\n\n\n\nfunction MyComponent() {\n\n  const [age, setAge] = useState(42);\n\n  const [name, setName] = useState('Taylor');\n\n  // ...\n\nThe convention is to name state variables like [something, setSomething] using array destructuring.\n\nuseState returns an array with exactly two items:\n\nThe current state of this state variable, initially set to the initial state you provided.\nThe set function that lets you change it to any other value in response to interaction.\n\nTo update what‚Äôs on the screen, call the set function with some next state:\n\nfunction handleClick() {\n\n  setName('Robin');\n\n}\n\nReact will store the next state, render your component again with the new values, and update the UI.\n\nPitfall\n\nCalling the set function does not change the current state in the already executing code:\n\nfunction handleClick() {\n\n  setName('Robin');\n\n  console.log(name); // Still \"Taylor\"!\n\n}\n\nIt only affects what useState will return starting from the next render.\n\nBasic useState examples\n1. Counter (number)\n2. Text field (string)\n3. Checkbox (boolean)\n4. Form (two variables)\nExample 1 of 4: Counter (number) \n\nIn this example, the count state variable holds a number. Clicking the button increments it.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return (\n    <button onClick={handleClick}>\n      You pressed me {count} times\n    </button>\n  );\n}\n\n\nNext Example\nUpdating state based on the previous state \n\nSuppose the age is 42. This handler calls setAge(age + 1) three times:\n\nfunction handleClick() {\n\n  setAge(age + 1); // setAge(42 + 1)\n\n  setAge(age + 1); // setAge(42 + 1)\n\n  setAge(age + 1); // setAge(42 + 1)\n\n}\n\nHowever, after one click, age will only be 43 rather than 45! This is because calling the set function does not update the age state variable in the already running code. So each setAge(age + 1) call becomes setAge(43).\n\nTo solve this problem, you may pass an updater function to setAge instead of the next state:\n\nfunction handleClick() {\n\n  setAge(a => a + 1); // setAge(42 => 43)\n\n  setAge(a => a + 1); // setAge(43 => 44)\n\n  setAge(a => a + 1); // setAge(44 => 45)\n\n}\n\nHere, a => a + 1 is your updater function. It takes the pending state and calculates the next state from it.\n\nReact puts your updater functions in a queue. Then, during the next render, it will call them in the same order:\n\na => a + 1 will receive 42 as the pending state and return 43 as the next state.\na => a + 1 will receive 43 as the pending state and return 44 as the next state.\na => a + 1 will receive 44 as the pending state and return 45 as the next state.\n\nThere are no other queued updates, so React will store 45 as the current state in the end.\n\nBy convention, it‚Äôs common to name the pending state argument for the first letter of the state variable name, like a for age. However, you may also call it like prevAge or something else that you find clearer.\n\nReact may call your updaters twice in development to verify that they are pure.\n\nDEEP DIVE\nIs using an updater always preferred? \nShow Details\nThe difference between passing an updater and passing the next state directly\n1. Passing the updater function\n2. Passing the next state directly\nExample 1 of 2: Passing the updater function \n\nThis example passes the updater function, so the ‚Äú+3‚Äù button works.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [age, setAge] = useState(42);\n\n  function increment() {\n    setAge(a => a + 1);\n  }\n\n  return (\n    <>\n      <h1>Your age: {age}</h1>\n      <button onClick={() => {\n        increment();\n        increment();\n        increment();\n      }}>+3</button>\n      <button onClick={() => {\n        increment();\n      }}>+1</button>\n    </>\n  );\n}\n\n\nShow more\nNext Example\nUpdating objects and arrays in state \n\nYou can put objects and arrays into state. In React, state is considered read-only, so you should replace it rather than mutate your existing objects. For example, if you have a form object in state, don‚Äôt mutate it:\n\n// üö© Don't mutate an object in state like this:\n\nform.firstName = 'Taylor';\n\nInstead, replace the whole object by creating a new one:\n\n// ‚úÖ Replace state with a new object\n\nsetForm({\n\n  ...form,\n\n  firstName: 'Taylor'\n\n});\n\nRead updating objects in state and updating arrays in state to learn more.\n\nExamples of objects and arrays in state\n1. Form (object)\n2. Form (nested object)\n3. List (array)\n4. Writing concise update logic with Immer\nExample 1 of 4: Form (object) \n\nIn this example, the form state variable holds an object. Each input has a change handler that calls setForm with the next state of the entire form. The { ...form } spread syntax ensures that the state object is replaced rather than mutated.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Form() {\n  const [form, setForm] = useState({\n    firstName: 'Barbara',\n    lastName: 'Hepworth',\n    email: 'bhepworth@sculpture.com',\n  });\n\n  return (\n    <>\n      <label>\n        First name:\n        <input\n          value={form.firstName}\n          onChange={e => {\n            setForm({\n              ...form,\n              firstName: e.target.value\n            });\n          }}\n        />\n      </label>\n      <label>\n        Last name:\n        <input\n          value={form.lastName}\n          onChange={e => {\n            setForm({\n              ...form,\n              lastName: e.target.value\n            });\n          }}\n        />\n      </label>\n      <label>\n        Email:\n        <input\n          value={form.email}\n          onChange={e => {\n            setForm({\n              ...form,\n              email: e.target.value\n            });\n          }}\n        />\n      </label>\n      <p>\n        {form.firstName}{' '}\n        {form.lastName}{' '}\n        ({form.email})\n      </p>\n    </>\n  );\n}\n\n\nShow more\nNext Example\nAvoiding recreating the initial state \n\nReact saves the initial state once and ignores it on the next renders.\n\nfunction TodoList() {\n\n  const [todos, setTodos] = useState(createInitialTodos());\n\n  // ...\n\nAlthough the result of createInitialTodos() is only used for the initial render, you‚Äôre still calling this function on every render. This can be wasteful if it‚Äôs creating large arrays or performing expensive calculations.\n\nTo solve this, you may pass it as an initializer function to useState instead:\n\nfunction TodoList() {\n\n  const [todos, setTodos] = useState(createInitialTodos);\n\n  // ...\n\nNotice that you‚Äôre passing createInitialTodos, which is the function itself, and not createInitialTodos(), which is the result of calling it. If you pass a function to useState, React will only call it during initialization.\n\nReact may call your initializers twice in development to verify that they are pure.\n\nThe difference between passing an initializer and passing the initial state directly\n1. Passing the initializer function\n2. Passing the initial state directly\nExample 1 of 2: Passing the initializer function \n\nThis example passes the initializer function, so the createInitialTodos function only runs during initialization. It does not run when component re-renders, such as when you type into the input.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nfunction createInitialTodos() {\n  const initialTodos = [];\n  for (let i = 0; i < 50; i++) {\n    initialTodos.push({\n      id: i,\n      text: 'Item ' + (i + 1)\n    });\n  }\n  return initialTodos;\n}\n\nexport default function TodoList() {\n  const [todos, setTodos] = useState(createInitialTodos);\n  const [text, setText] = useState('');\n\n  return (\n    <>\n      <input\n        value={text}\n        onChange={e => setText(e.target.value)}\n      />\n      <button onClick={() => {\n        setText('');\n        setTodos([{\n          id: todos.length,\n          text: text\n        }, ...todos]);\n      }}>Add</button>\n      <ul>\n        {todos.map(item => (\n          <li key={item.id}>\n            {item.text}\n          </li>\n        ))}\n      </ul>\n    </>\n  );\n}\n\n\nShow more\nNext Example\nResetting state with a key \n\nYou‚Äôll often encounter the key attribute when rendering lists. However, it also serves another purpose.\n\nYou can reset a component‚Äôs state by passing a different key to a component. In this example, the Reset button changes the version state variable, which we pass as a key to the Form. When the key changes, React re-creates the Form component (and all of its children) from scratch, so its state gets reset.\n\nRead preserving and resetting state to learn more.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function App() {\n  const [version, setVersion] = useState(0);\n\n  function handleReset() {\n    setVersion(version + 1);\n  }\n\n  return (\n    <>\n      <button onClick={handleReset}>Reset</button>\n      <Form key={version} />\n    </>\n  );\n}\n\nfunction Form() {\n  const [name, setName] = useState('Taylor');\n\n  return (\n    <>\n      <input\n        value={name}\n        onChange={e => setName(e.target.value)}\n      />\n      <p>Hello, {name}.</p>\n    </>\n  );\n}\n\n\nShow more\nStoring information from previous renders \n\nUsually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering ‚Äî for example, you might want to change a state variable when a prop changes.\n\nIn most cases, you don‚Äôt need this:\n\nIf the value you need can be computed entirely from the current props or other state, remove that redundant state altogether. If you‚Äôre worried about recomputing too often, the useMemo Hook can help.\nIf you want to reset the entire component tree‚Äôs state, pass a different key to your component.\nIf you can, update all the relevant state in the event handlers.\n\nIn the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a set function while your component is rendering.\n\nHere‚Äôs an example. This CountLabel component displays the count prop passed to it:\n\nexport default function CountLabel({ count }) {\n\n  return <h1>{count}</h1>\n\n}\n\nSay you want to show whether the counter has increased or decreased since the last change. The count prop doesn‚Äôt tell you this ‚Äî you need to keep track of its previous value. Add the prevCount state variable to track it. Add another state variable called trend to hold whether the count has increased or decreased. Compare prevCount with count, and if they‚Äôre not equal, update both prevCount and trend. Now you can show both the current count prop and how it has changed since the last render.\n\nApp.js\nCountLabel.js\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function CountLabel({ count }) {\n  const [prevCount, setPrevCount] = useState(count);\n  const [trend, setTrend] = useState(null);\n  if (prevCount !== count) {\n    setPrevCount(count);\n    setTrend(count > prevCount ? 'increasing' : 'decreasing');\n  }\n  return (\n    <>\n      <h1>{count}</h1>\n      {trend && <p>The count is {trend}</p>}\n    </>\n  );\n}\n\n\nShow more\n\nNote that if you call a set function while rendering, it must be inside a condition like prevCount !== count, and there must be a call like setPrevCount(count) inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the currently rendering component like this. Calling the set function of another component during rendering is an error. Finally, your set call should still update state without mutation ‚Äî this doesn‚Äôt mean you can break other rules of pure functions.\n\nThis pattern can be hard to understand and is usually best avoided. However, it‚Äôs better than updating state in an effect. When you call the set function during render, React will re-render that component immediately after your component exits with a return statement, and before rendering the children. This way, children don‚Äôt need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an early return; to restart rendering earlier.\n\nTroubleshooting \nI‚Äôve updated the state, but logging gives me the old value \n\nCalling the set function does not change state in the running code:\n\nfunction handleClick() {\n\n  console.log(count);  // 0\n\n\n\n  setCount(count + 1); // Request a re-render with 1\n\n  console.log(count);  // Still 0!\n\n\n\n  setTimeout(() => {\n\n    console.log(count); // Also 0!\n\n  }, 5000);\n\n}\n\nThis is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the count JavaScript variable in your already-running event handler.\n\nIf you need to use the next state, you can save it in a variable before passing it to the set function:\n\nconst nextCount = count + 1;\n\nsetCount(nextCount);\n\n\n\nconsole.log(count);     // 0\n\nconsole.log(nextCount); // 1\nI‚Äôve updated the state, but the screen doesn‚Äôt update \n\nReact will ignore your update if the next state is equal to the previous state, as determined by an Object.is comparison. This usually happens when you change an object or an array in state directly:\n\nobj.x = 10;  // üö© Wrong: mutating existing object\n\nsetObj(obj); // üö© Doesn't do anything\n\nYou mutated an existing obj object and passed it back to setObj, so React ignored the update. To fix this, you need to ensure that you‚Äôre always replacing objects and arrays in state instead of mutating them:\n\n// ‚úÖ Correct: creating a new object\n\nsetObj({\n\n  ...obj,\n\n  x: 10\n\n});\nI‚Äôm getting an error: ‚ÄúToo many re-renders‚Äù \n\nYou might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that you‚Äôre unconditionally setting state during render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:\n\n// üö© Wrong: calls the handler during render\n\nreturn <button onClick={handleClick()}>Click me</button>\n\n\n\n// ‚úÖ Correct: passes down the event handler\n\nreturn <button onClick={handleClick}>Click me</button>\n\n\n\n// ‚úÖ Correct: passes down an inline function\n\nreturn <button onClick={(e) => handleClick(e)}>Click me</button>\n\nIf you can‚Äôt find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific set function call responsible for the error.\n\nMy initializer or updater function runs twice \n\nIn Strict Mode, React will call some of your functions twice instead of once:\n\nfunction TodoList() {\n\n  // This component function will run twice for every render.\n\n\n\n  const [todos, setTodos] = useState(() => {\n\n    // This initializer function will run twice during initialization.\n\n    return createTodos();\n\n  });\n\n\n\n  function handleClick() {\n\n    setTodos(prevTodos => {\n\n      // This updater function will run twice for every click.\n\n      return [...prevTodos, createTodo()];\n\n    });\n\n  }\n\n  // ...\n\nThis is expected and shouldn‚Äôt break your code.\n\nThis development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn‚Äôt affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.\n\nFor example, this impure updater function mutates an array in state:\n\nsetTodos(prevTodos => {\n\n  // üö© Mistake: mutating state\n\n  prevTodos.push(createTodo());\n\n});\n\nBecause React calls your updater function twice, you‚Äôll see the todo was added twice, so you‚Äôll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it:\n\nsetTodos(prevTodos => {\n\n  // ‚úÖ Correct: replacing with new state\n\n  return [...prevTodos, createTodo()];\n\n});\n\nNow that this updater function is pure, calling it an extra time doesn‚Äôt make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and updater functions need to be pure. Event handlers don‚Äôt need to be pure, so React will never call your event handlers twice.\n\nRead keeping components pure to learn more.\n\nI‚Äôm trying to set state to a function, but it gets called instead \n\nYou can‚Äôt put a function into state like this:\n\nconst [fn, setFn] = useState(someFunction);\n\n\n\nfunction handleClick() {\n\n  setFn(someOtherFunction);\n\n}\n\nBecause you‚Äôre passing a function, React assumes that someFunction is an initializer function, and that someOtherFunction is an updater function, so it tries to call them and store the result. To actually store a function, you have to put () => before them in both cases. Then React will store the functions you pass.\n\nconst [fn, setFn] = useState(() => someFunction);\n\n\n\nfunction handleClick() {\n\n  setFn(() => someOtherFunction);\n\n}\nPREVIOUS\nuseRef\nNEXT\nuseSyncExternalStore"
  },
  {
    "title": "useSyncExternalStore ‚Äì React",
    "url": "https://react.dev/reference/react/useSyncExternalStore",
    "html": "API REFERENCE\nHOOKS\nuseSyncExternalStore\n\nuseSyncExternalStore is a React Hook that lets you subscribe to an external store.\n\nconst snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)\nReference\nuseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)\nUsage\nSubscribing to an external store\nSubscribing to a browser API\nExtracting the logic to a custom Hook\nAdding support for server rendering\nTroubleshooting\nI‚Äôm getting an error: ‚ÄúThe result of getSnapshot should be cached‚Äù\nMy subscribe function gets called after every re-render\nReference \nuseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?) \n\nCall useSyncExternalStore at the top level of your component to read a value from an external data store.\n\nimport { useSyncExternalStore } from 'react';\n\nimport { todosStore } from './todoStore.js';\n\n\n\nfunction TodosApp() {\n\n  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);\n\n  // ...\n\n}\n\nIt returns the snapshot of the data in the store. You need to pass two functions as arguments:\n\nThe subscribe function should subscribe to the store and return a function that unsubscribes.\nThe getSnapshot function should read a snapshot of the data from the store.\n\nSee more examples below.\n\nParameters \n\nsubscribe: A function that takes a single callback argument and subscribes it to the store. When the store changes, it should invoke the provided callback, which will cause React to re-call getSnapshot and (if needed) re-render the component. The subscribe function should return a function that cleans up the subscription.\n\ngetSnapshot: A function that returns a snapshot of the data in the store that‚Äôs needed by the component. While the store has not changed, repeated calls to getSnapshot must return the same value. If the store changes and the returned value is different (as compared by Object.is), React re-renders the component.\n\noptional getServerSnapshot: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error.\n\nReturns \n\nThe current snapshot of the store which you can use in your rendering logic.\n\nCaveats \n\nThe store snapshot returned by getSnapshot must be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot.\n\nIf a different subscribe function is passed during a re-render, React will re-subscribe to the store using the newly passed subscribe function. You can prevent this by declaring subscribe outside the component.\n\nIf the store is mutated during a non-blocking Transition update, React will fall back to performing that update as blocking. Specifically, for every Transition update, React will call getSnapshot a second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store.\n\nIt‚Äôs not recommended to suspend a render based on a store value returned by useSyncExternalStore. The reason is that mutations to the external store cannot be marked as non-blocking Transition updates, so they will trigger the nearest Suspense fallback, replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX.\n\nFor example, the following are discouraged:\n\nconst LazyProductDetailPage = lazy(() => import('./ProductDetailPage.js'));\n\n\n\nfunction ShoppingApp() {\n\n  const selectedProductId = useSyncExternalStore(...);\n\n\n\n  // ‚ùå Calling `use` with a Promise dependent on `selectedProductId`\n\n  const data = use(fetchItem(selectedProductId))\n\n\n\n  // ‚ùå Conditionally rendering a lazy component based on `selectedProductId`\n\n  return selectedProductId != null ? <LazyProductDetailPage /> : <FeaturedProducts />;\n\n}\nUsage \nSubscribing to an external store \n\nMost of your React components will only read data from their props, state, and context. However, sometimes a component needs to read some data from some store outside of React that changes over time. This includes:\n\nThird-party state management libraries that hold state outside of React.\nBrowser APIs that expose a mutable value and events to subscribe to its changes.\n\nCall useSyncExternalStore at the top level of your component to read a value from an external data store.\n\nimport { useSyncExternalStore } from 'react';\n\nimport { todosStore } from './todoStore.js';\n\n\n\nfunction TodosApp() {\n\n  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);\n\n  // ...\n\n}\n\nIt returns the snapshot of the data in the store. You need to pass two functions as arguments:\n\nThe subscribe function should subscribe to the store and return a function that unsubscribes.\nThe getSnapshot function should read a snapshot of the data from the store.\n\nReact will use these functions to keep your component subscribed to the store and re-render it on changes.\n\nFor example, in the sandbox below, todosStore is implemented as an external store that stores data outside of React. The TodosApp component connects to that external store with the useSyncExternalStore Hook.\n\nApp.js\ntodoStore.js\nReload\nClear\nFork\nimport { useSyncExternalStore } from 'react';\nimport { todosStore } from './todoStore.js';\n\nexport default function TodosApp() {\n  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);\n  return (\n    <>\n      <button onClick={() => todosStore.addTodo()}>Add todo</button>\n      <hr />\n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id}>{todo.text}</li>\n        ))}\n      </ul>\n    </>\n  );\n}\n\n\nShow more\nNote\n\nWhen possible, we recommend using built-in React state with useState and useReducer instead. The useSyncExternalStore API is mostly useful if you need to integrate with existing non-React code.\n\nSubscribing to a browser API \n\nAnother reason to add useSyncExternalStore is when you want to subscribe to some value exposed by the browser that changes over time. For example, suppose that you want your component to display whether the network connection is active. The browser exposes this information via a property called navigator.onLine.\n\nThis value can change without React‚Äôs knowledge, so you should read it with useSyncExternalStore.\n\nimport { useSyncExternalStore } from 'react';\n\n\n\nfunction ChatIndicator() {\n\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\n\n  // ...\n\n}\n\nTo implement the getSnapshot function, read the current value from the browser API:\n\nfunction getSnapshot() {\n\n  return navigator.onLine;\n\n}\n\nNext, you need to implement the subscribe function. For example, when navigator.onLine changes, the browser fires the online and offline events on the window object. You need to subscribe the callback argument to the corresponding events, and then return a function that cleans up the subscriptions:\n\nfunction subscribe(callback) {\n\n  window.addEventListener('online', callback);\n\n  window.addEventListener('offline', callback);\n\n  return () => {\n\n    window.removeEventListener('online', callback);\n\n    window.removeEventListener('offline', callback);\n\n  };\n\n}\n\nNow React knows how to read the value from the external navigator.onLine API and how to subscribe to its changes. Disconnect your device from the network and notice that the component re-renders in response:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useSyncExternalStore } from 'react';\n\nexport default function ChatIndicator() {\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\n  return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>;\n}\n\nfunction getSnapshot() {\n  return navigator.onLine;\n}\n\nfunction subscribe(callback) {\n  window.addEventListener('online', callback);\n  window.addEventListener('offline', callback);\n  return () => {\n    window.removeEventListener('online', callback);\n    window.removeEventListener('offline', callback);\n  };\n}\n\n\nShow more\nExtracting the logic to a custom Hook \n\nUsually you won‚Äôt write useSyncExternalStore directly in your components. Instead, you‚Äôll typically call it from your own custom Hook. This lets you use the same external store from different components.\n\nFor example, this custom useOnlineStatus Hook tracks whether the network is online:\n\nimport { useSyncExternalStore } from 'react';\n\n\n\nexport function useOnlineStatus() {\n\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\n\n  return isOnline;\n\n}\n\n\n\nfunction getSnapshot() {\n\n  // ...\n\n}\n\n\n\nfunction subscribe(callback) {\n\n  // ...\n\n}\n\nNow different components can call useOnlineStatus without repeating the underlying implementation:\n\nApp.js\nuseOnlineStatus.js\nReload\nClear\nFork\nimport { useOnlineStatus } from './useOnlineStatus.js';\n\nfunction StatusBar() {\n  const isOnline = useOnlineStatus();\n  return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>;\n}\n\nfunction SaveButton() {\n  const isOnline = useOnlineStatus();\n\n  function handleSaveClick() {\n    console.log('‚úÖ Progress saved');\n  }\n\n  return (\n    <button disabled={!isOnline} onClick={handleSaveClick}>\n      {isOnline ? 'Save progress' : 'Reconnecting...'}\n    </button>\n  );\n}\n\nexport default function App() {\n  return (\n    <>\n      <SaveButton />\n      <StatusBar />\n    </>\n  );\n}\n\n\nShow more\nAdding support for server rendering \n\nIf your React app uses server rendering, your React components will also run outside the browser environment to generate the initial HTML. This creates a few challenges when connecting to an external store:\n\nIf you‚Äôre connecting to a browser-only API, it won‚Äôt work because it does not exist on the server.\nIf you‚Äôre connecting to a third-party data store, you‚Äôll need its data to match between the server and client.\n\nTo solve these issues, pass a getServerSnapshot function as the third argument to useSyncExternalStore:\n\nimport { useSyncExternalStore } from 'react';\n\n\n\nexport function useOnlineStatus() {\n\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n\n  return isOnline;\n\n}\n\n\n\nfunction getSnapshot() {\n\n  return navigator.onLine;\n\n}\n\n\n\nfunction getServerSnapshot() {\n\n  return true; // Always show \"Online\" for server-generated HTML\n\n}\n\n\n\nfunction subscribe(callback) {\n\n  // ...\n\n}\n\nThe getServerSnapshot function is similar to getSnapshot, but it runs only in two situations:\n\nIt runs on the server when generating the HTML.\nIt runs on the client during hydration, i.e. when React takes the server HTML and makes it interactive.\n\nThis lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, omit this argument to force rendering on the client.\n\nNote\n\nMake sure that getServerSnapshot returns the same exact data on the initial client render as it returned on the server. For example, if getServerSnapshot returned some prepopulated store content on the server, you need to transfer this content to the client. One way to do this is to emit a <script> tag during server rendering that sets a global like window.MY_STORE_DATA, and read from that global on the client in getServerSnapshot. Your external store should provide instructions on how to do that.\n\nTroubleshooting \nI‚Äôm getting an error: ‚ÄúThe result of getSnapshot should be cached‚Äù \n\nThis error means your getSnapshot function returns a new object every time it‚Äôs called, for example:\n\nfunction getSnapshot() {\n\n  // üî¥ Do not return always different objects from getSnapshot\n\n  return {\n\n    todos: myStore.todos\n\n  };\n\n}\n\nReact will re-render the component if getSnapshot return value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error.\n\nYour getSnapshot object should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly:\n\nfunction getSnapshot() {\n\n  // ‚úÖ You can return immutable data\n\n  return myStore.todos;\n\n}\n\nIf your store data is mutable, your getSnapshot function should return an immutable snapshot of it. This means it does need to create new objects, but it shouldn‚Äôt do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on your mutable store.\n\nMy subscribe function gets called after every re-render \n\nThis subscribe function is defined inside a component so it is different on every re-render:\n\nfunction ChatIndicator() {\n\n  // üö© Always a different function, so React will resubscribe on every re-render\n\n  function subscribe() {\n\n    // ...\n\n  }\n\n  \n\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\n\n\n\n  // ...\n\n}\n\nReact will resubscribe to your store if you pass a different subscribe function between re-renders. If this causes performance issues and you‚Äôd like to avoid resubscribing, move the subscribe function outside:\n\n// ‚úÖ Always the same function, so React won't need to resubscribe\n\nfunction subscribe() {\n\n  // ...\n\n}\n\n\n\nfunction ChatIndicator() {\n\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\n\n  // ...\n\n}\n\nAlternatively, wrap subscribe into useCallback to only resubscribe when some argument changes:\n\nfunction ChatIndicator({ userId }) {\n\n  // ‚úÖ Same function as long as userId doesn't change\n\n  const subscribe = useCallback(() => {\n\n    // ...\n\n  }, [userId]);\n\n  \n\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\n\n\n\n  // ...\n\n}\nPREVIOUS\nuseState\nNEXT\nuseTransition"
  },
  {
    "title": "useTransition ‚Äì React",
    "url": "https://react.dev/reference/react/useTransition",
    "html": "API REFERENCE\nHOOKS\nuseTransition\n\nuseTransition is a React Hook that lets you render a part of the UI in the background.\n\nconst [isPending, startTransition] = useTransition()\nReference\nuseTransition()\nstartTransition(action)\nUsage\nPerform non-blocking updates with Actions\nExposing action prop from components\nDisplaying a pending visual state\nPreventing unwanted loading indicators\nBuilding a Suspense-enabled router\nDisplaying an error to users with an error boundary\nTroubleshooting\nUpdating an input in a Transition doesn‚Äôt work\nReact doesn‚Äôt treat my state update as a Transition\nReact doesn‚Äôt treat my state update after await as a Transition\nI want to call useTransition from outside a component\nThe function I pass to startTransition executes immediately\nMy state updates in Transitions are out of order\nReference \nuseTransition() \n\nCall useTransition at the top level of your component to mark some state updates as Transitions.\n\nimport { useTransition } from 'react';\n\n\n\nfunction TabContainer() {\n\n  const [isPending, startTransition] = useTransition();\n\n  // ...\n\n}\n\nSee more examples below.\n\nParameters \n\nuseTransition does not take any parameters.\n\nReturns \n\nuseTransition returns an array with exactly two items:\n\nThe isPending flag that tells you whether there is a pending Transition.\nThe startTransition function that lets you mark updates as a Transition.\nstartTransition(action) \n\nThe startTransition function returned by useTransition lets you mark an update as a Transition.\n\nfunction TabContainer() {\n\n  const [isPending, startTransition] = useTransition();\n\n  const [tab, setTab] = useState('about');\n\n\n\n  function selectTab(nextTab) {\n\n    startTransition(() => {\n\n      setTab(nextTab);\n\n    });\n\n  }\n\n  // ...\n\n}\nNote\nFunctions called in startTransition are called ‚ÄúActions‚Äù. \n\nThe function passed to startTransition is called an ‚ÄúAction‚Äù. By convention, any callback called inside startTransition (such as a callback prop) should be named action or include the ‚ÄúAction‚Äù suffix:\n\nfunction SubmitButton({ submitAction }) {\n\n  const [isPending, startTransition] = useTransition();\n\n\n\n  return (\n\n    <button\n\n      disabled={isPending}\n\n      onClick={() => {\n\n        startTransition(async () => {\n\n          await submitAction();\n\n        });\n\n      }}\n\n    >\n\n      Submit\n\n    </button>\n\n  );\n\n}\nParameters \naction: A function that updates some state by calling one or more set functions. React calls action immediately with no parameters and marks all state updates scheduled synchronously during the action function call as Transitions. Any async calls that are awaited in the action will be included in the Transition, but currently require wrapping any set functions after the await in an additional startTransition (see Troubleshooting). State updates marked as Transitions will be non-blocking and will not display unwanted loading indicators.\nReturns \n\nstartTransition does not return anything.\n\nCaveats \n\nuseTransition is a Hook, so it can only be called inside components or custom Hooks. If you need to start a Transition somewhere else (for example, from a data library), call the standalone startTransition instead.\n\nYou can wrap an update into a Transition only if you have access to the set function of that state. If you want to start a Transition in response to some prop or a custom Hook value, try useDeferredValue instead.\n\nThe function you pass to startTransition is called immediately, marking all state updates that happen while it executes as Transitions. If you try to perform state updates in a setTimeout, for example, they won‚Äôt be marked as Transitions.\n\nYou must wrap any state updates after any async requests in another startTransition to mark them as Transitions. This is a known limitation that we will fix in the future (see Troubleshooting).\n\nThe startTransition function has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. Learn more about removing Effect dependencies.\n\nA state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input update.\n\nTransition updates can‚Äôt be used to control text inputs.\n\nIf there are multiple ongoing Transitions, React currently batches them together. This is a limitation that may be removed in a future release.\n\nUsage \nPerform non-blocking updates with Actions \n\nCall useTransition at the top of your component to create Actions, and access the pending state:\n\nimport {useState, useTransition} from 'react';\n\n\n\nfunction CheckoutForm() {\n\n  const [isPending, startTransition] = useTransition();\n\n  // ...\n\n}\n\nuseTransition returns an array with exactly two items:\n\nThe isPending flag that tells you whether there is a pending Transition.\nThe startTransition function that lets you create an Action.\n\nTo start a Transition, pass a function to startTransition like this:\n\nimport {useState, useTransition} from 'react';\n\nimport {updateQuantity} from './api';\n\n\n\nfunction CheckoutForm() {\n\n  const [isPending, startTransition] = useTransition();\n\n  const [quantity, setQuantity] = useState(1);\n\n\n\n  function onSubmit(newQuantity) {\n\n    startTransition(async function () {\n\n      const savedQuantity = await updateQuantity(newQuantity);\n\n      startTransition(() => {\n\n        setQuantity(savedQuantity);\n\n      });\n\n    });\n\n  }\n\n  // ...\n\n}\n\nThe function passed to startTransition is called the ‚ÄúAction‚Äù. You can update state and (optionally) perform side effects within an Action, and the work will be done in the background without blocking user interactions on the page. A Transition can include multiple Actions, and while a Transition is in progress, your UI stays responsive. For example, if the user clicks a tab but then changes their mind and clicks another tab, the second click will be immediately handled without waiting for the first update to finish.\n\nTo give the user feedback about in-progress Transitions, the isPending state switches to true at the first call to startTransition, and stays true until all Actions complete and the final state is shown to the user. Transitions ensure side effects in Actions to complete in order to prevent unwanted loading indicators, and you can provide immediate feedback while the Transition is in progress with useOptimistic.\n\nThe difference between Actions and regular event handling\n1. Updating the quantity in an Action\n2. Updating the quantity without an Action\nExample 1 of 2: Updating the quantity in an Action \n\nIn this example, the updateQuantity function simulates a request to the server to update the item‚Äôs quantity in the cart. This function is artificially slowed down so that it takes at least a second to complete the request.\n\nUpdate the quantity multiple times quickly. Notice that the pending ‚ÄúTotal‚Äù state is shown while any requests are in progress, and the ‚ÄúTotal‚Äù updates only after the final request is complete. Because the update is in an Action, the ‚Äúquantity‚Äù can continue to be updated while the request is in progress.\n\nApp.js\nItem.js\nTotal.js\napi.js\nReload\nClear\nFork\nimport { useState, useTransition } from \"react\";\nimport { updateQuantity } from \"./api\";\nimport Item from \"./Item\";\nimport Total from \"./Total\";\n\nexport default function App({}) {\n  const [quantity, setQuantity] = useState(1);\n  const [isPending, startTransition] = useTransition();\n\n  const updateQuantityAction = async newQuantity => {\n    // To access the pending state of a transition,\n    // call startTransition again.\n    startTransition(async () => {\n      const savedQuantity = await updateQuantity(newQuantity);\n      startTransition(() => {\n        setQuantity(savedQuantity);\n      });\n    });\n  };\n\n  return (\n    <div>\n      <h1>Checkout</h1>\n      <Item action={updateQuantityAction}/>\n      <hr />\n      <Total quantity={quantity} isPending={isPending} />\n    </div>\n  );\n}\n\n\nShow more\n\nThis is a basic example to demonstrate how Actions work, but this example does not handle requests completing out of order. When updating the quantity multiple times, it‚Äôs possible for the previous requests to finish after later requests causing the quantity to update out of order. This is a known limitation that we will fix in the future (see Troubleshooting below).\n\nFor common use cases, React provides built-in abstractions such as:\n\nuseActionState\n<form> actions\nServer Functions\n\nThese solutions handle request ordering for you. When using Transitions to build your own custom hooks or libraries that manage async state transitions, you have greater control over the request ordering, but you must handle it yourself.\n\nNext Example\nExposing action prop from components \n\nYou can expose an action prop from a component to allow a parent to call an Action.\n\nFor example, this TabButton component wraps its onClick logic in an action prop:\n\nexport default function TabButton({ action, children, isActive }) {\n\n  const [isPending, startTransition] = useTransition();\n\n  if (isActive) {\n\n    return <b>{children}</b>\n\n  }\n\n  return (\n\n    <button onClick={() => {\n\n      startTransition(async () => {\n\n        // await the action that's passed in.\n\n        // This allows it to be either sync or async.\n\n        await action();\n\n      });\n\n    }}>\n\n      {children}\n\n    </button>\n\n  );\n\n}\n\nBecause the parent component updates its state inside the action, that state update gets marked as a Transition. This means you can click on ‚ÄúPosts‚Äù and then immediately click ‚ÄúContact‚Äù and it does not block user interactions:\n\nApp.js\nTabButton.js\nAboutTab.js\nPostsTab.js\nContactTab.js\nReload\nClear\nFork\nimport { useTransition } from 'react';\n\nexport default function TabButton({ action, children, isActive }) {\n  const [isPending, startTransition] = useTransition();\n  if (isActive) {\n    return <b>{children}</b>\n  }\n  if (isPending) {\n    return <b className=\"pending\">{children}</b>;\n  }\n  return (\n    <button onClick={async () => {\n      startTransition(async () => {\n        // await the action that's passed in.\n        // This allows it to be either sync or async.\n        await action();\n      });\n    }}>\n      {children}\n    </button>\n  );\n}\n\n\nShow more\nNote\n\nWhen exposing an action prop from a component, you should await it inside the transition.\n\nThis allows the action callback to be either synchronous or asynchronous without requiring an additional startTransition to wrap the await in the action.\n\nDisplaying a pending visual state \n\nYou can use the isPending boolean value returned by useTransition to indicate to the user that a Transition is in progress. For example, the tab button can have a special ‚Äúpending‚Äù visual state:\n\nfunction TabButton({ action, children, isActive }) {\n\n  const [isPending, startTransition] = useTransition();\n\n  // ...\n\n  if (isPending) {\n\n    return <b className=\"pending\">{children}</b>;\n\n  }\n\n  // ...\n\nNotice how clicking ‚ÄúPosts‚Äù now feels more responsive because the tab button itself updates right away:\n\nApp.js\nTabButton.js\nAboutTab.js\nPostsTab.js\nContactTab.js\nReload\nClear\nFork\nimport { useTransition } from 'react';\n\nexport default function TabButton({ action, children, isActive }) {\n  const [isPending, startTransition] = useTransition();\n  if (isActive) {\n    return <b>{children}</b>\n  }\n  if (isPending) {\n    return <b className=\"pending\">{children}</b>;\n  }\n  return (\n    <button onClick={() => {\n      startTransition(async () => {\n        await action();\n      });\n    }}>\n      {children}\n    </button>\n  );\n}\n\n\nShow more\nPreventing unwanted loading indicators \n\nIn this example, the PostsTab component fetches some data using use. When you click the ‚ÄúPosts‚Äù tab, the PostsTab component suspends, causing the closest loading fallback to appear:\n\nApp.js\nTabButton.js\nReload\nClear\nFork\nimport { Suspense, useState } from 'react';\nimport TabButton from './TabButton.js';\nimport AboutTab from './AboutTab.js';\nimport PostsTab from './PostsTab.js';\nimport ContactTab from './ContactTab.js';\n\nexport default function TabContainer() {\n  const [tab, setTab] = useState('about');\n  return (\n    <Suspense fallback={<h1>üåÄ Loading...</h1>}>\n      <TabButton\n        isActive={tab === 'about'}\n        action={() => setTab('about')}\n      >\n        About\n      </TabButton>\n      <TabButton\n        isActive={tab === 'posts'}\n        action={() => setTab('posts')}\n      >\n        Posts\n      </TabButton>\n      <TabButton\n        isActive={tab === 'contact'}\n        action={() => setTab('contact')}\n      >\n        Contact\n      </TabButton>\n      <hr />\n      {tab === 'about' && <AboutTab />}\n      {tab === 'posts' && <PostsTab />}\n      {tab === 'contact' && <ContactTab />}\n    </Suspense>\n  );\n}\n\n\nShow more\n\nHiding the entire tab container to show a loading indicator leads to a jarring user experience. If you add useTransition to TabButton, you can instead display the pending state in the tab button instead.\n\nNotice that clicking ‚ÄúPosts‚Äù no longer replaces the entire tab container with a spinner:\n\nApp.js\nTabButton.js\nReload\nClear\nFork\nimport { useTransition } from 'react';\n\nexport default function TabButton({ action, children, isActive }) {\n  const [isPending, startTransition] = useTransition();\n  if (isActive) {\n    return <b>{children}</b>\n  }\n  if (isPending) {\n    return <b className=\"pending\">{children}</b>;\n  }\n  return (\n    <button onClick={() => {\n      startTransition(async () => {\n        await action();\n      });\n    }}>\n      {children}\n    </button>\n  );\n}\n\n\nShow more\n\nRead more about using Transitions with Suspense.\n\nNote\n\nTransitions only ‚Äúwait‚Äù long enough to avoid hiding already revealed content (like the tab container). If the Posts tab had a nested <Suspense> boundary, the Transition would not ‚Äúwait‚Äù for it.\n\nBuilding a Suspense-enabled router \n\nIf you‚Äôre building a React framework or a router, we recommend marking page navigations as Transitions.\n\nfunction Router() {\n\n  const [page, setPage] = useState('/');\n\n  const [isPending, startTransition] = useTransition();\n\n\n\n  function navigate(url) {\n\n    startTransition(() => {\n\n      setPage(url);\n\n    });\n\n  }\n\n  // ...\n\nThis is recommended for three reasons:\n\nTransitions are interruptible, which lets the user click away without waiting for the re-render to complete.\nTransitions prevent unwanted loading indicators, which lets the user avoid jarring jumps on navigation.\nTransitions wait for all pending actions which lets the user wait for side effects to complete before the new page is shown.\n\nHere is a simplified router example using Transitions for navigations.\n\nApp.js\nLayout.js\nIndexPage.js\nArtistPage.js\nAlbums.js\nBiography.js\nPanel.js\nReload\nClear\nFork\nimport { Suspense, useState, useTransition } from 'react';\nimport IndexPage from './IndexPage.js';\nimport ArtistPage from './ArtistPage.js';\nimport Layout from './Layout.js';\n\nexport default function App() {\n  return (\n    <Suspense fallback={<BigSpinner />}>\n      <Router />\n    </Suspense>\n  );\n}\n\nfunction Router() {\n  const [page, setPage] = useState('/');\n  const [isPending, startTransition] = useTransition();\n\n  function navigate(url) {\n    startTransition(() => {\n      setPage(url);\n    });\n  }\n\n  let content;\n  if (page === '/') {\n    content = (\n      <IndexPage navigate={navigate} />\n    );\n  } else if (page === '/the-beatles') {\n    content = (\n      <ArtistPage\n        artist={{\n          id: 'the-beatles',\n          name: 'The Beatles',\n        }}\n      />\n    );\n  }\n  return (\n    <Layout isPending={isPending}>\n      {content}\n    </Layout>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2>üåÄ Loading...</h2>;\n}\n\n\nShow more\nNote\n\nSuspense-enabled routers are expected to wrap the navigation updates into Transitions by default.\n\nDisplaying an error to users with an error boundary \n\nIf a function passed to startTransition throws an error, you can display an error to your user with an error boundary. To use an error boundary, wrap the component where you are calling the useTransition in an error boundary. Once the function passed to startTransition errors, the fallback for the error boundary will be displayed.\n\nAddCommentContainer.js\nReload\nClear\nFork\nimport { useTransition } from \"react\";\nimport { ErrorBoundary } from \"react-error-boundary\";\n\nexport function AddCommentContainer() {\n  return (\n    <ErrorBoundary fallback={<p>‚ö†Ô∏èSomething went wrong</p>}>\n      <AddCommentButton />\n    </ErrorBoundary>\n  );\n}\n\nfunction addComment(comment) {\n  // For demonstration purposes to show Error Boundary\n  if (comment == null) {\n    throw new Error(\"Example Error: An error thrown to trigger error boundary\");\n  }\n}\n\nfunction AddCommentButton() {\n  const [pending, startTransition] = useTransition();\n\n  return (\n    <button\n      disabled={pending}\n      onClick={() => {\n        startTransition(() => {\n          // Intentionally not passing a comment\n          // so error gets thrown\n          addComment();\n        });\n      }}\n    >\n      Add comment\n    </button>\n  );\n}\n\n\nShow more\nTroubleshooting \nUpdating an input in a Transition doesn‚Äôt work \n\nYou can‚Äôt use a Transition for a state variable that controls an input:\n\nconst [text, setText] = useState('');\n\n// ...\n\nfunction handleChange(e) {\n\n  // ‚ùå Can't use Transitions for controlled input state\n\n  startTransition(() => {\n\n    setText(e.target.value);\n\n  });\n\n}\n\n// ...\n\nreturn <input value={text} onChange={handleChange} />;\n\nThis is because Transitions are non-blocking, but updating an input in response to the change event should happen synchronously. If you want to run a Transition in response to typing, you have two options:\n\nYou can declare two separate state variables: one for the input state (which always updates synchronously), and one that you will update in a Transition. This lets you control the input using the synchronous state, and pass the Transition state variable (which will ‚Äúlag behind‚Äù the input) to the rest of your rendering logic.\nAlternatively, you can have one state variable, and add useDeferredValue which will ‚Äúlag behind‚Äù the real value. It will trigger non-blocking re-renders to ‚Äúcatch up‚Äù with the new value automatically.\nReact doesn‚Äôt treat my state update as a Transition \n\nWhen you wrap a state update in a Transition, make sure that it happens during the startTransition call:\n\nstartTransition(() => {\n\n  // ‚úÖ Setting state *during* startTransition call\n\n  setPage('/about');\n\n});\n\nThe function you pass to startTransition must be synchronous. You can‚Äôt mark an update as a Transition like this:\n\nstartTransition(() => {\n\n  // ‚ùå Setting state *after* startTransition call\n\n  setTimeout(() => {\n\n    setPage('/about');\n\n  }, 1000);\n\n});\n\nInstead, you could do this:\n\nsetTimeout(() => {\n\n  startTransition(() => {\n\n    // ‚úÖ Setting state *during* startTransition call\n\n    setPage('/about');\n\n  });\n\n}, 1000);\nReact doesn‚Äôt treat my state update after await as a Transition \n\nWhen you use await inside a startTransition function, the state updates that happen after the await are not marked as Transitions. You must wrap state updates after each await in a startTransition call:\n\nstartTransition(async () => {\n\n  await someAsyncFunction();\n\n  // ‚ùå Not using startTransition after await\n\n  setPage('/about');\n\n});\n\nHowever, this works instead:\n\nstartTransition(async () => {\n\n  await someAsyncFunction();\n\n  // ‚úÖ Using startTransition *after* await\n\n  startTransition(() => {\n\n    setPage('/about');\n\n  });\n\n});\n\nThis is a JavaScript limitation due to React losing the scope of the async context. In the future, when AsyncContext is available, this limitation will be removed.\n\nI want to call useTransition from outside a component \n\nYou can‚Äôt call useTransition outside a component because it‚Äôs a Hook. In this case, use the standalone startTransition method instead. It works the same way, but it doesn‚Äôt provide the isPending indicator.\n\nThe function I pass to startTransition executes immediately \n\nIf you run this code, it will print 1, 2, 3:\n\nconsole.log(1);\n\nstartTransition(() => {\n\n  console.log(2);\n\n  setPage('/about');\n\n});\n\nconsole.log(3);\n\nIt is expected to print 1, 2, 3. The function you pass to startTransition does not get delayed. Unlike with the browser setTimeout, it does not run the callback later. React executes your function immediately, but any state updates scheduled while it is running are marked as Transitions. You can imagine that it works like this:\n\n// A simplified version of how React works\n\n\n\nlet isInsideTransition = false;\n\n\n\nfunction startTransition(scope) {\n\n  isInsideTransition = true;\n\n  scope();\n\n  isInsideTransition = false;\n\n}\n\n\n\nfunction setState() {\n\n  if (isInsideTransition) {\n\n    // ... schedule a Transition state update ...\n\n  } else {\n\n    // ... schedule an urgent state update ...\n\n  }\n\n}\nMy state updates in Transitions are out of order \n\nIf you await inside startTransition, you might see the updates happen out of order.\n\nIn this example, the updateQuantity function simulates a request to the server to update the item‚Äôs quantity in the cart. This function artificially returns every other request after the previous to simulate race conditions for network requests.\n\nTry updating the quantity once, then update it quickly multiple times. You might see the incorrect total:\n\nApp.js\nItem.js\nTotal.js\napi.js\nReload\nClear\nFork\nimport { useState, useTransition } from \"react\";\nimport { updateQuantity } from \"./api\";\nimport Item from \"./Item\";\nimport Total from \"./Total\";\n\nexport default function App({}) {\n  const [quantity, setQuantity] = useState(1);\n  const [isPending, startTransition] = useTransition();\n  // Store the actual quantity in separate state to show the mismatch.\n  const [clientQuantity, setClientQuantity] = useState(1);\n\n  const updateQuantityAction = newQuantity => {\n    setClientQuantity(newQuantity);\n\n    // Access the pending state of the transition,\n    // by wrapping in startTransition again.\n    startTransition(async () => {\n      const savedQuantity = await updateQuantity(newQuantity);\n      startTransition(() => {\n        setQuantity(savedQuantity);\n      });\n    });\n  };\n\n  return (\n    <div>\n      <h1>Checkout</h1>\n      <Item action={updateQuantityAction}/>\n      <hr />\n      <Total clientQuantity={clientQuantity} savedQuantity={quantity} isPending={isPending} />\n    </div>\n  );\n}\n\n\nShow more\n\nWhen clicking multiple times, it‚Äôs possible for previous requests to finish after later requests. When this happens, React currently has no way to know the intended order. This is because the updates are scheduled asynchronously, and React loses context of the order across the async boundary.\n\nThis is expected, because Actions within a Transition do not guarantee execution order. For common use cases, React provides higher-level abstractions like useActionState and <form> actions that handle ordering for you. For advanced use cases, you‚Äôll need to implement your own queuing and abort logic to handle this.\n\nExample of useActionState handling execution order:\n\nApp.js\nItem.js\nTotal.js\napi.js\nReload\nClear\nFork\nimport { useState, useActionState } from \"react\";\nimport { updateQuantity } from \"./api\";\nimport Item from \"./Item\";\nimport Total from \"./Total\";\n\nexport default function App({}) {\n  // Store the actual quantity in separate state to show the mismatch.\n  const [clientQuantity, setClientQuantity] = useState(1);\n  const [quantity, updateQuantityAction, isPending] = useActionState(\n    async (prevState, payload) => {\n      setClientQuantity(payload);\n      const savedQuantity = await updateQuantity(payload);\n      return savedQuantity; // Return the new quantity to update the state\n    },\n    1 // Initial quantity\n  );\n\n  return (\n    <div>\n      <h1>Checkout</h1>\n      <Item action={updateQuantityAction}/>\n      <hr />\n      <Total clientQuantity={clientQuantity} savedQuantity={quantity} isPending={isPending} />\n    </div>\n  );\n}\n\n\nShow more\nPREVIOUS\nuseSyncExternalStore\nNEXT\nComponents"
  },
  {
    "title": "Built-in React Components ‚Äì React",
    "url": "https://react.dev/reference/react/components",
    "html": "API REFERENCE\nBuilt-in React Components\n\nReact exposes a few built-in components that you can use in your JSX.\n\nBuilt-in components \n<Fragment>, alternatively written as <>...</>, lets you group multiple JSX nodes together.\n<Profiler> lets you measure rendering performance of a React tree programmatically.\n<Suspense> lets you display a fallback while the child components are loading.\n<StrictMode> enables extra development-only checks that help you find bugs early.\n<Activity> lets you hide and restore the UI and internal state of its children.\nYour own components \n\nYou can also define your own components as JavaScript functions.\n\nPREVIOUS\nuseTransition\nNEXT\n<Fragment> (<>)"
  },
  {
    "title": "<Fragment> (<>...</>) ‚Äì React",
    "url": "https://react.dev/reference/react/Fragment",
    "html": "API REFERENCE\nCOMPONENTS\n<Fragment> (<>...</>)\n\n<Fragment>, often used via <>...</> syntax, lets you group elements without a wrapper node.\n\nCanary\nFragments can also accept refs, which enable interacting with underlying DOM nodes without adding wrapper elements. See reference and usage below.\n<>\n\n  <OneChild />\n\n  <AnotherChild />\n\n</>\nReference\n<Fragment>\nCanary only FragmentInstance\nUsage\nReturning multiple elements\nAssigning multiple elements to a variable\nGrouping elements with text\nRendering a list of Fragments\nCanary only Using Fragment refs for DOM interaction\nCanary only Tracking visibility with Fragment refs\nCanary only Focus management with Fragment refs\nReference \n<Fragment> \n\nWrap elements in <Fragment> to group them together in situations where you need a single element. Grouping elements in Fragment has no effect on the resulting DOM; it is the same as if the elements were not grouped. The empty JSX tag <></> is shorthand for <Fragment></Fragment> in most cases.\n\nProps \noptional key: Fragments declared with the explicit <Fragment> syntax may have keys.\nCanary only optional ref: A ref object (e.g. from useRef) or callback function. React provides a FragmentInstance as the ref value that implements methods for interacting with the DOM nodes wrapped by the Fragment.\nCanary only FragmentInstance \n\nWhen you pass a ref to a fragment, React provides a FragmentInstance object with methods for interacting with the DOM nodes wrapped by the fragment:\n\nEvent handling methods:\n\naddEventListener(type, listener, options?): Adds an event listener to all first-level DOM children of the Fragment.\nremoveEventListener(type, listener, options?): Removes an event listener from all first-level DOM children of the Fragment.\ndispatchEvent(event): Dispatches an event to a virtual child of the Fragment to call any added listeners and can bubble to the DOM parent.\n\nLayout methods:\n\ncompareDocumentPosition(otherNode): Compares the document position of the Fragment with another node.\nIf the Fragment has children, the native compareDocumentPosition value is returned.\nEmpty Fragments will attempt to compare positioning within the React tree and include Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC.\nElements that have a different relationship in the React tree and DOM tree due to portaling or other insertions are Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC.\ngetClientRects(): Returns a flat array of DOMRect objects representing the bounding rectangles of all children.\ngetRootNode(): Returns the root node containing the Fragment‚Äôs parent DOM node.\n\nFocus management methods:\n\nfocus(options?): Focuses the first focusable DOM node in the Fragment. Focus is attempted on nested children depth-first.\nfocusLast(options?): Focuses the last focusable DOM node in the Fragment. Focus is attempted on nested children depth-first.\nblur(): Removes focus if document.activeElement is within the Fragment.\n\nObserver methods:\n\nobserveUsing(observer): Starts observing the Fragment‚Äôs DOM children with an IntersectionObserver or ResizeObserver.\nunobserveUsing(observer): Stops observing the Fragment‚Äôs DOM children with the specified observer.\nCaveats \n\nIf you want to pass key to a Fragment, you can‚Äôt use the <>...</> syntax. You have to explicitly import Fragment from 'react' and render <Fragment key={yourKey}>...</Fragment>.\n\nReact does not reset state when you go from rendering <><Child /></> to [<Child />] or back, or when you go from rendering <><Child /></> to <Child /> and back. This only works a single level deep: for example, going from <><><Child /></></> to <Child /> resets the state. See the precise semantics here.\n\nCanary only If you want to pass ref to a Fragment, you can‚Äôt use the <>...</> syntax. You have to explicitly import Fragment from 'react' and render <Fragment ref={yourRef}>...</Fragment>.\n\nUsage \nReturning multiple elements \n\nUse Fragment, or the equivalent <>...</> syntax, to group multiple elements together. You can use it to put multiple elements in any place where a single element can go. For example, a component can only return one element, but by using a Fragment you can group multiple elements together and then return them as a group:\n\nfunction Post() {\n\n  return (\n\n    <>\n\n      <PostTitle />\n\n      <PostBody />\n\n    </>\n\n  );\n\n}\n\nFragments are useful because grouping elements with a Fragment has no effect on layout or styles, unlike if you wrapped the elements in another container like a DOM element. If you inspect this example with the browser tools, you‚Äôll see that all <h1> and <article> DOM nodes appear as siblings without wrappers around them:\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function Blog() {\n  return (\n    <>\n      <Post title=\"An update\" body=\"It's been a while since I posted...\" />\n      <Post title=\"My new blog\" body=\"I am starting a new blog!\" />\n    </>\n  )\n}\n\nfunction Post({ title, body }) {\n  return (\n    <>\n      <PostTitle title={title} />\n      <PostBody body={body} />\n    </>\n  );\n}\n\nfunction PostTitle({ title }) {\n  return <h1>{title}</h1>\n}\n\nfunction PostBody({ body }) {\n  return (\n    <article>\n      <p>{body}</p>\n    </article>\n  );\n}\n\n\nShow more\nDEEP DIVE\nHow to write a Fragment without the special syntax? \nShow Details\nAssigning multiple elements to a variable \n\nLike any other element, you can assign Fragment elements to variables, pass them as props, and so on:\n\nfunction CloseDialog() {\n\n  const buttons = (\n\n    <>\n\n      <OKButton />\n\n      <CancelButton />\n\n    </>\n\n  );\n\n  return (\n\n    <AlertDialog buttons={buttons}>\n\n      Are you sure you want to leave this page?\n\n    </AlertDialog>\n\n  );\n\n}\nGrouping elements with text \n\nYou can use Fragment to group text together with components:\n\nfunction DateRangePicker({ start, end }) {\n\n  return (\n\n    <>\n\n      From\n\n      <DatePicker date={start} />\n\n      to\n\n      <DatePicker date={end} />\n\n    </>\n\n  );\n\n}\nRendering a list of Fragments \n\nHere‚Äôs a situation where you need to write Fragment explicitly instead of using the <></> syntax. When you render multiple elements in a loop, you need to assign a key to each element. If the elements within the loop are Fragments, you need to use the normal JSX element syntax in order to provide the key attribute:\n\nfunction Blog() {\n\n  return posts.map(post =>\n\n    <Fragment key={post.id}>\n\n      <PostTitle title={post.title} />\n\n      <PostBody body={post.body} />\n\n    </Fragment>\n\n  );\n\n}\n\nYou can inspect the DOM to verify that there are no wrapper elements around the Fragment children:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { Fragment } from 'react';\n\nconst posts = [\n  { id: 1, title: 'An update', body: \"It's been a while since I posted...\" },\n  { id: 2, title: 'My new blog', body: 'I am starting a new blog!' }\n];\n\nexport default function Blog() {\n  return posts.map(post =>\n    <Fragment key={post.id}>\n      <PostTitle title={post.title} />\n      <PostBody body={post.body} />\n    </Fragment>\n  );\n}\n\nfunction PostTitle({ title }) {\n  return <h1>{title}</h1>\n}\n\nfunction PostBody({ body }) {\n  return (\n    <article>\n      <p>{body}</p>\n    </article>\n  );\n}\n\n\nShow more\nCanary only Using Fragment refs for DOM interaction \n\nFragment refs allow you to interact with the DOM nodes wrapped by a Fragment without adding extra wrapper elements. This is useful for event handling, visibility tracking, focus management, and replacing deprecated patterns like ReactDOM.findDOMNode().\n\nimport { Fragment } from 'react';\n\n\n\nfunction ClickableFragment({ children, onClick }) {\n\n  return (\n\n    <Fragment ref={fragmentInstance => {\n\n      fragmentInstance.addEventListener('click', handleClick);\n\n      return () => fragmentInstance.removeEventListener('click', handleClick);\n\n    }}>\n\n      {children}\n\n    </Fragment>\n\n  );\n\n}\nCanary only Tracking visibility with Fragment refs \n\nFragment refs are useful for visibility tracking and intersection observation. This enables you to monitor when content becomes visible without requiring the child Components to expose refs:\n\nimport { Fragment, useRef, useLayoutEffect } from 'react';\n\n\n\nfunction VisibilityObserverFragment({ threshold = 0.5, onVisibilityChange, children }) {\n\n  const fragmentRef = useRef(null);\n\n\n\n  useLayoutEffect(() => {\n\n    const observer = new IntersectionObserver(\n\n      (entries) => {\n\n        onVisibilityChange(entries.some(entry => entry.isIntersecting))\n\n      },\n\n      { threshold }\n\n    );\n\n    \n\n    fragmentRef.current.observeUsing(observer);\n\n    return () => fragmentRef.current.unobserveUsing(observer);\n\n  }, [threshold, onVisibilityChange]);\n\n\n\n  return (\n\n    <Fragment ref={fragmentRef}>\n\n      {children}\n\n    </Fragment>\n\n  );\n\n}\n\n\n\nfunction MyComponent() {\n\n  const handleVisibilityChange = (isVisible) => {\n\n    console.log('Component is', isVisible ? 'visible' : 'hidden');\n\n  };\n\n\n\n  return (\n\n    <VisibilityObserverFragment onVisibilityChange={handleVisibilityChange}>\n\n      <SomeThirdPartyComponent />\n\n      <AnotherComponent />\n\n    </VisibilityObserverFragment>\n\n  );\n\n}\n\nThis pattern is an alternative to Effect-based visibility logging, which is an anti-pattern in most cases. Relying on Effects alone does not guarantee that the rendered Component is observable by the user.\n\nCanary only Focus management with Fragment refs \n\nFragment refs provide focus management methods that work across all DOM nodes within the Fragment:\n\nimport { Fragment, useRef } from 'react';\n\n\n\nfunction FocusFragment({ children }) {\n\n  return (\n\n    <Fragment ref={(fragmentInstance) => fragmentInstance?.focus()}>\n\n      {children}\n\n    </Fragment>\n\n  );\n\n}\n\nThe focus() method focuses the first focusable element within the Fragment, while focusLast() focuses the last focusable element.\n\nPREVIOUS\nComponents\nNEXT\n<Profiler>"
  },
  {
    "title": "<Profiler> ‚Äì React",
    "url": "https://react.dev/reference/react/Profiler",
    "html": "API REFERENCE\nCOMPONENTS\n<Profiler>\n\n<Profiler> lets you measure rendering performance of a React tree programmatically.\n\n<Profiler id=\"App\" onRender={onRender}>\n\n  <App />\n\n</Profiler>\nReference\n<Profiler>\nonRender callback\nUsage\nMeasuring rendering performance programmatically\nMeasuring different parts of the application\nReference \n<Profiler> \n\nWrap a component tree in a <Profiler> to measure its rendering performance.\n\n<Profiler id=\"App\" onRender={onRender}>\n\n  <App />\n\n</Profiler>\nProps \nid: A string identifying the part of the UI you are measuring.\nonRender: An onRender callback that React calls every time components within the profiled tree update. It receives information about what was rendered and how much time it took.\nCaveats \nProfiling adds some additional overhead, so it is disabled in the production build by default. To opt into production profiling, you need to enable a special production build with profiling enabled.\nonRender callback \n\nReact will call your onRender callback with information about what was rendered.\n\nfunction onRender(id, phase, actualDuration, baseDuration, startTime, commitTime) {\n\n  // Aggregate or log render timings...\n\n}\nParameters \nid: The string id prop of the <Profiler> tree that has just committed. This lets you identify which part of the tree was committed if you are using multiple profilers.\nphase: \"mount\", \"update\" or \"nested-update\". This lets you know whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or Hooks.\nactualDuration: The number of milliseconds spent rendering the <Profiler> and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. memo and useMemo). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change.\nbaseDuration: The number of milliseconds estimating how much time it would take to re-render the entire <Profiler> subtree without any optimizations. It is calculated by summing up the most recent render durations of each component in the tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). Compare actualDuration against it to see if memoization is working.\nstartTime: A numeric timestamp for when React began rendering the current update.\ncommitTime: A numeric timestamp for when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable.\nUsage \nMeasuring rendering performance programmatically \n\nWrap the <Profiler> component around a React tree to measure its rendering performance.\n\n<App>\n\n  <Profiler id=\"Sidebar\" onRender={onRender}>\n\n    <Sidebar />\n\n  </Profiler>\n\n  <PageContent />\n\n</App>\n\nIt requires two props: an id (string) and an onRender callback (function) which React calls any time a component within the tree ‚Äúcommits‚Äù an update.\n\nPitfall\n\nProfiling adds some additional overhead, so it is disabled in the production build by default. To opt into production profiling, you need to enable a special production build with profiling enabled.\n\nNote\n\n<Profiler> lets you gather measurements programmatically. If you‚Äôre looking for an interactive profiler, try the Profiler tab in React Developer Tools. It exposes similar functionality as a browser extension.\n\nComponents wrapped in <Profiler> will also be marked in the Component tracks of React Performance tracks even in profiling builds.\nIn development builds, all components are marked in the Components track regardless of whether they‚Äôre wrapped in <Profiler>.\n\nMeasuring different parts of the application \n\nYou can use multiple <Profiler> components to measure different parts of your application:\n\n<App>\n\n  <Profiler id=\"Sidebar\" onRender={onRender}>\n\n    <Sidebar />\n\n  </Profiler>\n\n  <Profiler id=\"Content\" onRender={onRender}>\n\n    <Content />\n\n  </Profiler>\n\n</App>\n\nYou can also nest <Profiler> components:\n\n<App>\n\n  <Profiler id=\"Sidebar\" onRender={onRender}>\n\n    <Sidebar />\n\n  </Profiler>\n\n  <Profiler id=\"Content\" onRender={onRender}>\n\n    <Content>\n\n      <Profiler id=\"Editor\" onRender={onRender}>\n\n        <Editor />\n\n      </Profiler>\n\n      <Preview />\n\n    </Content>\n\n  </Profiler>\n\n</App>\n\nAlthough <Profiler> is a lightweight component, it should be used only when necessary. Each use adds some CPU and memory overhead to an application.\n\nPREVIOUS\n<Fragment> (<>)\nNEXT\n<StrictMode>"
  },
  {
    "title": "<StrictMode> ‚Äì React",
    "url": "https://react.dev/reference/react/StrictMode",
    "html": "API REFERENCE\nCOMPONENTS\n<StrictMode>\n\n<StrictMode> lets you find common bugs in your components early during development.\n\n<StrictMode>\n\n  <App />\n\n</StrictMode>\nReference\n<StrictMode>\nUsage\nEnabling Strict Mode for entire app\nEnabling Strict Mode for a part of the app\nFixing bugs found by double rendering in development\nFixing bugs found by re-running Effects in development\nFixing bugs found by re-running ref callbacks in development\nFixing deprecation warnings enabled by Strict Mode\nReference \n<StrictMode> \n\nUse StrictMode to enable additional development behaviors and warnings for the component tree inside:\n\nimport { StrictMode } from 'react';\n\nimport { createRoot } from 'react-dom/client';\n\n\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(\n\n  <StrictMode>\n\n    <App />\n\n  </StrictMode>\n\n);\n\nSee more examples below.\n\nStrict Mode enables the following development-only behaviors:\n\nYour components will re-render an extra time to find bugs caused by impure rendering.\nYour components will re-run Effects an extra time to find bugs caused by missing Effect cleanup.\nYour components will re-run refs callbacks an extra time to find bugs caused by missing ref cleanup.\nYour components will be checked for usage of deprecated APIs.\nProps \n\nStrictMode accepts no props.\n\nCaveats \nThere is no way to opt out of Strict Mode inside a tree wrapped in <StrictMode>. This gives you confidence that all components inside <StrictMode> are checked. If two teams working on a product disagree whether they find the checks valuable, they need to either reach consensus or move <StrictMode> down in the tree.\nUsage \nEnabling Strict Mode for entire app \n\nStrict Mode enables extra development-only checks for the entire component tree inside the <StrictMode> component. These checks help you find common bugs in your components early in the development process.\n\nTo enable Strict Mode for your entire app, wrap your root component with <StrictMode> when you render it:\n\nimport { StrictMode } from 'react';\n\nimport { createRoot } from 'react-dom/client';\n\n\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(\n\n  <StrictMode>\n\n    <App />\n\n  </StrictMode>\n\n);\n\nWe recommend wrapping your entire app in Strict Mode, especially for newly created apps. If you use a framework that calls createRoot for you, check its documentation for how to enable Strict Mode.\n\nAlthough the Strict Mode checks only run in development, they help you find bugs that already exist in your code but can be tricky to reliably reproduce in production. Strict Mode lets you fix bugs before your users report them.\n\nNote\n\nStrict Mode enables the following checks in development:\n\nYour components will re-render an extra time to find bugs caused by impure rendering.\nYour components will re-run Effects an extra time to find bugs caused by missing Effect cleanup.\nYour components will re-run ref callbacks an extra time to find bugs caused by missing ref cleanup.\nYour components will be checked for usage of deprecated APIs.\n\nAll of these checks are development-only and do not impact the production build.\n\nEnabling Strict Mode for a part of the app \n\nYou can also enable Strict Mode for any part of your application:\n\nimport { StrictMode } from 'react';\n\n\n\nfunction App() {\n\n  return (\n\n    <>\n\n      <Header />\n\n      <StrictMode>\n\n        <main>\n\n          <Sidebar />\n\n          <Content />\n\n        </main>\n\n      </StrictMode>\n\n      <Footer />\n\n    </>\n\n  );\n\n}\n\nIn this example, Strict Mode checks will not run against the Header and Footer components. However, they will run on Sidebar and Content, as well as all of the components inside them, no matter how deep.\n\nNote\n\nWhen StrictMode is enabled for a part of the app, React will only enable behaviors that are possible in production. For example, if <StrictMode> is not enabled at the root of the app, it will not re-run Effects an extra time on initial mount, since this would cause child effects to double fire without the parent effects, which cannot happen in production.\n\nFixing bugs found by double rendering in development \n\nReact assumes that every component you write is a pure function. This means that React components you write must always return the same JSX given the same inputs (props, state, and context).\n\nComponents breaking this rule behave unpredictably and cause bugs. To help you find accidentally impure code, Strict Mode calls some of your functions (only the ones that should be pure) twice in development. This includes:\n\nYour component function body (only top-level logic, so this doesn‚Äôt include code inside event handlers)\nFunctions that you pass to useState, set functions, useMemo, or useReducer\nSome class component methods like constructor, render, shouldComponentUpdate (see the whole list)\n\nIf a function is pure, running it twice does not change its behavior because a pure function produces the same result every time. However, if a function is impure (for example, it mutates the data it receives), running it twice tends to be noticeable (that‚Äôs what makes it impure!) This helps you spot and fix the bug early.\n\nHere is an example to illustrate how double rendering in Strict Mode helps you find bugs early.\n\nThis StoryTray component takes an array of stories and adds one last ‚ÄúCreate Story‚Äù item at the end:\n\nindex.js\nApp.js\nStoryTray.js\nReload\nClear\nFork\nexport default function StoryTray({ stories }) {\n  const items = stories;\n  items.push({ id: 'create', label: 'Create Story' });\n  return (\n    <ul>\n      {items.map(story => (\n        <li key={story.id}>\n          {story.label}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n\n\nThere is a mistake in the code above. However, it is easy to miss because the initial output appears correct.\n\nThis mistake will become more noticeable if the StoryTray component re-renders multiple times. For example, let‚Äôs make the StoryTray re-render with a different background color whenever you hover over it:\n\nindex.js\nApp.js\nStoryTray.js\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function StoryTray({ stories }) {\n  const [isHover, setIsHover] = useState(false);\n  const items = stories;\n  items.push({ id: 'create', label: 'Create Story' });\n  return (\n    <ul\n      onPointerEnter={() => setIsHover(true)}\n      onPointerLeave={() => setIsHover(false)}\n      style={{\n        backgroundColor: isHover ? '#ddd' : '#fff'\n      }}\n    >\n      {items.map(story => (\n        <li key={story.id}>\n          {story.label}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n\nShow more\n\nNotice how every time you hover over the StoryTray component, ‚ÄúCreate Story‚Äù gets added to the list again. The intention of the code was to add it once at the end. But StoryTray directly modifies the stories array from the props. Every time StoryTray renders, it adds ‚ÄúCreate Story‚Äù again at the end of the same array. In other words, StoryTray is not a pure function‚Äîrunning it multiple times produces different results.\n\nTo fix this problem, you can make a copy of the array, and modify that copy instead of the original one:\n\nexport default function StoryTray({ stories }) {\n\n  const items = stories.slice(); // Clone the array\n\n  // ‚úÖ Good: Pushing into a new array\n\n  items.push({ id: 'create', label: 'Create Story' });\n\nThis would make the StoryTray function pure. Each time it is called, it would only modify a new copy of the array, and would not affect any external objects or variables. This solves the bug, but you had to make the component re-render more often before it became obvious that something is wrong with its behavior.\n\nIn the original example, the bug wasn‚Äôt obvious. Now let‚Äôs wrap the original (buggy) code in <StrictMode>:\n\nindex.js\nApp.js\nStoryTray.js\nReload\nClear\nFork\nexport default function StoryTray({ stories }) {\n  const items = stories;\n  items.push({ id: 'create', label: 'Create Story' });\n  return (\n    <ul>\n      {items.map(story => (\n        <li key={story.id}>\n          {story.label}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n\n\nStrict Mode always calls your rendering function twice, so you can see the mistake right away (‚ÄúCreate Story‚Äù appears twice). This lets you notice such mistakes early in the process. When you fix your component to render in Strict Mode, you also fix many possible future production bugs like the hover functionality from before:\n\nindex.js\nApp.js\nStoryTray.js\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function StoryTray({ stories }) {\n  const [isHover, setIsHover] = useState(false);\n  const items = stories.slice(); // Clone the array\n  items.push({ id: 'create', label: 'Create Story' });\n  return (\n    <ul\n      onPointerEnter={() => setIsHover(true)}\n      onPointerLeave={() => setIsHover(false)}\n      style={{\n        backgroundColor: isHover ? '#ddd' : '#fff'\n      }}\n    >\n      {items.map(story => (\n        <li key={story.id}>\n          {story.label}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n\nShow more\n\nWithout Strict Mode, it was easy to miss the bug until you added more re-renders. Strict Mode made the same bug appear right away. Strict Mode helps you find bugs before you push them to your team and to your users.\n\nRead more about keeping components pure.\n\nNote\n\nIf you have React DevTools installed, any console.log calls during the second render call will appear slightly dimmed. React DevTools also offers a setting (off by default) to suppress them completely.\n\nFixing bugs found by re-running Effects in development \n\nStrict Mode can also help find bugs in Effects.\n\nEvery Effect has some setup code and may have some cleanup code. Normally, React calls setup when the component mounts (is added to the screen) and calls cleanup when the component unmounts (is removed from the screen). React then calls cleanup and setup again if its dependencies changed since the last render.\n\nWhen Strict Mode is on, React will also run one extra setup+cleanup cycle in development for every Effect. This may feel surprising, but it helps reveal subtle bugs that are hard to catch manually.\n\nHere is an example to illustrate how re-running Effects in Strict Mode helps you find bugs early.\n\nConsider this example that connects a component to a chat:\n\nindex.js\nApp.js\nchat.js\nReload\nClear\nFork\nimport { createRoot } from 'react-dom/client';\nimport './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById(\"root\"));\nroot.render(<App />);\n\n\n\nThere is an issue with this code, but it might not be immediately clear.\n\nTo make the issue more obvious, let‚Äôs implement a feature. In the example below, roomId is not hardcoded. Instead, the user can select the roomId that they want to connect to from a dropdown. Click ‚ÄúOpen chat‚Äù and then select different chat rooms one by one. Keep track of the number of active connections in the console:\n\nindex.js\nApp.js\nchat.js\nReload\nClear\nFork\nimport { createRoot } from 'react-dom/client';\nimport './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById(\"root\"));\nroot.render(<App />);\n\n\n\nYou‚Äôll notice that the number of open connections always keeps growing. In a real app, this would cause performance and network problems. The issue is that your Effect is missing a cleanup function:\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [roomId]);\n\nNow that your Effect ‚Äúcleans up‚Äù after itself and destroys the outdated connections, the leak is solved. However, notice that the problem did not become visible until you‚Äôve added more features (the select box).\n\nIn the original example, the bug wasn‚Äôt obvious. Now let‚Äôs wrap the original (buggy) code in <StrictMode>:\n\nindex.js\nApp.js\nchat.js\nReload\nClear\nFork\nimport { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById(\"root\"));\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n\n\n\nWith Strict Mode, you immediately see that there is a problem (the number of active connections jumps to 2). Strict Mode runs an extra setup+cleanup cycle for every Effect. This Effect has no cleanup logic, so it creates an extra connection but doesn‚Äôt destroy it. This is a hint that you‚Äôre missing a cleanup function.\n\nStrict Mode lets you notice such mistakes early in the process. When you fix your Effect by adding a cleanup function in Strict Mode, you also fix many possible future production bugs like the select box from before:\n\nindex.js\nApp.js\nchat.js\nReload\nClear\nFork\nimport { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById(\"root\"));\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n\n\n\nNotice how the active connection count in the console doesn‚Äôt keep growing anymore.\n\nWithout Strict Mode, it was easy to miss that your Effect needed cleanup. By running setup ‚Üí cleanup ‚Üí setup instead of setup for your Effect in development, Strict Mode made the missing cleanup logic more noticeable.\n\nRead more about implementing Effect cleanup.\n\nFixing bugs found by re-running ref callbacks in development \n\nStrict Mode can also help find bugs in callbacks refs.\n\nEvery callback ref has some setup code and may have some cleanup code. Normally, React calls setup when the element is created (is added to the DOM) and calls cleanup when the element is removed (is removed from the DOM).\n\nWhen Strict Mode is on, React will also run one extra setup+cleanup cycle in development for every callback ref. This may feel surprising, but it helps reveal subtle bugs that are hard to catch manually.\n\nConsider this example, which allows you to select an animal and then scroll to one of them. Notice when you switch from ‚ÄúCats‚Äù to ‚ÄúDogs‚Äù, the console logs show that the number of animals in the list keeps growing, and the ‚ÄúScroll to‚Äù buttons stop working:\n\nindex.js\nApp.js\nReload\nClear\nFork\nimport { useRef, useState } from \"react\";\n\nexport default function CatFriends() {\n  const itemsRef = useRef([]);\n  const [catList, setCatList] = useState(setupCatList);\n  const [cat, setCat] = useState('neo');\n\n  function scrollToCat(index) {\n    const list = itemsRef.current;\n    const {node} = list[index];\n    node.scrollIntoView({\n      behavior: \"smooth\",\n      block: \"nearest\",\n      inline: \"center\",\n    });\n  }\n\n  const cats = catList.filter(c => c.type === cat)\n\n  return (\n    <>\n      <nav>\n        <button onClick={() => setCat('neo')}>Neo</button>\n        <button onClick={() => setCat('millie')}>Millie</button>\n      </nav>\n      <hr />\n      <nav>\n        <span>Scroll to:</span>{cats.map((cat, index) => (\n          <button key={cat.src} onClick={() => scrollToCat(index)}>\n            {index}\n          </button>\n        ))}\n      </nav>\n      <div>\n        <ul>\n          {cats.map((cat) => (\n            <li\n              key={cat.src}\n              ref={(node) => {\n                const list = itemsRef.current;\n                const item = {cat: cat, node};\n                list.push(item);\n                console.log(`‚úÖ Adding cat to the map. Total cats: ${list.length}`);\n                if (list.length > 10) {\n                  console.log('‚ùå Too many cats in the list!');\n                }\n                return () => {\n                  // üö© No cleanup, this is a bug!\n                }\n              }}\n            >\n              <img src={cat.src} />\n            </li>\n          ))}\n        </ul>\n      </div>\n    </>\n  );\n}\n\nfunction setupCatList() {\n  const catList = [];\n  for (let i = 0; i < 10; i++) {\n    catList.push({type: 'neo', src: \"https://placecats.com/neo/320/240?\" + i});\n  }\n  for (let i = 0; i < 10; i++) {\n    catList.push({type: 'millie', src: \"https://placecats.com/millie/320/240?\" + i});\n  }\n\n  return catList;\n}\n\n\nShow more\n\nThis is a production bug! Since the ref callback doesn‚Äôt remove animals from the list in the cleanup, the list of animals keeps growing. This is a memory leak that can cause performance problems in a real app, and breaks the behavior of the app.\n\nThe issue is the ref callback doesn‚Äôt cleanup after itself:\n\n<li\n\n  ref={node => {\n\n    const list = itemsRef.current;\n\n    const item = {animal, node};\n\n    list.push(item);\n\n    return () => {\n\n      // üö© No cleanup, this is a bug!\n\n    }\n\n  }}\n\n</li>\n\nNow let‚Äôs wrap the original (buggy) code in <StrictMode>:\n\nindex.js\nApp.js\nReload\nClear\nFork\nimport { useRef, useState } from \"react\";\n\nexport default function CatFriends() {\n  const itemsRef = useRef([]);\n  const [catList, setCatList] = useState(setupCatList);\n  const [cat, setCat] = useState('neo');\n\n  function scrollToCat(index) {\n    const list = itemsRef.current;\n    const {node} = list[index];\n    node.scrollIntoView({\n      behavior: \"smooth\",\n      block: \"nearest\",\n      inline: \"center\",\n    });\n  }\n\n  const cats = catList.filter(c => c.type === cat)\n\n  return (\n    <>\n      <nav>\n        <button onClick={() => setCat('neo')}>Neo</button>\n        <button onClick={() => setCat('millie')}>Millie</button>\n      </nav>\n      <hr />\n      <nav>\n        <span>Scroll to:</span>{cats.map((cat, index) => (\n          <button key={cat.src} onClick={() => scrollToCat(index)}>\n            {index}\n          </button>\n        ))}\n      </nav>\n      <div>\n        <ul>\n          {cats.map((cat) => (\n            <li\n              key={cat.src}\n              ref={(node) => {\n                const list = itemsRef.current;\n                const item = {cat: cat, node};\n                list.push(item);\n                console.log(`‚úÖ Adding cat to the map. Total cats: ${list.length}`);\n                if (list.length > 10) {\n                  console.log('‚ùå Too many cats in the list!');\n                }\n                return () => {\n                  // üö© No cleanup, this is a bug!\n                }\n              }}\n            >\n              <img src={cat.src} />\n            </li>\n          ))}\n        </ul>\n      </div>\n    </>\n  );\n}\n\nfunction setupCatList() {\n  const catList = [];\n  for (let i = 0; i < 10; i++) {\n    catList.push({type: 'neo', src: \"https://placecats.com/neo/320/240?\" + i});\n  }\n  for (let i = 0; i < 10; i++) {\n    catList.push({type: 'millie', src: \"https://placecats.com/millie/320/240?\" + i});\n  }\n\n  return catList;\n}\n\n\nShow more\n\nWith Strict Mode, you immediately see that there is a problem. Strict Mode runs an extra setup+cleanup cycle for every callback ref. This callback ref has no cleanup logic, so it adds refs but doesn‚Äôt remove them. This is a hint that you‚Äôre missing a cleanup function.\n\nStrict Mode lets you eagerly find mistakes in callback refs. When you fix your callback by adding a cleanup function in Strict Mode, you also fix many possible future production bugs like the ‚ÄúScroll to‚Äù bug from before:\n\nindex.js\nApp.js\nReload\nClear\nFork\nimport { useRef, useState } from \"react\";\n\nexport default function CatFriends() {\n  const itemsRef = useRef([]);\n  const [catList, setCatList] = useState(setupCatList);\n  const [cat, setCat] = useState('neo');\n\n  function scrollToCat(index) {\n    const list = itemsRef.current;\n    const {node} = list[index];\n    node.scrollIntoView({\n      behavior: \"smooth\",\n      block: \"nearest\",\n      inline: \"center\",\n    });\n  }\n\n  const cats = catList.filter(c => c.type === cat)\n\n  return (\n    <>\n      <nav>\n        <button onClick={() => setCat('neo')}>Neo</button>\n        <button onClick={() => setCat('millie')}>Millie</button>\n      </nav>\n      <hr />\n      <nav>\n        <span>Scroll to:</span>{cats.map((cat, index) => (\n          <button key={cat.src} onClick={() => scrollToCat(index)}>\n            {index}\n          </button>\n        ))}\n      </nav>\n      <div>\n        <ul>\n          {cats.map((cat) => (\n            <li\n              key={cat.src}\n              ref={(node) => {\n                const list = itemsRef.current;\n                const item = {cat: cat, node};\n                list.push(item);\n                console.log(`‚úÖ Adding cat to the map. Total cats: ${list.length}`);\n                if (list.length > 10) {\n                  console.log('‚ùå Too many cats in the list!');\n                }\n                return () => {\n                  list.splice(list.indexOf(item), 1);\n                  console.log(`‚ùå Removing cat from the map. Total cats: ${itemsRef.current.length}`);\n                }\n              }}\n            >\n              <img src={cat.src} />\n            </li>\n          ))}\n        </ul>\n      </div>\n    </>\n  );\n}\n\nfunction setupCatList() {\n  const catList = [];\n  for (let i = 0; i < 10; i++) {\n    catList.push({type: 'neo', src: \"https://placecats.com/neo/320/240?\" + i});\n  }\n  for (let i = 0; i < 10; i++) {\n    catList.push({type: 'millie', src: \"https://placecats.com/millie/320/240?\" + i});\n  }\n\n  return catList;\n}\n\n\nShow more\n\nNow on inital mount in StrictMode, the ref callbacks are all setup, cleaned up, and setup again:\n\n...\n\n‚úÖ Adding animal to the map. Total animals: 10\n\n...\n\n‚ùå Removing animal from the map. Total animals: 0\n\n...\n\n‚úÖ Adding animal to the map. Total animals: 10\n\nThis is expected. Strict Mode confirms that the ref callbacks are cleaned up correctly, so the size never grows above the expected amount. After the fix, there are no memory leaks, and all the features work as expected.\n\nWithout Strict Mode, it was easy to miss the bug until you clicked around to app to notice broken features. Strict Mode made the bugs appear right away, before you push them to production.\n\nFixing deprecation warnings enabled by Strict Mode \n\nReact warns if some component anywhere inside a <StrictMode> tree uses one of these deprecated APIs:\n\nUNSAFE_ class lifecycle methods like UNSAFE_componentWillMount. See alternatives.\n\nThese APIs are primarily used in older class components so they rarely appear in modern apps.\n\nPREVIOUS\n<Profiler>\nNEXT\n<Suspense>"
  },
  {
    "title": "<Suspense> ‚Äì React",
    "url": "https://react.dev/reference/react/Suspense",
    "html": "API REFERENCE\nCOMPONENTS\n<Suspense>\n\n<Suspense> lets you display a fallback until its children have finished loading.\n\n<Suspense fallback={<Loading />}>\n\n  <SomeComponent />\n\n</Suspense>\nReference\n<Suspense>\nUsage\nDisplaying a fallback while content is loading\nRevealing content together at once\nRevealing nested content as it loads\nShowing stale content while fresh content is loading\nPreventing already revealed content from hiding\nIndicating that a Transition is happening\nResetting Suspense boundaries on navigation\nProviding a fallback for server errors and client-only content\nTroubleshooting\nHow do I prevent the UI from being replaced by a fallback during an update?\nReference \n<Suspense> \nProps \nchildren: The actual UI you intend to render. If children suspends while rendering, the Suspense boundary will switch to rendering fallback.\nfallback: An alternate UI to render in place of the actual UI if it has not finished loading. Any valid React node is accepted, though in practice, a fallback is a lightweight placeholder view, such as a loading spinner or skeleton. Suspense will automatically switch to fallback when children suspends, and back to children when the data is ready. If fallback suspends while rendering, it will activate the closest parent Suspense boundary.\nCaveats \nReact does not preserve any state for renders that got suspended before they were able to mount for the first time. When the component has loaded, React will retry rendering the suspended tree from scratch.\nIf Suspense was displaying content for the tree, but then it suspended again, the fallback will be shown again unless the update causing it was caused by startTransition or useDeferredValue.\nIf React needs to hide the already visible content because it suspended again, it will clean up layout Effects in the content tree. When the content is ready to be shown again, React will fire the layout Effects again. This ensures that Effects measuring the DOM layout don‚Äôt try to do this while the content is hidden.\nReact includes under-the-hood optimizations like Streaming Server Rendering and Selective Hydration that are integrated with Suspense. Read an architectural overview and watch a technical talk to learn more.\nUsage \nDisplaying a fallback while content is loading \n\nYou can wrap any part of your application with a Suspense boundary:\n\n<Suspense fallback={<Loading />}>\n\n  <Albums />\n\n</Suspense>\n\nReact will display your loading fallback until all the code and data needed by the children has been loaded.\n\nIn the example below, the Albums component suspends while fetching the list of albums. Until it‚Äôs ready to render, React switches the closest Suspense boundary above to show the fallback‚Äîyour Loading component. Then, when the data loads, React hides the Loading fallback and renders the Albums component with data.\n\nArtistPage.js\nAlbums.js\nReload\nClear\nFork\nimport { Suspense } from 'react';\nimport Albums from './Albums.js';\n\nexport default function ArtistPage({ artist }) {\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Suspense fallback={<Loading />}>\n        <Albums artistId={artist.id} />\n      </Suspense>\n    </>\n  );\n}\n\nfunction Loading() {\n  return <h2>üåÄ Loading...</h2>;\n}\n\n\nShow more\nNote\n\nOnly Suspense-enabled data sources will activate the Suspense component. They include:\n\nData fetching with Suspense-enabled frameworks like Relay and Next.js\nLazy-loading component code with lazy\nReading the value of a cached Promise with use\n\nSuspense does not detect when data is fetched inside an Effect or event handler.\n\nThe exact way you would load data in the Albums component above depends on your framework. If you use a Suspense-enabled framework, you‚Äôll find the details in its data fetching documentation.\n\nSuspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.\n\nRevealing content together at once \n\nBy default, the whole tree inside Suspense is treated as a single unit. For example, even if only one of these components suspends waiting for some data, all of them together will be replaced by the loading indicator:\n\n<Suspense fallback={<Loading />}>\n\n  <Biography />\n\n  <Panel>\n\n    <Albums />\n\n  </Panel>\n\n</Suspense>\n\nThen, after all of them are ready to be displayed, they will all appear together at once.\n\nIn the example below, both Biography and Albums fetch some data. However, because they are grouped under a single Suspense boundary, these components always ‚Äúpop in‚Äù together at the same time.\n\nArtistPage.js\nPanel.js\nBiography.js\nAlbums.js\nReload\nClear\nFork\nimport { Suspense } from 'react';\nimport Albums from './Albums.js';\nimport Biography from './Biography.js';\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Suspense fallback={<Loading />}>\n        <Biography artistId={artist.id} />\n        <Panel>\n          <Albums artistId={artist.id} />\n        </Panel>\n      </Suspense>\n    </>\n  );\n}\n\nfunction Loading() {\n  return <h2>üåÄ Loading...</h2>;\n}\n\n\nShow more\n\nComponents that load data don‚Äôt have to be direct children of the Suspense boundary. For example, you can move Biography and Albums into a new Details component. This doesn‚Äôt change the behavior. Biography and Albums share the same closest parent Suspense boundary, so their reveal is coordinated together.\n\n<Suspense fallback={<Loading />}>\n\n  <Details artistId={artist.id} />\n\n</Suspense>\n\n\n\nfunction Details({ artistId }) {\n\n  return (\n\n    <>\n\n      <Biography artistId={artistId} />\n\n      <Panel>\n\n        <Albums artistId={artistId} />\n\n      </Panel>\n\n    </>\n\n  );\n\n}\nRevealing nested content as it loads \n\nWhen a component suspends, the closest parent Suspense component shows the fallback. This lets you nest multiple Suspense components to create a loading sequence. Each Suspense boundary‚Äôs fallback will be filled in as the next level of content becomes available. For example, you can give the album list its own fallback:\n\n<Suspense fallback={<BigSpinner />}>\n\n  <Biography />\n\n  <Suspense fallback={<AlbumsGlimmer />}>\n\n    <Panel>\n\n      <Albums />\n\n    </Panel>\n\n  </Suspense>\n\n</Suspense>\n\nWith this change, displaying the Biography doesn‚Äôt need to ‚Äúwait‚Äù for the Albums to load.\n\nThe sequence will be:\n\nIf Biography hasn‚Äôt loaded yet, BigSpinner is shown in place of the entire content area.\nOnce Biography finishes loading, BigSpinner is replaced by the content.\nIf Albums hasn‚Äôt loaded yet, AlbumsGlimmer is shown in place of Albums and its parent Panel.\nFinally, once Albums finishes loading, it replaces AlbumsGlimmer.\nArtistPage.js\nPanel.js\nBiography.js\nAlbums.js\nReload\nClear\nFork\nimport { Suspense } from 'react';\nimport Albums from './Albums.js';\nimport Biography from './Biography.js';\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Suspense fallback={<BigSpinner />}>\n        <Biography artistId={artist.id} />\n        <Suspense fallback={<AlbumsGlimmer />}>\n          <Panel>\n            <Albums artistId={artist.id} />\n          </Panel>\n        </Suspense>\n      </Suspense>\n    </>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2>üåÄ Loading...</h2>;\n}\n\nfunction AlbumsGlimmer() {\n  return (\n    <div className=\"glimmer-panel\">\n      <div className=\"glimmer-line\" />\n      <div className=\"glimmer-line\" />\n      <div className=\"glimmer-line\" />\n    </div>\n  );\n}\n\n\nShow more\n\nSuspense boundaries let you coordinate which parts of your UI should always ‚Äúpop in‚Äù together at the same time, and which parts should progressively reveal more content in a sequence of loading states. You can add, move, or delete Suspense boundaries in any place in the tree without affecting the rest of your app‚Äôs behavior.\n\nDon‚Äôt put a Suspense boundary around every component. Suspense boundaries should not be more granular than the loading sequence that you want the user to experience. If you work with a designer, ask them where the loading states should be placed‚Äîit‚Äôs likely that they‚Äôve already included them in their design wireframes.\n\nShowing stale content while fresh content is loading \n\nIn this example, the SearchResults component suspends while fetching the search results. Type \"a\", wait for the results, and then edit it to \"ab\". The results for \"a\" will get replaced by the loading fallback.\n\nApp.js\nSearchResults.js\nReload\nClear\nFork\nimport { Suspense, useState } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const [query, setQuery] = useState('');\n  return (\n    <>\n      <label>\n        Search albums:\n        <input value={query} onChange={e => setQuery(e.target.value)} />\n      </label>\n      <Suspense fallback={<h2>Loading...</h2>}>\n        <SearchResults query={query} />\n      </Suspense>\n    </>\n  );\n}\n\n\nShow more\n\nA common alternative UI pattern is to defer updating the list and to keep showing the previous results until the new results are ready. The useDeferredValue Hook lets you pass a deferred version of the query down:\n\nexport default function App() {\n\n  const [query, setQuery] = useState('');\n\n  const deferredQuery = useDeferredValue(query);\n\n  return (\n\n    <>\n\n      <label>\n\n        Search albums:\n\n        <input value={query} onChange={e => setQuery(e.target.value)} />\n\n      </label>\n\n      <Suspense fallback={<h2>Loading...</h2>}>\n\n        <SearchResults query={deferredQuery} />\n\n      </Suspense>\n\n    </>\n\n  );\n\n}\n\nThe query will update immediately, so the input will display the new value. However, the deferredQuery will keep its previous value until the data has loaded, so SearchResults will show the stale results for a bit.\n\nTo make it more obvious to the user, you can add a visual indication when the stale result list is displayed:\n\n<div style={{\n\n  opacity: query !== deferredQuery ? 0.5 : 1 \n\n}}>\n\n  <SearchResults query={deferredQuery} />\n\n</div>\n\nEnter \"a\" in the example below, wait for the results to load, and then edit the input to \"ab\". Notice how instead of the Suspense fallback, you now see the dimmed stale result list until the new results have loaded:\n\nApp.js\nReload\nClear\nFork\nimport { Suspense, useState, useDeferredValue } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  const isStale = query !== deferredQuery;\n  return (\n    <>\n      <label>\n        Search albums:\n        <input value={query} onChange={e => setQuery(e.target.value)} />\n      </label>\n      <Suspense fallback={<h2>Loading...</h2>}>\n        <div style={{ opacity: isStale ? 0.5 : 1 }}>\n          <SearchResults query={deferredQuery} />\n        </div>\n      </Suspense>\n    </>\n  );\n}\n\n\nShow more\nNote\n\nBoth deferred values and Transitions let you avoid showing Suspense fallback in favor of inline indicators. Transitions mark the whole update as non-urgent so they are typically used by frameworks and router libraries for navigation. Deferred values, on the other hand, are mostly useful in application code where you want to mark a part of UI as non-urgent and let it ‚Äúlag behind‚Äù the rest of the UI.\n\nPreventing already revealed content from hiding \n\nWhen a component suspends, the closest parent Suspense boundary switches to showing the fallback. This can lead to a jarring user experience if it was already displaying some content. Try pressing this button:\n\nApp.js\nLayout.js\nIndexPage.js\nArtistPage.js\nAlbums.js\nBiography.js\nPanel.js\nReload\nClear\nFork\nimport { Suspense, useState } from 'react';\nimport IndexPage from './IndexPage.js';\nimport ArtistPage from './ArtistPage.js';\nimport Layout from './Layout.js';\n\nexport default function App() {\n  return (\n    <Suspense fallback={<BigSpinner />}>\n      <Router />\n    </Suspense>\n  );\n}\n\nfunction Router() {\n  const [page, setPage] = useState('/');\n\n  function navigate(url) {\n    setPage(url);\n  }\n\n  let content;\n  if (page === '/') {\n    content = (\n      <IndexPage navigate={navigate} />\n    );\n  } else if (page === '/the-beatles') {\n    content = (\n      <ArtistPage\n        artist={{\n          id: 'the-beatles',\n          name: 'The Beatles',\n        }}\n      />\n    );\n  }\n  return (\n    <Layout>\n      {content}\n    </Layout>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2>üåÄ Loading...</h2>;\n}\n\n\nShow more\n\nWhen you pressed the button, the Router component rendered ArtistPage instead of IndexPage. A component inside ArtistPage suspended, so the closest Suspense boundary started showing the fallback. The closest Suspense boundary was near the root, so the whole site layout got replaced by BigSpinner.\n\nTo prevent this, you can mark the navigation state update as a Transition with startTransition:\n\nfunction Router() {\n\n  const [page, setPage] = useState('/');\n\n\n\n  function navigate(url) {\n\n    startTransition(() => {\n\n      setPage(url);      \n\n    });\n\n  }\n\n  // ...\n\nThis tells React that the state transition is not urgent, and it‚Äôs better to keep showing the previous page instead of hiding any already revealed content. Now clicking the button ‚Äúwaits‚Äù for the Biography to load:\n\nApp.js\nLayout.js\nIndexPage.js\nArtistPage.js\nAlbums.js\nBiography.js\nPanel.js\nReload\nClear\nFork\nimport { Suspense, startTransition, useState } from 'react';\nimport IndexPage from './IndexPage.js';\nimport ArtistPage from './ArtistPage.js';\nimport Layout from './Layout.js';\n\nexport default function App() {\n  return (\n    <Suspense fallback={<BigSpinner />}>\n      <Router />\n    </Suspense>\n  );\n}\n\nfunction Router() {\n  const [page, setPage] = useState('/');\n\n  function navigate(url) {\n    startTransition(() => {\n      setPage(url);\n    });\n  }\n\n  let content;\n  if (page === '/') {\n    content = (\n      <IndexPage navigate={navigate} />\n    );\n  } else if (page === '/the-beatles') {\n    content = (\n      <ArtistPage\n        artist={{\n          id: 'the-beatles',\n          name: 'The Beatles',\n        }}\n      />\n    );\n  }\n  return (\n    <Layout>\n      {content}\n    </Layout>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2>üåÄ Loading...</h2>;\n}\n\n\nShow more\n\nA Transition doesn‚Äôt wait for all content to load. It only waits long enough to avoid hiding already revealed content. For example, the website Layout was already revealed, so it would be bad to hide it behind a loading spinner. However, the nested Suspense boundary around Albums is new, so the Transition doesn‚Äôt wait for it.\n\nNote\n\nSuspense-enabled routers are expected to wrap the navigation updates into Transitions by default.\n\nIndicating that a Transition is happening \n\nIn the above example, once you click the button, there is no visual indication that a navigation is in progress. To add an indicator, you can replace startTransition with useTransition which gives you a boolean isPending value. In the example below, it‚Äôs used to change the website header styling while a Transition is happening:\n\nApp.js\nLayout.js\nIndexPage.js\nArtistPage.js\nAlbums.js\nBiography.js\nPanel.js\nReload\nClear\nFork\nimport { Suspense, useState, useTransition } from 'react';\nimport IndexPage from './IndexPage.js';\nimport ArtistPage from './ArtistPage.js';\nimport Layout from './Layout.js';\n\nexport default function App() {\n  return (\n    <Suspense fallback={<BigSpinner />}>\n      <Router />\n    </Suspense>\n  );\n}\n\nfunction Router() {\n  const [page, setPage] = useState('/');\n  const [isPending, startTransition] = useTransition();\n\n  function navigate(url) {\n    startTransition(() => {\n      setPage(url);\n    });\n  }\n\n  let content;\n  if (page === '/') {\n    content = (\n      <IndexPage navigate={navigate} />\n    );\n  } else if (page === '/the-beatles') {\n    content = (\n      <ArtistPage\n        artist={{\n          id: 'the-beatles',\n          name: 'The Beatles',\n        }}\n      />\n    );\n  }\n  return (\n    <Layout isPending={isPending}>\n      {content}\n    </Layout>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2>üåÄ Loading...</h2>;\n}\n\n\nShow more\nResetting Suspense boundaries on navigation \n\nDuring a Transition, React will avoid hiding already revealed content. However, if you navigate to a route with different parameters, you might want to tell React it is different content. You can express this with a key:\n\n<ProfilePage key={queryParams.id} />\n\nImagine you‚Äôre navigating within a user‚Äôs profile page, and something suspends. If that update is wrapped in a Transition, it will not trigger the fallback for already visible content. That‚Äôs the expected behavior.\n\nHowever, now imagine you‚Äôre navigating between two different user profiles. In that case, it makes sense to show the fallback. For example, one user‚Äôs timeline is different content from another user‚Äôs timeline. By specifying a key, you ensure that React treats different users‚Äô profiles as different components, and resets the Suspense boundaries during navigation. Suspense-integrated routers should do this automatically.\n\nProviding a fallback for server errors and client-only content \n\nIf you use one of the streaming server rendering APIs (or a framework that relies on them), React will also use your <Suspense> boundaries to handle errors on the server. If a component throws an error on the server, React will not abort the server render. Instead, it will find the closest <Suspense> component above it and include its fallback (such as a spinner) into the generated server HTML. The user will see a spinner at first.\n\nOn the client, React will attempt to render the same component again. If it errors on the client too, React will throw the error and display the closest Error Boundary. However, if it does not error on the client, React will not display the error to the user since the content was eventually displayed successfully.\n\nYou can use this to opt out some components from rendering on the server. To do this, throw an error in the server environment and then wrap them in a <Suspense> boundary to replace their HTML with fallbacks:\n\n<Suspense fallback={<Loading />}>\n\n  <Chat />\n\n</Suspense>\n\n\n\nfunction Chat() {\n\n  if (typeof window === 'undefined') {\n\n    throw Error('Chat should only render on the client.');\n\n  }\n\n  // ...\n\n}\n\nThe server HTML will include the loading indicator. It will be replaced by the Chat component on the client.\n\nTroubleshooting \nHow do I prevent the UI from being replaced by a fallback during an update? \n\nReplacing visible UI with a fallback creates a jarring user experience. This can happen when an update causes a component to suspend, and the nearest Suspense boundary is already showing content to the user.\n\nTo prevent this from happening, mark the update as non-urgent using startTransition. During a Transition, React will wait until enough data has loaded to prevent an unwanted fallback from appearing:\n\nfunction handleNextPageClick() {\n\n  // If this update suspends, don't hide the already displayed content\n\n  startTransition(() => {\n\n    setCurrentPage(currentPage + 1);\n\n  });\n\n}\n\nThis will avoid hiding existing content. However, any newly rendered Suspense boundaries will still immediately display fallbacks to avoid blocking the UI and let the user see the content as it becomes available.\n\nReact will only prevent unwanted fallbacks during non-urgent updates. It will not delay a render if it‚Äôs the result of an urgent update. You must opt in with an API like startTransition or useDeferredValue.\n\nIf your router is integrated with Suspense, it should wrap its updates into startTransition automatically.\n\nPREVIOUS\n<StrictMode>\nNEXT\n<Activity>"
  },
  {
    "title": "<Activity> ‚Äì React",
    "url": "https://react.dev/reference/react/Activity",
    "html": "API REFERENCE\nCOMPONENTS\n<Activity>\n\n<Activity> lets you hide and restore the UI and internal state of its children.\n\n<Activity mode={visibility}>\n\n  <Sidebar />\n\n</Activity>\nReference\n<Activity>\nUsage\nRestoring the state of hidden components\nRestoring the DOM of hidden components\nPre-rendering content that‚Äôs likely to become visible\nSpeeding up interactions during page load\nTroubleshooting\nMy hidden components have unwanted side effects\nMy hidden components have Effects that aren‚Äôt running\nReference \n<Activity> \n\nYou can use Activity to hide part of your application:\n\n<Activity mode={isShowingSidebar ? \"visible\" : \"hidden\"}>\n\n  <Sidebar />\n\n</Activity>\n\nWhen an Activity boundary is hidden, React will visually hide its children using the display: \"none\" CSS property. It will also destroy their Effects, cleaning up any active subscriptions.\n\nWhile hidden, children still re-render in response to new props, albeit at a lower priority than the rest of the content.\n\nWhen the boundary becomes visible again, React will reveal the children with their previous state restored, and re-create their Effects.\n\nIn this way, Activity can be thought of as a mechanism for rendering ‚Äúbackground activity‚Äù. Rather than completely discarding content that‚Äôs likely to become visible again, you can use Activity to maintain and restore that content‚Äôs UI and internal state, while ensuring that your hidden content has no unwanted side effects.\n\nSee more examples below.\n\nProps \nchildren: The UI you intend to show and hide.\nmode: A string value of either 'visible' or 'hidden'. If omitted, defaults to 'visible'.\nCaveats \nIf an Activity is rendered inside of a ViewTransition, and it becomes visible as a result of an update caused by startTransition, it will activate the ViewTransition‚Äôs enter animation. If it becomes hidden, it will activate its exit animation.\nAn Activity that just renders text will not render anything rather than rendering hidden text, because there‚Äôs no corresponding DOM element to apply visibility changes to. For example, <Activity mode=\"hidden\"><ComponentThatJustReturnsText /></Activity> will not produce any output in the DOM for const ComponentThatJustReturnsText = () => \"Hello, World!\".\nUsage \nRestoring the state of hidden components \n\nIn React, when you want to conditionally show or hide a component, you typically mount or unmount it based on that condition:\n\n{isShowingSidebar && (\n\n  <Sidebar />\n\n)}\n\nBut unmounting a component destroys its internal state, which is not always what you want.\n\nWhen you hide a component using an Activity boundary instead, React will ‚Äúsave‚Äù its state for later:\n\n<Activity mode={isShowingSidebar ? \"visible\" : \"hidden\"}>\n\n  <Sidebar />\n\n</Activity>\n\nThis makes it possible to hide and then later restore components in the state they were previously in.\n\nThe following example has a sidebar with an expandable section. You can press ‚ÄúOverview‚Äù to reveal the three subitems below it. The main app area also has a button that hides and shows the sidebar.\n\nTry expanding the Overview section, and then toggling the sidebar closed then open:\n\nApp.js\nSidebar.js\nReload\nClear\nFork\nimport { useState } from 'react';\nimport Sidebar from './Sidebar.js';\n\nexport default function App() {\n  const [isShowingSidebar, setIsShowingSidebar] = useState(true);\n\n  return (\n    <>\n      {isShowingSidebar && (\n        <Sidebar />\n      )}\n\n      <main>\n        <button onClick={() => setIsShowingSidebar(!isShowingSidebar)}>\n          Toggle sidebar\n        </button>\n        <h1>Main content</h1>\n      </main>\n    </>\n  );\n}\n\n\nShow more\n\nThe Overview section always starts out collapsed. Because we unmount the sidebar when isShowingSidebar flips to false, all its internal state is lost.\n\nThis is a perfect use case for Activity. We can preserve the internal state of our sidebar, even when visually hiding it.\n\nLet‚Äôs replace the conditional rendering of our sidebar with an Activity boundary:\n\n// Before\n\n{isShowingSidebar && (\n\n  <Sidebar />\n\n)}\n\n\n\n// After\n\n<Activity mode={isShowingSidebar ? 'visible' : 'hidden'}>\n\n  <Sidebar />\n\n</Activity>\n\nand check out the new behavior:\n\nApp.js\nSidebar.js\nReload\nClear\nFork\nimport { Activity, useState } from 'react';\n\nimport Sidebar from './Sidebar.js';\n\nexport default function App() {\n  const [isShowingSidebar, setIsShowingSidebar] = useState(true);\n\n  return (\n    <>\n      <Activity mode={isShowingSidebar ? 'visible' : 'hidden'}>\n        <Sidebar />\n      </Activity>\n\n      <main>\n        <button onClick={() => setIsShowingSidebar(!isShowingSidebar)}>\n          Toggle sidebar\n        </button>\n        <h1>Main content</h1>\n      </main>\n    </>\n  );\n}\n\n\nShow more\n\nOur sidebar‚Äôs internal state is now restored, without any changes to its implementation.\n\nRestoring the DOM of hidden components \n\nSince Activity boundaries hide their children using display: none, their children‚Äôs DOM is also preserved when hidden. This makes them great for maintaining ephemeral state in parts of the UI that the user is likely to interact with again.\n\nIn this example, the Contact tab has a <textarea> where the user can enter a message. If you enter some text, change to the Home tab, then change back to the Contact tab, the draft message is lost:\n\nApp.js\nTabButton.js\nHome.js\nContact.js\nReload\nClear\nFork\nexport default function Contact() {\n  return (\n    <div>\n      <p>Send me a message!</p>\n\n      <textarea />\n\n      <p>You can find me online here:</p>\n      <ul>\n        <li>admin@mysite.com</li>\n        <li>+123456789</li>\n      </ul>\n    </div>\n  );\n}\n\n\n\nThis is because we‚Äôre fully unmounting Contact in App. When the Contact tab unmounts, the <textarea> element‚Äôs internal DOM state is lost.\n\nIf we switch to using an Activity boundary to show and hide the active tab, we can preserve the state of each tab‚Äôs DOM. Try entering text and switching tabs again, and you‚Äôll see the draft message is no longer reset:\n\nApp.js\nTabButton.js\nHome.js\nContact.js\nReload\nClear\nFork\nimport { Activity, useState } from 'react';\nimport TabButton from './TabButton.js';\nimport Home from './Home.js';\nimport Contact from './Contact.js';\n\nexport default function App() {\n  const [activeTab, setActiveTab] = useState('contact');\n\n  return (\n    <>\n      <TabButton\n        isActive={activeTab === 'home'}\n        onClick={() => setActiveTab('home')}\n      >\n        Home\n      </TabButton>\n      <TabButton\n        isActive={activeTab === 'contact'}\n        onClick={() => setActiveTab('contact')}\n      >\n        Contact\n      </TabButton>\n\n      <hr />\n\n      <Activity mode={activeTab === 'home' ? 'visible' : 'hidden'}>\n        <Home />\n      </Activity>\n      <Activity mode={activeTab === 'contact' ? 'visible' : 'hidden'}>\n        <Contact />\n      </Activity>\n    </>\n  );\n}\n\n\nShow more\n\nAgain, the Activity boundary let us preserve the Contact tab‚Äôs internal state without changing its implementation.\n\nPre-rendering content that‚Äôs likely to become visible \n\nSo far, we‚Äôve seen how Activity can hide some content that the user has interacted with, without discarding that content‚Äôs ephemeral state.\n\nBut Activity boundaries can also be used to prepare content that the user has yet to see for the first time:\n\n<Activity mode=\"hidden\">\n\n  <SlowComponent />\n\n</Activity>\n\nWhen an Activity boundary is hidden during its initial render, its children won‚Äôt be visible on the page ‚Äî but they will still be rendered, albeit at a lower priority than the visible content, and without mounting their Effects.\n\nThis pre-rendering allows the children to load any code or data they need ahead of time, so that later, when the Activity boundary becomes visible, the children can appear faster with reduced loading times.\n\nLet‚Äôs look at an example.\n\nIn this demo, the Posts tab loads some data. If you press it, you‚Äôll see a Suspense fallback displayed while the data is being fetched:\n\nApp.js\nHome.js\nPosts.js\nReload\nClear\nFork\nimport { useState, Suspense } from 'react';\nimport TabButton from './TabButton.js';\nimport Home from './Home.js';\nimport Posts from './Posts.js';\n\nexport default function App() {\n  const [activeTab, setActiveTab] = useState('home');\n\n  return (\n    <>\n      <TabButton\n        isActive={activeTab === 'home'}\n        onClick={() => setActiveTab('home')}\n      >\n        Home\n      </TabButton>\n      <TabButton\n        isActive={activeTab === 'posts'}\n        onClick={() => setActiveTab('posts')}\n      >\n        Posts\n      </TabButton>\n\n      <hr />\n\n      <Suspense fallback={<h1>üåÄ Loading...</h1>}>\n        {activeTab === 'home' && <Home />}\n        {activeTab === 'posts' && <Posts />}\n      </Suspense>\n    </>\n  );\n}\n\n\nShow more\n\nThis is because App doesn‚Äôt mount Posts until its tab is active.\n\nIf we update App to use an Activity boundary to show and hide the active tab, Posts will be pre-rendered when the app first loads, allowing it to fetch its data before it becomes visible.\n\nTry clicking the Posts tab now:\n\nApp.js\nHome.js\nPosts.js\nReload\nClear\nFork\nimport { Activity, useState, Suspense } from 'react';\nimport TabButton from './TabButton.js';\nimport Home from './Home.js';\nimport Posts from './Posts.js';\n\nexport default function App() {\n  const [activeTab, setActiveTab] = useState('home');\n\n  return (\n    <>\n      <TabButton\n        isActive={activeTab === 'home'}\n        onClick={() => setActiveTab('home')}\n      >\n        Home\n      </TabButton>\n      <TabButton\n        isActive={activeTab === 'posts'}\n        onClick={() => setActiveTab('posts')}\n      >\n        Posts\n      </TabButton>\n\n      <hr />\n\n      <Suspense fallback={<h1>üåÄ Loading...</h1>}>\n        <Activity mode={activeTab === 'home' ? 'visible' : 'hidden'}>\n          <Home />\n        </Activity>\n        <Activity mode={activeTab === 'posts' ? 'visible' : 'hidden'}>\n          <Posts />\n        </Activity>\n      </Suspense>\n    </>\n  );\n}\n\n\nShow more\n\nPosts was able to prepare itself for a faster render, thanks to the hidden Activity boundary.\n\nPre-rendering components with hidden Activity boundaries is a powerful way to reduce loading times for parts of the UI that the user is likely to interact with next.\n\nNote\n\nOnly Suspense-enabled data sources will be fetched during pre-rendering. They include:\n\nData fetching with Suspense-enabled frameworks like Relay and Next.js\nLazy-loading component code with lazy\nReading the value of a cached Promise with use\n\nActivity does not detect data that is fetched inside an Effect.\n\nThe exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you‚Äôll find the details in its data fetching documentation.\n\nSuspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.\n\nSpeeding up interactions during page load \n\nReact includes an under-the-hood performance optimization called Selective Hydration. It works by hydrating your app‚Äôs initial HTML in chunks, enabling some components to become interactive even if other components on the page haven‚Äôt loaded their code or data yet.\n\nSuspense boundaries participate in Selective Hydration, because they naturally divide your component tree into units that are independent from one another:\n\nfunction Page() {\n\n  return (\n\n    <>\n\n      <MessageComposer />\n\n\n\n      <Suspense fallback=\"Loading chats...\">\n\n        <Chats />\n\n      </Suspense>\n\n    </>\n\n  )\n\n}\n\nHere, MessageComposer can be fully hydrated during the initial render of the page, even before Chats is mounted and starts to fetch its data.\n\nSo by breaking up your component tree into discrete units, Suspense allows React to hydrate your app‚Äôs server-rendered HTML in chunks, enabling parts of your app to become interactive as fast as possible.\n\nBut what about pages that don‚Äôt use Suspense?\n\nTake this tabs example:\n\nfunction Page() {\n\n  const [activeTab, setActiveTab] = useState('home');\n\n\n\n  return (\n\n    <>\n\n      <TabButton onClick={() => setActiveTab('home')}>\n\n        Home\n\n      </TabButton>\n\n      <TabButton onClick={() => setActiveTab('video')}>\n\n        Video\n\n      </TabButton>\n\n\n\n      {activeTab === 'home' && (\n\n        <Home />\n\n      )}\n\n      {activeTab === 'video' && (\n\n        <Video />\n\n      )}\n\n    </>\n\n  )\n\n}\n\nHere, React must hydrate the entire page all at once. If Home or Video are slower to render, they could make the tab buttons feel unresponsive during hydration.\n\nAdding Suspense around the active tab would solve this:\n\nfunction Page() {\n\n  const [activeTab, setActiveTab] = useState('home');\n\n\n\n  return (\n\n    <>\n\n      <TabButton onClick={() => setActiveTab('home')}>\n\n        Home\n\n      </TabButton>\n\n      <TabButton onClick={() => setActiveTab('video')}>\n\n        Video\n\n      </TabButton>\n\n\n\n      <Suspense fallback={<Placeholder />}>\n\n        {activeTab === 'home' && (\n\n          <Home />\n\n        )}\n\n        {activeTab === 'video' && (\n\n          <Video />\n\n        )}\n\n      </Suspense>\n\n    </>\n\n  )\n\n}\n\n‚Ä¶but it would also change the UI, since the Placeholder fallback would be displayed on the initial render.\n\nInstead, we can use Activity. Since Activity boundaries show and hide their children, they already naturally divide the component tree into independent units. And just like Suspense, this feature allows them to participate in Selective Hydration.\n\nLet‚Äôs update our example to use Activity boundaries around the active tab:\n\nfunction Page() {\n\n  const [activeTab, setActiveTab] = useState('home');\n\n\n\n  return (\n\n    <>\n\n      <TabButton onClick={() => setActiveTab('home')}>\n\n        Home\n\n      </TabButton>\n\n      <TabButton onClick={() => setActiveTab('video')}>\n\n        Video\n\n      </TabButton>\n\n\n\n      <Activity mode={activeTab === \"home\" ? \"visible\" : \"hidden\"}>\n\n        <Home />\n\n      </Activity>\n\n      <Activity mode={activeTab === \"video\" ? \"visible\" : \"hidden\"}>\n\n        <Video />\n\n      </Activity>\n\n    </>\n\n  )\n\n}\n\nNow our initial server-rendered HTML looks the same as it did in the original version, but thanks to Activity, React can hydrate the tab buttons first, before it even mounts Home or Video.\n\nThus, in addition to hiding and showing content, Activity boundaries help improve your app‚Äôs performance during hydration by letting React know which parts of your page can become interactive in isolation.\n\nAnd even if your page doesn‚Äôt ever hide part of its content, you can still add always-visible Activity boundaries to improve hydration performance:\n\nfunction Page() {\n\n  return (\n\n    <>\n\n      <Post />\n\n\n\n      <Activity>\n\n        <Comments />\n\n      </Activity>\n\n    </>\n\n  );\n\n}\nTroubleshooting \nMy hidden components have unwanted side effects \n\nAn Activity boundary hides its content by setting display: none on its children and cleaning up any of their Effects. So, most well-behaved React components that properly clean up their side effects will already be robust to being hidden by Activity.\n\nBut there are some situations where a hidden component behaves differently than an unmounted one. Most notably, since a hidden component‚Äôs DOM is not destroyed, any side effects from that DOM will persist, even after the component is hidden.\n\nAs an example, consider a <video> tag. Typically it doesn‚Äôt require any cleanup, because even if you‚Äôre playing a video, unmounting the tag stops the video and audio from playing in the browser. Try playing the video and then pressing Home in this demo:\n\nApp.js\nHome.js\nVideo.js\nReload\nClear\nFork\nimport { useState } from 'react';\nimport TabButton from './TabButton.js';\nimport Home from './Home.js';\nimport Video from './Video.js';\n\nexport default function App() {\n  const [activeTab, setActiveTab] = useState('video');\n\n  return (\n    <>\n      <TabButton\n        isActive={activeTab === 'home'}\n        onClick={() => setActiveTab('home')}\n      >\n        Home\n      </TabButton>\n      <TabButton\n        isActive={activeTab === 'video'}\n        onClick={() => setActiveTab('video')}\n      >\n        Video\n      </TabButton>\n\n      <hr />\n\n      {activeTab === 'home' && <Home />}\n      {activeTab === 'video' && <Video />}\n    </>\n  );\n}\n\n\nShow more\n\nThe video stops playing as expected.\n\nNow, let‚Äôs say we wanted to preserve the timecode where the user last watched, so that when they tab back to the video, it doesn‚Äôt start over from the beginning again.\n\nThis is a great use case for Activity!\n\nLet‚Äôs update App to hide the inactive tab with a hidden Activity boundary instead of unmounting it, and see how the demo behaves this time:\n\nApp.js\nHome.js\nVideo.js\nReload\nClear\nFork\nimport { Activity, useState } from 'react';\nimport TabButton from './TabButton.js';\nimport Home from './Home.js';\nimport Video from './Video.js';\n\nexport default function App() {\n  const [activeTab, setActiveTab] = useState('video');\n\n  return (\n    <>\n      <TabButton\n        isActive={activeTab === 'home'}\n        onClick={() => setActiveTab('home')}\n      >\n        Home\n      </TabButton>\n      <TabButton\n        isActive={activeTab === 'video'}\n        onClick={() => setActiveTab('video')}\n      >\n        Video\n      </TabButton>\n\n      <hr />\n\n      <Activity mode={activeTab === 'home' ? 'visible' : 'hidden'}>\n        <Home />\n      </Activity>\n      <Activity mode={activeTab === 'video' ? 'visible' : 'hidden'}>\n        <Video />\n      </Activity>\n    </>\n  );\n}\n\n\nShow more\n\nWhoops! The video and audio continue to play even after it‚Äôs been hidden, because the tab‚Äôs <video> element is still in the DOM.\n\nTo fix this, we can add an Effect with a cleanup function that pauses the video:\n\nexport default function VideoTab() {\n\n  const ref = useRef();\n\n\n\n  useLayoutEffect(() => {\n\n    const videoRef = ref.current;\n\n\n\n    return () => {\n\n      videoRef.pause()\n\n    }\n\n  }, []);\n\n\n\n  return (\n\n    <video\n\n      ref={ref}\n\n      controls\n\n      playsInline\n\n      src=\"...\"\n\n    />\n\n\n\n  );\n\n}\n\nWe call useLayoutEffect instead of useEffect because conceptually the clean-up code is tied to the component‚Äôs UI being visually hidden. If we used a regular effect, the code could be delayed by (say) a re-suspending Suspense boundary or a View Transition.\n\nLet‚Äôs see the new behavior. Try playing the video, switching to the Home tab, then back to the Video tab:\n\nApp.js\nHome.js\nVideo.js\nReload\nClear\nFork\nimport { Activity, useState } from 'react';\nimport TabButton from './TabButton.js';\nimport Home from './Home.js';\nimport Video from './Video.js';\n\nexport default function App() {\n  const [activeTab, setActiveTab] = useState('video');\n\n  return (\n    <>\n      <TabButton\n        isActive={activeTab === 'home'}\n        onClick={() => setActiveTab('home')}\n      >\n        Home\n      </TabButton>\n      <TabButton\n        isActive={activeTab === 'video'}\n        onClick={() => setActiveTab('video')}\n      >\n        Video\n      </TabButton>\n\n      <hr />\n\n      <Activity mode={activeTab === 'home' ? 'visible' : 'hidden'}>\n        <Home />\n      </Activity>\n      <Activity mode={activeTab === 'video' ? 'visible' : 'hidden'}>\n        <Video />\n      </Activity>\n    </>\n  );\n}\n\n\nShow more\n\nIt works great! Our cleanup function ensures that the video stops playing if it‚Äôs ever hidden by an Activity boundary, and even better, because the <video> tag is never destroyed, the timecode is preserved, and the video itself doesn‚Äôt need to be initialized or downloaded again when the user switches back to keep watching it.\n\nThis is a great example of using Activity to preserve ephemeral DOM state for parts of the UI that become hidden, but the user is likely to interact with again soon.\n\nOur example illustrates that for certain tags like <video>, unmounting and hiding have different behavior. If a component renders DOM that has a side effect, and you want to prevent that side effect when an Activity boundary hides it, add an Effect with a return function to clean it up.\n\nThe most common cases of this will be from the following tags:\n\n<video>\n<audio>\n<iframe>\n\nTypically, though, most of your React components should already be robust to being hidden by an Activity boundary. And conceptually, you should think of ‚Äúhidden‚Äù Activities as being unmounted.\n\nTo eagerly discover other Effects that don‚Äôt have proper cleanup, which is important not only for Activity boundaries but for many other behaviors in React, we recommend using <StrictMode>.\n\nMy hidden components have Effects that aren‚Äôt running \n\nWhen an <Activity> is ‚Äúhidden‚Äù, all its children‚Äôs Effects are cleaned up. Conceptually, the children are unmounted, but React saves their state for later. This is a feature of Activity because it means subscriptions won‚Äôt be active for hidden parts of the UI, reducing the amount of work needed for hidden content.\n\nIf you‚Äôre relying on an Effect mounting to clean up a component‚Äôs side effects, refactor the Effect to do the work in the returned cleanup function instead.\n\nTo eagerly find problematic Effects, we recommend adding <StrictMode> which will eagerly perform Activity unmounts and mounts to catch any unexpected side-effects.\n\nPREVIOUS\n<Suspense>\nNEXT\n<ViewTransition>"
  },
  {
    "title": "<ViewTransition> ‚Äì React",
    "url": "https://react.dev/reference/react/ViewTransition",
    "html": "API REFERENCE\nCOMPONENTS\n<ViewTransition>\nCanary\n\nThe <ViewTransition /> API is currently only available in React‚Äôs Canary and Experimental channels.\n\nLearn more about React‚Äôs release channels here.\n\n<ViewTransition> lets you animate elements that update inside a Transition.\n\nimport {ViewTransition} from 'react';\n\n\n\n<ViewTransition>\n\n  <div>...</div>\n\n</ViewTransition>\nReference\n<ViewTransition>\nView Transition Class\nStyling View Transitions\nUsage\nAnimating an element on enter/exit\nAnimating a shared element\nAnimating reorder of items in a list\nAnimating from Suspense content\nOpting-out of an animation\nCustomizing animations\nCustomizing animations with types\nBuilding View Transition enabled routers\nTroubleshooting\nMy <ViewTransition> is not activating\nI‚Äôm getting an error ‚ÄúThere are two <ViewTransition name=%s> components with the same name mounted at the same time.‚Äù\nReference \n<ViewTransition> \n\nWrap elements in <ViewTransition> to animate them when they update inside a Transition. React uses the following heuristics to determine if a View Transition activates for an animation:\n\nenter: If a ViewTransition itself gets inserted in this Transition, then this will activate.\nexit: If a ViewTransition itself gets deleted in this Transition, then this will activate.\nupdate: If a ViewTransition has any DOM mutations inside it that React is doing (such as a prop changing) or if the ViewTransition boundary itself changes size or position due to an immediate sibling. If there are nested ViewTransition then the mutation applies to them and not the parent.\nshare: If a named ViewTransition is inside a deleted subtree and another named ViewTransition with the same name is part of an inserted subtree in the same Transition, they form a Shared Element Transition, and it animates from the deleted one to the inserted one.\n\nBy default, <ViewTransition> animates with a smooth cross-fade (the browser default view transition). You can customize the animation by providing a View Transition Class to the <ViewTransition> component. You can  customize animations for each kind of trigger (see Styling View Transitions).\n\nDEEP DIVE\nHow does <ViewTransition> work? \nShow Details\nProps \n\nBy default, <ViewTransition> animates with a smooth cross-fade. You can customize the animation, or specify a shared element transition, with these props:\n\noptional enter: A string or object. The View Transition Class to apply when enter is activated.\noptional exit: A string or object. The View Transition Class to apply when exit is activated.\noptional update: A string or object. The View Transition Class to apply when an update is activated.\noptional share: A string or object. The View Transition Class to apply when a shared element is activated.\noptional default: A string or object. The View Transition Class used when no other matching activation prop is found.\noptional name: A string or object. The name of the View Transition used for shared element transitions. If not provided, React will use a unique name for each View Transition to prevent unexpected animations.\nCallback \n\nThese callbacks allow you to adjust the animation imperatively using the animate APIs:\n\noptional onEnter: A function. React calls onEnter after an ‚Äúenter‚Äù animation.\noptional onExit: A function. React calls onExit after an ‚Äúexit‚Äù animation.\noptional onShare: A function. React calls onShare after a ‚Äúshare‚Äù animation.\noptional onUpdate: A function. React calls onUpdate after an ‚Äúupdate‚Äù animation.\n\nEach callback receives as arguments:\n\nelement: The DOM element that was animated.\ntypes: The Transition Types included in the animation.\nView Transition Class \n\nThe View Transition Class is the CSS class name(s) applied by React during the transition when the ViewTransition activates. It can be a string or an object.\n\nstring: the class added on the child elements when activated. If 'none' is provided, no class will be added.\nobject: the class added on the child elements will be the key matching View Transition type added with addTransitionType. The object can also specify a default to use if no matching type is found.\n\nThe value 'none' can be used to prevent a View Transition from activating for a specific trigger.\n\nStyling View Transitions \nNote\n\nIn many early examples of View Transitions around the web, you‚Äôll have seen using a view-transition-name and then style it using ::view-transition-...(my-name) selectors. We don‚Äôt recommend that for styling. Instead, we normally recommend using a View Transition Class instead.\n\nTo customize the animation for a <ViewTransition> you can provide a View Transition Class to one of the activation props. The View Transition Class is a CSS class name that React applies to the child elements when the ViewTransition activates.\n\nFor example, to customize an ‚Äúenter‚Äù animation, provide a class name to the enter prop:\n\n<ViewTransition enter=\"slide-in\">\n\nWhen the <ViewTransition> activates an ‚Äúenter‚Äù animation, React will add the class name slide-in. Then you can refer to this class using view transition pseudo selectors to build reusable animations:\n\n::view-transition-group(.slide-in) {\n\n  \n\n}\n\n::view-transition-old(.slide-in) {\n\n\n\n}\n\n::view-transition-new(.slide-in) {\n\n\n\n}\n\nIn the future, CSS libraries may add built-in animations using View Transition Classes to make this easier to use.\n\nCaveats \nBy default, setState updates immediately and does not activate <ViewTransition>, only updates wrapped in a Transition. You can also use <Suspense> to opt-in to a Transition to reveal content.\n<ViewTransition> creates an image that can be moved around, scaled and cross-faded. Unlike Layout Animations you may have seen in React Native or Motion, this means that not every individual Element inside of it animates its position. This can lead to better performance and a more continuous feeling, smooth animation compared to animating every individual piece. However, it can also lose continuity in things that should be moving by themselves. So you might have to add more <ViewTransition> boundaries manually as a result.\nMany users may prefer not having animations on the page. React doesn‚Äôt automatically disable animations for this case. We recommend that using the @media (prefers-reduced-motion) media query to disable animations or tone them down based on user preference. In the future, CSS libraries may have this built-in to their presets.\nCurrently, <ViewTransition> only works in the DOM. We‚Äôre working on adding support for React Native and other platforms.\nUsage \nAnimating an element on enter/exit \n\nEnter/Exit Transitions trigger when a <ViewTransition> is added or removed by a component in a transition:\n\nfunction Child() {\n\n  return (\n\n    <ViewTransition>\n\n      <div>Hi</div>\n\n    </ViewTransition>\n\n  );\n\n}\n\n\n\nfunction Parent() {\n\n  const [show, setShow] = useState();\n\n  if (show) {\n\n    return <Child />;\n\n  }\n\n  return null;\n\n}\n\nWhen setShow is called, show switches to true and the Child component is rendered. When setShow is called inside startTransition, and Child renders a ViewTransition before any other DOM nodes, an enter animation is triggered.\n\nWhen show switches back to false, an exit animation is triggered.\n\nApp.js\nReload\nClear\nFork\nimport {\n  ViewTransition,\n  useState,\n  startTransition\n} from 'react';\nimport {Video} from \"./Video\";\nimport videos from \"./data\"\n\nfunction Item() {\n  return (\n    <ViewTransition>\n      <Video video={videos[0]}/>\n    </ViewTransition>\n  );\n}\n\nexport default function Component() {\n  const [showItem, setShowItem] = useState(false);\n  return (\n    <>\n      <button\n        onClick={() => {\n          startTransition(() => {\n            setShowItem((prev) => !prev);\n          });\n        }}\n      >{showItem ? '‚ûñ' : '‚ûï'}</button>\n\n      {showItem ? <Item /> : null}\n    </>\n  );\n}\n\n\nShow more\nPitfall\n\n<ViewTransition> only activates if it is placed before any DOM node. If Child instead looked like this, no animation would trigger:\n\nfunction Component() {\n\n  return <ViewTransition>Hi</ViewTransition>;\n\n}\nAnimating a shared element \n\nNormally, we don‚Äôt recommend assigning a name to a <ViewTransition> and instead let React assign it an automatic name. The reason you might want to assign a name is to animate between completely different components when one tree unmounts and another tree mounts at the same time. To preserve continuity.\n\n<ViewTransition name={UNIQUE_NAME}>\n\n  <Child />\n\n</ViewTransition>\n\nWhen one tree unmounts and another mounts, if there‚Äôs a pair where the same name exists in the unmounting tree and the mounting tree, they trigger the ‚Äúshare‚Äù animation on both. It animates from the unmounting side to the mounting side.\n\nUnlike an exit/enter animation this can be deeply inside the deleted/mounted tree. If a <ViewTransition> would also be eligible for exit/enter, then the ‚Äúshare‚Äù animation takes precedence.\n\nIf Transition first unmounts one side and then leads to a <Suspense> fallback being shown before eventually the new name being mounted, then no shared element transition happens.\n\nApp.js\nVideo.js\nReload\nClear\nFork\nimport {\n  ViewTransition,\n  useState,\n  startTransition\n} from \"react\";\nimport {Video, Thumbnail, FullscreenVideo} from \"./Video\";\nimport videos from \"./data\";\n\nexport default function Component() {\n  const [fullscreen, setFullscreen] = useState(false);\n  if (fullscreen) {\n    return <FullscreenVideo\n      video={videos[0]}\n      onExit={() => startTransition(() => setFullscreen(false))}\n    />\n  }\n  return <Video\n    video={videos[0]}\n    onClick={() => startTransition(() => setFullscreen(true))}\n  />\n}\n\n\nShow more\nNote\n\nIf either the mounted or unmounted side of a pair is outside the viewport, then no pair is formed. This ensures that it doesn‚Äôt fly in or out of the viewport when something is scrolled. Instead it‚Äôs treated as a regular enter/exit by itself.\n\nThis does not happen if the same Component instance changes position, which triggers an ‚Äúupdate‚Äù. Those animate regardless if one position is outside the viewport.\n\nThere‚Äôs currently a quirk where if a deeply nested unmounted <ViewTransition> is inside the viewport but the mounted side is not within the viewport, then the unmounted side animates as its own ‚Äúexit‚Äù animation even if it‚Äôs deeply nested instead of as part of the parent animation.\n\nPitfall\n\nIt‚Äôs important that there‚Äôs only one thing with the same name mounted at a time in the entire app. Therefore it‚Äôs important to use unique namespaces for the name to avoid conflicts. To ensure you can do this you might want to add a constant in a separate module that you import.\n\nexport const MY_NAME = \"my-globally-unique-name\";\n\nimport {MY_NAME} from './shared-name';\n\n...\n\n<ViewTransition name={MY_NAME}>\nAnimating reorder of items in a list \nitems.map(item => <Component key={item.id} item={item} />)\n\nWhen reordering a list, without updating the content, the ‚Äúupdate‚Äù animation triggers on each <ViewTransition> in the list if they‚Äôre outside a DOM node. Similar to enter/exit animations.\n\nThis means that this will trigger the animation on this <ViewTransition>:\n\nfunction Component() {\n\n  return <ViewTransition><div>...</div></ViewTransition>;\n\n}\nApp.js\nReload\nClear\nFork\nimport {\n  ViewTransition,\n  useState,\n  startTransition\n} from \"react\";\nimport {Video} from \"./Video\";\nimport videos from \"./data\";\n\nexport default function Component() {\n  const [orderedVideos, setOrderedVideos] = useState(videos);\n  const reorder = () => {\n    startTransition(() => {\n      setOrderedVideos((prev) => {\n        return [...prev.sort(() => Math.random() - 0.5)];\n      });\n    });\n  };\n  return (\n    <>\n      <button onClick={reorder}>üé≤</button>\n      <div className=\"listContainer\">\n        {orderedVideos.map((video, i) => {\n          return (\n            <ViewTransition key={video.title}>\n              <Video video={video} />\n            </ViewTransition>\n          );\n        })}\n      </div>\n    </>\n  );\n}\n\n\nShow more\n\nHowever, this wouldn‚Äôt animate each individual item:\n\nfunction Component() {\n\n  return <div><ViewTransition>...</ViewTransition></div>;\n\n}\n\nInstead, any parent <ViewTransition> would cross-fade. If there is no parent <ViewTransition> then there‚Äôs no animation in that case.\n\nApp.js\nReload\nClear\nFork\nimport {\n  ViewTransition,\n  useState,\n  startTransition\n} from \"react\";\nimport {Video} from \"./Video\";\nimport videos from \"./data\";\n\nexport default function Component() {\n  const [orderedVideos, setOrderedVideos] = useState(videos);\n  const reorder = () => {\n    startTransition(() => {\n      setOrderedVideos((prev) => {\n        return [...prev.sort(() => Math.random() - 0.5)];\n      });\n    });\n  };\n  return (\n    <>\n      <button onClick={reorder}>üé≤</button>\n      <ViewTransition>\n        <div className=\"listContainer\">\n          {orderedVideos.map((video, i) => {\n            return <Video video={video} key={video.title} />;\n          })}\n        </div>\n      </ViewTransition>\n    </>\n  );\n}\n\n\nShow more\n\nThis means you might want to avoid wrapper elements in lists where you want to allow the Component to control its own reorder animation:\n\nitems.map(item => <div><Component key={item.id} item={item} /></div>)\n\nThe above rule also applies if one of the items updates to resize, which then causes the siblings to resize, it‚Äôll also animate its sibling <ViewTransition> but only if they‚Äôre immediate siblings.\n\nThis means that during an update, which causes a lot of re-layout, it doesn‚Äôt individually animate every <ViewTransition> on the page. That would lead to a lot of noisy animations which distracts from the actual change. Therefore React is more conservative about when an individual animation triggers.\n\nPitfall\n\nIt‚Äôs important to properly use keys to preserve identity when reordering lists. It might seem like you could use ‚Äúname‚Äù, shared element transitions, to animate reorders but that would not trigger if one side was outside the viewport. To animate a reorder you often want to show that it went to a position outside the viewport.\n\nAnimating from Suspense content \n\nJust like any Transition, React waits for data and new CSS (<link rel=\"stylesheet\" precedence=\"...\">) before running the animation. In addition to this, ViewTransitions also wait up to 500ms for new fonts to load before starting the animation to avoid them flickering in later. For the same reason, an image wrapped in ViewTransition will wait for the image to load.\n\nIf it‚Äôs inside a new Suspense boundary instance, then the fallback is shown first. After the Suspense boundary fully loads, it triggers the <ViewTransition> to animate the reveal to the content.\n\nCurrently, this only happens for client-side Transition. In the future, this will also animate Suspense boundary for streaming SSR when content from the server suspends during the initial load.\n\nThere are two ways to animate Suspense boundaries depending on where you place the <ViewTransition>:\n\nUpdate:\n\n<ViewTransition>\n\n  <Suspense fallback={<A />}>\n\n    <B />\n\n  </Suspense>\n\n</ViewTransition>\n\nIn this scenario when the content goes from A to B, it‚Äôll be treated as an ‚Äúupdate‚Äù and apply that class if appropriate. Both A and B will get the same view-transition-name and therefore they‚Äôre acting as a cross-fade by default.\n\nApp.js\nReload\nClear\nFork\nimport {\n  ViewTransition,\n  useState,\n  startTransition,\n  Suspense\n} from 'react';\nimport {Video, VideoPlaceholder} from \"./Video\";\nimport {useLazyVideoData} from \"./data\"\n\nfunction LazyVideo() {\n  const video = useLazyVideoData();\n  return (\n    <Video video={video}/>\n  );\n}\n\nexport default function Component() {\n  const [showItem, setShowItem] = useState(false);\n  return (\n    <>\n      <button\n        onClick={() => {\n          startTransition(() => {\n            setShowItem((prev) => !prev);\n          });\n        }}\n      >{showItem ? '‚ûñ' : '‚ûï'}</button>\n      {showItem ? (\n        <ViewTransition>\n          <Suspense fallback={<VideoPlaceholder />}>\n            <LazyVideo />\n          </Suspense>\n        </ViewTransition>\n      ) : null}\n    </>\n  );\n}\n\n\nShow more\n\nEnter/Exit:\n\n<Suspense fallback={<ViewTransition><A /></ViewTransition>}>\n\n  <ViewTransition><B /></ViewTransition>\n\n</Suspense>\n\nIn this scenario, these are two separate ViewTransition instances each with their own view-transition-name. This will be treated as an ‚Äúexit‚Äù of the <A> and an ‚Äúenter‚Äù of the <B>.\n\nYou can achieve different effects depending on where you choose to place the <ViewTransition> boundary.\n\nOpting-out of an animation \n\nSometimes you‚Äôre wrapping a large existing component, like a whole page, and you want to animate some updates, such as changing the theme. However, you don‚Äôt want it to opt-in all updates inside the whole page to cross-fade when they‚Äôre updating. Especially if you‚Äôre incrementally adding more animations.\n\nYou can use the class ‚Äúnone‚Äù to opt-out of an animation. By wrapping your children in a ‚Äúnone‚Äù you can disable animations for updates to them while the parent still triggers.\n\n<ViewTransition>\n\n  <div className={theme}>\n\n    <ViewTransition update=\"none\">\n\n      {children}\n\n    </ViewTransition>\n\n  </div>\n\n</ViewTransition>\n\nThis will only animate if the theme changes and not if only the children update. The children can still opt-in again with their own <ViewTransition> but at least it‚Äôs manual again.\n\nCustomizing animations \n\nBy default, <ViewTransition> includes the default cross-fade from the browser.\n\nTo customize animations, you can provide props to the <ViewTransition> component to specify which animations to use, based on how the <ViewTransition> activates.\n\nFor example, we can slow down the default cross fade animation:\n\n<ViewTransition default=\"slow-fade\">\n\n  <Video />\n\n</ViewTransition>\n\nAnd define slow-fade in CSS using view transition classes:\n\n::view-transition-old(.slow-fade) {\n\n    animation-duration: 500ms;\n\n}\n\n\n\n::view-transition-new(.slow-fade) {\n\n    animation-duration: 500ms;\n\n}\nApp.js\nReload\nClear\nFork\nimport {\n  ViewTransition,\n  useState,\n  startTransition\n} from 'react';\nimport {Video} from \"./Video\";\nimport videos from \"./data\"\n\nfunction Item() {\n  return (\n    <ViewTransition default=\"slow-fade\">\n      <Video video={videos[0]}/>\n    </ViewTransition>\n  );\n}\n\nexport default function Component() {\n  const [showItem, setShowItem] = useState(false);\n  return (\n    <>\n      <button\n        onClick={() => {\n          startTransition(() => {\n            setShowItem((prev) => !prev);\n          });\n        }}\n      >{showItem ? '‚ûñ' : '‚ûï'}</button>\n\n      {showItem ? <Item /> : null}\n    </>\n  );\n}\n\n\nShow more\n\nIn addition to setting the default, you can also provide configurations for enter, exit, update, and share animations.\n\nApp.js\nReload\nClear\nFork\nimport {\n  ViewTransition,\n  useState,\n  startTransition\n} from 'react';\nimport {Video} from \"./Video\";\nimport videos from \"./data\"\n\nfunction Item() {\n  return (\n    <ViewTransition enter=\"slide-in\" exit=\"slide-out\">\n      <Video video={videos[0]}/>\n    </ViewTransition>\n  );\n}\n\nexport default function Component() {\n  const [showItem, setShowItem] = useState(false);\n  return (\n    <>\n      <button\n        onClick={() => {\n          startTransition(() => {\n            setShowItem((prev) => !prev);\n          });\n        }}\n      >{showItem ? '‚ûñ' : '‚ûï'}</button>\n\n      {showItem ? <Item /> : null}\n    </>\n  );\n}\n\n\nShow more\nCustomizing animations with types \n\nYou can use the addTransitionType API to add a class name to the child elements when a specific transition type is activated for a specific activation trigger. This allows you to customize the animation for each type of transition.\n\nFor example, to customize the animation for all forward and backward navigations:\n\n<ViewTransition default={{\n\n  'navigation-back': 'slide-right',\n\n  'navigation-forward': 'slide-left',\n\n }}>\n\n  <div>...</div>\n\n</ViewTransition>\n\n \n\n// in your router:\n\nstartTransition(() => {\n\n  addTransitionType('navigation-' + navigationType);\n\n});\n\nWhen the ViewTransition activates a ‚Äúnavigation-back‚Äù animation, React will add the class name ‚Äúslide-right‚Äù. When the ViewTransition activates a ‚Äúnavigation-forward‚Äù animation, React will add the class name ‚Äúslide-left‚Äù.\n\nIn the future, routers and other libraries may add support for standard view-transition types and styles.\n\nApp.js\nReload\nClear\nFork\nimport {\n  ViewTransition,\n  addTransitionType,\n  useState,\n  startTransition,\n} from \"react\";\nimport {Video} from \"./Video\";\nimport videos from \"./data\"\n\nfunction Item() {\n  return (\n    <ViewTransition enter={\n        {\n          \"add-video-back\": \"slide-in-back\",\n          \"add-video-forward\": \"slide-in-forward\"\n        }\n      }\n      exit={\n        {\n          \"remove-video-back\": \"slide-in-forward\",\n          \"remove-video-forward\": \"slide-in-back\"\n        }\n      }>\n      <Video video={videos[0]}/>\n    </ViewTransition>\n  );\n}\n\nexport default function Component() {\n  const [showItem, setShowItem] = useState(false);\n  return (\n    <>\n      <div className=\"button-container\">\n        <button\n          onClick={() => {\n            startTransition(() => {\n              if (showItem) {\n                addTransitionType(\"remove-video-back\")\n              } else {\n                addTransitionType(\"add-video-back\")\n              }\n              setShowItem((prev) => !prev);\n            });\n          }}\n        >‚¨ÖÔ∏è</button>\n        <button\n          onClick={() => {\n            startTransition(() => {\n              if (showItem) {\n                addTransitionType(\"remove-video-forward\")\n              } else {\n                addTransitionType(\"add-video-forward\")\n              }\n              setShowItem((prev) => !prev);\n            });\n          }}\n        >‚û°Ô∏è</button>\n      </div>\n      {showItem ? <Item /> : null}\n    </>\n  );\n}\n\n\nShow more\nBuilding View Transition enabled routers \n\nReact waits for any pending Navigation to finish to ensure that scroll restoration happens within the animation. If the Navigation is blocked on React, your router must unblock in useLayoutEffect since useEffect would lead to a deadlock.\n\nIf a startTransition is started from the legacy popstate event, such as during a ‚Äúback‚Äù-navigation then it must finish synchronously to ensure scroll and form restoration works correctly. This is in conflict with running a View Transition animation. Therefore, React will skip animations from popstate. Therefore animations won‚Äôt run for the back button. You can fix this by upgrading your router to use the Navigation API.\n\nTroubleshooting \nMy <ViewTransition> is not activating \n\n<ViewTransition> only activates if it is placed before any DOM node:\n\nfunction Component() {\n\n  return (\n\n    <div>\n\n      <ViewTransition>Hi</ViewTransition>\n\n    </div>\n\n  );\n\n}\n\nTo fix, ensure that the <ViewTransition> comes before any other DOM nodes:\n\nfunction Component() {\n\n  return (\n\n    <ViewTransition>\n\n      <div>Hi</div>\n\n    </ViewTransition>\n\n  );\n\n}\nI‚Äôm getting an error ‚ÄúThere are two <ViewTransition name=%s> components with the same name mounted at the same time.‚Äù \n\nThis error occurs when two <ViewTransition> components with the same name are mounted at the same time:\n\nfunction Item() {\n\n  // üö© All items will get the same \"name\".\n\n  return <ViewTransition name=\"item\">...</ViewTransition>;\n\n}\n\n\n\nfunction ItemList({items}) {\n\n  return (\n\n    <>\n\n      {item.map(item => <Item key={item.id} />)}\n\n    </>\n\n  );\n\n}\n\nThis will cause the View Transition to error. In development, React detects this issue to surface it and logs two errors:\n\nConsole\nThere are two <ViewTransition name=%s> components with the same name mounted at the same time. This is not supported and will cause View Transitions to error. Try to use a more unique name e.g. by using a namespace prefix and adding the id of an item to the name.\n    at Item\n    at ItemList\nThe existing <ViewTransition name=%s> duplicate has this stack trace.\n    at Item\n    at ItemList\n\nTo fix, ensure that there‚Äôs only one <ViewTransition> with the same name mounted at a time in the entire app by ensuring the name is unique, or adding an id to the name:\n\nfunction Item({id}) {\n\n  // ‚úÖ All items will get the same \"name\".\n\n  return <ViewTransition name={`item-${id}`}>...</ViewTransition>;\n\n}\n\n\n\nfunction ItemList({items}) {\n\n  return (\n\n    <>\n\n      {item.map(item => <Item key={item.id} item={item} />)}\n\n    </>\n\n  );\n\n}\nPREVIOUS\n<Activity>\nNEXT\nAPIs"
  },
  {
    "title": "Built-in React APIs ‚Äì React",
    "url": "https://react.dev/reference/react/apis",
    "html": "API REFERENCE\nBuilt-in React APIs\n\nIn addition to Hooks and Components, the react package exports a few other APIs that are useful for defining components. This page lists all the remaining modern React APIs.\n\ncreateContext lets you define and provide context to the child components. Used with useContext.\nlazy lets you defer loading a component‚Äôs code until it‚Äôs rendered for the first time.\nmemo lets your component skip re-renders with same props. Used with useMemo and useCallback.\nstartTransition lets you mark a state update as non-urgent. Similar to useTransition.\nact lets you wrap renders and interactions in tests to ensure updates have processed before making assertions.\nResource APIs \n\nResources can be accessed by a component without having them as part of their state. For example, a component can read a message from a Promise or read styling information from a context.\n\nTo read a value from a resource, use this API:\n\nuse lets you read the value of a resource like a Promise or context.\nfunction MessageComponent({ messagePromise }) {\n\n  const message = use(messagePromise);\n\n  const theme = use(ThemeContext);\n\n  // ...\n\n}\nPREVIOUS\n<ViewTransition>\nNEXT\nact"
  },
  {
    "title": "act ‚Äì React",
    "url": "https://react.dev/reference/react/act",
    "html": "API REFERENCE\nAPIS\nact\n\nact is a test helper to apply pending React updates before making assertions.\n\nawait act(async actFn)\n\nTo prepare a component for assertions, wrap the code rendering it and performing updates inside an await act() call. This makes your test run closer to how React works in the browser.\n\nNote\n\nYou might find using act() directly a bit too verbose. To avoid some of the boilerplate, you could use a library like React Testing Library, whose helpers are wrapped with act().\n\nReference\nawait act(async actFn)\nUsage\nRendering components in tests\nDispatching events in tests\nTroubleshooting\nI‚Äôm getting an error: ‚ÄúThe current testing environment is not configured to support act‚Äù(‚Ä¶)‚Äù\nReference \nawait act(async actFn) \n\nWhen writing UI tests, tasks like rendering, user events, or data fetching can be considered as ‚Äúunits‚Äù of interaction with a user interface. React provides a helper called act() that makes sure all updates related to these ‚Äúunits‚Äù have been processed and applied to the DOM before you make any assertions.\n\nThe name act comes from the Arrange-Act-Assert pattern.\n\nit ('renders with button disabled', async () => {\n\n  await act(async () => {\n\n    root.render(<TestComponent />)\n\n  });\n\n  expect(container.querySelector('button')).toBeDisabled();\n\n});\nNote\n\nWe recommend using act with await and an async function. Although the sync version works in many cases, it doesn‚Äôt work in all cases and due to the way React schedules updates internally, it‚Äôs difficult to predict when you can use the sync version.\n\nWe will deprecate and remove the sync version in the future.\n\nParameters \nasync actFn: An async function wrapping renders or interactions for components being tested. Any updates triggered within the actFn, are added to an internal act queue, which are then flushed together to process and apply any changes to the DOM. Since it is async, React will also run any code that crosses an async boundary, and flush any updates scheduled.\nReturns \n\nact does not return anything.\n\nUsage \n\nWhen testing a component, you can use act to make assertions about its output.\n\nFor example, let‚Äôs say we have this Counter component, the usage examples below show how to test it:\n\nfunction Counter() {\n\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n\n    setCount(prev => prev + 1);\n\n  }\n\n\n\n  useEffect(() => {\n\n    document.title = `You clicked ${count} times`;\n\n  }, [count]);\n\n\n\n  return (\n\n    <div>\n\n      <p>You clicked {count} times</p>\n\n      <button onClick={handleClick}>\n\n        Click me\n\n      </button>\n\n    </div>\n\n  )\n\n}\nRendering components in tests \n\nTo test the render output of a component, wrap the render inside act():\n\nimport {act} from 'react';\n\nimport ReactDOMClient from 'react-dom/client';\n\nimport Counter from './Counter';\n\n\n\nit('can render and update a counter', async () => {\n\n  container = document.createElement('div');\n\n  document.body.appendChild(container);\n\n  \n\n  // ‚úÖ Render the component inside act().\n\n  await act(() => {\n\n    ReactDOMClient.createRoot(container).render(<Counter />);\n\n  });\n\n  \n\n  const button = container.querySelector('button');\n\n  const label = container.querySelector('p');\n\n  expect(label.textContent).toBe('You clicked 0 times');\n\n  expect(document.title).toBe('You clicked 0 times');\n\n});\n\nHere, we create a container, append it to the document, and render the Counter component inside act(). This ensures that the component is rendered and its effects are applied before making assertions.\n\nUsing act ensures that all updates have been applied before we make assertions.\n\nDispatching events in tests \n\nTo test events, wrap the event dispatch inside act():\n\nimport {act} from 'react';\n\nimport ReactDOMClient from 'react-dom/client';\n\nimport Counter from './Counter';\n\n\n\nit.only('can render and update a counter', async () => {\n\n  const container = document.createElement('div');\n\n  document.body.appendChild(container);\n\n  \n\n  await act( async () => {\n\n    ReactDOMClient.createRoot(container).render(<Counter />);\n\n  });\n\n  \n\n  // ‚úÖ Dispatch the event inside act().\n\n  await act(async () => {\n\n    button.dispatchEvent(new MouseEvent('click', { bubbles: true }));\n\n  });\n\n\n\n  const button = container.querySelector('button');\n\n  const label = container.querySelector('p');\n\n  expect(label.textContent).toBe('You clicked 1 times');\n\n  expect(document.title).toBe('You clicked 1 times');\n\n});\n\nHere, we render the component with act, and then dispatch the event inside another act(). This ensures that all updates from the event are applied before making assertions.\n\nPitfall\n\nDon‚Äôt forget that dispatching DOM events only works when the DOM container is added to the document. You can use a library like React Testing Library to reduce the boilerplate code.\n\nTroubleshooting \nI‚Äôm getting an error: ‚ÄúThe current testing environment is not configured to support act‚Äù(‚Ä¶)‚Äù \n\nUsing act requires setting global.IS_REACT_ACT_ENVIRONMENT=true in your test environment. This is to ensure that act is only used in the correct environment.\n\nIf you don‚Äôt set the global, you will see an error like this:\n\nConsole\nWarning: The current testing environment is not configured to support act(‚Ä¶)\n\nTo fix, add this to your global setup file for React tests:\n\nglobal.IS_REACT_ACT_ENVIRONMENT=true\nNote\n\nIn testing frameworks like React Testing Library, IS_REACT_ACT_ENVIRONMENT is already set for you.\n\nPREVIOUS\nAPIs\nNEXT\naddTransitionType"
  },
  {
    "title": "addTransitionType ‚Äì React",
    "url": "https://react.dev/reference/react/addTransitionType",
    "html": "API REFERENCE\nAPIS\naddTransitionType\nCanary\n\nThe addTransitionType API is currently only available in React‚Äôs Canary and Experimental channels.\n\nLearn more about React‚Äôs release channels here.\n\naddTransitionType lets you specify the cause of a transition.\n\nstartTransition(() => {\n\n  addTransitionType('my-transition-type');\n\n  setState(newState);\n\n});\nReference\naddTransitionType\nUsage\nAdding the cause of a transition\nCustomize animations using browser view transition types\nCustomize animations using View Transition Class\nCustomize animations using ViewTransition events\nReference \naddTransitionType \nParameters \ntype: The type of transition to add. This can be any string.\nReturns \n\nstartTransition does not return anything.\n\nCaveats \nIf multiple transitions are combined, all Transition Types are collected. You can also add more than one type to a Transition.\nTransition Types are reset after each commit. This means a <Suspense> fallback will associate the types after a startTransition, but revealing the content does not.\nUsage \nAdding the cause of a transition \n\nCall addTransitionType inside of startTransition to indicate the cause of a transition:\n\nimport { startTransition, addTransitionType } from 'react';\n\n\n\nfunction Submit({action) {\n\n  function handleClick() {\n\n    startTransition(() => {\n\n      addTransitionType('submit-click');\n\n      action();\n\n    });\n\n  }\n\n\n\n  return <button onClick={handleClick}>Click me</button>;\n\n}\n\nWhen you call addTransitionType inside the scope of startTransition, React will associate submit-click as one of the causes for the Transition.\n\nCurrently, Transition Types can be used to customize different animations based on what caused the Transition. You have three different ways to choose from for how to use them:\n\nCustomize animations using browser view transition types\nCustomize animations using View Transition Class\nCustomize animations using ViewTransition events\n\nIn the future, we plan to support more use cases for using the cause of a transition.\n\nCustomize animations using browser view transition types \n\nWhen a ViewTransition activates from a transition, React adds all the Transition Types as browser view transition types to the element.\n\nThis allows you to customize different animations based on CSS scopes:\n\nfunction Component() {\n\n  return (\n\n    <ViewTransition>\n\n      <div>Hello</div>\n\n    </ViewTransition>\n\n  );\n\n}\n\n\n\nstartTransition(() => {\n\n  addTransitionType('my-transition-type');\n\n  setShow(true);\n\n});\n:root:active-view-transition-type(my-transition-type) {\n\n  &::view-transition-...(...) {\n\n    ...\n\n  }\n\n}\nCustomize animations using View Transition Class \n\nYou can customize animations for an activated ViewTransition based on type by passing an object to the View Transition Class:\n\nfunction Component() {\n\n  return (\n\n    <ViewTransition enter={{\n\n      'my-transition-type': 'my-transition-class',\n\n    }}>\n\n      <div>Hello</div>\n\n    </ViewTransition>\n\n  );\n\n}\n\n\n\n// ...\n\nstartTransition(() => {\n\n  addTransitionType('my-transition-type');\n\n  setState(newState);\n\n});\n\nIf multiple types match, then they‚Äôre joined together. If no types match then the special ‚Äúdefault‚Äù entry is used instead. If any type has the value ‚Äúnone‚Äù then that wins and the ViewTransition is disabled (not assigned a name).\n\nThese can be combined with enter/exit/update/layout/share props to match based on kind of trigger and Transition Type.\n\n<ViewTransition enter={{\n\n  'navigation-back': 'enter-right',\n\n  'navigation-forward': 'enter-left',\n\n}}\n\nexit={{\n\n  'navigation-back': 'exit-right',\n\n  'navigation-forward': 'exit-left',\n\n}}>\nCustomize animations using ViewTransition events \n\nYou can imperatively customize animations for an activated ViewTransition based on type using View Transition events:\n\n<ViewTransition onUpdate={(inst, types) => {\n\n  if (types.includes('navigation-back')) {\n\n    ...\n\n  } else if (types.includes('navigation-forward')) {\n\n    ...\n\n  } else {\n\n    ...\n\n  }\n\n}}>\n\nThis allows you to pick different imperative Animations based on the cause.\n\nPREVIOUS\nact\nNEXT\ncache"
  },
  {
    "title": "cache ‚Äì React",
    "url": "https://react.dev/reference/react/cache",
    "html": "API REFERENCE\nAPIS\ncache\nReact Server Components\n\ncache is only for use with React Server Components.\n\ncache lets you cache the result of a data fetch or computation.\n\nconst cachedFn = cache(fn);\nReference\ncache(fn)\nUsage\nCache an expensive computation\nShare a snapshot of data\nPreload data\nTroubleshooting\nMy memoized function still runs even though I‚Äôve called it with the same arguments\nReference \ncache(fn) \n\nCall cache outside of any components to create a version of the function with caching.\n\nimport {cache} from 'react';\n\nimport calculateMetrics from 'lib/metrics';\n\n\n\nconst getMetrics = cache(calculateMetrics);\n\n\n\nfunction Chart({data}) {\n\n  const report = getMetrics(data);\n\n  // ...\n\n}\n\nWhen getMetrics is first called with data, getMetrics will call calculateMetrics(data) and store the result in cache. If getMetrics is called again with the same data, it will return the cached result instead of calling calculateMetrics(data) again.\n\nSee more examples below.\n\nParameters \nfn: The function you want to cache results for. fn can take any arguments and return any value.\nReturns \n\ncache returns a cached version of fn with the same type signature. It does not call fn in the process.\n\nWhen calling cachedFn with given arguments, it first checks if a cached result exists in the cache. If a cached result exists, it returns the result. If not, it calls fn with the arguments, stores the result in the cache, and returns the result. The only time fn is called is when there is a cache miss.\n\nNote\n\nThe optimization of caching return values based on inputs is known as memoization. We refer to the function returned from cache as a memoized function.\n\nCaveats \nReact will invalidate the cache for all memoized functions for each server request.\nEach call to cache creates a new function. This means that calling cache with the same function multiple times will return different memoized functions that do not share the same cache.\ncachedFn will also cache errors. If fn throws an error for certain arguments, it will be cached, and the same error is re-thrown when cachedFn is called with those same arguments.\ncache is for use in Server Components only.\nUsage \nCache an expensive computation \n\nUse cache to skip duplicate work.\n\nimport {cache} from 'react';\n\nimport calculateUserMetrics from 'lib/user';\n\n\n\nconst getUserMetrics = cache(calculateUserMetrics);\n\n\n\nfunction Profile({user}) {\n\n  const metrics = getUserMetrics(user);\n\n  // ...\n\n}\n\n\n\nfunction TeamReport({users}) {\n\n  for (let user in users) {\n\n    const metrics = getUserMetrics(user);\n\n    // ...\n\n  }\n\n  // ...\n\n}\n\nIf the same user object is rendered in both Profile and TeamReport, the two components can share work and only call calculateUserMetrics once for that user.\n\nAssume Profile is rendered first. It will call getUserMetrics, and check if there is a cached result. Since it is the first time getUserMetrics is called with that user, there will be a cache miss. getUserMetrics will then call calculateUserMetrics with that user and write the result to cache.\n\nWhen TeamReport renders its list of users and reaches the same user object, it will call getUserMetrics and read the result from cache.\n\nIf calculateUserMetrics can be aborted by passing an AbortSignal, you can use cacheSignal() to cancel the expensive computation if React has finished rendering. calculateUserMetrics may already handle cancellation internally by using cacheSignal directly.\n\nPitfall\nCalling different memoized functions will read from different caches. \n\nTo access the same cache, components must call the same memoized function.\n\n// Temperature.js\n\nimport {cache} from 'react';\n\nimport {calculateWeekReport} from './report';\n\n\n\nexport function Temperature({cityData}) {\n\n  // üö© Wrong: Calling `cache` in component creates new `getWeekReport` for each render\n\n  const getWeekReport = cache(calculateWeekReport);\n\n  const report = getWeekReport(cityData);\n\n  // ...\n\n}\n// Precipitation.js\n\nimport {cache} from 'react';\n\nimport {calculateWeekReport} from './report';\n\n\n\n// üö© Wrong: `getWeekReport` is only accessible for `Precipitation` component.\n\nconst getWeekReport = cache(calculateWeekReport);\n\n\n\nexport function Precipitation({cityData}) {\n\n  const report = getWeekReport(cityData);\n\n  // ...\n\n}\n\nIn the above example, Precipitation and Temperature each call cache to create a new memoized function with their own cache look-up. If both components render for the same cityData, they will do duplicate work to call calculateWeekReport.\n\nIn addition, Temperature creates a new memoized function each time the component is rendered which doesn‚Äôt allow for any cache sharing.\n\nTo maximize cache hits and reduce work, the two components should call the same memoized function to access the same cache. Instead, define the memoized function in a dedicated module that can be import-ed across components.\n\n// getWeekReport.js\n\nimport {cache} from 'react';\n\nimport {calculateWeekReport} from './report';\n\n\n\nexport default cache(calculateWeekReport);\n// Temperature.js\n\nimport getWeekReport from './getWeekReport';\n\n\n\nexport default function Temperature({cityData}) {\n\n\tconst report = getWeekReport(cityData);\n\n  // ...\n\n}\n// Precipitation.js\n\nimport getWeekReport from './getWeekReport';\n\n\n\nexport default function Precipitation({cityData}) {\n\n  const report = getWeekReport(cityData);\n\n  // ...\n\n}\n\nHere, both components call the same memoized function exported from ./getWeekReport.js to read and write to the same cache.\n\nShare a snapshot of data \n\nTo share a snapshot of data between components, call cache with a data-fetching function like fetch. When multiple components make the same data fetch, only one request is made and the data returned is cached and shared across components. All components refer to the same snapshot of data across the server render.\n\nimport {cache} from 'react';\n\nimport {fetchTemperature} from './api.js';\n\n\n\nconst getTemperature = cache(async (city) => {\n\n\treturn await fetchTemperature(city);\n\n});\n\n\n\nasync function AnimatedWeatherCard({city}) {\n\n\tconst temperature = await getTemperature(city);\n\n\t// ...\n\n}\n\n\n\nasync function MinimalWeatherCard({city}) {\n\n\tconst temperature = await getTemperature(city);\n\n\t// ...\n\n}\n\nIf AnimatedWeatherCard and MinimalWeatherCard both render for the same city, they will receive the same snapshot of data from the memoized function.\n\nIf AnimatedWeatherCard and MinimalWeatherCard supply different city arguments to getTemperature, then fetchTemperature will be called twice and each call site will receive different data.\n\nThe city acts as a cache key.\n\nNote\n\nAsynchronous rendering is only supported for Server Components.\n\nasync function AnimatedWeatherCard({city}) {\n\n\tconst temperature = await getTemperature(city);\n\n\t// ...\n\n}\n\nTo render components that use asynchronous data in Client Components, see use() documentation.\n\nPreload data \n\nBy caching a long-running data fetch, you can kick off asynchronous work prior to rendering the component.\n\nconst getUser = cache(async (id) => {\n\n  return await db.user.query(id);\n\n});\n\n\n\nasync function Profile({id}) {\n\n  const user = await getUser(id);\n\n  return (\n\n    <section>\n\n      <img src={user.profilePic} />\n\n      <h2>{user.name}</h2>\n\n    </section>\n\n  );\n\n}\n\n\n\nfunction Page({id}) {\n\n  // ‚úÖ Good: start fetching the user data\n\n  getUser(id);\n\n  // ... some computational work\n\n  return (\n\n    <>\n\n      <Profile id={id} />\n\n    </>\n\n  );\n\n}\n\nWhen rendering Page, the component calls getUser but note that it doesn‚Äôt use the returned data. This early getUser call kicks off the asynchronous database query that occurs while Page is doing other computational work and rendering children.\n\nWhen rendering Profile, we call getUser again. If the initial getUser call has already returned and cached the user data, when Profile asks and waits for this data, it can simply read from the cache without requiring another remote procedure call. If the  initial data request hasn‚Äôt been completed, preloading data in this pattern reduces delay in data-fetching.\n\nDEEP DIVE\nCaching asynchronous work \nShow Details\nPitfall\nCalling a memoized function outside of a component will not use the cache. \nimport {cache} from 'react';\n\n\n\nconst getUser = cache(async (userId) => {\n\n  return await db.user.query(userId);\n\n});\n\n\n\n// üö© Wrong: Calling memoized function outside of component will not memoize.\n\ngetUser('demo-id');\n\n\n\nasync function DemoProfile() {\n\n  // ‚úÖ Good: `getUser` will memoize.\n\n  const user = await getUser('demo-id');\n\n  return <Profile user={user} />;\n\n}\n\nReact only provides cache access to the memoized function in a component. When calling getUser outside of a component, it will still evaluate the function but not read or update the cache.\n\nThis is because cache access is provided through a context which is only accessible from a component.\n\nDEEP DIVE\nWhen should I use cache, memo, or useMemo? \nShow Details\nTroubleshooting \nMy memoized function still runs even though I‚Äôve called it with the same arguments \n\nSee prior mentioned pitfalls\n\nCalling different memoized functions will read from different caches.\nCalling a memoized function outside of a component will not use the cache.\n\nIf none of the above apply, it may be a problem with how React checks if something exists in cache.\n\nIf your arguments are not primitives (ex. objects, functions, arrays), ensure you‚Äôre passing the same object reference.\n\nWhen calling a memoized function, React will look up the input arguments to see if a result is already cached. React will use shallow equality of the arguments to determine if there is a cache hit.\n\nimport {cache} from 'react';\n\n\n\nconst calculateNorm = cache((vector) => {\n\n  // ...\n\n});\n\n\n\nfunction MapMarker(props) {\n\n  // üö© Wrong: props is an object that changes every render.\n\n  const length = calculateNorm(props);\n\n  // ...\n\n}\n\n\n\nfunction App() {\n\n  return (\n\n    <>\n\n      <MapMarker x={10} y={10} z={10} />\n\n      <MapMarker x={10} y={10} z={10} />\n\n    </>\n\n  );\n\n}\n\nIn this case the two MapMarkers look like they‚Äôre doing the same work and calling calculateNorm with the same value of {x: 10, y: 10, z:10}. Even though the objects contain the same values, they are not the same object reference as each component creates its own props object.\n\nReact will call Object.is on the input to verify if there is a cache hit.\n\nimport {cache} from 'react';\n\n\n\nconst calculateNorm = cache((x, y, z) => {\n\n  // ...\n\n});\n\n\n\nfunction MapMarker(props) {\n\n  // ‚úÖ Good: Pass primitives to memoized function\n\n  const length = calculateNorm(props.x, props.y, props.z);\n\n  // ...\n\n}\n\n\n\nfunction App() {\n\n  return (\n\n    <>\n\n      <MapMarker x={10} y={10} z={10} />\n\n      <MapMarker x={10} y={10} z={10} />\n\n    </>\n\n  );\n\n}\n\nOne way to address this could be to pass the vector dimensions to calculateNorm. This works because the dimensions themselves are primitives.\n\nAnother solution may be to pass the vector object itself as a prop to the component. We‚Äôll need to pass the same object to both component instances.\n\nimport {cache} from 'react';\n\n\n\nconst calculateNorm = cache((vector) => {\n\n  // ...\n\n});\n\n\n\nfunction MapMarker(props) {\n\n  // ‚úÖ Good: Pass the same `vector` object\n\n  const length = calculateNorm(props.vector);\n\n  // ...\n\n}\n\n\n\nfunction App() {\n\n  const vector = [10, 10, 10];\n\n  return (\n\n    <>\n\n      <MapMarker vector={vector} />\n\n      <MapMarker vector={vector} />\n\n    </>\n\n  );\n\n}\nPREVIOUS\naddTransitionType\nNEXT\ncacheSignal"
  },
  {
    "title": "cacheSignal ‚Äì React",
    "url": "https://react.dev/reference/react/cacheSignal",
    "html": "API REFERENCE\nAPIS\ncacheSignal\nReact Server Components\n\ncacheSignal is currently only used with React Server Components.\n\ncacheSignal allows you to know when the cache() lifetime is over.\n\nconst signal = cacheSignal();\nReference\ncacheSignal\nUsage\nCancel in-flight requests\nIgnore errors after React has finished rendering\nReference \ncacheSignal \n\nCall cacheSignal to get an AbortSignal.\n\nimport {cacheSignal} from 'react';\n\nasync function Component() {\n\n  await fetch(url, { signal: cacheSignal() });\n\n}\n\nWhen React has finished rendering, the AbortSignal will be aborted. This allows you to cancel any in-flight work that is no longer needed.\nRendering is considered finished when:\n\nReact has successfully completed rendering\nthe render was aborted\nthe render has failed\nParameters \n\nThis function does not accept any parameters.\n\nReturns \n\ncacheSignal returns an AbortSignal if called during rendering. Otherwise cacheSignal() returns null.\n\nCaveats \ncacheSignal is currently for use in React Server Components only. In Client Components, it will always return null. In the future it will also be used for Client Component when a client cache refreshes or invalidates. You should not assume it‚Äôll always be null on the client.\nIf called outside of rendering, cacheSignal will return null to make it clear that the current scope isn‚Äôt cached forever.\nUsage \nCancel in-flight requests \n\nCall cacheSignal to abort in-flight requests.\n\nimport {cache, cacheSignal} from 'react';\n\nconst dedupedFetch = cache(fetch);\n\nasync function Component() {\n\n  await dedupedFetch(url, { signal: cacheSignal() });\n\n}\nPitfall\n\nYou can‚Äôt use cacheSignal to abort async work that was started outside of rendering e.g.\n\nimport {cacheSignal} from 'react';\n\n// üö© Pitfall: The request will not actually be aborted if the rendering of `Component` is finished.\n\nconst response = fetch(url, { signal: cacheSignal() });\n\nasync function Component() {\n\n  await response;\n\n}\nIgnore errors after React has finished rendering \n\nIf a function throws, it may be due to cancellation (e.g. the Database connection has been closed). You can use the aborted property to check if the error was due to cancellation or a real error. You may want to ignore errors that were due to cancellation.\n\nimport {cacheSignal} from \"react\";\n\nimport {queryDatabase, logError} from \"./database\";\n\n\n\nasync function getData(id) {\n\n  try {\n\n     return await queryDatabase(id);\n\n  } catch (x) {\n\n     if (!cacheSignal()?.aborted) {\n\n        // only log if it's a real error and not due to cancellation\n\n       logError(x);\n\n     }\n\n     return null;\n\n  }\n\n}\n\n\n\nasync function Component({id}) {\n\n  const data = await getData(id);\n\n  if (data === null) {\n\n    return <div>No data available</div>;\n\n  }\n\n  return <div>{data.name}</div>;\n\n}\nPREVIOUS\ncache\nNEXT\ncaptureOwnerStack"
  },
  {
    "title": "captureOwnerStack ‚Äì React",
    "url": "https://react.dev/reference/react/captureOwnerStack",
    "html": "API REFERENCE\nAPIS\ncaptureOwnerStack\n\ncaptureOwnerStack reads the current Owner Stack in development and returns it as a string if available.\n\nconst stack = captureOwnerStack();\nReference\ncaptureOwnerStack()\nUsage\nEnhance a custom error overlay\nTroubleshooting\nThe Owner Stack is null\ncaptureOwnerStack is not available\nReference \ncaptureOwnerStack() \n\nCall captureOwnerStack to get the current Owner Stack.\n\nimport * as React from 'react';\n\n\n\nfunction Component() {\n\n  if (process.env.NODE_ENV !== 'production') {\n\n    const ownerStack = React.captureOwnerStack();\n\n    console.log(ownerStack);\n\n  }\n\n}\nParameters \n\ncaptureOwnerStack does not take any parameters.\n\nReturns \n\ncaptureOwnerStack returns string | null.\n\nOwner Stacks are available in\n\nComponent render\nEffects (e.g. useEffect)\nReact‚Äôs event handlers (e.g. <button onClick={...} />)\nReact error handlers (React Root options onCaughtError, onRecoverableError, and onUncaughtError)\n\nIf no Owner Stack is available, null is returned (see Troubleshooting: The Owner Stack is null).\n\nCaveats \nOwner Stacks are only available in development. captureOwnerStack will always return null outside of development.\nDEEP DIVE\nOwner Stack vs Component Stack \nShow Details\nUsage \nEnhance a custom error overlay \nimport { captureOwnerStack } from \"react\";\n\nimport { instrumentedConsoleError } from \"./errorOverlay\";\n\n\n\nconst originalConsoleError = console.error;\n\nconsole.error = function patchedConsoleError(...args) {\n\n  originalConsoleError.apply(console, args);\n\n  const ownerStack = captureOwnerStack();\n\n  onConsoleError({\n\n    // Keep in mind that in a real application, console.error can be\n\n    // called with multiple arguments which you should account for.\n\n    consoleMessage: args[0],\n\n    ownerStack,\n\n  });\n\n};\n\nIf you intercept console.error calls to highlight them in an error overlay, you can call captureOwnerStack to include the Owner Stack.\n\nindex.js\nerrorOverlay.js\nApp.js\nReload\nClear\nFork\nimport { captureOwnerStack } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport App from './App';\nimport { onConsoleError } from \"./errorOverlay\";\nimport './styles.css';\n\nconst originalConsoleError = console.error;\nconsole.error = function patchedConsoleError(...args) {\n  originalConsoleError.apply(console, args);\n  const ownerStack = captureOwnerStack();\n  onConsoleError({\n    // Keep in mind that in a real application, console.error can be\n    // called with multiple arguments which you should account for.\n    consoleMessage: args[0],\n    ownerStack,\n  });\n};\n\nconst container = document.getElementById(\"root\");\ncreateRoot(container).render(<App />);\n\n\nShow more\nTroubleshooting \nThe Owner Stack is null \n\nThe call of captureOwnerStack happened outside of a React controlled function e.g. in a setTimeout callback, after a fetch call or in a custom DOM event handler. During render, Effects, React event handlers, and React error handlers (e.g. hydrateRoot#options.onCaughtError) Owner Stacks should be available.\n\nIn the example below, clicking the button will log an empty Owner Stack because captureOwnerStack was called during a custom DOM event handler. The Owner Stack must be captured earlier e.g. by moving the call of captureOwnerStack into the Effect body.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport {captureOwnerStack, useEffect} from 'react';\n\nexport default function App() {\n  useEffect(() => {\n    // Should call `captureOwnerStack` here.\n    function handleEvent() {\n      // Calling it in a custom DOM event handler is too late.\n      // The Owner Stack will be `null` at this point.\n      console.log('Owner Stack: ', captureOwnerStack());\n    }\n\n    document.addEventListener('click', handleEvent);\n\n    return () => {\n      document.removeEventListener('click', handleEvent);\n    }\n  })\n\n  return <button>Click me to see that Owner Stacks are not available in custom DOM event handlers</button>;\n}\n\n\nShow more\ncaptureOwnerStack is not available \n\ncaptureOwnerStack is only exported in development builds. It will be undefined in production builds. If captureOwnerStack is used in files that are bundled for production and development, you should conditionally access it from a namespace import.\n\n// Don't use named imports of `captureOwnerStack` in files that are bundled for development and production.\n\nimport {captureOwnerStack} from 'react';\n\n// Use a namespace import instead and access `captureOwnerStack` conditionally.\n\nimport * as React from 'react';\n\n\n\nif (process.env.NODE_ENV !== 'production') {\n\n  const ownerStack = React.captureOwnerStack();\n\n  console.log('Owner Stack', ownerStack);\n\n}\nPREVIOUS\ncacheSignal\nNEXT\ncreateContext"
  },
  {
    "title": "createContext ‚Äì React",
    "url": "https://react.dev/reference/react/createContext",
    "html": "API REFERENCE\nAPIS\ncreateContext\n\ncreateContext lets you create a context that components can provide or read.\n\nconst SomeContext = createContext(defaultValue)\nReference\ncreateContext(defaultValue)\nSomeContext Provider\nSomeContext.Consumer\nUsage\nCreating context\nImporting and exporting context from a file\nTroubleshooting\nI can‚Äôt find a way to change the context value\nReference \ncreateContext(defaultValue) \n\nCall createContext outside of any components to create a context.\n\nimport { createContext } from 'react';\n\n\n\nconst ThemeContext = createContext('light');\n\nSee more examples below.\n\nParameters \ndefaultValue: The value that you want the context to have when there is no matching context provider in the tree above the component that reads context. If you don‚Äôt have any meaningful default value, specify null. The default value is meant as a ‚Äúlast resort‚Äù fallback. It is static and never changes over time.\nReturns \n\ncreateContext returns a context object.\n\nThe context object itself does not hold any information. It represents which context other components read or provide. Typically, you will use SomeContext in components above to specify the context value, and call useContext(SomeContext) in components below to read it. The context object has a few properties:\n\nSomeContext lets you provide the context value to components.\nSomeContext.Consumer is an alternative and rarely used way to read the context value.\nSomeContext.Provider is a legacy way to provide the context value before React 19.\nSomeContext Provider \n\nWrap your components into a context provider to specify the value of this context for all components inside:\n\nfunction App() {\n\n  const [theme, setTheme] = useState('light');\n\n  // ...\n\n  return (\n\n    <ThemeContext value={theme}>\n\n      <Page />\n\n    </ThemeContext>\n\n  );\n\n}\nNote\n\nStarting in React 19, you can render <SomeContext> as a provider.\n\nIn older versions of React, use <SomeContext.Provider>.\n\nProps \nvalue: The value that you want to pass to all the components reading this context inside this provider, no matter how deep. The context value can be of any type. A component calling useContext(SomeContext) inside of the provider receives the value of the innermost corresponding context provider above it.\nSomeContext.Consumer \n\nBefore useContext existed, there was an older way to read context:\n\nfunction Button() {\n\n  // üü° Legacy way (not recommended)\n\n  return (\n\n    <ThemeContext.Consumer>\n\n      {theme => (\n\n        <button className={theme} />\n\n      )}\n\n    </ThemeContext.Consumer>\n\n  );\n\n}\n\nAlthough this older way still works, newly written code should read context with useContext() instead:\n\nfunction Button() {\n\n  // ‚úÖ Recommended way\n\n  const theme = useContext(ThemeContext);\n\n  return <button className={theme} />;\n\n}\nProps \nchildren: A function. React will call the function you pass with the current context value determined by the same algorithm as useContext() does, and render the result you return from this function. React will also re-run this function and update the UI whenever the context from the parent components changes.\nUsage \nCreating context \n\nContext lets components pass information deep down without explicitly passing props.\n\nCall createContext outside any components to create one or more contexts.\n\nimport { createContext } from 'react';\n\n\n\nconst ThemeContext = createContext('light');\n\nconst AuthContext = createContext(null);\n\ncreateContext returns a context object. Components can read context by passing it to useContext():\n\nfunction Button() {\n\n  const theme = useContext(ThemeContext);\n\n  // ...\n\n}\n\n\n\nfunction Profile() {\n\n  const currentUser = useContext(AuthContext);\n\n  // ...\n\n}\n\nBy default, the values they receive will be the default values you have specified when creating the contexts. However, by itself this isn‚Äôt useful because the default values never change.\n\nContext is useful because you can provide other, dynamic values from your components:\n\nfunction App() {\n\n  const [theme, setTheme] = useState('dark');\n\n  const [currentUser, setCurrentUser] = useState({ name: 'Taylor' });\n\n\n\n  // ...\n\n\n\n  return (\n\n    <ThemeContext value={theme}>\n\n      <AuthContext value={currentUser}>\n\n        <Page />\n\n      </AuthContext>\n\n    </ThemeContext>\n\n  );\n\n}\n\nNow the Page component and any components inside it, no matter how deep, will ‚Äúsee‚Äù the passed context values. If the passed context values change, React will re-render the components reading the context as well.\n\nRead more about reading and providing context and see examples.\n\nImporting and exporting context from a file \n\nOften, components in different files will need access to the same context. This is why it‚Äôs common to declare contexts in a separate file. Then you can use the export statement to make context available for other files:\n\n// Contexts.js\n\nimport { createContext } from 'react';\n\n\n\nexport const ThemeContext = createContext('light');\n\nexport const AuthContext = createContext(null);\n\nComponents declared in other files can then use the import statement to read or provide this context:\n\n// Button.js\n\nimport { ThemeContext } from './Contexts.js';\n\n\n\nfunction Button() {\n\n  const theme = useContext(ThemeContext);\n\n  // ...\n\n}\n// App.js\n\nimport { ThemeContext, AuthContext } from './Contexts.js';\n\n\n\nfunction App() {\n\n  // ...\n\n  return (\n\n    <ThemeContext value={theme}>\n\n      <AuthContext value={currentUser}>\n\n        <Page />\n\n      </AuthContext>\n\n    </ThemeContext>\n\n  );\n\n}\n\nThis works similar to importing and exporting components.\n\nTroubleshooting \nI can‚Äôt find a way to change the context value \n\nCode like this specifies the default context value:\n\nconst ThemeContext = createContext('light');\n\nThis value never changes. React only uses this value as a fallback if it can‚Äôt find a matching provider above.\n\nTo make context change over time, add state and wrap components in a context provider.\n\nPREVIOUS\ncaptureOwnerStack\nNEXT\nlazy"
  },
  {
    "title": "lazy ‚Äì React",
    "url": "https://react.dev/reference/react/lazy",
    "html": "API REFERENCE\nAPIS\nlazy\n\nlazy lets you defer loading component‚Äôs code until it is rendered for the first time.\n\nconst SomeComponent = lazy(load)\nReference\nlazy(load)\nload function\nUsage\nLazy-loading components with Suspense\nTroubleshooting\nMy lazy component‚Äôs state gets reset unexpectedly\nReference \nlazy(load) \n\nCall lazy outside your components to declare a lazy-loaded React component:\n\nimport { lazy } from 'react';\n\n\n\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n\nSee more examples below.\n\nParameters \nload: A function that returns a Promise or another thenable (a Promise-like object with a then method). React will not call load until the first time you attempt to render the returned component. After React first calls load, it will wait for it to resolve, and then render the resolved value‚Äôs .default as a React component. Both the returned Promise and the Promise‚Äôs resolved value will be cached, so React will not call load more than once. If the Promise rejects, React will throw the rejection reason for the nearest Error Boundary to handle.\nReturns \n\nlazy returns a React component you can render in your tree. While the code for the lazy component is still loading, attempting to render it will suspend. Use <Suspense> to display a loading indicator while it‚Äôs loading.\n\nload function \nParameters \n\nload receives no parameters.\n\nReturns \n\nYou need to return a Promise or some other thenable (a Promise-like object with a then method). It needs to eventually resolve to an object whose .default property is a valid React component type, such as a function, memo, or a forwardRef component.\n\nUsage \nLazy-loading components with Suspense \n\nUsually, you import components with the static import declaration:\n\nimport MarkdownPreview from './MarkdownPreview.js';\n\nTo defer loading this component‚Äôs code until it‚Äôs rendered for the first time, replace this import with:\n\nimport { lazy } from 'react';\n\n\n\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n\nThis code relies on dynamic import(), which might require support from your bundler or framework. Using this pattern requires that the lazy component you‚Äôre importing was exported as the default export.\n\nNow that your component‚Äôs code loads on demand, you also need to specify what should be displayed while it is loading. You can do this by wrapping the lazy component or any of its parents into a <Suspense> boundary:\n\n<Suspense fallback={<Loading />}>\n\n  <h2>Preview</h2>\n\n  <MarkdownPreview />\n\n</Suspense>\n\nIn this example, the code for MarkdownPreview won‚Äôt be loaded until you attempt to render it. If MarkdownPreview hasn‚Äôt loaded yet, Loading will be shown in its place. Try ticking the checkbox:\n\nApp.js\nLoading.js\nMarkdownPreview.js\nReload\nClear\nFork\nimport { useState, Suspense, lazy } from 'react';\nimport Loading from './Loading.js';\n\nconst MarkdownPreview = lazy(() => delayForDemo(import('./MarkdownPreview.js')));\n\nexport default function MarkdownEditor() {\n  const [showPreview, setShowPreview] = useState(false);\n  const [markdown, setMarkdown] = useState('Hello, **world**!');\n  return (\n    <>\n      <textarea value={markdown} onChange={e => setMarkdown(e.target.value)} />\n      <label>\n        <input type=\"checkbox\" checked={showPreview} onChange={e => setShowPreview(e.target.checked)} />\n        Show preview\n      </label>\n      <hr />\n      {showPreview && (\n        <Suspense fallback={<Loading />}>\n          <h2>Preview</h2>\n          <MarkdownPreview markdown={markdown} />\n        </Suspense>\n      )}\n    </>\n  );\n}\n\n// Add a fixed delay so you can see the loading state\nfunction delayForDemo(promise) {\n  return new Promise(resolve => {\n    setTimeout(resolve, 2000);\n  }).then(() => promise);\n}\n\n\nShow more\n\nThis demo loads with an artificial delay. The next time you untick and tick the checkbox, Preview will be cached, so there will be no loading state. To see the loading state again, click ‚ÄúReset‚Äù on the sandbox.\n\nLearn more about managing loading states with Suspense.\n\nTroubleshooting \nMy lazy component‚Äôs state gets reset unexpectedly \n\nDo not declare lazy components inside other components:\n\nimport { lazy } from 'react';\n\n\n\nfunction Editor() {\n\n  // üî¥ Bad: This will cause all state to be reset on re-renders\n\n  const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n\n  // ...\n\n}\n\nInstead, always declare them at the top level of your module:\n\nimport { lazy } from 'react';\n\n\n\n// ‚úÖ Good: Declare lazy components outside of your components\n\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n\n\n\nfunction Editor() {\n\n  // ...\n\n}\nPREVIOUS\ncreateContext\nNEXT\nmemo"
  },
  {
    "title": "memo ‚Äì React",
    "url": "https://react.dev/reference/react/memo",
    "html": "API REFERENCE\nAPIS\nmemo\n\nmemo lets you skip re-rendering a component when its props are unchanged.\n\nconst MemoizedComponent = memo(SomeComponent, arePropsEqual?)\nNote\n\nReact Compiler automatically applies the equivalent of memo to all components, reducing the need for manual memoization. You can use the compiler to handle component memoization automatically.\n\nReference\nmemo(Component, arePropsEqual?)\nUsage\nSkipping re-rendering when props are unchanged\nUpdating a memoized component using state\nUpdating a memoized component using a context\nMinimizing props changes\nSpecifying a custom comparison function\nDo I still need React.memo if I use React Compiler?\nTroubleshooting\nMy component re-renders when a prop is an object, array, or function\nReference \nmemo(Component, arePropsEqual?) \n\nWrap a component in memo to get a memoized version of that component. This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. But React may still re-render it: memoization is a performance optimization, not a guarantee.\n\nimport { memo } from 'react';\n\n\n\nconst SomeComponent = memo(function SomeComponent(props) {\n\n  // ...\n\n});\n\nSee more examples below.\n\nParameters \n\nComponent: The component that you want to memoize. The memo does not modify this component, but returns a new, memoized component instead. Any valid React component, including functions and forwardRef components, is accepted.\n\noptional arePropsEqual: A function that accepts two arguments: the component‚Äôs previous props, and its new props. It should return true if the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should return false. Usually, you will not specify this function. By default, React will compare each prop with Object.is.\n\nReturns \n\nmemo returns a new React component. It behaves the same as the component provided to memo except that React will not always re-render it when its parent is being re-rendered unless its props have changed.\n\nUsage \nSkipping re-rendering when props are unchanged \n\nReact normally re-renders a component whenever its parent re-renders. With memo, you can create a component that React will not re-render when its parent re-renders so long as its new props are the same as the old props. Such a component is said to be memoized.\n\nTo memoize a component, wrap it in memo and use the value that it returns in place of your original component:\n\nconst Greeting = memo(function Greeting({ name }) {\n\n  return <h1>Hello, {name}!</h1>;\n\n});\n\n\n\nexport default Greeting;\n\nA React component should always have pure rendering logic. This means that it must return the same output if its props, state, and context haven‚Äôt changed. By using memo, you are telling React that your component complies with this requirement, so React doesn‚Äôt need to re-render as long as its props haven‚Äôt changed. Even with memo, your component will re-render if its own state changes or if a context that it‚Äôs using changes.\n\nIn this example, notice that the Greeting component re-renders whenever name is changed (because that‚Äôs one of its props), but not when address is changed (because it‚Äôs not passed to Greeting as a prop):\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { memo, useState } from 'react';\n\nexport default function MyApp() {\n  const [name, setName] = useState('');\n  const [address, setAddress] = useState('');\n  return (\n    <>\n      <label>\n        Name{': '}\n        <input value={name} onChange={e => setName(e.target.value)} />\n      </label>\n      <label>\n        Address{': '}\n        <input value={address} onChange={e => setAddress(e.target.value)} />\n      </label>\n      <Greeting name={name} />\n    </>\n  );\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n  console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n  return <h3>Hello{name && ', '}{name}!</h3>;\n});\n\n\nShow more\nNote\n\nYou should only rely on memo as a performance optimization. If your code doesn‚Äôt work without it, find the underlying problem and fix it first. Then you may add memo to improve performance.\n\nDEEP DIVE\nShould you add memo everywhere? \nShow Details\nUpdating a memoized component using state \n\nEven when a component is memoized, it will still re-render when its own state changes. Memoization only has to do with props that are passed to the component from its parent.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { memo, useState } from 'react';\n\nexport default function MyApp() {\n  const [name, setName] = useState('');\n  const [address, setAddress] = useState('');\n  return (\n    <>\n      <label>\n        Name{': '}\n        <input value={name} onChange={e => setName(e.target.value)} />\n      </label>\n      <label>\n        Address{': '}\n        <input value={address} onChange={e => setAddress(e.target.value)} />\n      </label>\n      <Greeting name={name} />\n    </>\n  );\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n  console.log('Greeting was rendered at', new Date().toLocaleTimeString());\n  const [greeting, setGreeting] = useState('Hello');\n  return (\n    <>\n      <h3>{greeting}{name && ', '}{name}!</h3>\n      <GreetingSelector value={greeting} onChange={setGreeting} />\n    </>\n  );\n});\n\nfunction GreetingSelector({ value, onChange }) {\n  return (\n    <>\n      <label>\n        <input\n          type=\"radio\"\n          checked={value === 'Hello'}\n          onChange={e => onChange('Hello')}\n        />\n        Regular greeting\n      </label>\n      <label>\n        <input\n          type=\"radio\"\n          checked={value === 'Hello and welcome'}\n          onChange={e => onChange('Hello and welcome')}\n        />\n        Enthusiastic greeting\n      </label>\n    </>\n  );\n}\n\n\nShow more\n\nIf you set a state variable to its current value, React will skip re-rendering your component even without memo. You may still see your component function being called an extra time, but the result will be discarded.\n\nUpdating a memoized component using a context \n\nEven when a component is memoized, it will still re-render when a context that it‚Äôs using changes. Memoization only has to do with props that are passed to the component from its parent.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { createContext, memo, useContext, useState } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  const [theme, setTheme] = useState('dark');\n\n  function handleClick() {\n    setTheme(theme === 'dark' ? 'light' : 'dark');\n  }\n\n  return (\n    <ThemeContext value={theme}>\n      <button onClick={handleClick}>\n        Switch theme\n      </button>\n      <Greeting name=\"Taylor\" />\n    </ThemeContext>\n  );\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n  console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n  const theme = useContext(ThemeContext);\n  return (\n    <h3 className={theme}>Hello, {name}!</h3>\n  );\n});\n\n\nShow more\n\nTo make your component re-render only when a part of some context changes, split your component in two. Read what you need from the context in the outer component, and pass it down to a memoized child as a prop.\n\nMinimizing props changes \n\nWhen you use memo, your component re-renders whenever any prop is not shallowly equal to what it was previously. This means that React compares every prop in your component with its previous value using the Object.is comparison. Note that Object.is(3, 3) is true, but Object.is({}, {}) is false.\n\nTo get the most out of memo, minimize the times that the props change. For example, if the prop is an object, prevent the parent component from re-creating that object every time by using useMemo:\n\nfunction Page() {\n\n  const [name, setName] = useState('Taylor');\n\n  const [age, setAge] = useState(42);\n\n\n\n  const person = useMemo(\n\n    () => ({ name, age }),\n\n    [name, age]\n\n  );\n\n\n\n  return <Profile person={person} />;\n\n}\n\n\n\nconst Profile = memo(function Profile({ person }) {\n\n  // ...\n\n});\n\nA better way to minimize props changes is to make sure the component accepts the minimum necessary information in its props. For example, it could accept individual values instead of a whole object:\n\nfunction Page() {\n\n  const [name, setName] = useState('Taylor');\n\n  const [age, setAge] = useState(42);\n\n  return <Profile name={name} age={age} />;\n\n}\n\n\n\nconst Profile = memo(function Profile({ name, age }) {\n\n  // ...\n\n});\n\nEven individual values can sometimes be projected to ones that change less frequently. For example, here a component accepts a boolean indicating the presence of a value rather than the value itself:\n\nfunction GroupsLanding({ person }) {\n\n  const hasGroups = person.groups !== null;\n\n  return <CallToAction hasGroups={hasGroups} />;\n\n}\n\n\n\nconst CallToAction = memo(function CallToAction({ hasGroups }) {\n\n  // ...\n\n});\n\nWhen you need to pass a function to memoized component, either declare it outside your component so that it never changes, or useCallback to cache its definition between re-renders.\n\nSpecifying a custom comparison function \n\nIn rare cases it may be infeasible to minimize the props changes of a memoized component. In that case, you can provide a custom comparison function, which React will use to compare the old and new props instead of using shallow equality. This function is passed as a second argument to memo. It should return true only if the new props would result in the same output as the old props; otherwise it should return false.\n\nconst Chart = memo(function Chart({ dataPoints }) {\n\n  // ...\n\n}, arePropsEqual);\n\n\n\nfunction arePropsEqual(oldProps, newProps) {\n\n  return (\n\n    oldProps.dataPoints.length === newProps.dataPoints.length &&\n\n    oldProps.dataPoints.every((oldPoint, index) => {\n\n      const newPoint = newProps.dataPoints[index];\n\n      return oldPoint.x === newPoint.x && oldPoint.y === newPoint.y;\n\n    })\n\n  );\n\n}\n\nIf you do this, use the Performance panel in your browser developer tools to make sure that your comparison function is actually faster than re-rendering the component. You might be surprised.\n\nWhen you do performance measurements, make sure that React is running in the production mode.\n\nPitfall\n\nIf you provide a custom arePropsEqual implementation, you must compare every prop, including functions. Functions often close over the props and state of parent components. If you return true when oldProps.onClick !== newProps.onClick, your component will keep ‚Äúseeing‚Äù the props and state from a previous render inside its onClick handler, leading to very confusing bugs.\n\nAvoid doing deep equality checks inside arePropsEqual unless you are 100% sure that the data structure you‚Äôre working with has a known limited depth. Deep equality checks can become incredibly slow and can freeze your app for many seconds if someone changes the data structure later.\n\nDo I still need React.memo if I use React Compiler? \n\nWhen you enable React Compiler, you typically don‚Äôt need React.memo anymore. The compiler automatically optimizes component re-rendering for you.\n\nHere‚Äôs how it works:\n\nWithout React Compiler, you need React.memo to prevent unnecessary re-renders:\n\n// Parent re-renders every second\n\nfunction Parent() {\n\n  const [seconds, setSeconds] = useState(0);\n\n\n\n  useEffect(() => {\n\n    const interval = setInterval(() => {\n\n      setSeconds(s => s + 1);\n\n    }, 1000);\n\n    return () => clearInterval(interval);\n\n  }, []);\n\n\n\n  return (\n\n    <>\n\n      <h1>Seconds: {seconds}</h1>\n\n      <ExpensiveChild name=\"John\" />\n\n    </>\n\n  );\n\n}\n\n\n\n// Without memo, this re-renders every second even though props don't change\n\nconst ExpensiveChild = memo(function ExpensiveChild({ name }) {\n\n  console.log('ExpensiveChild rendered');\n\n  return <div>Hello, {name}!</div>;\n\n});\n\nWith React Compiler enabled, the same optimization happens automatically:\n\n// No memo needed - compiler prevents re-renders automatically\n\nfunction ExpensiveChild({ name }) {\n\n  console.log('ExpensiveChild rendered');\n\n  return <div>Hello, {name}!</div>;\n\n}\n\nHere‚Äôs the key part of what the React Compiler generates:\n\nfunction Parent() {\n\n  const $ = _c(7);\n\n  const [seconds, setSeconds] = useState(0);\n\n  // ... other code ...\n\n\n\n  let t3;\n\n  if ($[4] === Symbol.for(\"react.memo_cache_sentinel\")) {\n\n    t3 = <ExpensiveChild name=\"John\" />;\n\n    $[4] = t3;\n\n  } else {\n\n    t3 = $[4];\n\n  }\n\n  // ... return statement ...\n\n}\n\nNotice the highlighted lines: The compiler wraps <ExpensiveChild name=\"John\" /> in a cache check. Since the name prop is always \"John\", this JSX is created once and reused on every parent re-render. This is exactly what React.memo does - it prevents the child from re-rendering when its props haven‚Äôt changed.\n\nThe React Compiler automatically:\n\nTracks that the name prop passed to ExpensiveChild hasn‚Äôt changed\nReuses the previously created JSX for <ExpensiveChild name=\"John\" />\nSkips re-rendering ExpensiveChild entirely\n\nThis means you can safely remove React.memo from your components when using React Compiler. The compiler provides the same optimization automatically, making your code cleaner and easier to maintain.\n\nNote\n\nThe compiler‚Äôs optimization is actually more comprehensive than React.memo. It also memoizes intermediate values and expensive computations within your components, similar to combining React.memo with useMemo throughout your component tree.\n\nTroubleshooting \nMy component re-renders when a prop is an object, array, or function \n\nReact compares old and new props by shallow equality: that is, it considers whether each new prop is reference-equal to the old prop. If you create a new object or array each time the parent is re-rendered, even if the individual elements are each the same, React will still consider it to be changed. Similarly, if you create a new function when rendering the parent component, React will consider it to have changed even if the function has the same definition. To avoid this, simplify props or memoize props in the parent component.\n\nPREVIOUS\nlazy\nNEXT\nstartTransition"
  },
  {
    "title": "startTransition ‚Äì React",
    "url": "https://react.dev/reference/react/startTransition",
    "html": "API REFERENCE\nAPIS\nstartTransition\n\nstartTransition lets you render a part of the UI in the background.\n\nstartTransition(action)\nReference\nstartTransition(action)\nUsage\nMarking a state update as a non-blocking Transition\nReference \nstartTransition(action) \n\nThe startTransition function lets you mark a state update as a Transition.\n\nimport { startTransition } from 'react';\n\n\n\nfunction TabContainer() {\n\n  const [tab, setTab] = useState('about');\n\n\n\n  function selectTab(nextTab) {\n\n    startTransition(() => {\n\n      setTab(nextTab);\n\n    });\n\n  }\n\n  // ...\n\n}\n\nSee more examples below.\n\nParameters \naction: A function that updates some state by calling one or more set functions. React calls action immediately with no parameters and marks all state updates scheduled synchronously during the action function call as Transitions. Any async calls awaited in the action will be included in the transition, but currently require wrapping any set functions after the await in an additional startTransition (see Troubleshooting). State updates marked as Transitions will be non-blocking and will not display unwanted loading indicators..\nReturns \n\nstartTransition does not return anything.\n\nCaveats \n\nstartTransition does not provide a way to track whether a Transition is pending. To show a pending indicator while the Transition is ongoing, you need useTransition instead.\n\nYou can wrap an update into a Transition only if you have access to the set function of that state. If you want to start a Transition in response to some prop or a custom Hook return value, try useDeferredValue instead.\n\nThe function you pass to startTransition is called immediately, marking all state updates that happen while it executes as Transitions. If you try to perform state updates in a setTimeout, for example, they won‚Äôt be marked as Transitions.\n\nYou must wrap any state updates after any async requests in another startTransition to mark them as Transitions. This is a known limitation that we will fix in the future (see Troubleshooting).\n\nA state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input state update.\n\nTransition updates can‚Äôt be used to control text inputs.\n\nIf there are multiple ongoing Transitions, React currently batches them together. This is a limitation that may be removed in a future release.\n\nUsage \nMarking a state update as a non-blocking Transition \n\nYou can mark a state update as a Transition by wrapping it in a startTransition call:\n\nimport { startTransition } from 'react';\n\n\n\nfunction TabContainer() {\n\n  const [tab, setTab] = useState('about');\n\n\n\n  function selectTab(nextTab) {\n\n    startTransition(() => {\n\n      setTab(nextTab);\n\n    });\n\n  }\n\n  // ...\n\n}\n\nTransitions let you keep the user interface updates responsive even on slow devices.\n\nWith a Transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish.\n\nNote\n\nstartTransition is very similar to useTransition, except that it does not provide the isPending flag to track whether a Transition is ongoing. You can call startTransition when useTransition is not available. For example, startTransition works outside components, such as from a data library.\n\nLearn about Transitions and see examples on the useTransition page.\n\nPREVIOUS\nmemo\nNEXT\nuse"
  },
  {
    "title": "use ‚Äì React",
    "url": "https://react.dev/reference/react/use",
    "html": "API REFERENCE\nAPIS\nuse\n\nuse is a React API that lets you read the value of a resource like a Promise or context.\n\nconst value = use(resource);\nReference\nuse(resource)\nUsage\nReading context with use\nStreaming data from the server to the client\nDealing with rejected Promises\nTroubleshooting\n‚ÄúSuspense Exception: This is not a real error!‚Äù\nReference \nuse(resource) \n\nCall use in your component to read the value of a resource like a Promise or context.\n\nimport { use } from 'react';\n\n\n\nfunction MessageComponent({ messagePromise }) {\n\n  const message = use(messagePromise);\n\n  const theme = use(ThemeContext);\n\n  // ...\n\nUnlike React Hooks, use can be called within loops and conditional statements like if. Like React Hooks, the function that calls use must be a Component or Hook.\n\nWhen called with a Promise, the use API integrates with Suspense and Error Boundaries. The component calling use suspends while the Promise passed to use is pending. If the component that calls use is wrapped in a Suspense boundary, the fallback will be displayed.  Once the Promise is resolved, the Suspense fallback is replaced by the rendered components using the data returned by the use API. If the Promise passed to use is rejected, the fallback of the nearest Error Boundary will be displayed.\n\nSee more examples below.\n\nParameters \nresource: this is the source of the data you want to read a value from. A resource can be a Promise or a context.\nReturns \n\nThe use API returns the value that was read from the resource like the resolved value of a Promise or context.\n\nCaveats \nThe use API must be called inside a Component or a Hook.\nWhen fetching data in a Server Component, prefer async and await over use. async and await pick up rendering from the point where await was invoked, whereas use re-renders the component after the data is resolved.\nPrefer creating Promises in Server Components and passing them to Client Components over creating Promises in Client Components. Promises created in Client Components are recreated on every render. Promises passed from a Server Component to a Client Component are stable across re-renders. See this example.\nUsage \nReading context with use \n\nWhen a context is passed to use, it works similarly to useContext. While useContext must be called at the top level of your component, use can be called inside conditionals like if and loops like for. use is preferred over useContext because it is more flexible.\n\nimport { use } from 'react';\n\n\n\nfunction Button() {\n\n  const theme = use(ThemeContext);\n\n  // ...\n\nuse returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context.\n\nTo pass context to a Button, wrap it or one of its parent components into the corresponding context provider.\n\nfunction MyPage() {\n\n  return (\n\n    <ThemeContext value=\"dark\">\n\n      <Form />\n\n    </ThemeContext>\n\n  );\n\n}\n\n\n\nfunction Form() {\n\n  // ... renders buttons inside ...\n\n}\n\nIt doesn‚Äôt matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls use(ThemeContext), it will receive \"dark\" as the value.\n\nUnlike useContext, use can be called in conditionals and loops like if.\n\nfunction HorizontalRule({ show }) {\n\n  if (show) {\n\n    const theme = use(ThemeContext);\n\n    return <hr className={theme} />;\n\n  }\n\n  return false;\n\n}\n\nuse is called from inside a if statement, allowing you to conditionally read values from a Context.\n\nPitfall\n\nLike useContext, use(context) always looks for the closest context provider above the component that calls it. It searches upwards and does not consider context providers in the component from which you‚Äôre calling use(context).\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { createContext, use } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  return (\n    <ThemeContext value=\"dark\">\n      <Form />\n    </ThemeContext>\n  )\n}\n\nfunction Form() {\n  return (\n    <Panel title=\"Welcome\">\n      <Button show={true}>Sign up</Button>\n      <Button show={false}>Log in</Button>\n    </Panel>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = use(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      <h1>{title}</h1>\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ show, children }) {\n  if (show) {\n    const theme = use(ThemeContext);\n    const className = 'button-' + theme;\n    return (\n      <button className={className}>\n        {children}\n      </button>\n    );\n  }\n  return false\n}\n\n\nShow more\nStreaming data from the server to the client \n\nData can be streamed from the server to the client by passing a Promise as a prop from a Server Component to a Client Component.\n\nimport { fetchMessage } from './lib.js';\n\nimport { Message } from './message.js';\n\n\n\nexport default function App() {\n\n  const messagePromise = fetchMessage();\n\n  return (\n\n    <Suspense fallback={<p>waiting for message...</p>}>\n\n      <Message messagePromise={messagePromise} />\n\n    </Suspense>\n\n  );\n\n}\n\nThe Client Component then takes the Promise it received as a prop and passes it to the use API. This allows the Client Component to read the value from the Promise that was initially created by the Server Component.\n\n// message.js\n\n'use client';\n\n\n\nimport { use } from 'react';\n\n\n\nexport function Message({ messagePromise }) {\n\n  const messageContent = use(messagePromise);\n\n  return <p>Here is the message: {messageContent}</p>;\n\n}\n\nBecause Message is wrapped in Suspense, the fallback will be displayed until the Promise is resolved. When the Promise is resolved, the value will be read by the use API and the Message component will replace the Suspense fallback.\n\nmessage.js\nReload\nClear\nFork\n\"use client\";\n\nimport { use, Suspense } from \"react\";\n\nfunction Message({ messagePromise }) {\n  const messageContent = use(messagePromise);\n  return <p>Here is the message: {messageContent}</p>;\n}\n\nexport function MessageContainer({ messagePromise }) {\n  return (\n    <Suspense fallback={<p>‚åõDownloading message...</p>}>\n      <Message messagePromise={messagePromise} />\n    </Suspense>\n  );\n}\n\n\nShow more\nNote\n\nWhen passing a Promise from a Server Component to a Client Component, its resolved value must be serializable to pass between server and client. Data types like functions aren‚Äôt serializable and cannot be the resolved value of such a Promise.\n\nDEEP DIVE\nShould I resolve a Promise in a Server or Client Component? \nShow Details\nDealing with rejected Promises \n\nIn some cases a Promise passed to use could be rejected. You can handle rejected Promises by either:\n\nDisplaying an error to users with an Error Boundary.\nProviding an alternative value with Promise.catch\nPitfall\n\nuse cannot be called in a try-catch block. Instead of a try-catch block wrap your component in an Error Boundary, or provide an alternative value to use with the Promise‚Äôs .catch method.\n\nDisplaying an error to users with an Error Boundary \n\nIf you‚Äôd like to display an error to your users when a Promise is rejected, you can use an Error Boundary. To use an Error Boundary, wrap the component where you are calling the use API in an Error Boundary. If the Promise passed to use is rejected the fallback for the Error Boundary will be displayed.\n\nmessage.js\nReload\nClear\nFork\n\"use client\";\n\nimport { use, Suspense } from \"react\";\nimport { ErrorBoundary } from \"react-error-boundary\";\n\nexport function MessageContainer({ messagePromise }) {\n  return (\n    <ErrorBoundary fallback={<p>‚ö†Ô∏èSomething went wrong</p>}>\n      <Suspense fallback={<p>‚åõDownloading message...</p>}>\n        <Message messagePromise={messagePromise} />\n      </Suspense>\n    </ErrorBoundary>\n  );\n}\n\nfunction Message({ messagePromise }) {\n  const content = use(messagePromise);\n  return <p>Here is the message: {content}</p>;\n}\n\n\nShow more\nProviding an alternative value with Promise.catch \n\nIf you‚Äôd like to provide an alternative value when the Promise passed to use is rejected you can use the Promise‚Äôs catch method.\n\nimport { Message } from './message.js';\n\n\n\nexport default function App() {\n\n  const messagePromise = new Promise((resolve, reject) => {\n\n    reject();\n\n  }).catch(() => {\n\n    return \"no new message found.\";\n\n  });\n\n\n\n  return (\n\n    <Suspense fallback={<p>waiting for message...</p>}>\n\n      <Message messagePromise={messagePromise} />\n\n    </Suspense>\n\n  );\n\n}\n\nTo use the Promise‚Äôs catch method, call catch on the Promise object. catch takes a single argument: a function that takes an error message as an argument. Whatever is returned by the function passed to catch will be used as the resolved value of the Promise.\n\nTroubleshooting \n‚ÄúSuspense Exception: This is not a real error!‚Äù \n\nYou are either calling use outside of a React Component or Hook function, or calling use in a try‚Äìcatch block. If you are calling use inside a try‚Äìcatch block, wrap your component in an Error Boundary, or call the Promise‚Äôs catch to catch the error and resolve the Promise with another value. See these examples.\n\nIf you are calling use outside a React Component or Hook function, move the use call to a React Component or Hook function.\n\nfunction MessageComponent({messagePromise}) {\n\n  function download() {\n\n    // ‚ùå the function calling `use` is not a Component or Hook\n\n    const message = use(messagePromise);\n\n    // ...\n\nInstead, call use outside any component closures, where the function that calls use is a Component or Hook.\n\nfunction MessageComponent({messagePromise}) {\n\n  // ‚úÖ `use` is being called from a component. \n\n  const message = use(messagePromise);\n\n  // ...\nPREVIOUS\nstartTransition\nNEXT\nexperimental_taintObjectReference"
  },
  {
    "title": "experimental_taintObjectReference ‚Äì React",
    "url": "https://react.dev/reference/react/experimental_taintObjectReference",
    "html": "API REFERENCE\nAPIS\nexperimental_taintObjectReference\nExperimental Feature\n\nThis API is experimental and is not available in a stable version of React yet.\n\nYou can try it by upgrading React packages to the most recent experimental version:\n\nreact@experimental\nreact-dom@experimental\neslint-plugin-react-hooks@experimental\n\nExperimental versions of React may contain bugs. Don‚Äôt use them in production.\n\nThis API is only available inside React Server Components.\n\ntaintObjectReference lets you prevent a specific object instance from being passed to a Client Component like a user object.\n\nexperimental_taintObjectReference(message, object);\n\nTo prevent passing a key, hash or token, see taintUniqueValue.\n\nReference\ntaintObjectReference(message, object)\nUsage\nPrevent user data from unintentionally reaching the client\nReference \ntaintObjectReference(message, object) \n\nCall taintObjectReference with an object to register it with React as something that should not be allowed to be passed to the Client as is:\n\nimport {experimental_taintObjectReference} from 'react';\n\n\n\nexperimental_taintObjectReference(\n\n  'Do not pass ALL environment variables to the client.',\n\n  process.env\n\n);\n\nSee more examples below.\n\nParameters \n\nmessage: The message you want to display if the object gets passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if the object gets passed to a Client Component.\n\nobject: The object to be tainted. Functions and class instances can be passed to taintObjectReference as object. Functions and classes are already blocked from being passed to Client Components but the React‚Äôs default error message will be replaced by what you defined in message. When a specific instance of a Typed Array is passed to taintObjectReference as object, any other copies of the Typed Array will not be tainted.\n\nReturns \n\nexperimental_taintObjectReference returns undefined.\n\nCaveats \nRecreating or cloning a tainted object creates a new untainted object which may contain sensitive data. For example, if you have a tainted user object, const userInfo = {name: user.name, ssn: user.ssn} or {...user} will create new objects which are not tainted. taintObjectReference only protects against simple mistakes when the object is passed through to a Client Component unchanged.\nPitfall\n\nDo not rely on just tainting for security. Tainting an object doesn‚Äôt prevent leaking of every possible derived value. For example, the clone of a tainted object will create a new untainted object. Using data from a tainted object (e.g. {secret: taintedObj.secret}) will create a new value or object that is not tainted. Tainting is a layer of protection; a secure app will have multiple layers of protection, well designed APIs, and isolation patterns.\n\nUsage \nPrevent user data from unintentionally reaching the client \n\nA Client Component should never accept objects that carry sensitive data. Ideally, the data fetching functions should not expose data that the current user should not have access to. Sometimes mistakes happen during refactoring. To protect against these mistakes happening down the line we can ‚Äútaint‚Äù the user object in our data API.\n\nimport {experimental_taintObjectReference} from 'react';\n\n\n\nexport async function getUser(id) {\n\n  const user = await db`SELECT * FROM users WHERE id = ${id}`;\n\n  experimental_taintObjectReference(\n\n    'Do not pass the entire user object to the client. ' +\n\n      'Instead, pick off the specific properties you need for this use case.',\n\n    user,\n\n  );\n\n  return user;\n\n}\n\nNow whenever anyone tries to pass this object to a Client Component, an error will be thrown with the passed in error message instead.\n\nDEEP DIVE\nProtecting against leaks in data fetching \nShow Details\nPREVIOUS\nuse\nNEXT\nexperimental_taintUniqueValue"
  },
  {
    "title": "experimental_taintUniqueValue ‚Äì React",
    "url": "https://react.dev/reference/react/experimental_taintUniqueValue",
    "html": "API REFERENCE\nAPIS\nexperimental_taintUniqueValue\nExperimental Feature\n\nThis API is experimental and is not available in a stable version of React yet.\n\nYou can try it by upgrading React packages to the most recent experimental version:\n\nreact@experimental\nreact-dom@experimental\neslint-plugin-react-hooks@experimental\n\nExperimental versions of React may contain bugs. Don‚Äôt use them in production.\n\nThis API is only available inside React Server Components.\n\ntaintUniqueValue lets you prevent unique values from being passed to Client Components like passwords, keys, or tokens.\n\ntaintUniqueValue(errMessage, lifetime, value)\n\nTo prevent passing an object containing sensitive data, see taintObjectReference.\n\nReference\ntaintUniqueValue(message, lifetime, value)\nUsage\nPrevent a token from being passed to Client Components\nReference \ntaintUniqueValue(message, lifetime, value) \n\nCall taintUniqueValue with a password, token, key or hash to register it with React as something that should not be allowed to be passed to the Client as is:\n\nimport {experimental_taintUniqueValue} from 'react';\n\n\n\nexperimental_taintUniqueValue(\n\n  'Do not pass secret keys to the client.',\n\n  process,\n\n  process.env.SECRET_KEY\n\n);\n\nSee more examples below.\n\nParameters \n\nmessage: The message you want to display if value is passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if value is passed to a Client Component.\n\nlifetime: Any object that indicates how long value should be tainted. value will be blocked from being sent to any Client Component while this object still exists. For example, passing globalThis blocks the value for the lifetime of an app. lifetime is typically an object whose properties contains value.\n\nvalue: A string, bigint or TypedArray. value must be a unique sequence of characters or bytes with high entropy such as a cryptographic token, private key, hash, or a long password. value will be blocked from being sent to any Client Component.\n\nReturns \n\nexperimental_taintUniqueValue returns undefined.\n\nCaveats \nDeriving new values from tainted values can compromise tainting protection. New values created by uppercasing tainted values, concatenating tainted string values into a larger string, converting tainted values to base64, substringing tainted values, and other similar transformations are not tainted unless you explicitly call taintUniqueValue on these newly created values.\nDo not use taintUniqueValue to protect low-entropy values such as PIN codes or phone numbers. If any value in a request is controlled by an attacker, they could infer which value is tainted by enumerating all possible values of the secret.\nUsage \nPrevent a token from being passed to Client Components \n\nTo ensure that sensitive information such as passwords, session tokens, or other unique values do not inadvertently get passed to Client Components, the taintUniqueValue function provides a layer of protection. When a value is tainted, any attempt to pass it to a Client Component will result in an error.\n\nThe lifetime argument defines the duration for which the value remains tainted. For values that should remain tainted indefinitely, objects like globalThis or process can serve as the lifetime argument. These objects have a lifespan that spans the entire duration of your app‚Äôs execution.\n\nimport {experimental_taintUniqueValue} from 'react';\n\n\n\nexperimental_taintUniqueValue(\n\n  'Do not pass a user password to the client.',\n\n  globalThis,\n\n  process.env.SECRET_KEY\n\n);\n\nIf the tainted value‚Äôs lifespan is tied to a object, the lifetime should be the object that encapsulates the value. This ensures the tainted value remains protected for the lifetime of the encapsulating object.\n\nimport {experimental_taintUniqueValue} from 'react';\n\n\n\nexport async function getUser(id) {\n\n  const user = await db`SELECT * FROM users WHERE id = ${id}`;\n\n  experimental_taintUniqueValue(\n\n    'Do not pass a user session token to the client.',\n\n    user,\n\n    user.session.token\n\n  );\n\n  return user;\n\n}\n\nIn this example, the user object serves as the lifetime argument. If this object gets stored in a global cache or is accessible by another request, the session token remains tainted.\n\nPitfall\n\nDo not rely solely on tainting for security. Tainting a value doesn‚Äôt block every possible derived value. For example, creating a new value by upper casing a tainted string will not taint the new value.\n\nimport {experimental_taintUniqueValue} from 'react';\n\n\n\nconst password = 'correct horse battery staple';\n\n\n\nexperimental_taintUniqueValue(\n\n  'Do not pass the password to the client.',\n\n  globalThis,\n\n  password\n\n);\n\n\n\nconst uppercasePassword = password.toUpperCase() // `uppercasePassword` is not tainted\n\nIn this example, the constant password is tainted. Then password is used to create a new value uppercasePassword by calling the toUpperCase method on password. The newly created uppercasePassword is not tainted.\n\nOther similar ways of deriving new values from tainted values like concatenating it into a larger string, converting it to base64, or returning a substring create untained values.\n\nTainting only protects against simple mistakes like explicitly passing secret values to the client. Mistakes in calling the taintUniqueValue like using a global store outside of React, without the corresponding lifetime object, can cause the tainted value to become untainted. Tainting is a layer of protection; a secure app will have multiple layers of protection, well designed APIs, and isolation patterns.\n\nDEEP DIVE\nUsing server-only and taintUniqueValue to prevent leaking secrets \nShow Details\nPREVIOUS\nexperimental_taintObjectReference"
  },
  {
    "title": "Built-in React DOM Hooks ‚Äì React",
    "url": "https://react.dev/reference/react-dom/hooks",
    "html": "API REFERENCE\nBuilt-in React DOM Hooks\n\nThe react-dom package contains Hooks that are only supported for web applications (which run in the browser DOM environment). These Hooks are not supported in non-browser environments like iOS, Android, or Windows applications. If you are looking for Hooks that are supported in web browsers and other environments see the React Hooks page. This page lists all the Hooks in the react-dom package.\n\nForm Hooks \n\nForms let you create interactive controls for submitting information.  To manage forms in your components, use one of these Hooks:\n\nuseFormStatus allows you to make updates to the UI based on the status of a form.\nfunction Form({ action }) {\n\n  async function increment(n) {\n\n    return n + 1;\n\n  }\n\n  const [count, incrementFormAction] = useActionState(increment, 0);\n\n  return (\n\n    <form action={action}>\n\n      <button formAction={incrementFormAction}>Count: {count}</button>\n\n      <Button />\n\n    </form>\n\n  );\n\n}\n\n\n\nfunction Button() {\n\n  const { pending } = useFormStatus();\n\n  return (\n\n    <button disabled={pending} type=\"submit\">\n\n      Submit\n\n    </button>\n\n  );\n\n}\nNEXT\nuseFormStatus"
  },
  {
    "title": "useFormStatus ‚Äì React",
    "url": "https://react.dev/reference/react-dom/hooks/useFormStatus",
    "html": "API REFERENCE\nHOOKS\nuseFormStatus\n\nuseFormStatus is a Hook that gives you status information of the last form submission.\n\nconst { pending, data, method, action } = useFormStatus();\nReference\nuseFormStatus()\nUsage\nDisplay a pending state during form submission\nRead the form data being submitted\nTroubleshooting\nstatus.pending is never true\nReference \nuseFormStatus() \n\nThe useFormStatus Hook provides status information of the last form submission.\n\nimport { useFormStatus } from \"react-dom\";\n\nimport action from './actions';\n\n\n\nfunction Submit() {\n\n  const status = useFormStatus();\n\n  return <button disabled={status.pending}>Submit</button>\n\n}\n\n\n\nexport default function App() {\n\n  return (\n\n    <form action={action}>\n\n      <Submit />\n\n    </form>\n\n  );\n\n}\n\nTo get status information, the Submit component must be rendered within a <form>. The Hook returns information like the pending property which tells you if the form is actively submitting.\n\nIn the above example, Submit uses this information to disable <button> presses while the form is submitting.\n\nSee more examples below.\n\nParameters \n\nuseFormStatus does not take any parameters.\n\nReturns \n\nA status object with the following properties:\n\npending: A boolean. If true, this means the parent <form> is pending submission. Otherwise, false.\n\ndata: An object implementing the FormData interface that contains the data the parent <form> is submitting. If there is no active submission or no parent <form>, it will be null.\n\nmethod: A string value of either 'get' or 'post'. This represents whether the parent <form> is submitting with either a GET or POST HTTP method. By default, a <form> will use the GET method and can be specified by the method property.\n\naction: A reference to the function passed to the action prop on the parent <form>. If there is no parent <form>, the property is null. If there is a URI value provided to the action prop, or no action prop specified, status.action will be null.\nCaveats \nThe useFormStatus Hook must be called from a component that is rendered inside a <form>.\nuseFormStatus will only return status information for a parent <form>. It will not return status information for any <form> rendered in that same component or children components.\nUsage \nDisplay a pending state during form submission \n\nTo display a pending state while a form is submitting, you can call the useFormStatus Hook in a component rendered in a <form> and read the pending property returned.\n\nHere, we use the pending property to indicate the form is submitting.\n\nApp.js\nReload\nClear\nFork\nimport { useFormStatus } from \"react-dom\";\nimport { submitForm } from \"./actions.js\";\n\nfunction Submit() {\n  const { pending } = useFormStatus();\n  return (\n    <button type=\"submit\" disabled={pending}>\n      {pending ? \"Submitting...\" : \"Submit\"}\n    </button>\n  );\n}\n\nfunction Form({ action }) {\n  return (\n    <form action={action}>\n      <Submit />\n    </form>\n  );\n}\n\nexport default function App() {\n  return <Form action={submitForm} />;\n}\n\n\nShow more\nPitfall\nuseFormStatus will not return status information for a <form> rendered in the same component. \n\nThe useFormStatus Hook only returns status information for a parent <form> and not for any <form> rendered in the same component calling the Hook, or child components.\n\nfunction Form() {\n\n  // üö© `pending` will never be true\n\n  // useFormStatus does not track the form rendered in this component\n\n  const { pending } = useFormStatus();\n\n  return <form action={submit}></form>;\n\n}\n\nInstead call useFormStatus from inside a component that is located inside <form>.\n\nfunction Submit() {\n\n  // ‚úÖ `pending` will be derived from the form that wraps the Submit component\n\n  const { pending } = useFormStatus(); \n\n  return <button disabled={pending}>...</button>;\n\n}\n\n\n\nfunction Form() {\n\n  // This is the <form> `useFormStatus` tracks\n\n  return (\n\n    <form action={submit}>\n\n      <Submit />\n\n    </form>\n\n  );\n\n}\nRead the form data being submitted \n\nYou can use the data property of the status information returned from useFormStatus to display what data is being submitted by the user.\n\nHere, we have a form where users can request a username. We can use useFormStatus to display a temporary status message confirming what username they have requested.\n\nUsernameForm.js\nApp.js\nReload\nClear\nFork\nimport {useState, useMemo, useRef} from 'react';\nimport {useFormStatus} from 'react-dom';\n\nexport default function UsernameForm() {\n  const {pending, data} = useFormStatus();\n\n  return (\n    <div>\n      <h3>Request a Username: </h3>\n      <input type=\"text\" name=\"username\" disabled={pending}/>\n      <button type=\"submit\" disabled={pending}>\n        Submit\n      </button>\n      <br />\n      <p>{data ? `Requesting ${data?.get(\"username\")}...`: ''}</p>\n    </div>\n  );\n}\n\n\nShow more\nTroubleshooting \nstatus.pending is never true \n\nuseFormStatus will only return status information for a parent <form>.\n\nIf the component that calls useFormStatus is not nested in a <form>, status.pending will always return false. Verify useFormStatus is called in a component that is a child of a <form> element.\n\nuseFormStatus will not track the status of a <form> rendered in the same component. See Pitfall for more details.\n\nPREVIOUS\nHooks\nNEXT\nComponents"
  },
  {
    "title": "React DOM Components ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components",
    "html": "API REFERENCE\nReact DOM Components\n\nReact supports all of the browser built-in HTML and SVG components.\n\nCommon components \n\nAll of the built-in browser components support some props and events.\n\nCommon components (e.g. <div>)\n\nThis includes React-specific props like ref and dangerouslySetInnerHTML.\n\nForm components \n\nThese built-in browser components accept user input:\n\n<input>\n<select>\n<textarea>\n\nThey are special in React because passing the value prop to them makes them controlled.\n\nResource and Metadata Components \n\nThese built-in browser components let you load external resources or annotate the document with metadata:\n\n<link>\n<meta>\n<script>\n<style>\n<title>\n\nThey are special in React because React can render them into the document head, suspend while resources are loading, and enact other behaviors that are described on the reference page for each specific component.\n\nAll HTML components \n\nReact supports all built-in browser HTML components. This includes:\n\n<aside>\n<audio>\n<b>\n<base>\n<bdi>\n<bdo>\n<blockquote>\n<body>\n<br>\n<button>\n<canvas>\n<caption>\n<cite>\n<code>\n<col>\n<colgroup>\n<data>\n<datalist>\n<dd>\n<del>\n<details>\n<dfn>\n<dialog>\n<div>\n<dl>\n<dt>\n<em>\n<embed>\n<fieldset>\n<figcaption>\n<figure>\n<footer>\n<form>\n<h1>\n<head>\n<header>\n<hgroup>\n<hr>\n<html>\n<i>\n<iframe>\n<img>\n<input>\n<ins>\n<kbd>\n<label>\n<legend>\n<li>\n<link>\n<main>\n<map>\n<mark>\n<menu>\n<meta>\n<meter>\n<nav>\n<noscript>\n<object>\n<ol>\n<optgroup>\n<option>\n<output>\n<p>\n<picture>\n<pre>\n<progress>\n<q>\n<rp>\n<rt>\n<ruby>\n<s>\n<samp>\n<script>\n<section>\n<select>\n<slot>\n<small>\n<source>\n<span>\n<strong>\n<style>\n<sub>\n<summary>\n<sup>\n<table>\n<tbody>\n<td>\n<template>\n<textarea>\n<tfoot>\n<th>\n<thead>\n<time>\n<title>\n<tr>\n<track>\n<u>\n<ul>\n<var>\n<video>\n<wbr>\nNote\n\nSimilar to the DOM standard, React uses a camelCase convention for prop names. For example, you‚Äôll write tabIndex instead of tabindex. You can convert existing HTML to JSX with an online converter.\n\nCustom HTML elements \n\nIf you render a tag with a dash, like <my-element>, React will assume you want to render a custom HTML element.\n\nIf you render a built-in browser HTML element with an is attribute, it will also be treated as a custom element.\n\nSetting values on custom elements \n\nCustom elements have two methods of passing data into them:\n\nAttributes: Which are displayed in markup and can only be set to string values\nProperties: Which are not displayed in markup and can be set to arbitrary JavaScript values\n\nBy default, React will pass values bound in JSX as attributes:\n\n<my-element value=\"Hello, world!\"></my-element>\n\nNon-string JavaScript values passed to custom elements will be serialized by default:\n\n// Will be passed as `\"1,2,3\"` as the output of `[1,2,3].toString()`\n\n<my-element value={[1,2,3]}></my-element>\n\nReact will, however, recognize an custom element‚Äôs property as one that it may pass arbitrary values to if the property name shows up on the class during construction:\n\nMyElement.js\nApp.js\nReload\nClear\nFork\nexport class MyElement extends HTMLElement {\n  constructor() {\n    super();\n    // The value here will be overwritten by React \n    // when initialized as an element\n    this.value = undefined;\n  }\n\n  connectedCallback() {\n    this.innerHTML = this.value.join(\", \");\n  }\n}\n\n\nListening for events on custom elements \n\nA common pattern when using custom elements is that they may dispatch CustomEvents rather than accept a function to call when an event occur. You can listen for these events using an on prefix when binding to the event via JSX.\n\nMyElement.js\nApp.js\nReload\nClear\nFork\nexport function App() {\n  return (\n    <my-element\n      onspeak={e => console.log(e.detail.message)}\n    ></my-element>\n  )\n}\n\n\nNote\n\nEvents are case-sensitive and support dashes (-). Preserve the casing of the event and include all dashes when listening for custom element‚Äôs events:\n\n// Listens for `say-hi` events\n\n<my-element onsay-hi={console.log}></my-element>\n\n// Listens for `sayHi` events\n\n<my-element onsayHi={console.log}></my-element>\nAll SVG components \n\nReact supports all built-in browser SVG components. This includes:\n\n<a>\n<animate>\n<animateMotion>\n<animateTransform>\n<circle>\n<clipPath>\n<defs>\n<desc>\n<discard>\n<ellipse>\n<feBlend>\n<feColorMatrix>\n<feComponentTransfer>\n<feComposite>\n<feConvolveMatrix>\n<feDiffuseLighting>\n<feDisplacementMap>\n<feDistantLight>\n<feDropShadow>\n<feFlood>\n<feFuncA>\n<feFuncB>\n<feFuncG>\n<feFuncR>\n<feGaussianBlur>\n<feImage>\n<feMerge>\n<feMergeNode>\n<feMorphology>\n<feOffset>\n<fePointLight>\n<feSpecularLighting>\n<feSpotLight>\n<feTile>\n<feTurbulence>\n<filter>\n<foreignObject>\n<g>\n<hatch>\n<hatchpath>\n<image>\n<line>\n<linearGradient>\n<marker>\n<mask>\n<metadata>\n<mpath>\n<path>\n<pattern>\n<polygon>\n<polyline>\n<radialGradient>\n<rect>\n<script>\n<set>\n<stop>\n<style>\n<svg>\n<switch>\n<symbol>\n<text>\n<textPath>\n<title>\n<tspan>\n<use>\n<view>\nNote\n\nSimilar to the DOM standard, React uses a camelCase convention for prop names. For example, you‚Äôll write tabIndex instead of tabindex. You can convert existing SVG to JSX with an online converter.\n\nNamespaced attributes also have to be written without the colon:\n\nxlink:actuate becomes xlinkActuate.\nxlink:arcrole becomes xlinkArcrole.\nxlink:href becomes xlinkHref.\nxlink:role becomes xlinkRole.\nxlink:show becomes xlinkShow.\nxlink:title becomes xlinkTitle.\nxlink:type becomes xlinkType.\nxml:base becomes xmlBase.\nxml:lang becomes xmlLang.\nxml:space becomes xmlSpace.\nxmlns:xlink becomes xmlnsXlink.\nPREVIOUS\nuseFormStatus\nNEXT\nCommon (e.g. <div>)"
  },
  {
    "title": "Common components (e.g. <div>) ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/common",
    "html": "API REFERENCE\nCOMPONENTS\nCommon components (e.g. <div>)\n\nAll built-in browser components, such as <div>, support some common props and events.\n\nReference\nCommon components (e.g. <div>)\nref callback function\nReact event object\nAnimationEvent handler function\nClipboardEvent handler function\nCompositionEvent handler function\nDragEvent handler function\nFocusEvent handler function\nEvent handler function\nInputEvent handler function\nKeyboardEvent handler function\nMouseEvent handler function\nPointerEvent handler function\nTouchEvent handler function\nTransitionEvent handler function\nUIEvent handler function\nWheelEvent handler function\nUsage\nApplying CSS styles\nManipulating a DOM node with a ref\nDangerously setting the inner HTML\nHandling mouse events\nHandling pointer events\nHandling focus events\nHandling keyboard events\nReference \nCommon components (e.g. <div>) \n<div className=\"wrapper\">Some content</div>\n\nSee more examples below.\n\nProps \n\nThese special React props are supported for all built-in components:\n\nchildren: A React node (an element, a string, a number, a portal, an empty node like null, undefined and booleans, or an array of other React nodes). Specifies the content inside the component. When you use JSX, you will usually specify the children prop implicitly by nesting tags like <div><span /></div>.\n\ndangerouslySetInnerHTML: An object of the form { __html: '<p>some html</p>' } with a raw HTML string inside. Overrides the innerHTML property of the DOM node and displays the passed HTML inside. This should be used with extreme caution! If the HTML inside isn‚Äôt trusted (for example, if it‚Äôs based on user data), you risk introducing an XSS vulnerability. Read more about using dangerouslySetInnerHTML.\n\nref: A ref object from useRef or createRef, or a ref callback function, or a string for legacy refs. Your ref will be filled with the DOM element for this node. Read more about manipulating the DOM with refs.\n\nsuppressContentEditableWarning: A boolean. If true, suppresses the warning that React shows for elements that both have children and contentEditable={true} (which normally do not work together). Use this if you‚Äôre building a text input library that manages the contentEditable content manually.\n\nsuppressHydrationWarning: A boolean. If you use server rendering, normally there is a warning when the server and the client render different content. In some rare cases (like timestamps), it is very hard or impossible to guarantee an exact match. If you set suppressHydrationWarning to true, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don‚Äôt overuse it. Read about suppressing hydration errors.\n\nstyle: An object with CSS styles, for example { fontWeight: 'bold', margin: 20 }. Similarly to the DOM style property, the CSS property names need to be written as camelCase, for example fontWeight instead of font-weight. You can pass strings or numbers as values. If you pass a number, like width: 100, React will automatically append px (‚Äúpixels‚Äù) to the value unless it‚Äôs a unitless property. We recommend using style only for dynamic styles where you don‚Äôt know the style values ahead of time. In other cases, applying plain CSS classes with className is more efficient. Read more about className and style.\n\nThese standard DOM props are also supported for all built-in components:\n\naccessKey: A string. Specifies a keyboard shortcut for the element. Not generally recommended.\naria-*: ARIA attributes let you specify the accessibility tree information for this element. See ARIA attributes for a complete reference. In React, all ARIA attribute names are exactly the same as in HTML.\nautoCapitalize: A string. Specifies whether and how the user input should be capitalized.\nclassName: A string. Specifies the element‚Äôs CSS class name. Read more about applying CSS styles.\ncontentEditable: A boolean. If true, the browser lets the user edit the rendered element directly. This is used to implement rich text input libraries like Lexical. React warns if you try to pass React children to an element with contentEditable={true} because React will not be able to update its content after user edits.\ndata-*: Data attributes let you attach some string data to the element, for example data-fruit=\"banana\". In React, they are not commonly used because you would usually read data from props or state instead.\ndir: Either 'ltr' or 'rtl'. Specifies the text direction of the element.\ndraggable: A boolean. Specifies whether the element is draggable. Part of HTML Drag and Drop API.\nenterKeyHint: A string. Specifies which action to present for the enter key on virtual keyboards.\nhtmlFor: A string. For <label> and <output>, lets you associate the label with some control. Same as for HTML attribute. React uses the standard DOM property names (htmlFor) instead of HTML attribute names.\nhidden: A boolean or a string. Specifies whether the element should be hidden.\nid: A string. Specifies a unique identifier for this element, which can be used to find it later or connect it with other elements. Generate it with useId to avoid clashes between multiple instances of the same component.\nis: A string. If specified, the component will behave like a custom element.\ninputMode: A string. Specifies what kind of keyboard to display (for example, text, number or telephone).\nitemProp: A string. Specifies which property the element represents for structured data crawlers.\nlang: A string. Specifies the language of the element.\nonAnimationEnd: An AnimationEvent handler function. Fires when a CSS animation completes.\nonAnimationEndCapture: A version of onAnimationEnd that fires in the capture phase.\nonAnimationIteration: An AnimationEvent handler function. Fires when an iteration of a CSS animation ends, and another one begins.\nonAnimationIterationCapture: A version of onAnimationIteration that fires in the capture phase.\nonAnimationStart: An AnimationEvent handler function. Fires when a CSS animation starts.\nonAnimationStartCapture: onAnimationStart, but fires in the capture phase.\nonAuxClick: A MouseEvent handler function. Fires when a non-primary pointer button was clicked.\nonAuxClickCapture: A version of onAuxClick that fires in the capture phase.\nonBeforeInput: An InputEvent handler function. Fires before the value of an editable element is modified. React does not yet use the native beforeinput event, and instead attempts to polyfill it using other events.\nonBeforeInputCapture: A version of onBeforeInput that fires in the capture phase.\nonBlur: A FocusEvent handler function. Fires when an element lost focus. Unlike the built-in browser blur event, in React the onBlur event bubbles.\nonBlurCapture: A version of onBlur that fires in the capture phase.\nonClick: A MouseEvent handler function. Fires when the primary button was clicked on the pointing device.\nonClickCapture: A version of onClick that fires in the capture phase.\nonCompositionStart: A CompositionEvent handler function. Fires when an input method editor starts a new composition session.\nonCompositionStartCapture: A version of onCompositionStart that fires in the capture phase.\nonCompositionEnd: A CompositionEvent handler function. Fires when an input method editor completes or cancels a composition session.\nonCompositionEndCapture: A version of onCompositionEnd that fires in the capture phase.\nonCompositionUpdate: A CompositionEvent handler function. Fires when an input method editor receives a new character.\nonCompositionUpdateCapture: A version of onCompositionUpdate that fires in the capture phase.\nonContextMenu: A MouseEvent handler function. Fires when the user tries to open a context menu.\nonContextMenuCapture: A version of onContextMenu that fires in the capture phase.\nonCopy: A ClipboardEvent handler function. Fires when the user tries to copy something into the clipboard.\nonCopyCapture: A version of onCopy that fires in the capture phase.\nonCut: A ClipboardEvent handler function. Fires when the user tries to cut something into the clipboard.\nonCutCapture: A version of onCut that fires in the capture phase.\nonDoubleClick: A MouseEvent handler function. Fires when the user clicks twice. Corresponds to the browser dblclick event.\nonDoubleClickCapture: A version of onDoubleClick that fires in the capture phase.\nonDrag: A DragEvent handler function. Fires while the user is dragging something.\nonDragCapture: A version of onDrag that fires in the capture phase.\nonDragEnd: A DragEvent handler function. Fires when the user stops dragging something.\nonDragEndCapture: A version of onDragEnd that fires in the capture phase.\nonDragEnter: A DragEvent handler function. Fires when the dragged content enters a valid drop target.\nonDragEnterCapture: A version of onDragEnter that fires in the capture phase.\nonDragOver: A DragEvent handler function. Fires on a valid drop target while the dragged content is dragged over it. You must call e.preventDefault() here to allow dropping.\nonDragOverCapture: A version of onDragOver that fires in the capture phase.\nonDragStart: A DragEvent handler function. Fires when the user starts dragging an element.\nonDragStartCapture: A version of onDragStart that fires in the capture phase.\nonDrop: A DragEvent handler function. Fires when something is dropped on a valid drop target.\nonDropCapture: A version of onDrop that fires in the capture phase.\nonFocus: A FocusEvent handler function. Fires when an element receives focus. Unlike the built-in browser focus event, in React the onFocus event bubbles.\nonFocusCapture: A version of onFocus that fires in the capture phase.\nonGotPointerCapture: A PointerEvent handler function. Fires when an element programmatically captures a pointer.\nonGotPointerCaptureCapture: A version of onGotPointerCapture that fires in the capture phase.\nonKeyDown: A KeyboardEvent handler function. Fires when a key is pressed.\nonKeyDownCapture: A version of onKeyDown that fires in the capture phase.\nonKeyPress: A KeyboardEvent handler function. Deprecated. Use onKeyDown or onBeforeInput instead.\nonKeyPressCapture: A version of onKeyPress that fires in the capture phase.\nonKeyUp: A KeyboardEvent handler function. Fires when a key is released.\nonKeyUpCapture: A version of onKeyUp that fires in the capture phase.\nonLostPointerCapture: A PointerEvent handler function. Fires when an element stops capturing a pointer.\nonLostPointerCaptureCapture: A version of onLostPointerCapture that fires in the capture phase.\nonMouseDown: A MouseEvent handler function. Fires when the pointer is pressed down.\nonMouseDownCapture: A version of onMouseDown that fires in the capture phase.\nonMouseEnter: A MouseEvent handler function. Fires when the pointer moves inside an element. Does not have a capture phase. Instead, onMouseLeave and onMouseEnter propagate from the element being left to the one being entered.\nonMouseLeave: A MouseEvent handler function. Fires when the pointer moves outside an element. Does not have a capture phase. Instead, onMouseLeave and onMouseEnter propagate from the element being left to the one being entered.\nonMouseMove: A MouseEvent handler function. Fires when the pointer changes coordinates.\nonMouseMoveCapture: A version of onMouseMove that fires in the capture phase.\nonMouseOut: A MouseEvent handler function. Fires when the pointer moves outside an element, or if it moves into a child element.\nonMouseOutCapture: A version of onMouseOut that fires in the capture phase.\nonMouseUp: A MouseEvent handler function. Fires when the pointer is released.\nonMouseUpCapture: A version of onMouseUp that fires in the capture phase.\nonPointerCancel: A PointerEvent handler function. Fires when the browser cancels a pointer interaction.\nonPointerCancelCapture: A version of onPointerCancel that fires in the capture phase.\nonPointerDown: A PointerEvent handler function. Fires when a pointer becomes active.\nonPointerDownCapture: A version of onPointerDown that fires in the capture phase.\nonPointerEnter: A PointerEvent handler function. Fires when a pointer moves inside an element. Does not have a capture phase. Instead, onPointerLeave and onPointerEnter propagate from the element being left to the one being entered.\nonPointerLeave: A PointerEvent handler function. Fires when a pointer moves outside an element. Does not have a capture phase. Instead, onPointerLeave and onPointerEnter propagate from the element being left to the one being entered.\nonPointerMove: A PointerEvent handler function. Fires when a pointer changes coordinates.\nonPointerMoveCapture: A version of onPointerMove that fires in the capture phase.\nonPointerOut: A PointerEvent handler function. Fires when a pointer moves outside an element, if the pointer interaction is cancelled, and a few other reasons.\nonPointerOutCapture: A version of onPointerOut that fires in the capture phase.\nonPointerUp: A PointerEvent handler function. Fires when a pointer is no longer active.\nonPointerUpCapture: A version of onPointerUp that fires in the capture phase.\nonPaste: A ClipboardEvent handler function. Fires when the user tries to paste something from the clipboard.\nonPasteCapture: A version of onPaste that fires in the capture phase.\nonScroll: An Event handler function. Fires when an element has been scrolled. This event does not bubble.\nonScrollCapture: A version of onScroll that fires in the capture phase.\nonSelect: An Event handler function. Fires after the selection inside an editable element like an input changes. React extends the onSelect event to work for contentEditable={true} elements as well. In addition, React extends it to fire for empty selection and on edits (which may affect the selection).\nonSelectCapture: A version of onSelect that fires in the capture phase.\nonTouchCancel: A TouchEvent handler function. Fires when the browser cancels a touch interaction.\nonTouchCancelCapture: A version of onTouchCancel that fires in the capture phase.\nonTouchEnd: A TouchEvent handler function. Fires when one or more touch points are removed.\nonTouchEndCapture: A version of onTouchEnd that fires in the capture phase.\nonTouchMove: A TouchEvent handler function. Fires one or more touch points are moved.\nonTouchMoveCapture: A version of onTouchMove that fires in the capture phase.\nonTouchStart: A TouchEvent handler function. Fires when one or more touch points are placed.\nonTouchStartCapture: A version of onTouchStart that fires in the capture phase.\nonTransitionEnd: A TransitionEvent handler function. Fires when a CSS transition completes.\nonTransitionEndCapture: A version of onTransitionEnd that fires in the capture phase.\nonWheel: A WheelEvent handler function. Fires when the user rotates a wheel button.\nonWheelCapture: A version of onWheel that fires in the capture phase.\nrole: A string. Specifies the element role explicitly for assistive technologies.\nslot: A string. Specifies the slot name when using shadow DOM. In React, an equivalent pattern is typically achieved by passing JSX as props, for example <Layout left={<Sidebar />} right={<Content />} />.\nspellCheck: A boolean or null. If explicitly set to true or false, enables or disables spellchecking.\ntabIndex: A number. Overrides the default Tab button behavior. Avoid using values other than -1 and 0.\ntitle: A string. Specifies the tooltip text for the element.\ntranslate: Either 'yes' or 'no'. Passing 'no' excludes the element content from being translated.\n\nYou can also pass custom attributes as props, for example mycustomprop=\"someValue\". This can be useful when integrating with third-party libraries. The custom attribute name must be lowercase and must not start with on. The value will be converted to a string. If you pass null or undefined, the custom attribute will be removed.\n\nThese events fire only for the <form> elements:\n\nonReset: An Event handler function. Fires when a form gets reset.\nonResetCapture: A version of onReset that fires in the capture phase.\nonSubmit: An Event handler function. Fires when a form gets submitted.\nonSubmitCapture: A version of onSubmit that fires in the capture phase.\n\nThese events fire only for the <dialog> elements. Unlike browser events, they bubble in React:\n\nonCancel: An Event handler function. Fires when the user tries to dismiss the dialog.\nonCancelCapture: A version of onCancel that fires in the capture phase.\nonClose: An Event handler function. Fires when a dialog has been closed.\nonCloseCapture: A version of onClose that fires in the capture phase.\n\nThese events fire only for the <details> elements. Unlike browser events, they bubble in React:\n\nonToggle: An Event handler function. Fires when the user toggles the details.\nonToggleCapture: A version of onToggle that fires in the capture phase.\n\nThese events fire for <img>, <iframe>, <object>, <embed>, <link>, and SVG <image> elements. Unlike browser events, they bubble in React:\n\nonLoad: An Event handler function. Fires when the resource has loaded.\nonLoadCapture: A version of onLoad that fires in the capture phase.\nonError: An Event handler function. Fires when the resource could not be loaded.\nonErrorCapture: A version of onError that fires in the capture phase.\n\nThese events fire for resources like <audio> and <video>. Unlike browser events, they bubble in React:\n\nonAbort: An Event handler function. Fires when the resource has not fully loaded, but not due to an error.\nonAbortCapture: A version of onAbort that fires in the capture phase.\nonCanPlay: An Event handler function. Fires when there‚Äôs enough data to start playing, but not enough to play to the end without buffering.\nonCanPlayCapture: A version of onCanPlay that fires in the capture phase.\nonCanPlayThrough: An Event handler function. Fires when there‚Äôs enough data that it‚Äôs likely possible to start playing without buffering until the end.\nonCanPlayThroughCapture: A version of onCanPlayThrough that fires in the capture phase.\nonDurationChange: An Event handler function. Fires when the media duration has updated.\nonDurationChangeCapture: A version of onDurationChange that fires in the capture phase.\nonEmptied: An Event handler function. Fires when the media has become empty.\nonEmptiedCapture: A version of onEmptied that fires in the capture phase.\nonEncrypted: An Event handler function. Fires when the browser encounters encrypted media.\nonEncryptedCapture: A version of onEncrypted that fires in the capture phase.\nonEnded: An Event handler function. Fires when the playback stops because there‚Äôs nothing left to play.\nonEndedCapture: A version of onEnded that fires in the capture phase.\nonError: An Event handler function. Fires when the resource could not be loaded.\nonErrorCapture: A version of onError that fires in the capture phase.\nonLoadedData: An Event handler function. Fires when the current playback frame has loaded.\nonLoadedDataCapture: A version of onLoadedData that fires in the capture phase.\nonLoadedMetadata: An Event handler function. Fires when metadata has loaded.\nonLoadedMetadataCapture: A version of onLoadedMetadata that fires in the capture phase.\nonLoadStart: An Event handler function. Fires when the browser started loading the resource.\nonLoadStartCapture: A version of onLoadStart that fires in the capture phase.\nonPause: An Event handler function. Fires when the media was paused.\nonPauseCapture: A version of onPause that fires in the capture phase.\nonPlay: An Event handler function. Fires when the media is no longer paused.\nonPlayCapture: A version of onPlay that fires in the capture phase.\nonPlaying: An Event handler function. Fires when the media starts or restarts playing.\nonPlayingCapture: A version of onPlaying that fires in the capture phase.\nonProgress: An Event handler function. Fires periodically while the resource is loading.\nonProgressCapture: A version of onProgress that fires in the capture phase.\nonRateChange: An Event handler function. Fires when playback rate changes.\nonRateChangeCapture: A version of onRateChange that fires in the capture phase.\nonResize: An Event handler function. Fires when video changes size.\nonResizeCapture: A version of onResize that fires in the capture phase.\nonSeeked: An Event handler function. Fires when a seek operation completes.\nonSeekedCapture: A version of onSeeked that fires in the capture phase.\nonSeeking: An Event handler function. Fires when a seek operation starts.\nonSeekingCapture: A version of onSeeking that fires in the capture phase.\nonStalled: An Event handler function. Fires when the browser is waiting for data but it keeps not loading.\nonStalledCapture: A version of onStalled that fires in the capture phase.\nonSuspend: An Event handler function. Fires when loading the resource was suspended.\nonSuspendCapture: A version of onSuspend that fires in the capture phase.\nonTimeUpdate: An Event handler function. Fires when the current playback time updates.\nonTimeUpdateCapture: A version of onTimeUpdate that fires in the capture phase.\nonVolumeChange: An Event handler function. Fires when the volume has changed.\nonVolumeChangeCapture: A version of onVolumeChange that fires in the capture phase.\nonWaiting: An Event handler function. Fires when the playback stopped due to temporary lack of data.\nonWaitingCapture: A version of onWaiting that fires in the capture phase.\nCaveats \nYou cannot pass both children and dangerouslySetInnerHTML at the same time.\nSome events (like onAbort and onLoad) don‚Äôt bubble in the browser, but bubble in React.\nref callback function \n\nInstead of a ref object (like the one returned by useRef), you may pass a function to the ref attribute.\n\n<div ref={(node) => {\n\n  console.log('Attached', node);\n\n\n\n  return () => {\n\n    console.log('Clean up', node)\n\n  }\n\n}}>\n\nSee an example of using the ref callback.\n\nWhen the <div> DOM node is added to the screen, React will call your ref callback with the DOM node as the argument. When that <div> DOM node is removed, React will call your the cleanup function returned from the callback.\n\nReact will also call your ref callback whenever you pass a different ref callback. In the above example, (node) => { ... } is a different function on every render. When your component re-renders, the previous function will be called with null as the argument, and the next function will be called with the DOM node.\n\nParameters \nnode: A DOM node. React will pass you the DOM node when the ref gets attached. Unless you pass the same function reference for the ref callback on every render, the callback will get temporarily cleanup and re-create during every re-render of the component.\nNote\nReact 19 added cleanup functions for ref callbacks. \n\nTo support backwards compatibility, if a cleanup function is not returned from the ref callback, node will be called with null when the ref is detached. This behavior will be removed in a future version.\n\nReturns \noptional cleanup function: When the ref is detached, React will call the cleanup function. If a function is not returned by the ref callback, React will call the callback again with null as the argument when the ref gets detached. This behavior will be removed in a future version.\nCaveats \nWhen Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic ‚Äúmirrors‚Äù your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.\nWhen you pass a different ref callback, React will call the previous callback‚Äôs cleanup function if provided. If no cleanup function is defined, the ref callback will be called with null as the argument. The next function will be called with the DOM node.\nReact event object \n\nYour event handlers will receive a React event object. It is also sometimes known as a ‚Äúsynthetic event‚Äù.\n\n<button onClick={e => {\n\n  console.log(e); // React event object\n\n}} />\n\nIt conforms to the same standard as the underlying DOM events, but fixes some browser inconsistencies.\n\nSome React events do not map directly to the browser‚Äôs native events. For example in onMouseLeave, e.nativeEvent will point to a mouseout event. The specific mapping is not part of the public API and may change in the future. If you need the underlying browser event for some reason, read it from e.nativeEvent.\n\nProperties \n\nReact event objects implement some of the standard Event properties:\n\nbubbles: A boolean. Returns whether the event bubbles through the DOM.\ncancelable: A boolean. Returns whether the event can be canceled.\ncurrentTarget: A DOM node. Returns the node to which the current handler is attached in the React tree.\ndefaultPrevented: A boolean. Returns whether preventDefault was called.\neventPhase: A number. Returns which phase the event is currently in.\nisTrusted: A boolean. Returns whether the event was initiated by user.\ntarget: A DOM node. Returns the node on which the event has occurred (which could be a distant child).\ntimeStamp: A number. Returns the time when the event occurred.\n\nAdditionally, React event objects provide these properties:\n\nnativeEvent: A DOM Event. The original browser event object.\nMethods \n\nReact event objects implement some of the standard Event methods:\n\npreventDefault(): Prevents the default browser action for the event.\nstopPropagation(): Stops the event propagation through the React tree.\n\nAdditionally, React event objects provide these methods:\n\nisDefaultPrevented(): Returns a boolean value indicating whether preventDefault was called.\nisPropagationStopped(): Returns a boolean value indicating whether stopPropagation was called.\npersist(): Not used with React DOM. With React Native, call this to read event‚Äôs properties after the event.\nisPersistent(): Not used with React DOM. With React Native, returns whether persist has been called.\nCaveats \nThe values of currentTarget, eventPhase, target, and type reflect the values your React code expects. Under the hood, React attaches event handlers at the root, but this is not reflected in React event objects. For example, e.currentTarget may not be the same as the underlying e.nativeEvent.currentTarget. For polyfilled events, e.type (React event type) may differ from e.nativeEvent.type (underlying type).\nAnimationEvent handler function \n\nAn event handler type for the CSS animation events.\n\n<div\n\n  onAnimationStart={e => console.log('onAnimationStart')}\n\n  onAnimationIteration={e => console.log('onAnimationIteration')}\n\n  onAnimationEnd={e => console.log('onAnimationEnd')}\n\n/>\nParameters \ne: A React event object with these extra AnimationEvent properties:\nanimationName\nelapsedTime\npseudoElement\nClipboardEvent handler function \n\nAn event handler type for the Clipboard API events.\n\n<input\n\n  onCopy={e => console.log('onCopy')}\n\n  onCut={e => console.log('onCut')}\n\n  onPaste={e => console.log('onPaste')}\n\n/>\nParameters \n\ne: A React event object with these extra ClipboardEvent properties:\n\nclipboardData\nCompositionEvent handler function \n\nAn event handler type for the input method editor (IME) events.\n\n<input\n\n  onCompositionStart={e => console.log('onCompositionStart')}\n\n  onCompositionUpdate={e => console.log('onCompositionUpdate')}\n\n  onCompositionEnd={e => console.log('onCompositionEnd')}\n\n/>\nParameters \ne: A React event object with these extra CompositionEvent properties:\ndata\nDragEvent handler function \n\nAn event handler type for the HTML Drag and Drop API events.\n\n<>\n\n  <div\n\n    draggable={true}\n\n    onDragStart={e => console.log('onDragStart')}\n\n    onDragEnd={e => console.log('onDragEnd')}\n\n  >\n\n    Drag source\n\n  </div>\n\n\n\n  <div\n\n    onDragEnter={e => console.log('onDragEnter')}\n\n    onDragLeave={e => console.log('onDragLeave')}\n\n    onDragOver={e => { e.preventDefault(); console.log('onDragOver'); }}\n\n    onDrop={e => console.log('onDrop')}\n\n  >\n\n    Drop target\n\n  </div>\n\n</>\nParameters \n\ne: A React event object with these extra DragEvent properties:\n\ndataTransfer\n\nIt also includes the inherited MouseEvent properties:\n\naltKey\nbutton\nbuttons\nctrlKey\nclientX\nclientY\ngetModifierState(key)\nmetaKey\nmovementX\nmovementY\npageX\npageY\nrelatedTarget\nscreenX\nscreenY\nshiftKey\n\nIt also includes the inherited UIEvent properties:\n\ndetail\nview\nFocusEvent handler function \n\nAn event handler type for the focus events.\n\n<input\n\n  onFocus={e => console.log('onFocus')}\n\n  onBlur={e => console.log('onBlur')}\n\n/>\n\nSee an example.\n\nParameters \n\ne: A React event object with these extra FocusEvent properties:\n\nrelatedTarget\n\nIt also includes the inherited UIEvent properties:\n\ndetail\nview\nEvent handler function \n\nAn event handler type for generic events.\n\nParameters \ne: A React event object with no additional properties.\nInputEvent handler function \n\nAn event handler type for the onBeforeInput event.\n\n<input onBeforeInput={e => console.log('onBeforeInput')} />\nParameters \ne: A React event object with these extra InputEvent properties:\ndata\nKeyboardEvent handler function \n\nAn event handler type for keyboard events.\n\n<input\n\n  onKeyDown={e => console.log('onKeyDown')}\n\n  onKeyUp={e => console.log('onKeyUp')}\n\n/>\n\nSee an example.\n\nParameters \n\ne: A React event object with these extra KeyboardEvent properties:\n\naltKey\ncharCode\ncode\nctrlKey\ngetModifierState(key)\nkey\nkeyCode\nlocale\nmetaKey\nlocation\nrepeat\nshiftKey\nwhich\n\nIt also includes the inherited UIEvent properties:\n\ndetail\nview\nMouseEvent handler function \n\nAn event handler type for mouse events.\n\n<div\n\n  onClick={e => console.log('onClick')}\n\n  onMouseEnter={e => console.log('onMouseEnter')}\n\n  onMouseOver={e => console.log('onMouseOver')}\n\n  onMouseDown={e => console.log('onMouseDown')}\n\n  onMouseUp={e => console.log('onMouseUp')}\n\n  onMouseLeave={e => console.log('onMouseLeave')}\n\n/>\n\nSee an example.\n\nParameters \n\ne: A React event object with these extra MouseEvent properties:\n\naltKey\nbutton\nbuttons\nctrlKey\nclientX\nclientY\ngetModifierState(key)\nmetaKey\nmovementX\nmovementY\npageX\npageY\nrelatedTarget\nscreenX\nscreenY\nshiftKey\n\nIt also includes the inherited UIEvent properties:\n\ndetail\nview\nPointerEvent handler function \n\nAn event handler type for pointer events.\n\n<div\n\n  onPointerEnter={e => console.log('onPointerEnter')}\n\n  onPointerMove={e => console.log('onPointerMove')}\n\n  onPointerDown={e => console.log('onPointerDown')}\n\n  onPointerUp={e => console.log('onPointerUp')}\n\n  onPointerLeave={e => console.log('onPointerLeave')}\n\n/>\n\nSee an example.\n\nParameters \n\ne: A React event object with these extra PointerEvent properties:\n\nheight\nisPrimary\npointerId\npointerType\npressure\ntangentialPressure\ntiltX\ntiltY\ntwist\nwidth\n\nIt also includes the inherited MouseEvent properties:\n\naltKey\nbutton\nbuttons\nctrlKey\nclientX\nclientY\ngetModifierState(key)\nmetaKey\nmovementX\nmovementY\npageX\npageY\nrelatedTarget\nscreenX\nscreenY\nshiftKey\n\nIt also includes the inherited UIEvent properties:\n\ndetail\nview\nTouchEvent handler function \n\nAn event handler type for touch events.\n\n<div\n\n  onTouchStart={e => console.log('onTouchStart')}\n\n  onTouchMove={e => console.log('onTouchMove')}\n\n  onTouchEnd={e => console.log('onTouchEnd')}\n\n  onTouchCancel={e => console.log('onTouchCancel')}\n\n/>\nParameters \n\ne: A React event object with these extra TouchEvent properties:\n\naltKey\nctrlKey\nchangedTouches\ngetModifierState(key)\nmetaKey\nshiftKey\ntouches\ntargetTouches\n\nIt also includes the inherited UIEvent properties:\n\ndetail\nview\nTransitionEvent handler function \n\nAn event handler type for the CSS transition events.\n\n<div\n\n  onTransitionEnd={e => console.log('onTransitionEnd')}\n\n/>\nParameters \ne: A React event object with these extra TransitionEvent properties:\nelapsedTime\npropertyName\npseudoElement\nUIEvent handler function \n\nAn event handler type for generic UI events.\n\n<div\n\n  onScroll={e => console.log('onScroll')}\n\n/>\nParameters \ne: A React event object with these extra UIEvent properties:\ndetail\nview\nWheelEvent handler function \n\nAn event handler type for the onWheel event.\n\n<div\n\n  onWheel={e => console.log('onWheel')}\n\n/>\nParameters \n\ne: A React event object with these extra WheelEvent properties:\n\ndeltaMode\ndeltaX\ndeltaY\ndeltaZ\n\nIt also includes the inherited MouseEvent properties:\n\naltKey\nbutton\nbuttons\nctrlKey\nclientX\nclientY\ngetModifierState(key)\nmetaKey\nmovementX\nmovementY\npageX\npageY\nrelatedTarget\nscreenX\nscreenY\nshiftKey\n\nIt also includes the inherited UIEvent properties:\n\ndetail\nview\nUsage \nApplying CSS styles \n\nIn React, you specify a CSS class with className. It works like the class attribute in HTML:\n\n<img className=\"avatar\" />\n\nThen you write the CSS rules for it in a separate CSS file:\n\n/* In your CSS */\n\n.avatar {\n\n  border-radius: 50%;\n\n}\n\nReact does not prescribe how you add CSS files. In the simplest case, you‚Äôll add a <link> tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project.\n\nSometimes, the style values depend on data. Use the style attribute to pass some styles dynamically:\n\n<img\n\n  className=\"avatar\"\n\n  style={{\n\n    width: user.imageSize,\n\n    height: user.imageSize\n\n  }}\n\n/>\n\nIn the above example, style={{}} is not a special syntax, but a regular {} object inside the style={ } JSX curly braces. We recommend only using the style attribute when your styles depend on JavaScript variables.\n\nApp.js\nAvatar.js\nReload\nClear\nFork\nexport default function Avatar({ user }) {\n  return (\n    <img\n      src={user.imageUrl}\n      alt={'Photo of ' + user.name}\n      className=\"avatar\"\n      style={{\n        width: user.imageSize,\n        height: user.imageSize\n      }}\n    />\n  );\n}\n\n\nDEEP DIVE\nHow to apply multiple CSS classes conditionally? \nShow Details\nManipulating a DOM node with a ref \n\nSometimes, you‚Äôll need to get the browser DOM node associated with a tag in JSX. For example, if you want to focus an <input> when a button is clicked, you need to call focus() on the browser <input> DOM node.\n\nTo obtain the browser DOM node for a tag, declare a ref and pass it as the ref attribute to that tag:\n\nimport { useRef } from 'react';\n\n\n\nexport default function Form() {\n\n  const inputRef = useRef(null);\n\n  // ...\n\n  return (\n\n    <input ref={inputRef} />\n\n    // ...\n\nReact will put the DOM node into inputRef.current after it‚Äôs been rendered to the screen.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useRef } from 'react';\n\nexport default function Form() {\n  const inputRef = useRef(null);\n\n  function handleClick() {\n    inputRef.current.focus();\n  }\n\n  return (\n    <>\n      <input ref={inputRef} />\n      <button onClick={handleClick}>\n        Focus the input\n      </button>\n    </>\n  );\n}\n\n\nShow more\n\nRead more about manipulating DOM with refs and check out more examples.\n\nFor more advanced use cases, the ref attribute also accepts a callback function.\n\nDangerously setting the inner HTML \n\nYou can pass a raw HTML string to an element like so:\n\nconst markup = { __html: '<p>some raw html</p>' };\n\nreturn <div dangerouslySetInnerHTML={markup} />;\n\nThis is dangerous. As with the underlying DOM innerHTML property, you must exercise extreme caution! Unless the markup is coming from a completely trusted source, it is trivial to introduce an XSS vulnerability this way.\n\nFor example, if you use a Markdown library that converts Markdown to HTML, you trust that its parser doesn‚Äôt contain bugs, and the user only sees their own input, you can display the resulting HTML like this:\n\npackage.json\nApp.js\nMarkdownPreview.js\nReload\nClear\nFork\nimport { Remarkable } from 'remarkable';\n\nconst md = new Remarkable();\n\nfunction renderMarkdownToHTML(markdown) {\n  // This is ONLY safe because the output HTML\n  // is shown to the same user, and because you\n  // trust this Markdown parser to not have bugs.\n  const renderedHTML = md.render(markdown);\n  return {__html: renderedHTML};\n}\n\nexport default function MarkdownPreview({ markdown }) {\n  const markup = renderMarkdownToHTML(markdown);\n  return <div dangerouslySetInnerHTML={markup} />;\n}\n\n\nShow more\n\nThe {__html} object should be created as close to where the HTML is generated as possible, like the above example does in the renderMarkdownToHTML function. This ensures that all raw HTML being used in your code is explicitly marked as such, and that only variables that you expect to contain HTML are passed to dangerouslySetInnerHTML. It is not recommended to create the object inline like <div dangerouslySetInnerHTML={{__html: markup}} />.\n\nTo see why rendering arbitrary HTML is dangerous, replace the code above with this:\n\nconst post = {\n\n  // Imagine this content is stored in the database.\n\n  content: `<img src=\"\" onerror='alert(\"you were hacked\")'>`\n\n};\n\n\n\nexport default function MarkdownPreview() {\n\n  // üî¥ SECURITY HOLE: passing untrusted input to dangerouslySetInnerHTML\n\n  const markup = { __html: post.content };\n\n  return <div dangerouslySetInnerHTML={markup} />;\n\n}\n\nThe code embedded in the HTML will run. A hacker could use this security hole to steal user information or to perform actions on their behalf. Only use dangerouslySetInnerHTML with trusted and sanitized data.\n\nHandling mouse events \n\nThis example shows some common mouse events and when they fire.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function MouseExample() {\n  return (\n    <div\n      onMouseEnter={e => console.log('onMouseEnter (parent)')}\n      onMouseLeave={e => console.log('onMouseLeave (parent)')}\n    >\n      <button\n        onClick={e => console.log('onClick (first button)')}\n        onMouseDown={e => console.log('onMouseDown (first button)')}\n        onMouseEnter={e => console.log('onMouseEnter (first button)')}\n        onMouseLeave={e => console.log('onMouseLeave (first button)')}\n        onMouseOver={e => console.log('onMouseOver (first button)')}\n        onMouseUp={e => console.log('onMouseUp (first button)')}\n      >\n        First button\n      </button>\n      <button\n        onClick={e => console.log('onClick (second button)')}\n        onMouseDown={e => console.log('onMouseDown (second button)')}\n        onMouseEnter={e => console.log('onMouseEnter (second button)')}\n        onMouseLeave={e => console.log('onMouseLeave (second button)')}\n        onMouseOver={e => console.log('onMouseOver (second button)')}\n        onMouseUp={e => console.log('onMouseUp (second button)')}\n      >\n        Second button\n      </button>\n    </div>\n  );\n}\n\n\nShow more\nHandling pointer events \n\nThis example shows some common pointer events and when they fire.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function PointerExample() {\n  return (\n    <div\n      onPointerEnter={e => console.log('onPointerEnter (parent)')}\n      onPointerLeave={e => console.log('onPointerLeave (parent)')}\n      style={{ padding: 20, backgroundColor: '#ddd' }}\n    >\n      <div\n        onPointerDown={e => console.log('onPointerDown (first child)')}\n        onPointerEnter={e => console.log('onPointerEnter (first child)')}\n        onPointerLeave={e => console.log('onPointerLeave (first child)')}\n        onPointerMove={e => console.log('onPointerMove (first child)')}\n        onPointerUp={e => console.log('onPointerUp (first child)')}\n        style={{ padding: 20, backgroundColor: 'lightyellow' }}\n      >\n        First child\n      </div>\n      <div\n        onPointerDown={e => console.log('onPointerDown (second child)')}\n        onPointerEnter={e => console.log('onPointerEnter (second child)')}\n        onPointerLeave={e => console.log('onPointerLeave (second child)')}\n        onPointerMove={e => console.log('onPointerMove (second child)')}\n        onPointerUp={e => console.log('onPointerUp (second child)')}\n        style={{ padding: 20, backgroundColor: 'lightblue' }}\n      >\n        Second child\n      </div>\n    </div>\n  );\n}\n\n\nShow more\nHandling focus events \n\nIn React, focus events bubble. You can use the currentTarget and relatedTarget to differentiate if the focusing or blurring events originated from outside of the parent element. The example shows how to detect focusing a child, focusing the parent element, and how to detect focus entering or leaving the whole subtree.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function FocusExample() {\n  return (\n    <div\n      tabIndex={1}\n      onFocus={(e) => {\n        if (e.currentTarget === e.target) {\n          console.log('focused parent');\n        } else {\n          console.log('focused child', e.target.name);\n        }\n        if (!e.currentTarget.contains(e.relatedTarget)) {\n          // Not triggered when swapping focus between children\n          console.log('focus entered parent');\n        }\n      }}\n      onBlur={(e) => {\n        if (e.currentTarget === e.target) {\n          console.log('unfocused parent');\n        } else {\n          console.log('unfocused child', e.target.name);\n        }\n        if (!e.currentTarget.contains(e.relatedTarget)) {\n          // Not triggered when swapping focus between children\n          console.log('focus left parent');\n        }\n      }}\n    >\n      <label>\n        First name:\n        <input name=\"firstName\" />\n      </label>\n      <label>\n        Last name:\n        <input name=\"lastName\" />\n      </label>\n    </div>\n  );\n}\n\n\nShow more\nHandling keyboard events \n\nThis example shows some common keyboard events and when they fire.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function KeyboardExample() {\n  return (\n    <label>\n      First name:\n      <input\n        name=\"firstName\"\n        onKeyDown={e => console.log('onKeyDown:', e.key, e.code)}\n        onKeyUp={e => console.log('onKeyUp:', e.key, e.code)}\n      />\n    </label>\n  );\n}\n\n\nPREVIOUS\nComponents\nNEXT\n<form>"
  },
  {
    "title": "<form> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/form",
    "html": "API REFERENCE\nCOMPONENTS\n<form>\n\nThe built-in browser <form> component lets you create interactive controls for submitting information.\n\n<form action={search}>\n\n    <input name=\"query\" />\n\n    <button type=\"submit\">Search</button>\n\n</form>\nReference\n<form>\nUsage\nHandle form submission on the client\nHandle form submission with a Server Function\nDisplay a pending state during form submission\nOptimistically updating form data\nHandling form submission errors\nDisplay a form submission error without JavaScript\nHandling multiple submission types\nReference \n<form> \n\nTo create interactive controls for submitting information, render the built-in browser <form> component.\n\n<form action={search}>\n\n    <input name=\"query\" />\n\n    <button type=\"submit\">Search</button>\n\n</form>\n\nSee more examples below.\n\nProps \n\n<form> supports all common element props.\n\naction: a URL or function. When a URL is passed to action the form will behave like the HTML form component. When a function is passed to action the function will handle the form submission in a Transition following the Action prop pattern. The function passed to action may be async and will be called with a single argument containing the form data of the submitted form. The action prop can be overridden by a formAction attribute on a <button>, <input type=\"submit\">, or <input type=\"image\"> component.\n\nCaveats \nWhen a function is passed to action or formAction the HTTP method will be POST regardless of value of the method prop.\nUsage \nHandle form submission on the client \n\nPass a function to the action prop of form to run the function when the form is submitted. formData will be passed to the function as an argument so you can access the data submitted by the form. This differs from the conventional HTML action, which only accepts URLs. After the action function succeeds, all uncontrolled field elements in the form are reset.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function Search() {\n  function search(formData) {\n    const query = formData.get(\"query\");\n    alert(`You searched for '${query}'`);\n  }\n  return (\n    <form action={search}>\n      <input name=\"query\" />\n      <button type=\"submit\">Search</button>\n    </form>\n  );\n}\n\n\nHandle form submission with a Server Function \n\nRender a <form> with an input and submit button. Pass a Server Function (a function marked with 'use server') to the action prop of form to run the function when the form is submitted.\n\nPassing a Server Function to <form action> allow users to submit forms without JavaScript enabled or before the code has loaded. This is beneficial to users who have a slow connection, device, or have JavaScript disabled and is similar to the way forms work when a URL is passed to the action prop.\n\nYou can use hidden form fields to provide data to the <form>‚Äôs action. The Server Function will be called with the hidden form field data as an instance of FormData.\n\nimport { updateCart } from './lib.js';\n\n\n\nfunction AddToCart({productId}) {\n\n  async function addToCart(formData) {\n\n    'use server'\n\n    const productId = formData.get('productId')\n\n    await updateCart(productId)\n\n  }\n\n  return (\n\n    <form action={addToCart}>\n\n        <input type=\"hidden\" name=\"productId\" value={productId} />\n\n        <button type=\"submit\">Add to Cart</button>\n\n    </form>\n\n\n\n  );\n\n}\n\nIn lieu of using hidden form fields to provide data to the <form>‚Äôs action, you can call the bind method to supply it with extra arguments. This will bind a new argument (productId) to the function in addition to the formData that is passed as an argument to the function.\n\nimport { updateCart } from './lib.js';\n\n\n\nfunction AddToCart({productId}) {\n\n  async function addToCart(productId, formData) {\n\n    \"use server\";\n\n    await updateCart(productId)\n\n  }\n\n  const addProductToCart = addToCart.bind(null, productId);\n\n  return (\n\n    <form action={addProductToCart}>\n\n      <button type=\"submit\">Add to Cart</button>\n\n    </form>\n\n  );\n\n}\n\nWhen <form> is rendered by a Server Component, and a Server Function is passed to the <form>‚Äôs action prop, the form is progressively enhanced.\n\nDisplay a pending state during form submission \n\nTo display a pending state when a form is being submitted, you can call the useFormStatus Hook in a component rendered in a <form> and read the pending property returned.\n\nHere, we use the pending property to indicate the form is submitting.\n\nApp.js\nReload\nClear\nFork\nimport { useFormStatus } from \"react-dom\";\nimport { submitForm } from \"./actions.js\";\n\nfunction Submit() {\n  const { pending } = useFormStatus();\n  return (\n    <button type=\"submit\" disabled={pending}>\n      {pending ? \"Submitting...\" : \"Submit\"}\n    </button>\n  );\n}\n\nfunction Form({ action }) {\n  return (\n    <form action={action}>\n      <Submit />\n    </form>\n  );\n}\n\nexport default function App() {\n  return <Form action={submitForm} />;\n}\n\n\nShow more\n\nTo learn more about the useFormStatus Hook see the reference documentation.\n\nOptimistically updating form data \n\nThe useOptimistic Hook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a user submits a form, instead of waiting for the server‚Äôs response to reflect the changes, the interface is immediately updated with the expected outcome.\n\nFor example, when a user types a message into the form and hits the ‚ÄúSend‚Äù button, the useOptimistic Hook allows the message to immediately appear in the list with a ‚ÄúSending‚Ä¶‚Äù label, even before the message is actually sent to a server. This ‚Äúoptimistic‚Äù approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the ‚ÄúSending‚Ä¶‚Äù label is removed.\n\nApp.js\nactions.js\nReload\nClear\nFork\nimport { useOptimistic, useState, useRef } from \"react\";\nimport { deliverMessage } from \"./actions.js\";\n\nfunction Thread({ messages, sendMessage }) {\n  const formRef = useRef();\n  async function formAction(formData) {\n    addOptimisticMessage(formData.get(\"message\"));\n    formRef.current.reset();\n    await sendMessage(formData);\n  }\n  const [optimisticMessages, addOptimisticMessage] = useOptimistic(\n    messages,\n    (state, newMessage) => [\n      ...state,\n      {\n        text: newMessage,\n        sending: true\n      }\n    ]\n  );\n\n  return (\n    <>\n      {optimisticMessages.map((message, index) => (\n        <div key={index}>\n          {message.text}\n          {!!message.sending && <small> (Sending...)</small>}\n        </div>\n      ))}\n      <form action={formAction} ref={formRef}>\n        <input type=\"text\" name=\"message\" placeholder=\"Hello!\" />\n        <button type=\"submit\">Send</button>\n      </form>\n    </>\n  );\n}\n\nexport default function App() {\n  const [messages, setMessages] = useState([\n    { text: \"Hello there!\", sending: false, key: 1 }\n  ]);\n  async function sendMessage(formData) {\n    const sentMessage = await deliverMessage(formData.get(\"message\"));\n    setMessages((messages) => [...messages, { text: sentMessage }]);\n  }\n  return <Thread messages={messages} sendMessage={sendMessage} />;\n}\n\n\nShow more\nHandling form submission errors \n\nIn some cases the function called by a <form>‚Äôs action prop throws an error. You can handle these errors by wrapping <form> in an Error Boundary. If the function called by a <form>‚Äôs action prop throws an error, the fallback for the error boundary will be displayed.\n\nApp.js\nReload\nClear\nFork\nimport { ErrorBoundary } from \"react-error-boundary\";\n\nexport default function Search() {\n  function search() {\n    throw new Error(\"search error\");\n  }\n  return (\n    <ErrorBoundary\n      fallback={<p>There was an error while submitting the form</p>}\n    >\n      <form action={search}>\n        <input name=\"query\" />\n        <button type=\"submit\">Search</button>\n      </form>\n    </ErrorBoundary>\n  );\n}\n\n\nShow more\nDisplay a form submission error without JavaScript \n\nDisplaying a form submission error message before the JavaScript bundle loads for progressive enhancement requires that:\n\n<form> be rendered by a Client Component\nthe function passed to the <form>‚Äôs action prop be a Server Function\nthe useActionState Hook be used to display the error message\n\nuseActionState takes two parameters: a Server Function and an initial state. useActionState returns two values, a state variable and an action. The action returned by useActionState should be passed to the action prop of the form. The state variable returned by useActionState can be used to display an error message. The value returned by the Server Function passed to useActionState will be used to update the state variable.\n\nApp.js\nReload\nClear\nFork\nimport { useActionState } from \"react\";\nimport { signUpNewUser } from \"./api\";\n\nexport default function Page() {\n  async function signup(prevState, formData) {\n    \"use server\";\n    const email = formData.get(\"email\");\n    try {\n      await signUpNewUser(email);\n      alert(`Added \"${email}\"`);\n    } catch (err) {\n      return err.toString();\n    }\n  }\n  const [message, signupAction] = useActionState(signup, null);\n  return (\n    <>\n      <h1>Signup for my newsletter</h1>\n      <p>Signup with the same email twice to see an error</p>\n      <form action={signupAction} id=\"signup-form\">\n        <label htmlFor=\"email\">Email: </label>\n        <input name=\"email\" id=\"email\" placeholder=\"react@example.com\" />\n        <button>Sign up</button>\n        {!!message && <p>{message}</p>}\n      </form>\n    </>\n  );\n}\n\n\nShow more\n\nLearn more about updating state from a form action with the useActionState docs\n\nHandling multiple submission types \n\nForms can be designed to handle multiple submission actions based on the button pressed by the user. Each button inside a form can be associated with a distinct action or behavior by setting the formAction prop.\n\nWhen a user taps a specific button, the form is submitted, and a corresponding action, defined by that button‚Äôs attributes and action, is executed. For instance, a form might submit an article for review by default but have a separate button with formAction set to save the article as a draft.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function Search() {\n  function publish(formData) {\n    const content = formData.get(\"content\");\n    const button = formData.get(\"button\");\n    alert(`'${content}' was published with the '${button}' button`);\n  }\n\n  function save(formData) {\n    const content = formData.get(\"content\");\n    alert(`Your draft of '${content}' has been saved!`);\n  }\n\n  return (\n    <form action={publish}>\n      <textarea name=\"content\" rows={4} cols={40} />\n      <br />\n      <button type=\"submit\" name=\"button\" value=\"submit\">Publish</button>\n      <button formAction={save}>Save draft</button>\n    </form>\n  );\n}\n\n\nShow more\nPREVIOUS\nCommon (e.g. <div>)\nNEXT\n<input>"
  },
  {
    "title": "<input> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/input",
    "html": "API REFERENCE\nCOMPONENTS\n<input>\n\nThe built-in browser <input> component lets you render different kinds of form inputs.\n\n<input />\nReference\n<input>\nUsage\nDisplaying inputs of different types\nProviding a label for an input\nProviding an initial value for an input\nReading the input values when submitting a form\nControlling an input with a state variable\nOptimizing re-rendering on every keystroke\nTroubleshooting\nMy text input doesn‚Äôt update when I type into it\nMy checkbox doesn‚Äôt update when I click on it\nMy input caret jumps to the beginning on every keystroke\nI‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù\nReference \n<input> \n\nTo display an input, render the built-in browser <input> component.\n\n<input name=\"myInput\" />\n\nSee more examples below.\n\nProps \n\n<input> supports all common element props.\n\nformAction: A string or function. Overrides the parent <form action> for type=\"submit\" and type=\"image\". When a URL is passed to action the form will behave like a standard HTML form. When a function is passed to formAction the function will handle the form submission. See <form action>.\n\nYou can make an input controlled by passing one of these props:\n\nchecked: A boolean. For a checkbox input or a radio button, controls whether it is selected.\nvalue: A string. For a text input, controls its text. (For a radio button, specifies its form data.)\n\nWhen you pass either of them, you must also pass an onChange handler that updates the passed value.\n\nThese <input> props are only relevant for uncontrolled inputs:\n\ndefaultChecked: A boolean. Specifies the initial value for type=\"checkbox\" and type=\"radio\" inputs.\ndefaultValue: A string. Specifies the initial value for a text input.\n\nThese <input> props are relevant both for uncontrolled and controlled inputs:\n\naccept: A string. Specifies which filetypes are accepted by a type=\"file\" input.\nalt: A string. Specifies the alternative image text for a type=\"image\" input.\ncapture: A string. Specifies the media (microphone, video, or camera) captured by a type=\"file\" input.\nautoComplete: A string. Specifies one of the possible autocomplete behaviors.\nautoFocus: A boolean. If true, React will focus the element on mount.\ndirname: A string. Specifies the form field name for the element‚Äôs directionality.\ndisabled: A boolean. If true, the input will not be interactive and will appear dimmed.\nchildren: <input> does not accept children.\nform: A string. Specifies the id of the <form> this input belongs to. If omitted, it‚Äôs the closest parent form.\nformAction: A string. Overrides the parent <form action> for type=\"submit\" and type=\"image\".\nformEnctype: A string. Overrides the parent <form enctype> for type=\"submit\" and type=\"image\".\nformMethod: A string. Overrides the parent <form method> for type=\"submit\" and type=\"image\".\nformNoValidate: A string. Overrides the parent <form noValidate> for type=\"submit\" and type=\"image\".\nformTarget: A string. Overrides the parent <form target> for type=\"submit\" and type=\"image\".\nheight: A string. Specifies the image height for type=\"image\".\nlist: A string. Specifies the id of the <datalist> with the autocomplete options.\nmax: A number. Specifies the maximum value of numerical and datetime inputs.\nmaxLength: A number. Specifies the maximum length of text and other inputs.\nmin: A number. Specifies the minimum value of numerical and datetime inputs.\nminLength: A number. Specifies the minimum length of text and other inputs.\nmultiple: A boolean. Specifies whether multiple values are allowed for <type=\"file\" and type=\"email\".\nname: A string. Specifies the name for this input that‚Äôs submitted with the form.\nonChange: An Event handler function. Required for controlled inputs. Fires immediately when the input‚Äôs value is changed by the user (for example, it fires on every keystroke). Behaves like the browser input event.\nonChangeCapture: A version of onChange that fires in the capture phase.\nonInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly.\nonInputCapture: A version of onInput that fires in the capture phase.\nonInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles.\nonInvalidCapture: A version of onInvalid that fires in the capture phase.\nonSelect: An Event handler function. Fires after the selection inside the <input> changes. React extends the onSelect event to also fire for empty selection and on edits (which may affect the selection).\nonSelectCapture: A version of onSelect that fires in the capture phase.\npattern: A string. Specifies the pattern that the value must match.\nplaceholder: A string. Displayed in a dimmed color when the input value is empty.\nreadOnly: A boolean. If true, the input is not editable by the user.\nrequired: A boolean. If true, the value must be provided for the form to submit.\nsize: A number. Similar to setting width, but the unit depends on the control.\nsrc: A string. Specifies the image source for a type=\"image\" input.\nstep: A positive number or an 'any' string. Specifies the distance between valid values.\ntype: A string. One of the input types.\nwidth: A string. Specifies the image width for a type=\"image\" input.\nCaveats \nCheckboxes need checked (or defaultChecked), not value (or defaultValue).\nIf a text input receives a string value prop, it will be treated as controlled.\nIf a checkbox or a radio button receives a boolean checked prop, it will be treated as controlled.\nAn input can‚Äôt be both controlled and uncontrolled at the same time.\nAn input cannot switch between being controlled or uncontrolled over its lifetime.\nEvery controlled input needs an onChange event handler that synchronously updates its backing value.\nUsage \nDisplaying inputs of different types \n\nTo display an input, render an <input> component. By default, it will be a text input. You can pass type=\"checkbox\" for a checkbox, type=\"radio\" for a radio button, or one of the other input types.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function MyForm() {\n  return (\n    <>\n      <label>\n        Text input: <input name=\"myInput\" />\n      </label>\n      <hr />\n      <label>\n        Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" />\n      </label>\n      <hr />\n      <p>\n        Radio buttons:\n        <label>\n          <input type=\"radio\" name=\"myRadio\" value=\"option1\" />\n          Option 1\n        </label>\n        <label>\n          <input type=\"radio\" name=\"myRadio\" value=\"option2\" />\n          Option 2\n        </label>\n        <label>\n          <input type=\"radio\" name=\"myRadio\" value=\"option3\" />\n          Option 3\n        </label>\n      </p>\n    </>\n  );\n}\n\n\nShow more\nProviding a label for an input \n\nTypically, you will place every <input> inside a <label> tag. This tells the browser that this label is associated with that input. When the user clicks the label, the browser will automatically focus the input. It‚Äôs also essential for accessibility: a screen reader will announce the label caption when the user focuses the associated input.\n\nIf you can‚Äôt nest <input> into a <label>, associate them by passing the same ID to <input id> and <label htmlFor>. To avoid conflicts between multiple instances of one component, generate such an ID with useId.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useId } from 'react';\n\nexport default function Form() {\n  const ageInputId = useId();\n  return (\n    <>\n      <label>\n        Your first name:\n        <input name=\"firstName\" />\n      </label>\n      <hr />\n      <label htmlFor={ageInputId}>Your age:</label>\n      <input id={ageInputId} name=\"age\" type=\"number\" />\n    </>\n  );\n}\n\n\nShow more\nProviding an initial value for an input \n\nYou can optionally specify the initial value for any input. Pass it as the defaultValue string for text inputs. Checkboxes and radio buttons should specify the initial value with the defaultChecked boolean instead.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function MyForm() {\n  return (\n    <>\n      <label>\n        Text input: <input name=\"myInput\" defaultValue=\"Some initial value\" />\n      </label>\n      <hr />\n      <label>\n        Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" defaultChecked={true} />\n      </label>\n      <hr />\n      <p>\n        Radio buttons:\n        <label>\n          <input type=\"radio\" name=\"myRadio\" value=\"option1\" />\n          Option 1\n        </label>\n        <label>\n          <input\n            type=\"radio\"\n            name=\"myRadio\"\n            value=\"option2\"\n            defaultChecked={true} \n          />\n          Option 2\n        </label>\n        <label>\n          <input type=\"radio\" name=\"myRadio\" value=\"option3\" />\n          Option 3\n        </label>\n      </p>\n    </>\n  );\n}\n\n\nShow more\nReading the input values when submitting a form \n\nAdd a <form> around your inputs with a <button type=\"submit\"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target).\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function MyForm() {\n  function handleSubmit(e) {\n    // Prevent the browser from reloading the page\n    e.preventDefault();\n\n    // Read the form data\n    const form = e.target;\n    const formData = new FormData(form);\n\n    // You can pass formData as a fetch body directly:\n    fetch('/some-api', { method: form.method, body: formData });\n\n    // Or you can work with it as a plain object:\n    const formJson = Object.fromEntries(formData.entries());\n    console.log(formJson);\n  }\n\n  return (\n    <form method=\"post\" onSubmit={handleSubmit}>\n      <label>\n        Text input: <input name=\"myInput\" defaultValue=\"Some initial value\" />\n      </label>\n      <hr />\n      <label>\n        Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" defaultChecked={true} />\n      </label>\n      <hr />\n      <p>\n        Radio buttons:\n        <label><input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1</label>\n        <label><input type=\"radio\" name=\"myRadio\" value=\"option2\" defaultChecked={true} /> Option 2</label>\n        <label><input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3</label>\n      </p>\n      <hr />\n      <button type=\"reset\">Reset form</button>\n      <button type=\"submit\">Submit form</button>\n    </form>\n  );\n}\n\n\nShow more\nNote\n\nGive a name to every <input>, for example <input name=\"firstName\" defaultValue=\"Taylor\" />. The name you specified will be used as a key in the form data, for example { firstName: \"Taylor\" }.\n\nPitfall\n\nBy default, a <button> inside a <form> without a type attribute will submit it. This can be surprising! If you have your own custom Button React component, consider using <button type=\"button\"> instead of <button> (with no type). Then, to be explicit, use <button type=\"submit\"> for buttons that are supposed to submit the form.\n\nControlling an input with a state variable \n\nAn input like <input /> is uncontrolled. Even if you pass an initial value like <input defaultValue=\"Initial text\" />, your JSX only specifies the initial value. It does not control what the value should be right now.\n\nTo render a controlled input, pass the value prop to it (or checked for checkboxes and radios). React will force the input to always have the value you passed. Usually, you would do this by declaring a state variable:\n\nfunction Form() {\n\n  const [firstName, setFirstName] = useState(''); // Declare a state variable...\n\n  // ...\n\n  return (\n\n    <input\n\n      value={firstName} // ...force the input's value to match the state variable...\n\n      onChange={e => setFirstName(e.target.value)} // ... and update the state variable on any edits!\n\n    />\n\n  );\n\n}\n\nA controlled input makes sense if you needed state anyway‚Äîfor example, to re-render your UI on every edit:\n\nfunction Form() {\n\n  const [firstName, setFirstName] = useState('');\n\n  return (\n\n    <>\n\n      <label>\n\n        First name:\n\n        <input value={firstName} onChange={e => setFirstName(e.target.value)} />\n\n      </label>\n\n      {firstName !== '' && <p>Your name is {firstName}.</p>}\n\n      ...\n\nIt‚Äôs also useful if you want to offer multiple ways to adjust the input state (for example, by clicking a button):\n\nfunction Form() {\n\n  // ...\n\n  const [age, setAge] = useState('');\n\n  const ageAsNumber = Number(age);\n\n  return (\n\n    <>\n\n      <label>\n\n        Age:\n\n        <input\n\n          value={age}\n\n          onChange={e => setAge(e.target.value)}\n\n          type=\"number\"\n\n        />\n\n        <button onClick={() => setAge(ageAsNumber + 10)}>\n\n          Add 10 years\n\n        </button>\n\nThe value you pass to controlled components should not be undefined or null. If you need the initial value to be empty (such as with the firstName field below), initialize your state variable to an empty string ('').\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Form() {\n  const [firstName, setFirstName] = useState('');\n  const [age, setAge] = useState('20');\n  const ageAsNumber = Number(age);\n  return (\n    <>\n      <label>\n        First name:\n        <input\n          value={firstName}\n          onChange={e => setFirstName(e.target.value)}\n        />\n      </label>\n      <label>\n        Age:\n        <input\n          value={age}\n          onChange={e => setAge(e.target.value)}\n          type=\"number\"\n        />\n        <button onClick={() => setAge(ageAsNumber + 10)}>\n          Add 10 years\n        </button>\n      </label>\n      {firstName !== '' &&\n        <p>Your name is {firstName}.</p>\n      }\n      {ageAsNumber > 0 &&\n        <p>Your age is {ageAsNumber}.</p>\n      }\n    </>\n  );\n}\n\n\nShow more\nPitfall\n\nIf you pass value without onChange, it will be impossible to type into the input. When you control an input by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the input after every keystroke back to the value that you specified.\n\nOptimizing re-rendering on every keystroke \n\nWhen you use a controlled input, you set the state on every keystroke. If the component containing your state re-renders a large tree, this can get slow. There‚Äôs a few ways you can optimize re-rendering performance.\n\nFor example, suppose you start with a form that re-renders all page content on every keystroke:\n\nfunction App() {\n\n  const [firstName, setFirstName] = useState('');\n\n  return (\n\n    <>\n\n      <form>\n\n        <input value={firstName} onChange={e => setFirstName(e.target.value)} />\n\n      </form>\n\n      <PageContent />\n\n    </>\n\n  );\n\n}\n\nSince <PageContent /> doesn‚Äôt rely on the input state, you can move the input state into its own component:\n\nfunction App() {\n\n  return (\n\n    <>\n\n      <SignupForm />\n\n      <PageContent />\n\n    </>\n\n  );\n\n}\n\n\n\nfunction SignupForm() {\n\n  const [firstName, setFirstName] = useState('');\n\n  return (\n\n    <form>\n\n      <input value={firstName} onChange={e => setFirstName(e.target.value)} />\n\n    </form>\n\n  );\n\n}\n\nThis significantly improves performance because now only SignupForm re-renders on every keystroke.\n\nIf there is no way to avoid re-rendering (for example, if PageContent depends on the search input‚Äôs value), useDeferredValue lets you keep the controlled input responsive even in the middle of a large re-render.\n\nTroubleshooting \nMy text input doesn‚Äôt update when I type into it \n\nIf you render an input with value but no onChange, you will see an error in the console:\n\n// üî¥ Bug: controlled text input with no onChange handler\n\n<input value={something} />\nConsole\nYou provided a value prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultValue. Otherwise, set either onChange or readOnly.\n\nAs the error message suggests, if you only wanted to specify the initial value, pass defaultValue instead:\n\n// ‚úÖ Good: uncontrolled input with an initial value\n\n<input defaultValue={something} />\n\nIf you want to control this input with a state variable, specify an onChange handler:\n\n// ‚úÖ Good: controlled input with onChange\n\n<input value={something} onChange={e => setSomething(e.target.value)} />\n\nIf the value is intentionally read-only, add a readOnly prop to suppress the error:\n\n// ‚úÖ Good: readonly controlled input without on change\n\n<input value={something} readOnly={true} />\nMy checkbox doesn‚Äôt update when I click on it \n\nIf you render a checkbox with checked but no onChange, you will see an error in the console:\n\n// üî¥ Bug: controlled checkbox with no onChange handler\n\n<input type=\"checkbox\" checked={something} />\nConsole\nYou provided a checked prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultChecked. Otherwise, set either onChange or readOnly.\n\nAs the error message suggests, if you only wanted to specify the initial value, pass defaultChecked instead:\n\n// ‚úÖ Good: uncontrolled checkbox with an initial value\n\n<input type=\"checkbox\" defaultChecked={something} />\n\nIf you want to control this checkbox with a state variable, specify an onChange handler:\n\n// ‚úÖ Good: controlled checkbox with onChange\n\n<input type=\"checkbox\" checked={something} onChange={e => setSomething(e.target.checked)} />\nPitfall\n\nYou need to read e.target.checked rather than e.target.value for checkboxes.\n\nIf the checkbox is intentionally read-only, add a readOnly prop to suppress the error:\n\n// ‚úÖ Good: readonly controlled input without on change\n\n<input type=\"checkbox\" checked={something} readOnly={true} />\nMy input caret jumps to the beginning on every keystroke \n\nIf you control an input, you must update its state variable to the input‚Äôs value from the DOM during onChange.\n\nYou can‚Äôt update it to something other than e.target.value (or e.target.checked for checkboxes):\n\nfunction handleChange(e) {\n\n  // üî¥ Bug: updating an input to something other than e.target.value\n\n  setFirstName(e.target.value.toUpperCase());\n\n}\n\nYou also can‚Äôt update it asynchronously:\n\nfunction handleChange(e) {\n\n  // üî¥ Bug: updating an input asynchronously\n\n  setTimeout(() => {\n\n    setFirstName(e.target.value);\n\n  }, 100);\n\n}\n\nTo fix your code, update it synchronously to e.target.value:\n\nfunction handleChange(e) {\n\n  // ‚úÖ Updating a controlled input to e.target.value synchronously\n\n  setFirstName(e.target.value);\n\n}\n\nIf this doesn‚Äôt fix the problem, it‚Äôs possible that the input gets removed and re-added from the DOM on every keystroke. This can happen if you‚Äôre accidentally resetting state on every re-render, for example if the input or one of its parents always receives a different key attribute, or if you nest component function definitions (which is not supported and causes the ‚Äúinner‚Äù component to always be considered a different tree).\n\nI‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù \n\nIf you provide a value to the component, it must remain a string throughout its lifetime.\n\nYou cannot pass value={undefined} first and later pass value=\"some string\" because React won‚Äôt know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value, not null or undefined.\n\nIf your value is coming from an API or a state variable, it might be initialized to null or undefined. In that case, either set it to an empty string ('') initially, or pass value={someValue ?? ''} to ensure value is a string.\n\nSimilarly, if you pass checked to a checkbox, ensure it‚Äôs always a boolean.\n\nPREVIOUS\n<form>\nNEXT\n<option>"
  },
  {
    "title": "<option> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/option",
    "html": "API REFERENCE\nCOMPONENTS\n<option>\n\nThe built-in browser <option> component lets you render an option inside a <select> box.\n\n<select>\n\n  <option value=\"someOption\">Some option</option>\n\n  <option value=\"otherOption\">Other option</option>\n\n</select>\nReference\n<option>\nUsage\nDisplaying a select box with options\nReference \n<option> \n\nThe built-in browser <option> component lets you render an option inside a <select> box.\n\n<select>\n\n  <option value=\"someOption\">Some option</option>\n\n  <option value=\"otherOption\">Other option</option>\n\n</select>\n\nSee more examples below.\n\nProps \n\n<option> supports all common element props.\n\nAdditionally, <option> supports these props:\n\ndisabled: A boolean. If true, the option will not be selectable and will appear dimmed.\nlabel: A string. Specifies the meaning of the option. If not specified, the text inside the option is used.\nvalue: The value to be used when submitting the parent <select> in a form if this option is selected.\nCaveats \nReact does not support the selected attribute on <option>. Instead, pass this option‚Äôs value to the parent <select defaultValue> for an uncontrolled select box, or <select value> for a controlled select.\nUsage \nDisplaying a select box with options \n\nRender a <select> with a list of <option> components inside to display a select box. Give each <option> a value representing the data to be submitted with the form.\n\nRead more about displaying a <select> with a list of <option> components.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function FruitPicker() {\n  return (\n    <label>\n      Pick a fruit:\n      <select name=\"selectedFruit\">\n        <option value=\"apple\">Apple</option>\n        <option value=\"banana\">Banana</option>\n        <option value=\"orange\">Orange</option>\n      </select>\n    </label>\n  );\n}\n\n\nPREVIOUS\n<input>\nNEXT\n<progress>"
  },
  {
    "title": "<progress> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/progress",
    "html": "API REFERENCE\nCOMPONENTS\n<progress>\n\nThe built-in browser <progress> component lets you render a progress indicator.\n\n<progress value={0.5} />\nReference\n<progress>\nUsage\nControlling a progress indicator\nReference \n<progress> \n\nTo display a progress indicator, render the built-in browser <progress> component.\n\n<progress value={0.5} />\n\nSee more examples below.\n\nProps \n\n<progress> supports all common element props.\n\nAdditionally, <progress> supports these props:\n\nmax: A number. Specifies the maximum value. Defaults to 1.\nvalue: A number between 0 and max, or null for indeterminate progress. Specifies how much was done.\nUsage \nControlling a progress indicator \n\nTo display a progress indicator, render a <progress> component. You can pass a number value between 0 and the max value you specify. If you don‚Äôt pass a max value, it will assumed to be 1 by default.\n\nIf the operation is not ongoing, pass value={null} to put the progress indicator into an indeterminate state.\n\nApp.js\nDownload\nReload\nClear\nFork\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nexport default function App() {\n  return (\n    <>\n      <progress value={0} />\n      <progress value={0.5} />\n      <progress value={0.7} />\n      <progress value={75} max={100} />\n      <progress value={1} />\n      <progress value={null} />\n    </>\n  );\n}\n\n\nPREVIOUS\n<option>\nNEXT\n<select>"
  },
  {
    "title": "<select> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/select",
    "html": "API REFERENCE\nCOMPONENTS\n<select>\n\nThe built-in browser <select> component lets you render a select box with options.\n\n<select>\n\n  <option value=\"someOption\">Some option</option>\n\n  <option value=\"otherOption\">Other option</option>\n\n</select>\nReference\n<select>\nUsage\nDisplaying a select box with options\nProviding a label for a select box\nProviding an initially selected option\nEnabling multiple selection\nReading the select box value when submitting a form\nControlling a select box with a state variable\nReference \n<select> \n\nTo display a select box, render the built-in browser <select> component.\n\n<select>\n\n  <option value=\"someOption\">Some option</option>\n\n  <option value=\"otherOption\">Other option</option>\n\n</select>\n\nSee more examples below.\n\nProps \n\n<select> supports all common element props.\n\nYou can make a select box controlled by passing a value prop:\n\nvalue: A string (or an array of strings for multiple={true}). Controls which option is selected. Every value string match the value of some <option> nested inside the <select>.\n\nWhen you pass value, you must also pass an onChange handler that updates the passed value.\n\nIf your <select> is uncontrolled, you may pass the defaultValue prop instead:\n\ndefaultValue: A string (or an array of strings for multiple={true}). Specifies the initially selected option.\n\nThese <select> props are relevant both for uncontrolled and controlled select boxes:\n\nautoComplete: A string. Specifies one of the possible autocomplete behaviors.\nautoFocus: A boolean. If true, React will focus the element on mount.\nchildren: <select> accepts <option>, <optgroup>, and <datalist> components as children. You can also pass your own components as long as they eventually render one of the allowed components. If you pass your own components that eventually render <option> tags, each <option> you render must have a value.\ndisabled: A boolean. If true, the select box will not be interactive and will appear dimmed.\nform: A string. Specifies the id of the <form> this select box belongs to. If omitted, it‚Äôs the closest parent form.\nmultiple: A boolean. If true, the browser allows multiple selection.\nname: A string. Specifies the name for this select box that‚Äôs submitted with the form.\nonChange: An Event handler function. Required for controlled select boxes. Fires immediately when the user picks a different option. Behaves like the browser input event.\nonChangeCapture: A version of onChange that fires in the capture phase.\nonInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly.\nonInputCapture: A version of onInput that fires in the capture phase.\nonInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles.\nonInvalidCapture: A version of onInvalid that fires in the capture phase.\nrequired: A boolean. If true, the value must be provided for the form to submit.\nsize: A number. For multiple={true} selects, specifies the preferred number of initially visible items.\nCaveats \nUnlike in HTML, passing a selected attribute to <option> is not supported. Instead, use <select defaultValue> for uncontrolled select boxes and <select value> for controlled select boxes.\nIf a select box receives a value prop, it will be treated as controlled.\nA select box can‚Äôt be both controlled and uncontrolled at the same time.\nA select box cannot switch between being controlled or uncontrolled over its lifetime.\nEvery controlled select box needs an onChange event handler that synchronously updates its backing value.\nUsage \nDisplaying a select box with options \n\nRender a <select> with a list of <option> components inside to display a select box. Give each <option> a value representing the data to be submitted with the form.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function FruitPicker() {\n  return (\n    <label>\n      Pick a fruit:\n      <select name=\"selectedFruit\">\n        <option value=\"apple\">Apple</option>\n        <option value=\"banana\">Banana</option>\n        <option value=\"orange\">Orange</option>\n      </select>\n    </label>\n  );\n}\n\n\nProviding a label for a select box \n\nTypically, you will place every <select> inside a <label> tag. This tells the browser that this label is associated with that select box. When the user clicks the label, the browser will automatically focus the select box. It‚Äôs also essential for accessibility: a screen reader will announce the label caption when the user focuses the select box.\n\nIf you can‚Äôt nest <select> into a <label>, associate them by passing the same ID to <select id> and <label htmlFor>. To avoid conflicts between multiple instances of one component, generate such an ID with useId.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useId } from 'react';\n\nexport default function Form() {\n  const vegetableSelectId = useId();\n  return (\n    <>\n      <label>\n        Pick a fruit:\n        <select name=\"selectedFruit\">\n          <option value=\"apple\">Apple</option>\n          <option value=\"banana\">Banana</option>\n          <option value=\"orange\">Orange</option>\n        </select>\n      </label>\n      <hr />\n      <label htmlFor={vegetableSelectId}>\n        Pick a vegetable:\n      </label>\n      <select id={vegetableSelectId} name=\"selectedVegetable\">\n        <option value=\"cucumber\">Cucumber</option>\n        <option value=\"corn\">Corn</option>\n        <option value=\"tomato\">Tomato</option>\n      </select>\n    </>\n  );\n}\n\n\nShow more\nProviding an initially selected option \n\nBy default, the browser will select the first <option> in the list. To select a different option by default, pass that <option>‚Äôs value as the defaultValue to the <select> element.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function FruitPicker() {\n  return (\n    <label>\n      Pick a fruit:\n      <select name=\"selectedFruit\" defaultValue=\"orange\">\n        <option value=\"apple\">Apple</option>\n        <option value=\"banana\">Banana</option>\n        <option value=\"orange\">Orange</option>\n      </select>\n    </label>\n  );\n}\n\n\nPitfall\n\nUnlike in HTML, passing a selected attribute to an individual <option> is not supported.\n\nEnabling multiple selection \n\nPass multiple={true} to the <select> to let the user select multiple options. In that case, if you also specify defaultValue to choose the initially selected options, it must be an array.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function FruitPicker() {\n  return (\n    <label>\n      Pick some fruits:\n      <select\n        name=\"selectedFruit\"\n        defaultValue={['orange', 'banana']}\n        multiple={true}\n      >\n        <option value=\"apple\">Apple</option>\n        <option value=\"banana\">Banana</option>\n        <option value=\"orange\">Orange</option>\n      </select>\n    </label>\n  );\n}\n\n\nShow more\nReading the select box value when submitting a form \n\nAdd a <form> around your select box with a <button type=\"submit\"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target).\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function EditPost() {\n  function handleSubmit(e) {\n    // Prevent the browser from reloading the page\n    e.preventDefault();\n    // Read the form data\n    const form = e.target;\n    const formData = new FormData(form);\n    // You can pass formData as a fetch body directly:\n    fetch('/some-api', { method: form.method, body: formData });\n    // You can generate a URL out of it, as the browser does by default:\n    console.log(new URLSearchParams(formData).toString());\n    // You can work with it as a plain object.\n    const formJson = Object.fromEntries(formData.entries());\n    console.log(formJson); // (!) This doesn't include multiple select values\n    // Or you can get an array of name-value pairs.\n    console.log([...formData.entries()]);\n  }\n\n  return (\n    <form method=\"post\" onSubmit={handleSubmit}>\n      <label>\n        Pick your favorite fruit:\n        <select name=\"selectedFruit\" defaultValue=\"orange\">\n          <option value=\"apple\">Apple</option>\n          <option value=\"banana\">Banana</option>\n          <option value=\"orange\">Orange</option>\n        </select>\n      </label>\n      <label>\n        Pick all your favorite vegetables:\n        <select\n          name=\"selectedVegetables\"\n          multiple={true}\n          defaultValue={['corn', 'tomato']}\n        >\n          <option value=\"cucumber\">Cucumber</option>\n          <option value=\"corn\">Corn</option>\n          <option value=\"tomato\">Tomato</option>\n        </select>\n      </label>\n      <hr />\n      <button type=\"reset\">Reset</button>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n\nShow more\nNote\n\nGive a name to your <select>, for example <select name=\"selectedFruit\" />. The name you specified will be used as a key in the form data, for example { selectedFruit: \"orange\" }.\n\nIf you use <select multiple={true}>, the FormData you‚Äôll read from the form will include each selected value as a separate name-value pair. Look closely at the console logs in the example above.\n\nPitfall\n\nBy default, any <button> inside a <form> will submit it. This can be surprising! If you have your own custom Button React component, consider returning <button type=\"button\"> instead of <button>. Then, to be explicit, use <button type=\"submit\"> for buttons that are supposed to submit the form.\n\nControlling a select box with a state variable \n\nA select box like <select /> is uncontrolled. Even if you pass an initially selected value like <select defaultValue=\"orange\" />, your JSX only specifies the initial value, not the value right now.\n\nTo render a controlled select box, pass the value prop to it. React will force the select box to always have the value you passed. Typically, you will control a select box by declaring a state variable:\n\nfunction FruitPicker() {\n\n  const [selectedFruit, setSelectedFruit] = useState('orange'); // Declare a state variable...\n\n  // ...\n\n  return (\n\n    <select\n\n      value={selectedFruit} // ...force the select's value to match the state variable...\n\n      onChange={e => setSelectedFruit(e.target.value)} // ... and update the state variable on any change!\n\n    >\n\n      <option value=\"apple\">Apple</option>\n\n      <option value=\"banana\">Banana</option>\n\n      <option value=\"orange\">Orange</option>\n\n    </select>\n\n  );\n\n}\n\nThis is useful if you want to re-render some part of the UI in response to every selection.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function FruitPicker() {\n  const [selectedFruit, setSelectedFruit] = useState('orange');\n  const [selectedVegs, setSelectedVegs] = useState(['corn', 'tomato']);\n  return (\n    <>\n      <label>\n        Pick a fruit:\n        <select\n          value={selectedFruit}\n          onChange={e => setSelectedFruit(e.target.value)}\n        >\n          <option value=\"apple\">Apple</option>\n          <option value=\"banana\">Banana</option>\n          <option value=\"orange\">Orange</option>\n        </select>\n      </label>\n      <hr />\n      <label>\n        Pick all your favorite vegetables:\n        <select\n          multiple={true}\n          value={selectedVegs}\n          onChange={e => {\n            const options = [...e.target.selectedOptions];\n            const values = options.map(option => option.value);\n            setSelectedVegs(values);\n          }}\n        >\n          <option value=\"cucumber\">Cucumber</option>\n          <option value=\"corn\">Corn</option>\n          <option value=\"tomato\">Tomato</option>\n        </select>\n      </label>\n      <hr />\n      <p>Your favorite fruit: {selectedFruit}</p>\n      <p>Your favorite vegetables: {selectedVegs.join(', ')}</p>\n    </>\n  );\n}\n\n\nShow more\nPitfall\n\nIf you pass value without onChange, it will be impossible to select an option. When you control a select box by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the select box after every keystroke back to the value that you specified.\n\nUnlike in HTML, passing a selected attribute to an individual <option> is not supported.\n\nPREVIOUS\n<progress>\nNEXT\n<textarea>"
  },
  {
    "title": "<textarea> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/textarea",
    "html": "API REFERENCE\nCOMPONENTS\n<textarea>\n\nThe built-in browser <textarea> component lets you render a multiline text input.\n\n<textarea />\nReference\n<textarea>\nUsage\nDisplaying a text area\nProviding a label for a text area\nProviding an initial value for a text area\nReading the text area value when submitting a form\nControlling a text area with a state variable\nTroubleshooting\nMy text area doesn‚Äôt update when I type into it\nMy text area caret jumps to the beginning on every keystroke\nI‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù\nReference \n<textarea> \n\nTo display a text area, render the built-in browser <textarea> component.\n\n<textarea name=\"postContent\" />\n\nSee more examples below.\n\nProps \n\n<textarea> supports all common element props.\n\nYou can make a text area controlled by passing a value prop:\n\nvalue: A string. Controls the text inside the text area.\n\nWhen you pass value, you must also pass an onChange handler that updates the passed value.\n\nIf your <textarea> is uncontrolled, you may pass the defaultValue prop instead:\n\ndefaultValue: A string. Specifies the initial value for a text area.\n\nThese <textarea> props are relevant both for uncontrolled and controlled text areas:\n\nautoComplete: Either 'on' or 'off'. Specifies the autocomplete behavior.\nautoFocus: A boolean. If true, React will focus the element on mount.\nchildren: <textarea> does not accept children. To set the initial value, use defaultValue.\ncols: A number. Specifies the default width in average character widths. Defaults to 20.\ndisabled: A boolean. If true, the input will not be interactive and will appear dimmed.\nform: A string. Specifies the id of the <form> this input belongs to. If omitted, it‚Äôs the closest parent form.\nmaxLength: A number. Specifies the maximum length of text.\nminLength: A number. Specifies the minimum length of text.\nname: A string. Specifies the name for this input that‚Äôs submitted with the form.\nonChange: An Event handler function. Required for controlled text areas. Fires immediately when the input‚Äôs value is changed by the user (for example, it fires on every keystroke). Behaves like the browser input event.\nonChangeCapture: A version of onChange that fires in the capture phase.\nonInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly.\nonInputCapture: A version of onInput that fires in the capture phase.\nonInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles.\nonInvalidCapture: A version of onInvalid that fires in the capture phase.\nonSelect: An Event handler function. Fires after the selection inside the <textarea> changes. React extends the onSelect event to also fire for empty selection and on edits (which may affect the selection).\nonSelectCapture: A version of onSelect that fires in the capture phase.\nplaceholder: A string. Displayed in a dimmed color when the text area value is empty.\nreadOnly: A boolean. If true, the text area is not editable by the user.\nrequired: A boolean. If true, the value must be provided for the form to submit.\nrows: A number. Specifies the default height in average character heights. Defaults to 2.\nwrap: Either 'hard', 'soft', or 'off'. Specifies how the text should be wrapped when submitting a form.\nCaveats \nPassing children like <textarea>something</textarea> is not allowed. Use defaultValue for initial content.\nIf a text area receives a string value prop, it will be treated as controlled.\nA text area can‚Äôt be both controlled and uncontrolled at the same time.\nA text area cannot switch between being controlled or uncontrolled over its lifetime.\nEvery controlled text area needs an onChange event handler that synchronously updates its backing value.\nUsage \nDisplaying a text area \n\nRender <textarea> to display a text area. You can specify its default size with the rows and cols attributes, but by default the user will be able to resize it. To disable resizing, you can specify resize: none in the CSS.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function NewPost() {\n  return (\n    <label>\n      Write your post:\n      <textarea name=\"postContent\" rows={4} cols={40} />\n    </label>\n  );\n}\n\n\nProviding a label for a text area \n\nTypically, you will place every <textarea> inside a <label> tag. This tells the browser that this label is associated with that text area. When the user clicks the label, the browser will focus the text area. It‚Äôs also essential for accessibility: a screen reader will announce the label caption when the user focuses the text area.\n\nIf you can‚Äôt nest <textarea> into a <label>, associate them by passing the same ID to <textarea id> and <label htmlFor>. To avoid conflicts between instances of one component, generate such an ID with useId.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useId } from 'react';\n\nexport default function Form() {\n  const postTextAreaId = useId();\n  return (\n    <>\n      <label htmlFor={postTextAreaId}>\n        Write your post:\n      </label>\n      <textarea\n        id={postTextAreaId}\n        name=\"postContent\"\n        rows={4}\n        cols={40}\n      />\n    </>\n  );\n}\n\n\nShow more\nProviding an initial value for a text area \n\nYou can optionally specify the initial value for the text area. Pass it as the defaultValue string.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function EditPost() {\n  return (\n    <label>\n      Edit your post:\n      <textarea\n        name=\"postContent\"\n        defaultValue=\"I really enjoyed biking yesterday!\"\n        rows={4}\n        cols={40}\n      />\n    </label>\n  );\n}\n\n\nPitfall\n\nUnlike in HTML, passing initial text like <textarea>Some content</textarea> is not supported.\n\nReading the text area value when submitting a form \n\nAdd a <form> around your textarea with a <button type=\"submit\"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target).\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function EditPost() {\n  function handleSubmit(e) {\n    // Prevent the browser from reloading the page\n    e.preventDefault();\n\n    // Read the form data\n    const form = e.target;\n    const formData = new FormData(form);\n\n    // You can pass formData as a fetch body directly:\n    fetch('/some-api', { method: form.method, body: formData });\n\n    // Or you can work with it as a plain object:\n    const formJson = Object.fromEntries(formData.entries());\n    console.log(formJson);\n  }\n\n  return (\n    <form method=\"post\" onSubmit={handleSubmit}>\n      <label>\n        Post title: <input name=\"postTitle\" defaultValue=\"Biking\" />\n      </label>\n      <label>\n        Edit your post:\n        <textarea\n          name=\"postContent\"\n          defaultValue=\"I really enjoyed biking yesterday!\"\n          rows={4}\n          cols={40}\n        />\n      </label>\n      <hr />\n      <button type=\"reset\">Reset edits</button>\n      <button type=\"submit\">Save post</button>\n    </form>\n  );\n}\n\n\nShow more\nNote\n\nGive a name to your <textarea>, for example <textarea name=\"postContent\" />. The name you specified will be used as a key in the form data, for example { postContent: \"Your post\" }.\n\nPitfall\n\nBy default, any <button> inside a <form> will submit it. This can be surprising! If you have your own custom Button React component, consider returning <button type=\"button\"> instead of <button>. Then, to be explicit, use <button type=\"submit\"> for buttons that are supposed to submit the form.\n\nControlling a text area with a state variable \n\nA text area like <textarea /> is uncontrolled. Even if you pass an initial value like <textarea defaultValue=\"Initial text\" />, your JSX only specifies the initial value, not the value right now.\n\nTo render a controlled text area, pass the value prop to it. React will force the text area to always have the value you passed. Typically, you will control a text area by declaring a state variable:\n\nfunction NewPost() {\n\n  const [postContent, setPostContent] = useState(''); // Declare a state variable...\n\n  // ...\n\n  return (\n\n    <textarea\n\n      value={postContent} // ...force the input's value to match the state variable...\n\n      onChange={e => setPostContent(e.target.value)} // ... and update the state variable on any edits!\n\n    />\n\n  );\n\n}\n\nThis is useful if you want to re-render some part of the UI in response to every keystroke.\n\npackage.json\nApp.js\nMarkdownPreview.js\nReload\nClear\nFork\n{\n  \"dependencies\": {\n    \"react\": \"latest\",\n    \"react-dom\": \"latest\",\n    \"react-scripts\": \"latest\",\n    \"remarkable\": \"2.0.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test --env=jsdom\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"devDependencies\": {}\n}\nPitfall\n\nIf you pass value without onChange, it will be impossible to type into the text area. When you control a text area by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the text area after every keystroke back to the value that you specified.\n\nTroubleshooting \nMy text area doesn‚Äôt update when I type into it \n\nIf you render a text area with value but no onChange, you will see an error in the console:\n\n// üî¥ Bug: controlled text area with no onChange handler\n\n<textarea value={something} />\nConsole\nYou provided a value prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultValue. Otherwise, set either onChange or readOnly.\n\nAs the error message suggests, if you only wanted to specify the initial value, pass defaultValue instead:\n\n// ‚úÖ Good: uncontrolled text area with an initial value\n\n<textarea defaultValue={something} />\n\nIf you want to control this text area with a state variable, specify an onChange handler:\n\n// ‚úÖ Good: controlled text area with onChange\n\n<textarea value={something} onChange={e => setSomething(e.target.value)} />\n\nIf the value is intentionally read-only, add a readOnly prop to suppress the error:\n\n// ‚úÖ Good: readonly controlled text area without on change\n\n<textarea value={something} readOnly={true} />\nMy text area caret jumps to the beginning on every keystroke \n\nIf you control a text area, you must update its state variable to the text area‚Äôs value from the DOM during onChange.\n\nYou can‚Äôt update it to something other than e.target.value:\n\nfunction handleChange(e) {\n\n  // üî¥ Bug: updating an input to something other than e.target.value\n\n  setFirstName(e.target.value.toUpperCase());\n\n}\n\nYou also can‚Äôt update it asynchronously:\n\nfunction handleChange(e) {\n\n  // üî¥ Bug: updating an input asynchronously\n\n  setTimeout(() => {\n\n    setFirstName(e.target.value);\n\n  }, 100);\n\n}\n\nTo fix your code, update it synchronously to e.target.value:\n\nfunction handleChange(e) {\n\n  // ‚úÖ Updating a controlled input to e.target.value synchronously\n\n  setFirstName(e.target.value);\n\n}\n\nIf this doesn‚Äôt fix the problem, it‚Äôs possible that the text area gets removed and re-added from the DOM on every keystroke. This can happen if you‚Äôre accidentally resetting state on every re-render. For example, this can happen if the text area or one of its parents always receives a different key attribute, or if you nest component definitions (which is not allowed in React and causes the ‚Äúinner‚Äù component to remount on every render).\n\nI‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù \n\nIf you provide a value to the component, it must remain a string throughout its lifetime.\n\nYou cannot pass value={undefined} first and later pass value=\"some string\" because React won‚Äôt know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value, not null or undefined.\n\nIf your value is coming from an API or a state variable, it might be initialized to null or undefined. In that case, either set it to an empty string ('') initially, or pass value={someValue ?? ''} to ensure value is a string.\n\nPREVIOUS\n<select>\nNEXT\n<link>"
  },
  {
    "title": "<link> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/link",
    "html": "API REFERENCE\nCOMPONENTS\n<link>\n\nThe built-in browser <link> component lets you use external resources such as stylesheets or annotate the document with link metadata.\n\n<link rel=\"icon\" href=\"favicon.ico\" />\nReference\n<link>\nUsage\nLinking to related resources\nLinking to a stylesheet\nControlling stylesheet precedence\nDeduplicated stylesheet rendering\nAnnotating specific items within the document with links\nReference \n<link> \n\nTo link to external resources such as stylesheets, fonts, and icons, or to annotate the document with link metadata, render the built-in browser <link> component. You can render <link> from any component and React will in most cases place the corresponding DOM element in the document head.\n\n<link rel=\"icon\" href=\"favicon.ico\" />\n\nSee more examples below.\n\nProps \n\n<link> supports all common element props.\n\nrel: a string, required. Specifies the relationship to the resource. React treats links with rel=\"stylesheet\" differently from other links.\n\nThese props apply when rel=\"stylesheet\":\n\nprecedence: a string. Tells React where to rank the <link> DOM node relative to others in the document <head>, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are ‚Äúlower‚Äù and precedence values it discovers later are ‚Äúhigher‚Äù. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are <link> or inline <style> tags or loaded using preinit functions.\nmedia: a string. Restricts the stylesheet to a certain media query.\ntitle: a string. Specifies the name of an alternative stylesheet.\n\nThese props apply when rel=\"stylesheet\" but disable React‚Äôs special treatment of stylesheets:\n\ndisabled: a boolean. Disables the stylesheet.\nonError: a function. Called when the stylesheet fails to load.\nonLoad: a function. Called when the stylesheet finishes being loaded.\n\nThese props apply when rel=\"preload\" or rel=\"modulepreload\":\n\nas: a string. The type of resource. Its possible values are audio, document, embed, fetch, font, image, object, script, style, track, video, worker.\nimageSrcSet: a string. Applicable only when as=\"image\". Specifies the source set of the image.\nimageSizes: a string. Applicable only when as=\"image\". Specifies the sizes of the image.\n\nThese props apply when rel=\"icon\" or rel=\"apple-touch-icon\":\n\nsizes: a string. The sizes of the icon.\n\nThese props apply in all cases:\n\nhref: a string. The URL of the linked resource.\ncrossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials. It is required when as is set to \"fetch\".\nreferrerPolicy: a string. The Referrer header to send when fetching. Its possible values are no-referrer-when-downgrade (the default), no-referrer, origin, origin-when-cross-origin, and unsafe-url.\nfetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values are auto (the default), high, and low.\nhrefLang: a string. The language of the linked resource.\nintegrity: a string. A cryptographic hash of the resource, to verify its authenticity.\ntype: a string. The MIME type of the linked resource.\n\nProps that are not recommended for use with React:\n\nblocking: a string. If set to \"render\", instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.\nSpecial rendering behavior \n\nReact will always place the DOM element corresponding to the <link> component within the document‚Äôs <head>, regardless of where in the React tree it is rendered. The <head> is the only valid place for <link> to exist within the DOM, yet it‚Äôs convenient and keeps things composable if a component representing a specific page can render <link> components itself.\n\nThere are a few exceptions to this:\n\nIf the <link> has a rel=\"stylesheet\" prop, then it has to also have a precedence prop to get this special behavior. This is because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using the precedence prop. If the precedence prop is omitted, there is no special behavior.\nIf the <link> has an itemProp prop, there is no special behavior, because in this case it doesn‚Äôt apply to the document but instead represents metadata about a specific part of the page.\nIf the <link> has an onLoad or onError prop, because in that case you are managing the loading of the linked resource manually within your React component.\nSpecial behavior for stylesheets \n\nIn addition, if the <link> is to a stylesheet (namely, it has rel=\"stylesheet\" in its props), React treats it specially in the following ways:\n\nThe component that renders <link> will suspend while the stylesheet is loading.\nIf multiple components render links to the same stylesheet, React will de-duplicate them and only put a single link into the DOM. Two links are considered the same if they have the same href prop.\n\nThere are two exception to this special behavior:\n\nIf the link doesn‚Äôt have a precedence prop, there is no special behavior, because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using the precedence prop.\nIf you supply any of the onLoad, onError, or disabled props, there is no special behavior, because these props indicate that you are managing the loading of the stylesheet manually within your component.\n\nThis special treatment comes with two caveats:\n\nReact will ignore changes to props after the link has been rendered. (React will issue a warning in development if this happens.)\nReact may leave the link in the DOM even after the component that rendered it has been unmounted.\nUsage \nLinking to related resources \n\nYou can annotate the document with links to related resources such as an icon, canonical URL, or pingback. React will place this metadata within the document <head> regardless of where in the React tree it is rendered.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nexport default function BlogPage() {\n  return (\n    <ShowRenderedHTML>\n      <link rel=\"icon\" href=\"favicon.ico\" />\n      <link rel=\"pingback\" href=\"http://www.example.com/xmlrpc.php\" />\n      <h1>My Blog</h1>\n      <p>...</p>\n    </ShowRenderedHTML>\n  );\n}\n\n\nLinking to a stylesheet \n\nIf a component depends on a certain stylesheet in order to be displayed correctly, you can render a link to that stylesheet within the component. Your component will suspend while the stylesheet is loading. You must supply the precedence prop, which tells React where to place this stylesheet relative to others ‚Äî stylesheets with higher precedence can override those with lower precedence.\n\nNote\n\nWhen you want to use a stylesheet, it can be beneficial to call the preinit function. Calling this function may allow the browser to start fetching the stylesheet earlier than if you just render a <link> component, for example by sending an HTTP Early Hints response.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nexport default function SiteMapPage() {\n  return (\n    <ShowRenderedHTML>\n      <link rel=\"stylesheet\" href=\"sitemap.css\" precedence=\"medium\" />\n      <p>...</p>\n    </ShowRenderedHTML>\n  );\n}\n\n\nControlling stylesheet precedence \n\nStylesheets can conflict with each other, and when they do, the browser goes with the one that comes later in the document. React lets you control the order of stylesheets with the precedence prop. In this example, three components render stylesheets, and the ones with the same precedence are grouped together in the <head>.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nexport default function HomePage() {\n  return (\n    <ShowRenderedHTML>\n      <FirstComponent />\n      <SecondComponent />\n      <ThirdComponent/>\n      ...\n    </ShowRenderedHTML>\n  );\n}\n\nfunction FirstComponent() {\n  return <link rel=\"stylesheet\" href=\"first.css\" precedence=\"first\" />;\n}\n\nfunction SecondComponent() {\n  return <link rel=\"stylesheet\" href=\"second.css\" precedence=\"second\" />;\n}\n\nfunction ThirdComponent() {\n  return <link rel=\"stylesheet\" href=\"third.css\" precedence=\"first\" />;\n}\n\n\nShow more\n\nNote the precedence values themselves are arbitrary and their naming is up to you. React will infer that precedence values it discovers first are ‚Äúlower‚Äù and precedence values it discovers later are ‚Äúhigher‚Äù.\n\nDeduplicated stylesheet rendering \n\nIf you render the same stylesheet from multiple components, React will place only a single <link> in the document head.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nexport default function HomePage() {\n  return (\n    <ShowRenderedHTML>\n      <Component />\n      <Component />\n      ...\n    </ShowRenderedHTML>\n  );\n}\n\nfunction Component() {\n  return <link rel=\"stylesheet\" href=\"styles.css\" precedence=\"medium\" />;\n}\n\n\nAnnotating specific items within the document with links \n\nYou can use the <link> component with the itemProp prop to annotate specific items within the document with links to related resources. In this case, React will not place these annotations within the document <head> but will place them like any other React component.\n\n<section itemScope>\n\n  <h3>Annotating specific items</h3>\n\n  <link itemProp=\"author\" href=\"http://example.com/\" />\n\n  <p>...</p>\n\n</section>\nPREVIOUS\n<textarea>\nNEXT\n<meta>"
  },
  {
    "title": "<script> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/script",
    "html": "API REFERENCE\nCOMPONENTS\n<script>\n\nThe built-in browser <script> component lets you add a script to your document.\n\n<script> alert(\"hi!\") </script>\nReference\n<script>\nUsage\nRendering an external script\nRendering an inline script\nReference \n<script> \n\nTo add inline or external scripts to your document, render the built-in browser <script> component. You can render <script> from any component and React will in certain cases place the corresponding DOM element in the document head and de-duplicate identical scripts.\n\n<script> alert(\"hi!\") </script>\n\n<script src=\"script.js\" />\n\nSee more examples below.\n\nProps \n\n<script> supports all common element props.\n\nIt should have either children or a src prop.\n\nchildren: a string. The source code of an inline script.\nsrc: a string. The URL of an external script.\n\nOther supported props:\n\nasync: a boolean. Allows the browser to defer execution of the script until the rest of the document has been processed ‚Äî the preferred behavior for performance.\ncrossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials.\nfetchPriority: a string. Lets the browser rank scripts in priority when fetching multiple scripts at the same time. Can be \"high\", \"low\", or \"auto\" (the default).\nintegrity: a string. A cryptographic hash of the script, to verify its authenticity.\nnoModule: a boolean. Disables the script in browsers that support ES modules ‚Äî allowing for a fallback script for browsers that do not.\nnonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.\nreferrer: a string. Says what Referer header to send when fetching the script and any resources that the script fetches in turn.\ntype: a string. Says whether the script is a classic script, ES module, or import map.\n\nProps that disable React‚Äôs special treatment of scripts:\n\nonError: a function. Called when the script fails to load.\nonLoad: a function. Called when the script finishes being loaded.\n\nProps that are not recommended for use with React:\n\nblocking: a string. If set to \"render\", instructs the browser not to render the page until the scriptsheet is loaded. React provides more fine-grained control using Suspense.\ndefer: a string. Prevents the browser from executing the script until the document is done loading. Not compatible with streaming server-rendered components. Use the async prop instead.\nSpecial rendering behavior \n\nReact can move <script> components to the document‚Äôs <head> and de-duplicate identical scripts.\n\nTo opt into this behavior, provide the src and async={true} props. React will de-duplicate scripts if they have the same src. The async prop must be true to allow scripts to be safely moved.\n\nThis special treatment comes with two caveats:\n\nReact will ignore changes to props after the script has been rendered. (React will issue a warning in development if this happens.)\nReact may leave the script in the DOM even after the component that rendered it has been unmounted. (This has no effect as scripts just execute once when they are inserted into the DOM.)\nUsage \nRendering an external script \n\nIf a component depends on certain scripts in order to be displayed correctly, you can render a <script> within the component.\nHowever, the component might be committed before the script has finished loading.\nYou can start depending on the script content once the load event is fired e.g. by using the onLoad prop.\n\nReact will de-duplicate scripts that have the same src, inserting only one of them into the DOM even if multiple components render it.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nfunction Map({lat, long}) {\n  return (\n    <>\n      <script async src=\"map-api.js\" onLoad={() => console.log('script loaded')} />\n      <div id=\"map\" data-lat={lat} data-long={long} />\n    </>\n  );\n}\n\nexport default function Page() {\n  return (\n    <ShowRenderedHTML>\n      <Map />\n    </ShowRenderedHTML>\n  );\n}\n\n\nShow more\nNote\n\nWhen you want to use a script, it can be beneficial to call the preinit function. Calling this function may allow the browser to start fetching the script earlier than if you just render a <script> component, for example by sending an HTTP Early Hints response.\n\nRendering an inline script \n\nTo include an inline script, render the <script> component with the script source code as its children. Inline scripts are not de-duplicated or moved to the document <head>.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nfunction Tracking() {\n  return (\n    <script>\n      ga('send', 'pageview');\n    </script>\n  );\n}\n\nexport default function Page() {\n  return (\n    <ShowRenderedHTML>\n      <h1>My Website</h1>\n      <Tracking />\n      <p>Welcome</p>\n    </ShowRenderedHTML>\n  );\n}\n\n\nShow more\nPREVIOUS\n<meta>\nNEXT\n<style>"
  },
  {
    "title": "<style> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/style",
    "html": "API REFERENCE\nCOMPONENTS\n<style>\n\nThe built-in browser <style> component lets you add inline CSS stylesheets to your document.\n\n<style>{` p { color: red; } `}</style>\nReference\n<style>\nUsage\nRendering an inline CSS stylesheet\nReference \n<style> \n\nTo add inline styles to your document, render the built-in browser <style> component. You can render <style> from any component and React will in certain cases place the corresponding DOM element in the document head and de-duplicate identical styles.\n\n<style>{` p { color: red; } `}</style>\n\nSee more examples below.\n\nProps \n\n<style> supports all common element props.\n\nchildren: a string, required. The contents of the stylesheet.\nprecedence: a string. Tells React where to rank the <style> DOM node relative to others in the document <head>, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are ‚Äúlower‚Äù and precedence values it discovers later are ‚Äúhigher‚Äù. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are <link> or inline <style> tags or loaded using preinit functions.\nhref: a string. Allows React to de-duplicate styles that have the same href.\nmedia: a string. Restricts the stylesheet to a certain media query.\nnonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.\ntitle: a string. Specifies the name of an alternative stylesheet.\n\nProps that are not recommended for use with React:\n\nblocking: a string. If set to \"render\", instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.\nSpecial rendering behavior \n\nReact can move <style> components to the document‚Äôs <head>, de-duplicate identical stylesheets, and suspend while the stylesheet is loading.\n\nTo opt into this behavior, provide the href and precedence props. React will de-duplicate styles if they have the same href. The precedence prop tells React where to rank the <style> DOM node relative to others in the document <head>, which determines which stylesheet can override the other.\n\nThis special treatment comes with three caveats:\n\nReact will ignore changes to props after the style has been rendered. (React will issue a warning in development if this happens.)\nReact will drop all extraneous props when using the precedence prop (beyond href and precedence).\nReact may leave the style in the DOM even after the component that rendered it has been unmounted.\nUsage \nRendering an inline CSS stylesheet \n\nIf a component depends on certain CSS styles in order to be displayed correctly, you can render an inline stylesheet within the component.\n\nThe href prop should uniquely identify the stylesheet, because React will de-duplicate stylesheets that have the same href.\nIf you supply a precedence prop, React will reorder inline stylesheets based on the order these values appear in the component tree.\n\nInline stylesheets will not trigger Suspense boundaries while they‚Äôre loading.\nEven if they load async resources like fonts or images.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\nimport { useId } from 'react';\n\nfunction PieChart({data, colors}) {\n  const id = useId();\n  const stylesheet = colors.map((color, index) =>\n    `#${id} .color-${index}: \\{ color: \"${color}\"; \\}`\n  ).join();\n  return (\n    <>\n      <style href={\"PieChart-\" + JSON.stringify(colors)} precedence=\"medium\">\n        {stylesheet}\n      </style>\n      <svg id={id}>\n        ‚Ä¶\n      </svg>\n    </>\n  );\n}\n\nexport default function App() {\n  return (\n    <ShowRenderedHTML>\n      <PieChart data=\"...\" colors={['red', 'green', 'blue']} />\n    </ShowRenderedHTML>\n  );\n}\n\n\nShow more\nPREVIOUS\n<script>\nNEXT\n<title>"
  },
  {
    "title": "<meta> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/meta",
    "html": "API REFERENCE\nCOMPONENTS\n<meta>\n\nThe built-in browser <meta> component lets you add metadata to the document.\n\n<meta name=\"keywords\" content=\"React, JavaScript, semantic markup, html\" />\nReference\n<meta>\nUsage\nAnnotating the document with metadata\nAnnotating specific items within the document with metadata\nReference \n<meta> \n\nTo add document metadata, render the built-in browser <meta> component. You can render <meta> from any component and React will always place the corresponding DOM element in the document head.\n\n<meta name=\"keywords\" content=\"React, JavaScript, semantic markup, html\" />\n\nSee more examples below.\n\nProps \n\n<meta> supports all common element props.\n\nIt should have exactly one of the following props: name, httpEquiv, charset, itemProp. The <meta> component does something different depending on which of these props is specified.\n\nname: a string. Specifies the kind of metadata to be attached to the document.\ncharset: a string. Specifies the character set used by the document. The only valid value is \"utf-8\".\nhttpEquiv: a string. Specifies a directive for processing the document.\nitemProp: a string. Specifies metadata about a particular item within the document rather than the document as a whole.\ncontent: a string. Specifies the metadata to be attached when used with the name or itemProp props or the behavior of the directive when used with the httpEquiv prop.\nSpecial rendering behavior \n\nReact will always place the DOM element corresponding to the <meta> component within the document‚Äôs <head>, regardless of where in the React tree it is rendered. The <head> is the only valid place for <meta> to exist within the DOM, yet it‚Äôs convenient and keeps things composable if a component representing a specific page can render <meta> components itself.\n\nThere is one exception to this: if <meta> has an itemProp prop, there is no special behavior, because in this case it doesn‚Äôt represent metadata about the document but rather metadata about a specific part of the page.\n\nUsage \nAnnotating the document with metadata \n\nYou can annotate the document with metadata such as keywords, a summary, or the author‚Äôs name. React will place this metadata within the document <head> regardless of where in the React tree it is rendered.\n\n<meta name=\"author\" content=\"John Smith\" />\n\n<meta name=\"keywords\" content=\"React, JavaScript, semantic markup, html\" />\n\n<meta name=\"description\" content=\"API reference for the <meta> component in React DOM\" />\n\nYou can render the <meta> component from any component. React will put a <meta> DOM node in the document <head>.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nexport default function SiteMapPage() {\n  return (\n    <ShowRenderedHTML>\n      <meta name=\"keywords\" content=\"React\" />\n      <meta name=\"description\" content=\"A site map for the React website\" />\n      <h1>Site Map</h1>\n      <p>...</p>\n    </ShowRenderedHTML>\n  );\n}\n\n\nAnnotating specific items within the document with metadata \n\nYou can use the <meta> component with the itemProp prop to annotate specific items within the document with metadata. In this case, React will not place these annotations within the document <head> but will place them like any other React component.\n\n<section itemScope>\n\n  <h3>Annotating specific items</h3>\n\n  <meta itemProp=\"description\" content=\"API reference for using <meta> with itemProp\" />\n\n  <p>...</p>\n\n</section>\nPREVIOUS\n<link>\nNEXT\n<script>"
  },
  {
    "title": "<title> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/title",
    "html": "API REFERENCE\nCOMPONENTS\n<title>\n\nThe built-in browser <title> component lets you specify the title of the document.\n\n<title>My Blog</title>\nReference\n<title>\nUsage\nSet the document title\nUse variables in the title\nReference \n<title> \n\nTo specify the title of the document, render the built-in browser <title> component. You can render <title> from any component and React will always place the corresponding DOM element in the document head.\n\n<title>My Blog</title>\n\nSee more examples below.\n\nProps \n\n<title> supports all common element props.\n\nchildren: <title> accepts only text as a child. This text will become the title of the document. You can also pass your own components as long as they only render text.\nSpecial rendering behavior \n\nReact will always place the DOM element corresponding to the <title> component within the document‚Äôs <head>, regardless of where in the React tree it is rendered. The <head> is the only valid place for <title> to exist within the DOM, yet it‚Äôs convenient and keeps things composable if a component representing a specific page can render its <title> itself.\n\nThere are two exception to this:\n\nIf <title> is within an <svg> component, then there is no special behavior, because in this context it doesn‚Äôt represent the document‚Äôs title but rather is an accessibility annotation for that SVG graphic.\nIf the <title> has an itemProp prop, there is no special behavior, because in this case it doesn‚Äôt represent the document‚Äôs title but rather metadata about a specific part of the page.\nPitfall\n\nOnly render a single <title> at a time. If more than one component renders a <title> tag at the same time, React will place all of those titles in the document head. When this happens, the behavior of browsers and search engines is undefined.\n\nUsage \nSet the document title \n\nRender the <title> component from any component with text as its children. React will put a <title> DOM node in the document <head>.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nexport default function ContactUsPage() {\n  return (\n    <ShowRenderedHTML>\n      <title>My Site: Contact Us</title>\n      <h1>Contact Us</h1>\n      <p>Email us at support@example.com</p>\n    </ShowRenderedHTML>\n  );\n}\n\n\nUse variables in the title \n\nThe children of the <title> component must be a single string of text. (Or a single number or a single object with a toString method.) It might not be obvious, but using JSX curly braces like this:\n\n<title>Results page {pageNumber}</title> // üî¥ Problem: This is not a single string\n\n‚Ä¶ actually causes the <title> component to get a two-element array as its children (the string \"Results page\" and the value of pageNumber). This will cause an error. Instead, use string interpolation to pass <title> a single string:\n\n<title>{`Results page ${pageNumber}`}</title>\nPREVIOUS\n<style>\nNEXT\nAPIs"
  },
  {
    "title": "createPortal ‚Äì React",
    "url": "https://react.dev/reference/react-dom/createPortal",
    "html": "API REFERENCE\nAPIS\ncreatePortal\n\ncreatePortal lets you render some children into a different part of the DOM.\n\n<div>\n\n  <SomeComponent />\n\n  {createPortal(children, domNode, key?)}\n\n</div>\nReference\ncreatePortal(children, domNode, key?)\nUsage\nRendering to a different part of the DOM\nRendering a modal dialog with a portal\nRendering React components into non-React server markup\nRendering React components into non-React DOM nodes\nReference \ncreatePortal(children, domNode, key?) \n\nTo create a portal, call createPortal, passing some JSX, and the DOM node where it should be rendered:\n\nimport { createPortal } from 'react-dom';\n\n\n\n// ...\n\n\n\n<div>\n\n  <p>This child is placed in the parent div.</p>\n\n  {createPortal(\n\n    <p>This child is placed in the document body.</p>,\n\n    document.body\n\n  )}\n\n</div>\n\nSee more examples below.\n\nA portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events bubble up from children to parents according to the React tree.\n\nParameters \n\nchildren: Anything that can be rendered with React, such as a piece of JSX (e.g. <div /> or <SomeComponent />), a Fragment (<>...</>), a string or a number, or an array of these.\n\ndomNode: Some DOM node, such as those returned by document.getElementById(). The node must already exist. Passing a different DOM node during an update will cause the portal content to be recreated.\n\noptional key: A unique string or number to be used as the portal‚Äôs key.\n\nReturns \n\ncreatePortal returns a React node that can be included into JSX or returned from a React component. If React encounters it in the render output, it will place the provided children inside the provided domNode.\n\nCaveats \nEvents from portals propagate according to the React tree rather than the DOM tree. For example, if you click inside a portal, and the portal is wrapped in <div onClick>, that onClick handler will fire. If this causes issues, either stop the event propagation from inside the portal, or move the portal itself up in the React tree.\nUsage \nRendering to a different part of the DOM \n\nPortals let your components render some of their children into a different place in the DOM. This lets a part of your component ‚Äúescape‚Äù from whatever containers it may be in. For example, a component can display a modal dialog or a tooltip that appears above and outside of the rest of the page.\n\nTo create a portal, render the result of createPortal with some JSX and the DOM node where it should go:\n\nimport { createPortal } from 'react-dom';\n\n\n\nfunction MyComponent() {\n\n  return (\n\n    <div style={{ border: '2px solid black' }}>\n\n      <p>This child is placed in the parent div.</p>\n\n      {createPortal(\n\n        <p>This child is placed in the document body.</p>,\n\n        document.body\n\n      )}\n\n    </div>\n\n  );\n\n}\n\nReact will put the DOM nodes for the JSX you passed inside of the DOM node you provided.\n\nWithout a portal, the second <p> would be placed inside the parent <div>, but the portal ‚Äúteleported‚Äù it into the document.body:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { createPortal } from 'react-dom';\n\nexport default function MyComponent() {\n  return (\n    <div style={{ border: '2px solid black' }}>\n      <p>This child is placed in the parent div.</p>\n      {createPortal(\n        <p>This child is placed in the document body.</p>,\n        document.body\n      )}\n    </div>\n  );\n}\n\n\n\nNotice how the second paragraph visually appears outside the parent <div> with the border. If you inspect the DOM structure with developer tools, you‚Äôll see that the second <p> got placed directly into the <body>:\n\n<body>\n\n  <div id=\"root\">\n\n    ...\n\n      <div style=\"border: 2px solid black\">\n\n        <p>This child is placed inside the parent div.</p>\n\n      </div>\n\n    ...\n\n  </div>\n\n  <p>This child is placed in the document body.</p>\n\n</body>\n\nA portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events still bubble up from children to parents according to the React tree.\n\nRendering a modal dialog with a portal \n\nYou can use a portal to create a modal dialog that floats above the rest of the page, even if the component that summons the dialog is inside a container with overflow: hidden or other styles that interfere with the dialog.\n\nIn this example, the two containers have styles that disrupt the modal dialog, but the one rendered into a portal is unaffected because, in the DOM, the modal is not contained within the parent JSX elements.\n\nApp.js\nNoPortalExample.js\nPortalExample.js\nModalContent.js\nReload\nClear\nFork\nimport NoPortalExample from './NoPortalExample';\nimport PortalExample from './PortalExample';\n\nexport default function App() {\n  return (\n    <>\n      <div className=\"clipping-container\">\n        <NoPortalExample  />\n      </div>\n      <div className=\"clipping-container\">\n        <PortalExample />\n      </div>\n    </>\n  );\n}\n\n\nPitfall\n\nIt‚Äôs important to make sure that your app is accessible when using portals. For instance, you may need to manage keyboard focus so that the user can move the focus in and out of the portal in a natural way.\n\nFollow the WAI-ARIA Modal Authoring Practices when creating modals. If you use a community package, ensure that it is accessible and follows these guidelines.\n\nRendering React components into non-React server markup \n\nPortals can be useful if your React root is only part of a static or server-rendered page that isn‚Äôt built with React. For example, if your page is built with a server framework like Rails, you can create areas of interactivity within static areas such as sidebars. Compared with having multiple separate React roots, portals let you treat the app as a single React tree with shared state even though its parts render to different parts of the DOM.\n\nindex.js\nindex.html\nApp.js\nReload\nClear\nFork\nimport { createPortal } from 'react-dom';\n\nconst sidebarContentEl = document.getElementById('sidebar-content');\n\nexport default function App() {\n  return (\n    <>\n      <MainContent />\n      {createPortal(\n        <SidebarContent />,\n        sidebarContentEl\n      )}\n    </>\n  );\n}\n\nfunction MainContent() {\n  return <p>This part is rendered by React</p>;\n}\n\nfunction SidebarContent() {\n  return <p>This part is also rendered by React!</p>;\n}\n\n\nShow more\nRendering React components into non-React DOM nodes \n\nYou can also use a portal to manage the content of a DOM node that‚Äôs managed outside of React. For example, suppose you‚Äôre integrating with a non-React map widget and you want to render React content inside a popup. To do this, declare a popupContainer state variable to store the DOM node you‚Äôre going to render into:\n\nconst [popupContainer, setPopupContainer] = useState(null);\n\nWhen you create the third-party widget, store the DOM node returned by the widget so you can render into it:\n\nuseEffect(() => {\n\n  if (mapRef.current === null) {\n\n    const map = createMapWidget(containerRef.current);\n\n    mapRef.current = map;\n\n    const popupDiv = addPopupToMapWidget(map);\n\n    setPopupContainer(popupDiv);\n\n  }\n\n}, []);\n\nThis lets you use createPortal to render React content into popupContainer once it becomes available:\n\nreturn (\n\n  <div style={{ width: 250, height: 250 }} ref={containerRef}>\n\n    {popupContainer !== null && createPortal(\n\n      <p>Hello from React!</p>,\n\n      popupContainer\n\n    )}\n\n  </div>\n\n);\n\nHere is a complete example you can play with:\n\nApp.js\nmap-widget.js\nReload\nClear\nFork\nimport { useRef, useEffect, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport { createMapWidget, addPopupToMapWidget } from './map-widget.js';\n\nexport default function Map() {\n  const containerRef = useRef(null);\n  const mapRef = useRef(null);\n  const [popupContainer, setPopupContainer] = useState(null);\n\n  useEffect(() => {\n    if (mapRef.current === null) {\n      const map = createMapWidget(containerRef.current);\n      mapRef.current = map;\n      const popupDiv = addPopupToMapWidget(map);\n      setPopupContainer(popupDiv);\n    }\n  }, []);\n\n  return (\n    <div style={{ width: 250, height: 250 }} ref={containerRef}>\n      {popupContainer !== null && createPortal(\n        <p>Hello from React!</p>,\n        popupContainer\n      )}\n    </div>\n  );\n}\n\n\nShow more\nPREVIOUS\nAPIs\nNEXT\nflushSync"
  },
  {
    "title": "flushSync ‚Äì React",
    "url": "https://react.dev/reference/react-dom/flushSync",
    "html": "API REFERENCE\nAPIS\nflushSync\nPitfall\n\nUsing flushSync is uncommon and can hurt the performance of your app.\n\nflushSync lets you force React to flush any updates inside the provided callback synchronously. This ensures that the DOM is updated immediately.\n\nflushSync(callback)\nReference\nflushSync(callback)\nUsage\nFlushing updates for third-party integrations\nTroubleshooting\nI‚Äôm getting an error: ‚ÄúflushSync was called from inside a lifecycle method‚Äù\nReference \nflushSync(callback) \n\nCall flushSync to force React to flush any pending work and update the DOM synchronously.\n\nimport { flushSync } from 'react-dom';\n\n\n\nflushSync(() => {\n\n  setSomething(123);\n\n});\n\nMost of the time, flushSync can be avoided. Use flushSync as last resort.\n\nSee more examples below.\n\nParameters \ncallback: A function. React will immediately call this callback and flush any updates it contains synchronously. It may also flush any pending updates, or Effects, or updates inside of Effects. If an update suspends as a result of this flushSync call, the fallbacks may be re-shown.\nReturns \n\nflushSync returns undefined.\n\nCaveats \nflushSync can significantly hurt performance. Use sparingly.\nflushSync may force pending Suspense boundaries to show their fallback state.\nflushSync may run pending Effects and synchronously apply any updates they contain before returning.\nflushSync may flush updates outside the callback when necessary to flush the updates inside the callback. For example, if there are pending updates from a click, React may flush those before flushing the updates inside the callback.\nUsage \nFlushing updates for third-party integrations \n\nWhen integrating with third-party code such as browser APIs or UI libraries, it may be necessary to force React to flush updates. Use flushSync to force React to flush any state updates inside the callback synchronously:\n\nflushSync(() => {\n\n  setSomething(123);\n\n});\n\n// By this line, the DOM is updated.\n\nThis ensures that, by the time the next line of code runs, React has already updated the DOM.\n\nUsing flushSync is uncommon, and using it often can significantly hurt the performance of your app. If your app only uses React APIs, and does not integrate with third-party libraries, flushSync should be unnecessary.\n\nHowever, it can be helpful for integrating with third-party code like browser APIs.\n\nSome browser APIs expect results inside of callbacks to be written to the DOM synchronously, by the end of the callback, so the browser can do something with the rendered DOM. In most cases, React handles this for you automatically. But in some cases it may be necessary to force a synchronous update.\n\nFor example, the browser onbeforeprint API allows you to change the page immediately before the print dialog opens. This is useful for applying custom print styles that allow the document to display better for printing. In the example below, you use flushSync inside of the onbeforeprint callback to immediately ‚Äúflush‚Äù the React state to the DOM. Then, by the time the print dialog opens, isPrinting displays ‚Äúyes‚Äù:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { flushSync } from 'react-dom';\n\nexport default function PrintApp() {\n  const [isPrinting, setIsPrinting] = useState(false);\n\n  useEffect(() => {\n    function handleBeforePrint() {\n      flushSync(() => {\n        setIsPrinting(true);\n      })\n    }\n\n    function handleAfterPrint() {\n      setIsPrinting(false);\n    }\n\n    window.addEventListener('beforeprint', handleBeforePrint);\n    window.addEventListener('afterprint', handleAfterPrint);\n    return () => {\n      window.removeEventListener('beforeprint', handleBeforePrint);\n      window.removeEventListener('afterprint', handleAfterPrint);\n    }\n  }, []);\n\n  return (\n    <>\n      <h1>isPrinting: {isPrinting ? 'yes' : 'no'}</h1>\n      <button onClick={() => window.print()}>\n        Print\n      </button>\n    </>\n  );\n}\n\n\nShow more\n\nWithout flushSync, the print dialog will display isPrinting as ‚Äúno‚Äù. This is because React batches the updates asynchronously and the print dialog is displayed before the state is updated.\n\nPitfall\n\nflushSync can significantly hurt performance, and may unexpectedly force pending Suspense boundaries to show their fallback state.\n\nMost of the time, flushSync can be avoided, so use flushSync as a last resort.\n\nTroubleshooting \nI‚Äôm getting an error: ‚ÄúflushSync was called from inside a lifecycle method‚Äù \n\nReact cannot flushSync in the middle of a render. If you do, it will noop and warn:\n\nConsole\nWarning: flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.\n\nThis includes calling flushSync inside:\n\nrendering a component.\nuseLayoutEffect or useEffect hooks.\nClass component lifecycle methods.\n\nFor example, calling flushSync in an Effect will noop and warn:\n\nimport { useEffect } from 'react';\n\nimport { flushSync } from 'react-dom';\n\n\n\nfunction MyComponent() {\n\n  useEffect(() => {\n\n    // üö© Wrong: calling flushSync inside an effect\n\n    flushSync(() => {\n\n      setSomething(newValue);\n\n    });\n\n  }, []);\n\n\n\n  return <div>{/* ... */}</div>;\n\n}\n\nTo fix this, you usually want to move the flushSync call to an event:\n\nfunction handleClick() {\n\n  // ‚úÖ Correct: flushSync in event handlers is safe\n\n  flushSync(() => {\n\n    setSomething(newValue);\n\n  });\n\n}\n\nIf it‚Äôs difficult to move to an event, you can defer flushSync in a microtask:\n\nuseEffect(() => {\n\n  // ‚úÖ Correct: defer flushSync to a microtask\n\n  queueMicrotask(() => {\n\n    flushSync(() => {\n\n      setSomething(newValue);\n\n    });\n\n  });\n\n}, []);\n\nThis will allow the current render to finish and schedule another syncronous render to flush the updates.\n\nPitfall\n\nflushSync can significantly hurt performance, but this particular pattern is even worse for performance. Exhaust all other options before calling flushSync in a microtask as an escape hatch.\n\nPREVIOUS\ncreatePortal\nNEXT\npreconnect"
  },
  {
    "title": "preconnect ‚Äì React",
    "url": "https://react.dev/reference/react-dom/preconnect",
    "html": "API REFERENCE\nAPIS\npreconnect\n\npreconnect lets you eagerly connect to a server that you expect to load resources from.\n\npreconnect(\"https://example.com\");\nReference\npreconnect(href)\nUsage\nPreconnecting when rendering\nPreconnecting in an event handler\nReference \npreconnect(href) \n\nTo preconnect to a host, call the preconnect function from react-dom.\n\nimport { preconnect } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preconnect(\"https://example.com\");\n\n  // ...\n\n}\n\nSee more examples below.\n\nThe preconnect function provides the browser with a hint that it should open a connection to the given server. If the browser chooses to do so, this can speed up the loading of resources from that server.\n\nParameters \nhref: a string. The URL of the server you want to connect to.\nReturns \n\npreconnect returns nothing.\n\nCaveats \nMultiple calls to preconnect with the same server have the same effect as a single call.\nIn the browser, you can call preconnect in any situation: while rendering a component, in an Effect, in an event handler, and so on.\nIn server-side rendering or when rendering Server Components, preconnect only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nIf you know the specific resources you‚Äôll need, you can call other functions instead that will start loading the resources right away.\nThere is no benefit to preconnecting to the same server the webpage itself is hosted from because it‚Äôs already been connected to by the time the hint would be given.\nUsage \nPreconnecting when rendering \n\nCall preconnect when rendering a component if you know that its children will load external resources from that host.\n\nimport { preconnect } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preconnect(\"https://example.com\");\n\n  return ...;\n\n}\nPreconnecting in an event handler \n\nCall preconnect in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\n\nimport { preconnect } from 'react-dom';\n\n\n\nfunction CallToAction() {\n\n  const onClick = () => {\n\n    preconnect('http://example.com');\n\n    startWizard();\n\n  }\n\n  return (\n\n    <button onClick={onClick}>Start Wizard</button>\n\n  );\n\n}\nPREVIOUS\nflushSync\nNEXT\nprefetchDNS"
  },
  {
    "title": "prefetchDNS ‚Äì React",
    "url": "https://react.dev/reference/react-dom/prefetchDNS",
    "html": "API REFERENCE\nAPIS\nprefetchDNS\n\nprefetchDNS lets you eagerly look up the IP of a server that you expect to load resources from.\n\nprefetchDNS(\"https://example.com\");\nReference\nprefetchDNS(href)\nUsage\nPrefetching DNS when rendering\nPrefetching DNS in an event handler\nReference \nprefetchDNS(href) \n\nTo look up a host, call the prefetchDNS function from react-dom.\n\nimport { prefetchDNS } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  prefetchDNS(\"https://example.com\");\n\n  // ...\n\n}\n\nSee more examples below.\n\nThe prefetchDNS function provides the browser with a hint that it should look up the IP address of a given server. If the browser chooses to do so, this can speed up the loading of resources from that server.\n\nParameters \nhref: a string. The URL of the server you want to connect to.\nReturns \n\nprefetchDNS returns nothing.\n\nCaveats \nMultiple calls to prefetchDNS with the same server have the same effect as a single call.\nIn the browser, you can call prefetchDNS in any situation: while rendering a component, in an Effect, in an event handler, and so on.\nIn server-side rendering or when rendering Server Components, prefetchDNS only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nIf you know the specific resources you‚Äôll need, you can call other functions instead that will start loading the resources right away.\nThere is no benefit to prefetching the same server the webpage itself is hosted from because it‚Äôs already been looked up by the time the hint would be given.\nCompared with preconnect, prefetchDNS may be better if you are speculatively connecting to a large number of domains, in which case the overhead of preconnections might outweigh the benefit.\nUsage \nPrefetching DNS when rendering \n\nCall prefetchDNS when rendering a component if you know that its children will load external resources from that host.\n\nimport { prefetchDNS } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  prefetchDNS(\"https://example.com\");\n\n  return ...;\n\n}\nPrefetching DNS in an event handler \n\nCall prefetchDNS in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\n\nimport { prefetchDNS } from 'react-dom';\n\n\n\nfunction CallToAction() {\n\n  const onClick = () => {\n\n    prefetchDNS('http://example.com');\n\n    startWizard();\n\n  }\n\n  return (\n\n    <button onClick={onClick}>Start Wizard</button>\n\n  );\n\n}\nPREVIOUS\npreconnect\nNEXT\npreinit"
  },
  {
    "title": "preinit ‚Äì React",
    "url": "https://react.dev/reference/react-dom/preinit",
    "html": "API REFERENCE\nAPIS\npreinit\nNote\n\nReact-based frameworks frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework‚Äôs documentation for details.\n\npreinit lets you eagerly fetch and evaluate a stylesheet or external script.\n\npreinit(\"https://example.com/script.js\", {as: \"script\"});\nReference\npreinit(href, options)\nUsage\nPreiniting when rendering\nPreiniting in an event handler\nReference \npreinit(href, options) \n\nTo preinit a script or stylesheet, call the preinit function from react-dom.\n\nimport { preinit } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preinit(\"https://example.com/script.js\", {as: \"script\"});\n\n  // ...\n\n}\n\nSee more examples below.\n\nThe preinit function provides the browser with a hint that it should start downloading and executing the given resource, which can save time. Scripts that you preinit are executed when they finish downloading. Stylesheets that you preinit are inserted into the document, which causes them to go into effect right away.\n\nParameters \nhref: a string. The URL of the resource you want to download and execute.\noptions: an object. It contains the following properties:\nas: a required string. The type of resource. Its possible values are script and style.\nprecedence: a string. Required with stylesheets. Says where to insert the stylesheet relative to others. Stylesheets with higher precedence can override those with lower precedence. The possible values are reset, low, medium, high.\ncrossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials.\nintegrity: a string. A cryptographic hash of the resource, to verify its authenticity.\nnonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.\nfetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values are auto (the default), high, and low.\nReturns \n\npreinit returns nothing.\n\nCaveats \nMultiple calls to preinit with the same href have the same effect as a single call.\nIn the browser, you can call preinit in any situation: while rendering a component, in an Effect, in an event handler, and so on.\nIn server-side rendering or when rendering Server Components, preinit only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nUsage \nPreiniting when rendering \n\nCall preinit when rendering a component if you know that it or its children will use a specific resource, and you‚Äôre OK with the resource being evaluated and thereby taking effect immediately upon being downloaded.\n\nExamples of preiniting\n1. Preiniting an external script\n2. Preiniting a stylesheet\nExample 1 of 2: Preiniting an external script \nimport { preinit } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preinit(\"https://example.com/script.js\", {as: \"script\"});\n\n  return ...;\n\n}\n\nIf you want the browser to download the script but not to execute it right away, use preload instead. If you want to load an ESM module, use preinitModule.\n\nNext Example\nPreiniting in an event handler \n\nCall preinit in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\n\nimport { preinit } from 'react-dom';\n\n\n\nfunction CallToAction() {\n\n  const onClick = () => {\n\n    preinit(\"https://example.com/wizardStyles.css\", {as: \"style\"});\n\n    startWizard();\n\n  }\n\n  return (\n\n    <button onClick={onClick}>Start Wizard</button>\n\n  );\n\n}\nPREVIOUS\nprefetchDNS\nNEXT\npreinitModule"
  },
  {
    "title": "preinitModule ‚Äì React",
    "url": "https://react.dev/reference/react-dom/preinitModule",
    "html": "API REFERENCE\nAPIS\npreinitModule\nNote\n\nReact-based frameworks frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework‚Äôs documentation for details.\n\npreinitModule lets you eagerly fetch and evaluate an ESM module.\n\npreinitModule(\"https://example.com/module.js\", {as: \"script\"});\nReference\npreinitModule(href, options)\nUsage\nPreloading when rendering\nPreloading in an event handler\nReference \npreinitModule(href, options) \n\nTo preinit an ESM module, call the preinitModule function from react-dom.\n\nimport { preinitModule } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preinitModule(\"https://example.com/module.js\", {as: \"script\"});\n\n  // ...\n\n}\n\nSee more examples below.\n\nThe preinitModule function provides the browser with a hint that it should start downloading and executing the given module, which can save time. Modules that you preinit are executed when they finish downloading.\n\nParameters \nhref: a string. The URL of the module you want to download and execute.\noptions: an object. It contains the following properties:\nas: a required string. It must be 'script'.\ncrossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials.\nintegrity: a string. A cryptographic hash of the module, to verify its authenticity.\nnonce: a string. A cryptographic nonce to allow the module when using a strict Content Security Policy.\nReturns \n\npreinitModule returns nothing.\n\nCaveats \nMultiple calls to preinitModule with the same href have the same effect as a single call.\nIn the browser, you can call preinitModule in any situation: while rendering a component, in an Effect, in an event handler, and so on.\nIn server-side rendering or when rendering Server Components, preinitModule only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nUsage \nPreloading when rendering \n\nCall preinitModule when rendering a component if you know that it or its children will use a specific module and you‚Äôre OK with the module being evaluated and thereby taking effect immediately upon being downloaded.\n\nimport { preinitModule } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preinitModule(\"https://example.com/module.js\", {as: \"script\"});\n\n  return ...;\n\n}\n\nIf you want the browser to download the module but not to execute it right away, use preloadModule instead. If you want to preinit a script that isn‚Äôt an ESM module, use preinit.\n\nPreloading in an event handler \n\nCall preinitModule in an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\n\nimport { preinitModule } from 'react-dom';\n\n\n\nfunction CallToAction() {\n\n  const onClick = () => {\n\n    preinitModule(\"https://example.com/module.js\", {as: \"script\"});\n\n    startWizard();\n\n  }\n\n  return (\n\n    <button onClick={onClick}>Start Wizard</button>\n\n  );\n\n}\nPREVIOUS\npreinit\nNEXT\npreload"
  },
  {
    "title": "preload ‚Äì React",
    "url": "https://react.dev/reference/react-dom/preload",
    "html": "API REFERENCE\nAPIS\npreload\nNote\n\nReact-based frameworks frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework‚Äôs documentation for details.\n\npreload lets you eagerly fetch a resource such as a stylesheet, font, or external script that you expect to use.\n\npreload(\"https://example.com/font.woff2\", {as: \"font\"});\nReference\npreload(href, options)\nUsage\nPreloading when rendering\nPreloading in an event handler\nReference \npreload(href, options) \n\nTo preload a resource, call the preload function from react-dom.\n\nimport { preload } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preload(\"https://example.com/font.woff2\", {as: \"font\"});\n\n  // ...\n\n}\n\nSee more examples below.\n\nThe preload function provides the browser with a hint that it should start downloading the given resource, which can save time.\n\nParameters \nhref: a string. The URL of the resource you want to download.\noptions: an object. It contains the following properties:\nas: a required string. The type of resource. Its possible values are audio, document, embed, fetch, font, image, object, script, style, track, video, worker.\ncrossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials. It is required when as is set to \"fetch\".\nreferrerPolicy: a string. The Referrer header to send when fetching. Its possible values are no-referrer-when-downgrade (the default), no-referrer, origin, origin-when-cross-origin, and unsafe-url.\nintegrity: a string. A cryptographic hash of the resource, to verify its authenticity.\ntype: a string. The MIME type of the resource.\nnonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.\nfetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values are auto (the default), high, and low.\nimageSrcSet: a string. For use only with as: \"image\". Specifies the source set of the image.\nimageSizes: a string. For use only with as: \"image\". Specifies the sizes of the image.\nReturns \n\npreload returns nothing.\n\nCaveats \nMultiple equivalent calls to preload have the same effect as a single call. Calls to preload are considered equivalent according to the following rules:\nTwo calls are equivalent if they have the same href, except:\nIf as is set to image, two calls are equivalent if they have the same href, imageSrcSet, and imageSizes.\nIn the browser, you can call preload in any situation: while rendering a component, in an Effect, in an event handler, and so on.\nIn server-side rendering or when rendering Server Components, preload only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nUsage \nPreloading when rendering \n\nCall preload when rendering a component if you know that it or its children will use a specific resource.\n\nExamples of preloading\n1. Preloading an external script\n2. Preloading a stylesheet\n3. Preloading a font\n4. Preloading an image\nExample 1 of 4: Preloading an external script \nimport { preload } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preload(\"https://example.com/script.js\", {as: \"script\"});\n\n  return ...;\n\n}\n\nIf you want the browser to start executing the script immediately (rather than just downloading it), use preinit instead. If you want to load an ESM module, use preloadModule.\n\nNext Example\nPreloading in an event handler \n\nCall preload in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\n\nimport { preload } from 'react-dom';\n\n\n\nfunction CallToAction() {\n\n  const onClick = () => {\n\n    preload(\"https://example.com/wizardStyles.css\", {as: \"style\"});\n\n    startWizard();\n\n  }\n\n  return (\n\n    <button onClick={onClick}>Start Wizard</button>\n\n  );\n\n}\nPREVIOUS\npreinitModule\nNEXT\npreloadModule"
  },
  {
    "title": "preloadModule ‚Äì React",
    "url": "https://react.dev/reference/react-dom/preloadModule",
    "html": "API REFERENCE\nAPIS\npreloadModule\nNote\n\nReact-based frameworks frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework‚Äôs documentation for details.\n\npreloadModule lets you eagerly fetch an ESM module that you expect to use.\n\npreloadModule(\"https://example.com/module.js\", {as: \"script\"});\nReference\npreloadModule(href, options)\nUsage\nPreloading when rendering\nPreloading in an event handler\nReference \npreloadModule(href, options) \n\nTo preload an ESM module, call the preloadModule function from react-dom.\n\nimport { preloadModule } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preloadModule(\"https://example.com/module.js\", {as: \"script\"});\n\n  // ...\n\n}\n\nSee more examples below.\n\nThe preloadModule function provides the browser with a hint that it should start downloading the given module, which can save time.\n\nParameters \nhref: a string. The URL of the module you want to download.\noptions: an object. It contains the following properties:\nas: a required string. It must be 'script'.\ncrossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials.\nintegrity: a string. A cryptographic hash of the module, to verify its authenticity.\nnonce: a string. A cryptographic nonce to allow the module when using a strict Content Security Policy.\nReturns \n\npreloadModule returns nothing.\n\nCaveats \nMultiple calls to preloadModule with the same href have the same effect as a single call.\nIn the browser, you can call preloadModule in any situation: while rendering a component, in an Effect, in an event handler, and so on.\nIn server-side rendering or when rendering Server Components, preloadModule only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nUsage \nPreloading when rendering \n\nCall preloadModule when rendering a component if you know that it or its children will use a specific module.\n\nimport { preloadModule } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preloadModule(\"https://example.com/module.js\", {as: \"script\"});\n\n  return ...;\n\n}\n\nIf you want the browser to start executing the module immediately (rather than just downloading it), use preinitModule instead. If you want to load a script that isn‚Äôt an ESM module, use preload.\n\nPreloading in an event handler \n\nCall preloadModule in an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\n\nimport { preloadModule } from 'react-dom';\n\n\n\nfunction CallToAction() {\n\n  const onClick = () => {\n\n    preloadModule(\"https://example.com/module.js\", {as: \"script\"});\n\n    startWizard();\n\n  }\n\n  return (\n\n    <button onClick={onClick}>Start Wizard</button>\n\n  );\n\n}\nPREVIOUS\npreload\nNEXT\nClient APIs"
  },
  {
    "title": "Client React DOM APIs ‚Äì React",
    "url": "https://react.dev/reference/react-dom/client",
    "html": "API REFERENCE\nClient React DOM APIs\n\nThe react-dom/client APIs let you render React components on the client (in the browser). These APIs are typically used at the top level of your app to initialize your React tree. A framework may call them for you. Most of your components don‚Äôt need to import or use them.\n\nClient APIs \ncreateRoot lets you create a root to display React components inside a browser DOM node.\nhydrateRoot lets you display React components inside a browser DOM node whose HTML content was previously generated by react-dom/server.\nBrowser support \n\nReact supports all popular browsers, including Internet Explorer 9 and above. Some polyfills are required for older browsers such as IE 9 and IE 10.\n\nPREVIOUS\npreloadModule\nNEXT\ncreateRoot"
  },
  {
    "title": "createRoot ‚Äì React",
    "url": "https://react.dev/reference/react-dom/client/createRoot",
    "html": "API REFERENCE\nCLIENT APIS\ncreateRoot\n\ncreateRoot lets you create a root to display React components inside a browser DOM node.\n\nconst root = createRoot(domNode, options?)\nReference\ncreateRoot(domNode, options?)\nroot.render(reactNode)\nroot.unmount()\nUsage\nRendering an app fully built with React\nRendering a page partially built with React\nUpdating a root component\nError logging in production\nTroubleshooting\nI‚Äôve created a root, but nothing is displayed\nI‚Äôm getting an error: ‚ÄúYou passed a second argument to root.render‚Äù\nI‚Äôm getting an error: ‚ÄúTarget container is not a DOM element‚Äù\nI‚Äôm getting an error: ‚ÄúFunctions are not valid as a React child.‚Äù\nMy server-rendered HTML gets re-created from scratch\nReference \ncreateRoot(domNode, options?) \n\nCall createRoot to create a React root for displaying content inside a browser DOM element.\n\nimport { createRoot } from 'react-dom/client';\n\n\n\nconst domNode = document.getElementById('root');\n\nconst root = createRoot(domNode);\n\nReact will create a root for the domNode, and take over managing the DOM inside it. After you‚Äôve created a root, you need to call root.render to display a React component inside of it:\n\nroot.render(<App />);\n\nAn app fully built with React will usually only have one createRoot call for its root component. A page that uses ‚Äúsprinkles‚Äù of React for parts of the page may have as many separate roots as needed.\n\nSee more examples below.\n\nParameters \n\ndomNode: A DOM element. React will create a root for this DOM element and allow you to call functions on the root, such as render to display rendered React content.\n\noptional options: An object with options for this React root.\n\noptional onCaughtError: Callback called when React catches an error in an Error Boundary. Called with the error caught by the Error Boundary, and an errorInfo object containing the componentStack.\noptional onUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with the error that was thrown, and an errorInfo object containing the componentStack.\noptional onRecoverableError: Callback called when React automatically recovers from errors. Called with an error React throws, and an errorInfo object containing the componentStack. Some recoverable errors may include the original error cause as error.cause.\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page.\nReturns \n\ncreateRoot returns an object with two methods: render and unmount.\n\nCaveats \nIf your app is server-rendered, using createRoot() is not supported. Use hydrateRoot() instead.\nYou‚Äôll likely have only one createRoot call in your app. If you use a framework, it might do this call for you.\nWhen you want to render a piece of JSX in a different part of the DOM tree that isn‚Äôt a child of your component (for example, a modal or a tooltip), use createPortal instead of createRoot.\nroot.render(reactNode) \n\nCall root.render to display a piece of JSX (‚ÄúReact node‚Äù) into the React root‚Äôs browser DOM node.\n\nroot.render(<App />);\n\nReact will display <App /> in the root, and take over managing the DOM inside it.\n\nSee more examples below.\n\nParameters \nreactNode: A React node that you want to display. This will usually be a piece of JSX like <App />, but you can also pass a React element constructed with createElement(), a string, a number, null, or undefined.\nReturns \n\nroot.render returns undefined.\n\nCaveats \n\nThe first time you call root.render, React will clear all the existing HTML content inside the React root before rendering the React component into it.\n\nIf your root‚Äôs DOM node contains HTML generated by React on the server or during the build, use hydrateRoot() instead, which attaches the event handlers to the existing HTML.\n\nIf you call render on the same root more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by ‚Äúmatching it up‚Äù with the previously rendered tree. Calling render on the same root again is similar to calling the set function on the root component: React avoids unnecessary DOM updates.\n\nAlthough rendering is synchronous once it starts, root.render(...) is not. This means code after root.render() may run before any effects (useLayoutEffect, useEffect) of that specific render are fired. This is usually fine and rarely needs adjustment. In rare cases where effect timing matters, you can wrap root.render(...) in flushSync to ensure the initial render runs fully synchronously.\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(<App />);\n\n// üö© The HTML will not include the rendered <App /> yet:\n\nconsole.log(document.body.innerHTML);\nroot.unmount() \n\nCall root.unmount to destroy a rendered tree inside a React root.\n\nroot.unmount();\n\nAn app fully built with React will usually not have any calls to root.unmount.\n\nThis is mostly useful if your React root‚Äôs DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. In that case, you need to tell React to ‚Äústop‚Äù managing the removed root‚Äôs content by calling root.unmount. Otherwise, the components inside the removed root won‚Äôt know to clean up and free up global resources like subscriptions.\n\nCalling root.unmount will unmount all the components in the root and ‚Äúdetach‚Äù React from the root DOM node, including removing any event handlers or state in the tree.\n\nParameters \n\nroot.unmount does not accept any parameters.\n\nReturns \n\nroot.unmount returns undefined.\n\nCaveats \n\nCalling root.unmount will unmount all the components in the tree and ‚Äúdetach‚Äù React from the root DOM node.\n\nOnce you call root.unmount you cannot call root.render again on the same root. Attempting to call root.render on an unmounted root will throw a ‚ÄúCannot update an unmounted root‚Äù error. However, you can create a new root for the same DOM node after the previous root for that node has been unmounted.\n\nUsage \nRendering an app fully built with React \n\nIf your app is fully built with React, create a single root for your entire app.\n\nimport { createRoot } from 'react-dom/client';\n\n\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(<App />);\n\nUsually, you only need to run this code once at startup. It will:\n\nFind the browser DOM node defined in your HTML.\nDisplay the React component for your app inside.\nindex.js\nindex.html\nApp.js\nReload\nClear\nFork\nimport { createRoot } from 'react-dom/client';\nimport App from './App.js';\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\n\n\n\nIf your app is fully built with React, you shouldn‚Äôt need to create any more roots, or to call root.render again.\n\nFrom this point on, React will manage the DOM of your entire app. To add more components, nest them inside the App component. When you need to update the UI, each of your components can do this by using state. When you need to display extra content like a modal or a tooltip outside the DOM node, render it with a portal.\n\nNote\n\nWhen your HTML is empty, the user sees a blank page until the app‚Äôs JavaScript code loads and runs:\n\n<div id=\"root\"></div>\n\nThis can feel very slow! To solve this, you can generate the initial HTML from your components on the server or during the build. Then your visitors can read text, see images, and click links before any of the JavaScript code loads. We recommend using a framework that does this optimization out of the box. Depending on when it runs, this is called server-side rendering (SSR) or static site generation (SSG).\n\nPitfall\n\nApps using server rendering or static generation must call hydrateRoot instead of createRoot. React will then hydrate (reuse) the DOM nodes from your HTML instead of destroying and re-creating them.\n\nRendering a page partially built with React \n\nIf your page isn‚Äôt fully built with React, you can call createRoot multiple times to create a root for each top-level piece of UI managed by React. You can display different content in each root by calling root.render.\n\nHere, two different React components are rendered into two DOM nodes defined in the index.html file:\n\nindex.js\nindex.html\nComponents.js\nReload\nClear\nFork\nimport './styles.css';\nimport { createRoot } from 'react-dom/client';\nimport { Comments, Navigation } from './Components.js';\n\nconst navDomNode = document.getElementById('navigation');\nconst navRoot = createRoot(navDomNode); \nnavRoot.render(<Navigation />);\n\nconst commentDomNode = document.getElementById('comments');\nconst commentRoot = createRoot(commentDomNode); \ncommentRoot.render(<Comments />);\n\n\n\nYou could also create a new DOM node with document.createElement() and add it to the document manually.\n\nconst domNode = document.createElement('div');\n\nconst root = createRoot(domNode); \n\nroot.render(<Comment />);\n\ndocument.body.appendChild(domNode); // You can add it anywhere in the document\n\nTo remove the React tree from the DOM node and clean up all the resources used by it, call root.unmount.\n\nroot.unmount();\n\nThis is mostly useful if your React components are inside an app written in a different framework.\n\nUpdating a root component \n\nYou can call render more than once on the same root. As long as the component tree structure matches up with what was previously rendered, React will preserve the state. Notice how you can type in the input, which means that the updates from repeated render calls every second in this example are not destructive:\n\nindex.js\nApp.js\nReload\nClear\nFork\nimport { createRoot } from 'react-dom/client';\nimport './styles.css';\nimport App from './App.js';\n\nconst root = createRoot(document.getElementById('root'));\n\nlet i = 0;\nsetInterval(() => {\n  root.render(<App counter={i} />);\n  i++;\n}, 1000);\n\n\n\nIt is uncommon to call render multiple times. Usually, your components will update state instead.\n\nError logging in production \n\nBy default, React will log all errors to the console. To implement your own error reporting, you can provide the optional error handler root options onUncaughtError, onCaughtError and onRecoverableError:\n\nimport { createRoot } from \"react-dom/client\";\n\nimport { reportCaughtError } from \"./reportError\";\n\n\n\nconst container = document.getElementById(\"root\");\n\nconst root = createRoot(container, {\n\n  onCaughtError: (error, errorInfo) => {\n\n    if (error.message !== \"Known error\") {\n\n      reportCaughtError({\n\n        error,\n\n        componentStack: errorInfo.componentStack,\n\n      });\n\n    }\n\n  },\n\n});\n\nThe onCaughtError option is a function called with two arguments:\n\nThe error that was thrown.\nAn errorInfo object that contains the componentStack of the error.\n\nTogether with onUncaughtError and onRecoverableError, you can can implement your own error reporting system:\n\nindex.js\nreportError.js\nApp.js\nReload\nClear\nFork\nimport { createRoot } from \"react-dom/client\";\nimport App from \"./App.js\";\nimport {\n  onCaughtErrorProd,\n  onRecoverableErrorProd,\n  onUncaughtErrorProd,\n} from \"./reportError\";\n\nconst container = document.getElementById(\"root\");\nconst root = createRoot(container, {\n  // Keep in mind to remove these options in development to leverage\n  // React's default handlers or implement your own overlay for development.\n  // The handlers are only specfied unconditionally here for demonstration purposes.\n  onCaughtError: onCaughtErrorProd,\n  onRecoverableError: onRecoverableErrorProd,\n  onUncaughtError: onUncaughtErrorProd,\n});\nroot.render(<App />);\n\n\nShow more\nTroubleshooting \nI‚Äôve created a root, but nothing is displayed \n\nMake sure you haven‚Äôt forgotten to actually render your app into the root:\n\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\n\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(<App />);\n\nUntil you do that, nothing is displayed.\n\nI‚Äôm getting an error: ‚ÄúYou passed a second argument to root.render‚Äù \n\nA common mistake is to pass the options for createRoot to root.render(...):\n\nConsole\nWarning: You passed a second argument to root.render(‚Ä¶) but it only accepts one argument.\n\nTo fix, pass the root options to createRoot(...), not root.render(...):\n\n// üö© Wrong: root.render only takes one argument.\n\nroot.render(App, {onUncaughtError});\n\n\n\n// ‚úÖ Correct: pass options to createRoot.\n\nconst root = createRoot(container, {onUncaughtError}); \n\nroot.render(<App />);\nI‚Äôm getting an error: ‚ÄúTarget container is not a DOM element‚Äù \n\nThis error means that whatever you‚Äôre passing to createRoot is not a DOM node.\n\nIf you‚Äôre not sure what‚Äôs happening, try logging it:\n\nconst domNode = document.getElementById('root');\n\nconsole.log(domNode); // ???\n\nconst root = createRoot(domNode);\n\nroot.render(<App />);\n\nFor example, if domNode is null, it means that getElementById returned null. This will happen if there is no node in the document with the given ID at the time of your call. There may be a few reasons for it:\n\nThe ID you‚Äôre looking for might differ from the ID you used in the HTML file. Check for typos!\nYour bundle‚Äôs <script> tag cannot ‚Äúsee‚Äù any DOM nodes that appear after it in the HTML.\n\nAnother common way to get this error is to write createRoot(<App />) instead of createRoot(domNode).\n\nI‚Äôm getting an error: ‚ÄúFunctions are not valid as a React child.‚Äù \n\nThis error means that whatever you‚Äôre passing to root.render is not a React component.\n\nThis may happen if you call root.render with Component instead of <Component />:\n\n// üö© Wrong: App is a function, not a Component.\n\nroot.render(App);\n\n\n\n// ‚úÖ Correct: <App /> is a component.\n\nroot.render(<App />);\n\nOr if you pass a function to root.render, instead of the result of calling it:\n\n// üö© Wrong: createApp is a function, not a component.\n\nroot.render(createApp);\n\n\n\n// ‚úÖ Correct: call createApp to return a component.\n\nroot.render(createApp());\nMy server-rendered HTML gets re-created from scratch \n\nIf your app is server-rendered and includes the initial HTML generated by React, you might notice that creating a root and calling root.render deletes all that HTML, and then re-creates all the DOM nodes from scratch. This can be slower, resets focus and scroll positions, and may lose other user input.\n\nServer-rendered apps must use hydrateRoot instead of createRoot:\n\nimport { hydrateRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\n\n\nhydrateRoot(\n\n  document.getElementById('root'),\n\n  <App />\n\n);\n\nNote that its API is different. In particular, usually there will be no further root.render call.\n\nPREVIOUS\nClient APIs\nNEXT\nhydrateRoot"
  },
  {
    "title": "hydrateRoot ‚Äì React",
    "url": "https://react.dev/reference/react-dom/client/hydrateRoot",
    "html": "API REFERENCE\nCLIENT APIS\nhydrateRoot\n\nhydrateRoot lets you display React components inside a browser DOM node whose HTML content was previously generated by react-dom/server.\n\nconst root = hydrateRoot(domNode, reactNode, options?)\nReference\nhydrateRoot(domNode, reactNode, options?)\nroot.render(reactNode)\nroot.unmount()\nUsage\nHydrating server-rendered HTML\nHydrating an entire document\nSuppressing unavoidable hydration mismatch errors\nHandling different client and server content\nUpdating a hydrated root component\nError logging in production\nTroubleshooting\nI‚Äôm getting an error: ‚ÄúYou passed a second argument to root.render‚Äù\nReference \nhydrateRoot(domNode, reactNode, options?) \n\nCall hydrateRoot to ‚Äúattach‚Äù React to existing HTML that was already rendered by React in a server environment.\n\nimport { hydrateRoot } from 'react-dom/client';\n\n\n\nconst domNode = document.getElementById('root');\n\nconst root = hydrateRoot(domNode, reactNode);\n\nReact will attach to the HTML that exists inside the domNode, and take over managing the DOM inside it. An app fully built with React will usually only have one hydrateRoot call with its root component.\n\nSee more examples below.\n\nParameters \n\ndomNode: A DOM element that was rendered as the root element on the server.\n\nreactNode: The ‚ÄúReact node‚Äù used to render the existing HTML. This will usually be a piece of JSX like <App /> which was rendered with a ReactDOM Server method such as renderToPipeableStream(<App />).\n\noptional options: An object with options for this React root.\n\noptional onCaughtError: Callback called when React catches an error in an Error Boundary. Called with the error caught by the Error Boundary, and an errorInfo object containing the componentStack.\noptional onUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with the error that was thrown and an errorInfo object containing the componentStack.\noptional onRecoverableError: Callback called when React automatically recovers from errors. Called with the error React throws, and an errorInfo object containing the componentStack. Some recoverable errors may include the original error cause as error.cause.\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server.\nReturns \n\nhydrateRoot returns an object with two methods: render and unmount.\n\nCaveats \nhydrateRoot() expects the rendered content to be identical with the server-rendered content. You should treat mismatches as bugs and fix them.\nIn development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.\nYou‚Äôll likely have only one hydrateRoot call in your app. If you use a framework, it might do this call for you.\nIf your app is client-rendered with no HTML rendered already, using hydrateRoot() is not supported. Use createRoot() instead.\nroot.render(reactNode) \n\nCall root.render to update a React component inside a hydrated React root for a browser DOM element.\n\nroot.render(<App />);\n\nReact will update <App /> in the hydrated root.\n\nSee more examples below.\n\nParameters \nreactNode: A ‚ÄúReact node‚Äù that you want to update. This will usually be a piece of JSX like <App />, but you can also pass a React element constructed with createElement(), a string, a number, null, or undefined.\nReturns \n\nroot.render returns undefined.\n\nCaveats \nIf you call root.render before the root has finished hydrating, React will clear the existing server-rendered HTML content and switch the entire root to client rendering.\nroot.unmount() \n\nCall root.unmount to destroy a rendered tree inside a React root.\n\nroot.unmount();\n\nAn app fully built with React will usually not have any calls to root.unmount.\n\nThis is mostly useful if your React root‚Äôs DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. You need to tell React to ‚Äústop‚Äù managing the removed root‚Äôs content by calling root.unmount. Otherwise, the components inside the removed root won‚Äôt clean up and free up resources like subscriptions.\n\nCalling root.unmount will unmount all the components in the root and ‚Äúdetach‚Äù React from the root DOM node, including removing any event handlers or state in the tree.\n\nParameters \n\nroot.unmount does not accept any parameters.\n\nReturns \n\nroot.unmount returns undefined.\n\nCaveats \n\nCalling root.unmount will unmount all the components in the tree and ‚Äúdetach‚Äù React from the root DOM node.\n\nOnce you call root.unmount you cannot call root.render again on the root. Attempting to call root.render on an unmounted root will throw a ‚ÄúCannot update an unmounted root‚Äù error.\n\nUsage \nHydrating server-rendered HTML \n\nIf your app‚Äôs HTML was generated by react-dom/server, you need to hydrate it on the client.\n\nimport { hydrateRoot } from 'react-dom/client';\n\n\n\nhydrateRoot(document.getElementById('root'), <App />);\n\nThis will hydrate the server HTML inside the browser DOM node with the React component for your app. Usually, you will do it once at startup. If you use a framework, it might do this behind the scenes for you.\n\nTo hydrate your app, React will ‚Äúattach‚Äù your components‚Äô logic to the initial generated HTML from the server. Hydration turns the initial HTML snapshot from the server into a fully interactive app that runs in the browser.\n\nindex.js\nindex.html\nApp.js\nReload\nClear\nFork\nimport './styles.css';\nimport { hydrateRoot } from 'react-dom/client';\nimport App from './App.js';\n\nhydrateRoot(\n  document.getElementById('root'),\n  <App />\n);\n\n\n\nYou shouldn‚Äôt need to call hydrateRoot again or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will use state instead.\n\nPitfall\n\nThe React tree you pass to hydrateRoot needs to produce the same output as it did on the server.\n\nThis is important for the user experience. The user will spend some time looking at the server-generated HTML before your JavaScript code loads. Server rendering creates an illusion that the app loads faster by showing the HTML snapshot of its output. Suddenly showing different content breaks that illusion. This is why the server render output must match the initial render output on the client.\n\nThe most common causes leading to hydration errors include:\n\nExtra whitespace (like newlines) around the React-generated HTML inside the root node.\nUsing checks like typeof window !== 'undefined' in your rendering logic.\nUsing browser-only APIs like window.matchMedia in your rendering logic.\nRendering different data on the server and the client.\n\nReact recovers from some hydration errors, but you must fix them like other bugs. In the best case, they‚Äôll lead to a slowdown; in the worst case, event handlers can get attached to the wrong elements.\n\nHydrating an entire document \n\nApps fully built with React can render the entire document as JSX, including the <html> tag:\n\nfunction App() {\n\n  return (\n\n    <html>\n\n      <head>\n\n        <meta charSet=\"utf-8\" />\n\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\n        <link rel=\"stylesheet\" href=\"/styles.css\"></link>\n\n        <title>My app</title>\n\n      </head>\n\n      <body>\n\n        <Router />\n\n      </body>\n\n    </html>\n\n  );\n\n}\n\nTo hydrate the entire document, pass the document global as the first argument to hydrateRoot:\n\nimport { hydrateRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\n\n\nhydrateRoot(document, <App />);\nSuppressing unavoidable hydration mismatch errors \n\nIf a single element‚Äôs attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning.\n\nTo silence hydration warnings on an element, add suppressHydrationWarning={true}:\n\nindex.js\nindex.html\nApp.js\nReload\nClear\nFork\nexport default function App() {\n  return (\n    <h1 suppressHydrationWarning={true}>\n      Current Date: {new Date().toLocaleDateString()}\n    </h1>\n  );\n}\n\n\n\nThis only works one level deep, and is intended to be an escape hatch. Don‚Äôt overuse it. React will not attempt to patch mismatched text content.\n\nHandling different client and server content \n\nIf you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a state variable like isClient, which you can set to true in an Effect:\n\nindex.js\nindex.html\nApp.js\nReload\nClear\nFork\nimport { useState, useEffect } from \"react\";\n\nexport default function App() {\n  const [isClient, setIsClient] = useState(false);\n\n  useEffect(() => {\n    setIsClient(true);\n  }, []);\n\n  return (\n    <h1>\n      {isClient ? 'Is Client' : 'Is Server'}\n    </h1>\n  );\n}\n\n\n\nThis way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration.\n\nPitfall\n\nThis approach makes hydration slower because your components have to render twice. Be mindful of the user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so rendering a different UI immediately after hydration may also feel jarring to the user.\n\nUpdating a hydrated root component \n\nAfter the root has finished hydrating, you can call root.render to update the root React component. Unlike with createRoot, you don‚Äôt usually need to do this because the initial content was already rendered as HTML.\n\nIf you call root.render at some point after hydration, and the component tree structure matches up with what was previously rendered, React will preserve the state. Notice how you can type in the input, which means that the updates from repeated render calls every second in this example are not destructive:\n\nindex.js\nindex.html\nApp.js\nReload\nClear\nFork\nimport { hydrateRoot } from 'react-dom/client';\nimport './styles.css';\nimport App from './App.js';\n\nconst root = hydrateRoot(\n  document.getElementById('root'),\n  <App counter={0} />\n);\n\nlet i = 0;\nsetInterval(() => {\n  root.render(<App counter={i} />);\n  i++;\n}, 1000);\n\n\n\nIt is uncommon to call root.render on a hydrated root. Usually, you‚Äôll update state inside one of the components instead.\n\nError logging in production \n\nBy default, React will log all errors to the console. To implement your own error reporting, you can provide the optional error handler root options onUncaughtError, onCaughtError and onRecoverableError:\n\nimport { hydrateRoot } from \"react-dom/client\";\n\nimport App from \"./App.js\";\n\nimport { reportCaughtError } from \"./reportError\";\n\n\n\nconst container = document.getElementById(\"root\");\n\nconst root = hydrateRoot(container, <App />, {\n\n  onCaughtError: (error, errorInfo) => {\n\n    if (error.message !== \"Known error\") {\n\n      reportCaughtError({\n\n        error,\n\n        componentStack: errorInfo.componentStack,\n\n      });\n\n    }\n\n  },\n\n});\n\nThe onCaughtError option is a function called with two arguments:\n\nThe error that was thrown.\nAn errorInfo object that contains the componentStack of the error.\n\nTogether with onUncaughtError and onRecoverableError, you can implement your own error reporting system:\n\nindex.js\nreportError.js\nApp.js\nReload\nClear\nFork\nimport { hydrateRoot } from \"react-dom/client\";\nimport App from \"./App.js\";\nimport {\n  onCaughtErrorProd,\n  onRecoverableErrorProd,\n  onUncaughtErrorProd,\n} from \"./reportError\";\n\nconst container = document.getElementById(\"root\");\nhydrateRoot(container, <App />, {\n  // Keep in mind to remove these options in development to leverage\n  // React's default handlers or implement your own overlay for development.\n  // The handlers are only specfied unconditionally here for demonstration purposes.\n  onCaughtError: onCaughtErrorProd,\n  onRecoverableError: onRecoverableErrorProd,\n  onUncaughtError: onUncaughtErrorProd,\n});\n\n\nShow more\nTroubleshooting \nI‚Äôm getting an error: ‚ÄúYou passed a second argument to root.render‚Äù \n\nA common mistake is to pass the options for hydrateRoot to root.render(...):\n\nConsole\nWarning: You passed a second argument to root.render(‚Ä¶) but it only accepts one argument.\n\nTo fix, pass the root options to hydrateRoot(...), not root.render(...):\n\n// üö© Wrong: root.render only takes one argument.\n\nroot.render(App, {onUncaughtError});\n\n\n\n// ‚úÖ Correct: pass options to createRoot.\n\nconst root = hydrateRoot(container, <App />, {onUncaughtError});\nPREVIOUS\ncreateRoot\nNEXT\nServer APIs"
  },
  {
    "title": "Server React DOM APIs ‚Äì React",
    "url": "https://react.dev/reference/react-dom/server",
    "html": "API REFERENCE\nServer React DOM APIs\n\nThe react-dom/server APIs let you server-side render React components to HTML. These APIs are only used on the server at the top level of your app to generate the initial HTML. A framework may call them for you. Most of your components don‚Äôt need to import or use them.\n\nServer APIs for Web Streams \n\nThese methods are only available in the environments with Web Streams, which includes browsers, Deno, and some modern edge runtimes:\n\nrenderToReadableStream renders a React tree to a Readable Web Stream.\nresume resumes prerender to a Readable Web Stream.\nNote\n\nNode.js also includes these methods for compatibility, but they are not recommended due to worse performance. Use the dedicated Node.js APIs instead.\n\nServer APIs for Node.js Streams \n\nThese methods are only available in the environments with Node.js Streams:\n\nrenderToPipeableStream renders a React tree to a pipeable Node.js Stream.\nresumeToPipeableStream resumes prerenderToNodeStream to a pipeable Node.js Stream.\nLegacy Server APIs for non-streaming environments \n\nThese methods can be used in the environments that don‚Äôt support streams:\n\nrenderToString renders a React tree to a string.\nrenderToStaticMarkup renders a non-interactive React tree to a string.\n\nThey have limited functionality compared to the streaming APIs.\n\nPREVIOUS\nhydrateRoot\nNEXT\nrenderToPipeableStream"
  },
  {
    "title": "renderToPipeableStream ‚Äì React",
    "url": "https://react.dev/reference/react-dom/server/renderToPipeableStream",
    "html": "API REFERENCE\nSERVER APIS\nrenderToPipeableStream\n\nrenderToPipeableStream renders a React tree to a pipeable Node.js Stream.\n\nconst { pipe, abort } = renderToPipeableStream(reactNode, options?)\nReference\nrenderToPipeableStream(reactNode, options?)\nUsage\nRendering a React tree as HTML to a Node.js Stream\nStreaming more content as it loads\nSpecifying what goes into the shell\nLogging crashes on the server\nRecovering from errors inside the shell\nRecovering from errors outside the shell\nSetting the status code\nHandling different errors in different ways\nWaiting for all content to load for crawlers and static generation\nAborting server rendering\nNote\n\nThis API is specific to Node.js. Environments with Web Streams, like Deno and modern edge runtimes, should use renderToReadableStream instead.\n\nReference \nrenderToPipeableStream(reactNode, options?) \n\nCall renderToPipeableStream to render your React tree as HTML into a Node.js Stream.\n\nimport { renderToPipeableStream } from 'react-dom/server';\n\n\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    response.setHeader('content-type', 'text/html');\n\n    pipe(response);\n\n  }\n\n});\n\nOn the client, call hydrateRoot to make the server-generated HTML interactive.\n\nSee more examples below.\n\nParameters \n\nreactNode: A React node you want to render to HTML. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\n\noptional options: An object with streaming options.\n\noptional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag.\noptional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don‚Äôt want to run React on the client at all.\noptional bootstrapModules: Like bootstrapScripts, but emits <script type=\"module\"> instead.\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.\noptional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML.\noptional nonce: A nonce string to allow scripts for script-src Content-Security-Policy.\noptional onAllReady: A callback that fires when all rendering is complete, including both the shell and all additional content. You can use this instead of onShellReady for crawlers and static generation. If you start streaming here, you won‚Äôt get any progressive loading. The stream will contain the final HTML.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted.\noptional onShellReady: A callback that fires right after the initial shell has been rendered. You can set the status code and call pipe here to start streaming. React will stream the additional content after the shell along with the inline <script> tags that replace the HTML loading fallbacks with the content.\noptional onShellError: A callback that fires if there was an error rendering the initial shell. It receives the error as an argument. No bytes were emitted from the stream yet, and neither onShellReady nor onAllReady will get called, so you can output a fallback HTML shell.\noptional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic.\nReturns \n\nrenderToPipeableStream returns an object with two methods:\n\npipe outputs the HTML into the provided Writable Node.js Stream. Call pipe in onShellReady if you want to enable streaming, or in onAllReady for crawlers and static generation.\nabort lets you abort server rendering and render the rest on the client.\nUsage \nRendering a React tree as HTML to a Node.js Stream \n\nCall renderToPipeableStream to render your React tree as HTML into a Node.js Stream:\n\nimport { renderToPipeableStream } from 'react-dom/server';\n\n\n\n// The route handler syntax depends on your backend framework\n\napp.use('/', (request, response) => {\n\n  const { pipe } = renderToPipeableStream(<App />, {\n\n    bootstrapScripts: ['/main.js'],\n\n    onShellReady() {\n\n      response.setHeader('content-type', 'text/html');\n\n      pipe(response);\n\n    }\n\n  });\n\n});\n\nAlong with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.\n\nFor example, it might look like this:\n\nexport default function App() {\n\n  return (\n\n    <html>\n\n      <head>\n\n        <meta charSet=\"utf-8\" />\n\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\n        <link rel=\"stylesheet\" href=\"/styles.css\"></link>\n\n        <title>My app</title>\n\n      </head>\n\n      <body>\n\n        <Router />\n\n      </body>\n\n    </html>\n\n  );\n\n}\n\nReact will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:\n\n<!DOCTYPE html>\n\n<html>\n\n  <!-- ... HTML from your components ... -->\n\n</html>\n\n<script src=\"/main.js\" async=\"\"></script>\n\nOn the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:\n\nimport { hydrateRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\n\n\nhydrateRoot(document, <App />);\n\nThis will attach event listeners to the server-generated HTML and make it interactive.\n\nDEEP DIVE\nReading CSS and JS asset paths from the build output \nShow Details\nStreaming more content as it loads \n\nStreaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Sidebar>\n\n        <Friends />\n\n        <Photos />\n\n      </Sidebar>\n\n      <Posts />\n\n    </ProfileLayout>\n\n  );\n\n}\n\nImagine that loading data for <Posts /> takes some time. Ideally, you‚Äôd want to show the rest of the profile page content to the user without waiting for the posts. To do this, wrap Posts in a <Suspense> boundary:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Sidebar>\n\n        <Friends />\n\n        <Photos />\n\n      </Sidebar>\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nThis tells React to start streaming the HTML before Posts loads its data. React will send the HTML for the loading fallback (PostsGlimmer) first, and then, when Posts finishes loading its data, React will send the remaining HTML along with an inline <script> tag that replaces the loading fallback with that HTML. From the user‚Äôs perspective, the page will first appear with the PostsGlimmer, later replaced by the Posts.\n\nYou can further nest <Suspense> boundaries to create a more granular loading sequence:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<BigSpinner />}>\n\n        <Sidebar>\n\n          <Friends />\n\n          <Photos />\n\n        </Sidebar>\n\n        <Suspense fallback={<PostsGlimmer />}>\n\n          <Posts />\n\n        </Suspense>\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIn this example, React can start streaming the page even earlier. Only ProfileLayout and ProfileCover must finish rendering first because they are not wrapped in any <Suspense> boundary. However, if Sidebar, Friends, or Photos need to load some data, React will send the HTML for the BigSpinner fallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.\n\nStreaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the <script> tags load.\n\nRead more about how streaming HTML works.\n\nNote\n\nOnly Suspense-enabled data sources will activate the Suspense component. They include:\n\nData fetching with Suspense-enabled frameworks like Relay and Next.js\nLazy-loading component code with lazy\nReading the value of a Promise with use\n\nSuspense does not detect when data is fetched inside an Effect or event handler.\n\nThe exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you‚Äôll find the details in its data fetching documentation.\n\nSuspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.\n\nSpecifying what goes into the shell \n\nThe part of your app outside of any <Suspense> boundaries is called the shell:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<BigSpinner />}>\n\n        <Sidebar>\n\n          <Friends />\n\n          <Photos />\n\n        </Sidebar>\n\n        <Suspense fallback={<PostsGlimmer />}>\n\n          <Posts />\n\n        </Suspense>\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIt determines the earliest loading state that the user may see:\n\n<ProfileLayout>\n\n  <ProfileCover />\n\n  <BigSpinner />\n\n</ProfileLayout>\n\nIf you wrap the whole app into a <Suspense> boundary at the root, the shell will only contain that spinner. However, that‚Äôs not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you‚Äôll want to place the <Suspense> boundaries so that the shell feels minimal but complete‚Äîlike a skeleton of the entire page layout.\n\nThe onShellReady callback fires when the entire shell has been rendered. Usually, you‚Äôll start streaming then:\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    response.setHeader('content-type', 'text/html');\n\n    pipe(response);\n\n  }\n\n});\n\nBy the time onShellReady fires, components in nested <Suspense> boundaries might still be loading data.\n\nLogging crashes on the server \n\nBy default, all errors on the server are logged to console. You can override this behavior to log crash reports:\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    response.setHeader('content-type', 'text/html');\n\n    pipe(response);\n\n  },\n\n  onError(error) {\n\n    console.error(error);\n\n    logServerCrashReport(error);\n\n  }\n\n});\n\nIf you provide a custom onError implementation, don‚Äôt forget to also log errors to the console like above.\n\nRecovering from errors inside the shell \n\nIn this example, the shell contains ProfileLayout, ProfileCover, and PostsGlimmer:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIf an error occurs while rendering those components, React won‚Äôt have any meaningful HTML to send to the client. Override onShellError to send a fallback HTML that doesn‚Äôt rely on server rendering as the last resort:\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    response.setHeader('content-type', 'text/html');\n\n    pipe(response);\n\n  },\n\n  onShellError(error) {\n\n    response.statusCode = 500;\n\n    response.setHeader('content-type', 'text/html');\n\n    response.send('<h1>Something went wrong</h1>'); \n\n  },\n\n  onError(error) {\n\n    console.error(error);\n\n    logServerCrashReport(error);\n\n  }\n\n});\n\nIf there is an error while generating the shell, both onError and onShellError will fire. Use onError for error reporting and use onShellError to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.\n\nRecovering from errors outside the shell \n\nIn this example, the <Posts /> component is wrapped in <Suspense> so it is not a part of the shell:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIf an error happens in the Posts component or somewhere inside it, React will try to recover from it:\n\nIt will emit the loading fallback for the closest <Suspense> boundary (PostsGlimmer) into the HTML.\nIt will ‚Äúgive up‚Äù on trying to render the Posts content on the server anymore.\nWhen the JavaScript code loads on the client, React will retry rendering Posts on the client.\n\nIf retrying rendering Posts on the client also fails, React will throw the error on the client. As with all the errors thrown during rendering, the closest parent error boundary determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.\n\nIf retrying rendering Posts on the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server onError callback and the client onRecoverableError callbacks will fire so that you can get notified about the error.\n\nSetting the status code \n\nStreaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.\n\nBy dividing your app into the shell (above all <Suspense> boundaries) and the rest of the content, you‚Äôve already solved a part of this problem. If the shell errors, you‚Äôll get the onShellError callback which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send ‚ÄúOK‚Äù.\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    response.statusCode = 200;\n\n    response.setHeader('content-type', 'text/html');\n\n    pipe(response);\n\n  },\n\n  onShellError(error) {\n\n    response.statusCode = 500;\n\n    response.setHeader('content-type', 'text/html');\n\n    response.send('<h1>Something went wrong</h1>'); \n\n  },\n\n  onError(error) {\n\n    console.error(error);\n\n    logServerCrashReport(error);\n\n  }\n\n});\n\nIf a component outside the shell (i.e. inside a <Suspense> boundary) throws an error, React will not stop rendering. This means that the onError callback will fire, but you will still get onShellReady instead of onShellError. This is because React will try to recover from that error on the client, as described above.\n\nHowever, if you‚Äôd like, you can use the fact that something has errored to set the status code:\n\nlet didError = false;\n\n\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    response.statusCode = didError ? 500 : 200;\n\n    response.setHeader('content-type', 'text/html');\n\n    pipe(response);\n\n  },\n\n  onShellError(error) {\n\n    response.statusCode = 500;\n\n    response.setHeader('content-type', 'text/html');\n\n    response.send('<h1>Something went wrong</h1>'); \n\n  },\n\n  onError(error) {\n\n    didError = true;\n\n    console.error(error);\n\n    logServerCrashReport(error);\n\n  }\n\n});\n\nThis will only catch errors outside the shell that happened while generating the initial shell content, so it‚Äôs not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.\n\nHandling different errors in different ways \n\nYou can create your own Error subclasses and use the instanceof operator to check which error is thrown. For example, you can define a custom NotFoundError and throw it from your component. Then your onError, onShellReady, and onShellError callbacks can do something different depending on the error type:\n\nlet didError = false;\n\nlet caughtError = null;\n\n\n\nfunction getStatusCode() {\n\n  if (didError) {\n\n    if (caughtError instanceof NotFoundError) {\n\n      return 404;\n\n    } else {\n\n      return 500;\n\n    }\n\n  } else {\n\n    return 200;\n\n  }\n\n}\n\n\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    response.statusCode = getStatusCode();\n\n    response.setHeader('content-type', 'text/html');\n\n    pipe(response);\n\n  },\n\n  onShellError(error) {\n\n   response.statusCode = getStatusCode();\n\n   response.setHeader('content-type', 'text/html');\n\n   response.send('<h1>Something went wrong</h1>'); \n\n  },\n\n  onError(error) {\n\n    didError = true;\n\n    caughtError = error;\n\n    console.error(error);\n\n    logServerCrashReport(error);\n\n  }\n\n});\n\nKeep in mind that once you emit the shell and start streaming, you can‚Äôt change the status code.\n\nWaiting for all content to load for crawlers and static generation \n\nStreaming offers a better user experience because the user can see the content as it becomes available.\n\nHowever, when a crawler visits your page, or if you‚Äôre generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.\n\nYou can wait for all the content to load using the onAllReady callback:\n\nlet didError = false;\n\nlet isCrawler = // ... depends on your bot detection strategy ...\n\n\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    if (!isCrawler) {\n\n      response.statusCode = didError ? 500 : 200;\n\n      response.setHeader('content-type', 'text/html');\n\n      pipe(response);\n\n    }\n\n  },\n\n  onShellError(error) {\n\n    response.statusCode = 500;\n\n    response.setHeader('content-type', 'text/html');\n\n    response.send('<h1>Something went wrong</h1>'); \n\n  },\n\n  onAllReady() {\n\n    if (isCrawler) {\n\n      response.statusCode = didError ? 500 : 200;\n\n      response.setHeader('content-type', 'text/html');\n\n      pipe(response);      \n\n    }\n\n  },\n\n  onError(error) {\n\n    didError = true;\n\n    console.error(error);\n\n    logServerCrashReport(error);\n\n  }\n\n});\n\nA regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for all data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.\n\nAborting server rendering \n\nYou can force the server rendering to ‚Äúgive up‚Äù after a timeout:\n\nconst { pipe, abort } = renderToPipeableStream(<App />, {\n\n  // ...\n\n});\n\n\n\nsetTimeout(() => {\n\n  abort();\n\n}, 10000);\n\nReact will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.\n\nPREVIOUS\nServer APIs\nNEXT\nrenderToReadableStream"
  },
  {
    "title": "renderToReadableStream ‚Äì React",
    "url": "https://react.dev/reference/react-dom/server/renderToReadableStream",
    "html": "API REFERENCE\nSERVER APIS\nrenderToReadableStream\n\nrenderToReadableStream renders a React tree to a Readable Web Stream.\n\nconst stream = await renderToReadableStream(reactNode, options?)\nReference\nrenderToReadableStream(reactNode, options?)\nUsage\nRendering a React tree as HTML to a Readable Web Stream\nStreaming more content as it loads\nSpecifying what goes into the shell\nLogging crashes on the server\nRecovering from errors inside the shell\nRecovering from errors outside the shell\nSetting the status code\nHandling different errors in different ways\nWaiting for all content to load for crawlers and static generation\nAborting server rendering\nNote\n\nThis API depends on Web Streams. For Node.js, use renderToPipeableStream instead.\n\nReference \nrenderToReadableStream(reactNode, options?) \n\nCall renderToReadableStream to render your React tree as HTML into a Readable Web Stream.\n\nimport { renderToReadableStream } from 'react-dom/server';\n\n\n\nasync function handler(request) {\n\n  const stream = await renderToReadableStream(<App />, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n  return new Response(stream, {\n\n    headers: { 'content-type': 'text/html' },\n\n  });\n\n}\n\nOn the client, call hydrateRoot to make the server-generated HTML interactive.\n\nSee more examples below.\n\nParameters \n\nreactNode: A React node you want to render to HTML. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\n\noptional options: An object with streaming options.\n\noptional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag.\noptional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don‚Äôt want to run React on the client at all.\noptional bootstrapModules: Like bootstrapScripts, but emits <script type=\"module\"> instead.\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.\noptional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML.\noptional nonce: A nonce string to allow scripts for script-src Content-Security-Policy.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted.\noptional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic.\noptional signal: An abort signal that lets you abort server rendering and render the rest on the client.\nReturns \n\nrenderToReadableStream returns a Promise:\n\nIf rendering the shell is successful, that Promise will resolve to a Readable Web Stream.\nIf rendering the shell fails, the Promise will be rejected. Use this to output a fallback shell.\n\nThe returned stream has an additional property:\n\nallReady: A Promise that resolves when all rendering is complete, including both the shell and all additional content. You can await stream.allReady before returning a response for crawlers and static generation. If you do that, you won‚Äôt get any progressive loading. The stream will contain the final HTML.\nUsage \nRendering a React tree as HTML to a Readable Web Stream \n\nCall renderToReadableStream to render your React tree as HTML into a Readable Web Stream:\n\nimport { renderToReadableStream } from 'react-dom/server';\n\n\n\nasync function handler(request) {\n\n  const stream = await renderToReadableStream(<App />, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n  return new Response(stream, {\n\n    headers: { 'content-type': 'text/html' },\n\n  });\n\n}\n\nAlong with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.\n\nFor example, it might look like this:\n\nexport default function App() {\n\n  return (\n\n    <html>\n\n      <head>\n\n        <meta charSet=\"utf-8\" />\n\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\n        <link rel=\"stylesheet\" href=\"/styles.css\"></link>\n\n        <title>My app</title>\n\n      </head>\n\n      <body>\n\n        <Router />\n\n      </body>\n\n    </html>\n\n  );\n\n}\n\nReact will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:\n\n<!DOCTYPE html>\n\n<html>\n\n  <!-- ... HTML from your components ... -->\n\n</html>\n\n<script src=\"/main.js\" async=\"\"></script>\n\nOn the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:\n\nimport { hydrateRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\n\n\nhydrateRoot(document, <App />);\n\nThis will attach event listeners to the server-generated HTML and make it interactive.\n\nDEEP DIVE\nReading CSS and JS asset paths from the build output \nShow Details\nStreaming more content as it loads \n\nStreaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Sidebar>\n\n        <Friends />\n\n        <Photos />\n\n      </Sidebar>\n\n      <Posts />\n\n    </ProfileLayout>\n\n  );\n\n}\n\nImagine that loading data for <Posts /> takes some time. Ideally, you‚Äôd want to show the rest of the profile page content to the user without waiting for the posts. To do this, wrap Posts in a <Suspense> boundary:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Sidebar>\n\n        <Friends />\n\n        <Photos />\n\n      </Sidebar>\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nThis tells React to start streaming the HTML before Posts loads its data. React will send the HTML for the loading fallback (PostsGlimmer) first, and then, when Posts finishes loading its data, React will send the remaining HTML along with an inline <script> tag that replaces the loading fallback with that HTML. From the user‚Äôs perspective, the page will first appear with the PostsGlimmer, later replaced by the Posts.\n\nYou can further nest <Suspense> boundaries to create a more granular loading sequence:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<BigSpinner />}>\n\n        <Sidebar>\n\n          <Friends />\n\n          <Photos />\n\n        </Sidebar>\n\n        <Suspense fallback={<PostsGlimmer />}>\n\n          <Posts />\n\n        </Suspense>\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIn this example, React can start streaming the page even earlier. Only ProfileLayout and ProfileCover must finish rendering first because they are not wrapped in any <Suspense> boundary. However, if Sidebar, Friends, or Photos need to load some data, React will send the HTML for the BigSpinner fallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.\n\nStreaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the <script> tags load.\n\nRead more about how streaming HTML works.\n\nNote\n\nOnly Suspense-enabled data sources will activate the Suspense component. They include:\n\nData fetching with Suspense-enabled frameworks like Relay and Next.js\nLazy-loading component code with lazy\nReading the value of a Promise with use\n\nSuspense does not detect when data is fetched inside an Effect or event handler.\n\nThe exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you‚Äôll find the details in its data fetching documentation.\n\nSuspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.\n\nSpecifying what goes into the shell \n\nThe part of your app outside of any <Suspense> boundaries is called the shell:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<BigSpinner />}>\n\n        <Sidebar>\n\n          <Friends />\n\n          <Photos />\n\n        </Sidebar>\n\n        <Suspense fallback={<PostsGlimmer />}>\n\n          <Posts />\n\n        </Suspense>\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIt determines the earliest loading state that the user may see:\n\n<ProfileLayout>\n\n  <ProfileCover />\n\n  <BigSpinner />\n\n</ProfileLayout>\n\nIf you wrap the whole app into a <Suspense> boundary at the root, the shell will only contain that spinner. However, that‚Äôs not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you‚Äôll want to place the <Suspense> boundaries so that the shell feels minimal but complete‚Äîlike a skeleton of the entire page layout.\n\nThe async call to renderToReadableStream will resolve to a stream as soon as the entire shell has been rendered. Usually, you‚Äôll start streaming then by creating and returning a response with that stream:\n\nasync function handler(request) {\n\n  const stream = await renderToReadableStream(<App />, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n  return new Response(stream, {\n\n    headers: { 'content-type': 'text/html' },\n\n  });\n\n}\n\nBy the time the stream is returned, components in nested <Suspense> boundaries might still be loading data.\n\nLogging crashes on the server \n\nBy default, all errors on the server are logged to console. You can override this behavior to log crash reports:\n\nasync function handler(request) {\n\n  const stream = await renderToReadableStream(<App />, {\n\n    bootstrapScripts: ['/main.js'],\n\n    onError(error) {\n\n      console.error(error);\n\n      logServerCrashReport(error);\n\n    }\n\n  });\n\n  return new Response(stream, {\n\n    headers: { 'content-type': 'text/html' },\n\n  });\n\n}\n\nIf you provide a custom onError implementation, don‚Äôt forget to also log errors to the console like above.\n\nRecovering from errors inside the shell \n\nIn this example, the shell contains ProfileLayout, ProfileCover, and PostsGlimmer:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIf an error occurs while rendering those components, React won‚Äôt have any meaningful HTML to send to the client. Wrap your renderToReadableStream call in a try...catch to send a fallback HTML that doesn‚Äôt rely on server rendering as the last resort:\n\nasync function handler(request) {\n\n  try {\n\n    const stream = await renderToReadableStream(<App />, {\n\n      bootstrapScripts: ['/main.js'],\n\n      onError(error) {\n\n        console.error(error);\n\n        logServerCrashReport(error);\n\n      }\n\n    });\n\n    return new Response(stream, {\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  } catch (error) {\n\n    return new Response('<h1>Something went wrong</h1>', {\n\n      status: 500,\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  }\n\n}\n\nIf there is an error while generating the shell, both onError and your catch block will fire. Use onError for error reporting and use the catch block to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.\n\nRecovering from errors outside the shell \n\nIn this example, the <Posts /> component is wrapped in <Suspense> so it is not a part of the shell:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIf an error happens in the Posts component or somewhere inside it, React will try to recover from it:\n\nIt will emit the loading fallback for the closest <Suspense> boundary (PostsGlimmer) into the HTML.\nIt will ‚Äúgive up‚Äù on trying to render the Posts content on the server anymore.\nWhen the JavaScript code loads on the client, React will retry rendering Posts on the client.\n\nIf retrying rendering Posts on the client also fails, React will throw the error on the client. As with all the errors thrown during rendering, the closest parent error boundary determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.\n\nIf retrying rendering Posts on the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server onError callback and the client onRecoverableError callbacks will fire so that you can get notified about the error.\n\nSetting the status code \n\nStreaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.\n\nBy dividing your app into the shell (above all <Suspense> boundaries) and the rest of the content, you‚Äôve already solved a part of this problem. If the shell errors, your catch block will run which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send ‚ÄúOK‚Äù.\n\nasync function handler(request) {\n\n  try {\n\n    const stream = await renderToReadableStream(<App />, {\n\n      bootstrapScripts: ['/main.js'],\n\n      onError(error) {\n\n        console.error(error);\n\n        logServerCrashReport(error);\n\n      }\n\n    });\n\n    return new Response(stream, {\n\n      status: 200,\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  } catch (error) {\n\n    return new Response('<h1>Something went wrong</h1>', {\n\n      status: 500,\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  }\n\n}\n\nIf a component outside the shell (i.e. inside a <Suspense> boundary) throws an error, React will not stop rendering. This means that the onError callback will fire, but your code will continue running without getting into the catch block. This is because React will try to recover from that error on the client, as described above.\n\nHowever, if you‚Äôd like, you can use the fact that something has errored to set the status code:\n\nasync function handler(request) {\n\n  try {\n\n    let didError = false;\n\n    const stream = await renderToReadableStream(<App />, {\n\n      bootstrapScripts: ['/main.js'],\n\n      onError(error) {\n\n        didError = true;\n\n        console.error(error);\n\n        logServerCrashReport(error);\n\n      }\n\n    });\n\n    return new Response(stream, {\n\n      status: didError ? 500 : 200,\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  } catch (error) {\n\n    return new Response('<h1>Something went wrong</h1>', {\n\n      status: 500,\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  }\n\n}\n\nThis will only catch errors outside the shell that happened while generating the initial shell content, so it‚Äôs not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.\n\nHandling different errors in different ways \n\nYou can create your own Error subclasses and use the instanceof operator to check which error is thrown. For example, you can define a custom NotFoundError and throw it from your component. Then you can save the error in onError and do something different before returning the response depending on the error type:\n\nasync function handler(request) {\n\n  let didError = false;\n\n  let caughtError = null;\n\n\n\n  function getStatusCode() {\n\n    if (didError) {\n\n      if (caughtError instanceof NotFoundError) {\n\n        return 404;\n\n      } else {\n\n        return 500;\n\n      }\n\n    } else {\n\n      return 200;\n\n    }\n\n  }\n\n\n\n  try {\n\n    const stream = await renderToReadableStream(<App />, {\n\n      bootstrapScripts: ['/main.js'],\n\n      onError(error) {\n\n        didError = true;\n\n        caughtError = error;\n\n        console.error(error);\n\n        logServerCrashReport(error);\n\n      }\n\n    });\n\n    return new Response(stream, {\n\n      status: getStatusCode(),\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  } catch (error) {\n\n    return new Response('<h1>Something went wrong</h1>', {\n\n      status: getStatusCode(),\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  }\n\n}\n\nKeep in mind that once you emit the shell and start streaming, you can‚Äôt change the status code.\n\nWaiting for all content to load for crawlers and static generation \n\nStreaming offers a better user experience because the user can see the content as it becomes available.\n\nHowever, when a crawler visits your page, or if you‚Äôre generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.\n\nYou can wait for all the content to load by awaiting the stream.allReady Promise:\n\nasync function handler(request) {\n\n  try {\n\n    let didError = false;\n\n    const stream = await renderToReadableStream(<App />, {\n\n      bootstrapScripts: ['/main.js'],\n\n      onError(error) {\n\n        didError = true;\n\n        console.error(error);\n\n        logServerCrashReport(error);\n\n      }\n\n    });\n\n    let isCrawler = // ... depends on your bot detection strategy ...\n\n    if (isCrawler) {\n\n      await stream.allReady;\n\n    }\n\n    return new Response(stream, {\n\n      status: didError ? 500 : 200,\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  } catch (error) {\n\n    return new Response('<h1>Something went wrong</h1>', {\n\n      status: 500,\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  }\n\n}\n\nA regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for all data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.\n\nAborting server rendering \n\nYou can force the server rendering to ‚Äúgive up‚Äù after a timeout:\n\nasync function handler(request) {\n\n  try {\n\n    const controller = new AbortController();\n\n    setTimeout(() => {\n\n      controller.abort();\n\n    }, 10000);\n\n\n\n    const stream = await renderToReadableStream(<App />, {\n\n      signal: controller.signal,\n\n      bootstrapScripts: ['/main.js'],\n\n      onError(error) {\n\n        didError = true;\n\n        console.error(error);\n\n        logServerCrashReport(error);\n\n      }\n\n    });\n\n    // ...\n\nReact will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.\n\nPREVIOUS\nrenderToPipeableStream\nNEXT\nrenderToStaticMarkup"
  },
  {
    "title": "renderToStaticMarkup ‚Äì React",
    "url": "https://react.dev/reference/react-dom/server/renderToStaticMarkup",
    "html": "API REFERENCE\nSERVER APIS\nrenderToStaticMarkup\n\nrenderToStaticMarkup renders a non-interactive React tree to an HTML string.\n\nconst html = renderToStaticMarkup(reactNode, options?)\nReference\nrenderToStaticMarkup(reactNode, options?)\nUsage\nRendering a non-interactive React tree as HTML to a string\nReference \nrenderToStaticMarkup(reactNode, options?) \n\nOn the server, call renderToStaticMarkup to render your app to HTML.\n\nimport { renderToStaticMarkup } from 'react-dom/server';\n\n\n\nconst html = renderToStaticMarkup(<Page />);\n\nIt will produce non-interactive HTML output of your React components.\n\nSee more examples below.\n\nParameters \nreactNode: A React node you want to render to HTML. For example, a JSX node like <Page />.\noptional options: An object for server render.\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page.\nReturns \n\nAn HTML string.\n\nCaveats \n\nrenderToStaticMarkup output cannot be hydrated.\n\nrenderToStaticMarkup has limited Suspense support. If a component suspends, renderToStaticMarkup immediately sends its fallback as HTML.\n\nrenderToStaticMarkup works in the browser, but using it in the client code is not recommended. If you need to render a component to HTML in the browser, get the HTML by rendering it into a DOM node.\n\nUsage \nRendering a non-interactive React tree as HTML to a string \n\nCall renderToStaticMarkup to render your app to an HTML string which you can send with your server response:\n\nimport { renderToStaticMarkup } from 'react-dom/server';\n\n\n\n// The route handler syntax depends on your backend framework\n\napp.use('/', (request, response) => {\n\n  const html = renderToStaticMarkup(<Page />);\n\n  response.send(html);\n\n});\n\nThis will produce the initial non-interactive HTML output of your React components.\n\nPitfall\n\nThis method renders non-interactive HTML that cannot be hydrated.  This is useful if you want to use React as a simple static page generator, or if you‚Äôre rendering completely static content like emails.\n\nInteractive apps should use renderToString on the server and hydrateRoot on the client.\n\nPREVIOUS\nrenderToReadableStream\nNEXT\nrenderToString"
  },
  {
    "title": "renderToString ‚Äì React",
    "url": "https://react.dev/reference/react-dom/server/renderToString",
    "html": "API REFERENCE\nSERVER APIS\nrenderToString\nPitfall\n\nrenderToString does not support streaming or waiting for data. See the alternatives.\n\nrenderToString renders a React tree to an HTML string.\n\nconst html = renderToString(reactNode, options?)\nReference\nrenderToString(reactNode, options?)\nUsage\nRendering a React tree as HTML to a string\nAlternatives\nMigrating from renderToString to a streaming render on the server\nMigrating from renderToString to a static prerender on the server\nRemoving renderToString from the client code\nTroubleshooting\nWhen a component suspends, the HTML always contains a fallback\nReference \nrenderToString(reactNode, options?) \n\nOn the server, call renderToString to render your app to HTML.\n\nimport { renderToString } from 'react-dom/server';\n\n\n\nconst html = renderToString(<App />);\n\nOn the client, call hydrateRoot to make the server-generated HTML interactive.\n\nSee more examples below.\n\nParameters \n\nreactNode: A React node you want to render to HTML. For example, a JSX node like <App />.\n\noptional options: An object for server render.\n\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.\nReturns \n\nAn HTML string.\n\nCaveats \n\nrenderToString has limited Suspense support. If a component suspends, renderToString immediately sends its fallback as HTML.\n\nrenderToString works in the browser, but using it in the client code is not recommended.\n\nUsage \nRendering a React tree as HTML to a string \n\nCall renderToString to render your app to an HTML string which you can send with your server response:\n\nimport { renderToString } from 'react-dom/server';\n\n\n\n// The route handler syntax depends on your backend framework\n\napp.use('/', (request, response) => {\n\n  const html = renderToString(<App />);\n\n  response.send(html);\n\n});\n\nThis will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive.\n\nPitfall\n\nrenderToString does not support streaming or waiting for data. See the alternatives.\n\nAlternatives \nMigrating from renderToString to a streaming render on the server \n\nrenderToString returns a string immediately, so it does not support streaming content as it loads.\n\nWhen possible, we recommend using these fully-featured alternatives:\n\nIf you use Node.js, use renderToPipeableStream.\nIf you use Deno or a modern edge runtime with Web Streams, use renderToReadableStream.\n\nYou can continue using renderToString if your server environment does not support streams.\n\nMigrating from renderToString to a static prerender on the server \n\nrenderToString returns a string immediately, so it does not support waiting for data to load for static HTML generation.\n\nWe recommend using these fully-featured alternatives:\n\nIf you use Node.js, use prerenderToNodeStream.\nIf you use Deno or a modern edge runtime with Web Streams, use prerender.\n\nYou can continue using renderToString if your static site generation environment does not support streams.\n\nRemoving renderToString from the client code \n\nSometimes, renderToString is used on the client to convert some component to HTML.\n\n// üö© Unnecessary: using renderToString on the client\n\nimport { renderToString } from 'react-dom/server';\n\n\n\nconst html = renderToString(<MyIcon />);\n\nconsole.log(html); // For example, \"<svg>...</svg>\"\n\nImporting react-dom/server on the client unnecessarily increases your bundle size and should be avoided. If you need to render some component to HTML in the browser, use createRoot and read HTML from the DOM:\n\nimport { createRoot } from 'react-dom/client';\n\nimport { flushSync } from 'react-dom';\n\n\n\nconst div = document.createElement('div');\n\nconst root = createRoot(div);\n\nflushSync(() => {\n\n  root.render(<MyIcon />);\n\n});\n\nconsole.log(div.innerHTML); // For example, \"<svg>...</svg>\"\n\nThe flushSync call is necessary so that the DOM is updated before reading its innerHTML property.\n\nTroubleshooting \nWhen a component suspends, the HTML always contains a fallback \n\nrenderToString does not fully support Suspense.\n\nIf some component suspends (for example, because it‚Äôs defined with lazy or fetches data), renderToString will not wait for its content to resolve. Instead, renderToString will find the closest <Suspense> boundary above it and render its fallback prop in the HTML. The content will not appear until the client code loads.\n\nTo solve this, use one of the recommended streaming solutions. For server side rendering, they can stream content in chunks as it resolves on the server so that the user sees the page being progressively filled in before the client code loads. For static site generation, they can wait for all the content to resolve before generating the static HTML.\n\nPREVIOUS\nrenderToStaticMarkup\nNEXT\nresume"
  },
  {
    "title": "resume ‚Äì React",
    "url": "https://react.dev/reference/react-dom/server/resume",
    "html": "API REFERENCE\nSERVER APIS\nresume\n\nresume streams a pre-rendered React tree to a Readable Web Stream.\n\nconst stream = await resume(reactNode, postponedState, options?)\nReference\nresume(node, postponedState, options?)\nUsage\nResuming a prerender\nFurther reading\nNote\n\nThis API depends on Web Streams. For Node.js, use resumeToNodeStream instead.\n\nReference \nresume(node, postponedState, options?) \n\nCall resume to resume rendering a pre-rendered React tree as HTML into a Readable Web Stream.\n\nimport { resume } from 'react-dom/server';\n\nimport {getPostponedState} from './storage';\n\n\n\nasync function handler(request, writable) {\n\n  const postponed = await getPostponedState(request);\n\n  const resumeStream = await resume(<App />, postponed);\n\n  return resumeStream.pipeTo(writable)\n\n}\n\nSee more examples below.\n\nParameters \nreactNode: The React node you called prerender with. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\npostponedState: The opaque postpone object returned from a prerender API, loaded from wherever you stored it (e.g. redis, a file, or S3).\noptional options: An object with streaming options.\noptional nonce: A nonce string to allow scripts for script-src Content-Security-Policy.\noptional signal: An abort signal that lets you abort server rendering and render the rest on the client.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error.\nReturns \n\nresume returns a Promise:\n\nIf resume successfully produced a shell, that Promise will resolve to a Readable Web Stream. that can be piped to a Writable Web Stream..\nIf an error happens in the shell, the Promise will reject with that error.\n\nThe returned stream has an additional property:\n\nallReady: A Promise that resolves when all rendering is complete. You can await stream.allReady before returning a response for crawlers and static generation. If you do that, you won‚Äôt get any progressive loading. The stream will contain the final HTML.\nCaveats \nresume does not accept options for bootstrapScripts, bootstrapScriptContent, or bootstrapModules. Instead, you need to pass these options to the prerender call that generates the postponedState. You can also inject bootstrap content into the writable stream manually.\nresume does not accept identifierPrefix since the prefix needs to be the same in both prerender and resume.\nSince nonce cannot be provided to prerender, you should only provide nonce to resume if you‚Äôre not providing scripts to prerender.\nresume re-renders from the root until it finds a component that was not fully pre-rendered. Only fully prerendered Components (the Component and its children finished prerendering) are skipped entirely.\nUsage \nResuming a prerender \nindex.js\nindex.html\ndemo-helpers.js\nReload\nClear\nFork\nimport {\n  flushReadableStreamToFrame,\n  getUser,\n  Postponed,\n  sleep,\n} from \"./demo-helpers\";\nimport { StrictMode, Suspense, use, useEffect } from \"react\";\nimport { prerender } from \"react-dom/static\";\nimport { resume } from \"react-dom/server\";\nimport { hydrateRoot } from \"react-dom/client\";\n\nfunction Header() {\n  return <header>Me and my descendants can be prerendered</header>;\n}\n\nconst { promise: cookies, resolve: resolveCookies } = Promise.withResolvers();\n\nfunction Main() {\n  const { sessionID } = use(cookies);\n  const user = getUser(sessionID);\n\n  useEffect(() => {\n    console.log(\"reached interactivity!\");\n  }, []);\n\n  return (\n    <main>\n      Hello, {user.name}!\n      <button onClick={() => console.log(\"hydrated!\")}>\n        Clicking me requires hydration.\n      </button>\n    </main>\n  );\n}\n\nfunction Shell({ children }) {\n  // In a real app, this is where you would put your html and body.\n  // We're just using tags here we can include in an existing body for demonstration purposes\n  return (\n    <html>\n      <body>{children}</body>\n    </html>\n  );\n}\n\nfunction App() {\n  return (\n    <Shell>\n      <Suspense fallback=\"loading header\">\n        <Header />\n      </Suspense>\n      <Suspense fallback=\"loading main\">\n        <Main />\n      </Suspense>\n    </Shell>\n  );\n}\n\nasync function main(frame) {\n  // Layer 1\n  const controller = new AbortController();\n  const prerenderedApp = prerender(<App />, {\n    signal: controller.signal,\n    onError(error) {\n      if (error instanceof Postponed) {\n      } else {\n        console.error(error);\n      }\n    },\n  });\n  // We're immediately aborting in a macrotask.\n  // Any data fetching that's not available synchronously, or in a microtask, will not have finished.\n  setTimeout(() => {\n    controller.abort(new Postponed());\n  });\n\n  const { prelude, postponed } = await prerenderedApp;\n  await flushReadableStreamToFrame(prelude, frame);\n\n  // Layer 2\n  // Just waiting here for demonstration purposes.\n  // In a real app, the prelude and postponed state would've been serialized in Layer 1 and Layer would deserialize them.\n  // The prelude content could be flushed immediated as plain HTML while\n  // React is continuing to render from where the prerender left off.\n  await sleep(2000);\n\n  // You would get the cookies from the incoming HTTP request\n  resolveCookies({ sessionID: \"abc\" });\n\n  const stream = await resume(<App />, postponed);\n\n  await flushReadableStreamToFrame(stream, frame);\n\n  // Layer 3\n  // Just waiting here for demonstration purposes.\n  await sleep(2000);\n\n  hydrateRoot(frame.contentWindow.document, <App />);\n}\n\nmain(document.getElementById(\"container\"));\n\n\nShow more\nFurther reading \n\nResuming behaves like renderToReadableStream. For more examples, check out the usage section of renderToReadableStream.\nThe usage section of prerender includes examples of how to use prerender specifically.\n\nPREVIOUS\nrenderToString\nNEXT\nresumeToPipeableStream"
  },
  {
    "title": "resumeToPipeableStream ‚Äì React",
    "url": "https://react.dev/reference/react-dom/server/resumeToPipeableStream",
    "html": "API REFERENCE\nSERVER APIS\nresumeToPipeableStream\n\nresumeToPipeableStream streams a pre-rendered React tree  to a pipeable Node.js Stream.\n\nconst {pipe, abort} = await resumeToPipeableStream(reactNode, postponedState, options?)\nReference\nresumeToPipeableStream(node, postponed, options?)\nUsage\nFurther reading\nNote\n\nThis API is specific to Node.js. Environments with Web Streams, like Deno and modern edge runtimes, should use resume instead.\n\nReference \nresumeToPipeableStream(node, postponed, options?) \n\nCall resume to resume rendering a pre-rendered React tree as HTML into a Node.js Stream.\n\nimport { resume } from 'react-dom/server';\n\nimport {getPostponedState} from './storage';\n\n\n\nasync function handler(request, response) {\n\n  const postponed = await getPostponedState(request);\n\n  const {pipe} = resumeToPipeableStream(<App />, postponed, {\n\n    onShellReady: () => {\n\n      pipe(response);\n\n    }\n\n  });\n\n}\n\nSee more examples below.\n\nParameters \nreactNode: The React node you called prerender with. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\npostponedState: The opaque postpone object returned from a prerender API, loaded from wherever you stored it (e.g. redis, a file, or S3).\noptional options: An object with streaming options.\noptional nonce: A nonce string to allow scripts for script-src Content-Security-Policy.\noptional signal: An abort signal that lets you abort server rendering and render the rest on the client.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error.\noptional onShellReady: A callback that fires right after the shell has finished. You can call pipe here to start streaming. React will stream the additional content after the shell along with the inline <script> tags that replace the HTML loading fallbacks with the content.\noptional onShellError: A callback that fires if there was an error rendering the shell. It receives the error as an argument. No bytes were emitted from the stream yet, and neither onShellReady nor onAllReady will get called, so you can output a fallback HTML shell or use the prelude.\nReturns \n\nresume returns an object with two methods:\n\npipe outputs the HTML into the provided Writable Node.js Stream. Call pipe in onShellReady if you want to enable streaming, or in onAllReady for crawlers and static generation.\nabort lets you abort server rendering and render the rest on the client.\nCaveats \nresumeToPipeableStream does not accept options for bootstrapScripts, bootstrapScriptContent, or bootstrapModules. Instead, you need to pass these options to the prerender call that generates the postponedState. You can also inject bootstrap content into the writable stream manually.\nresumeToPipeableStream does not accept identifierPrefix since the prefix needs to be the same in both prerender and resumeToPipeableStream.\nSince nonce cannot be provided to prerender, you should only provide nonce to resumeToPipeableStream if you‚Äôre not providing scripts to prerender.\nresumeToPipeableStream re-renders from the root until it finds a component that was not fully pre-rendered. Only fully prerendered Components (the Component and its children finished prerendering) are skipped entirely.\nUsage \nFurther reading \n\nResuming behaves like renderToReadableStream. For more examples, check out the usage section of renderToReadableStream.\nThe usage section of prerender includes examples of how to use prerenderToNodeStream specifically.\n\nPREVIOUS\nresume\nNEXT\nStatic APIs"
  },
  {
    "title": "Static React DOM APIs ‚Äì React",
    "url": "https://react.dev/reference/react-dom/static",
    "html": "API REFERENCE\nStatic React DOM APIs\n\nThe react-dom/static APIs let you generate static HTML for React components. They have limited functionality compared to the streaming APIs. A framework may call them for you. Most of your components don‚Äôt need to import or use them.\n\nStatic APIs for Web Streams \n\nThese methods are only available in the environments with Web Streams, which includes browsers, Deno, and some modern edge runtimes:\n\nprerender renders a React tree to static HTML with a Readable Web Stream.\nExperimental only resumeAndPrerender continues a prerendered React tree to static HTML with a Readable Web Stream.\n\nNode.js also includes these methods for compatibility, but they are not recommended due to worse performance. Use the dedicated Node.js APIs instead.\n\nStatic APIs for Node.js Streams \n\nThese methods are only available in the environments with Node.js Streams:\n\nprerenderToNodeStream renders a React tree to static HTML with a Node.js Stream.\nExperimental only resumeAndPrerenderToNodeStream continues a prerendered React tree to static HTML with a Node.js Stream.\nPREVIOUS\nresumeToPipeableStream\nNEXT\nprerender"
  },
  {
    "title": "prerender ‚Äì React",
    "url": "https://react.dev/reference/react-dom/static/prerender",
    "html": "API REFERENCE\nSTATIC APIS\nprerender\n\nprerender renders a React tree to a static HTML string using a Web Stream.\n\nconst {prelude, postponed} = await prerender(reactNode, options?)\nReference\nprerender(reactNode, options?)\nUsage\nRendering a React tree to a stream of static HTML\nRendering a React tree to a string of static HTML\nWaiting for all data to load\nAborting prerendering\nTroubleshooting\nMy stream doesn‚Äôt start until the entire app is rendered\nNote\n\nThis API depends on Web Streams. For Node.js, use prerenderToNodeStream instead.\n\nReference \nprerender(reactNode, options?) \n\nCall prerender to render your app to static HTML.\n\nimport { prerender } from 'react-dom/static';\n\n\n\nasync function handler(request, response) {\n\n  const {prelude} = await prerender(<App />, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n  return new Response(prelude, {\n\n    headers: { 'content-type': 'text/html' },\n\n  });\n\n}\n\nOn the client, call hydrateRoot to make the server-generated HTML interactive.\n\nSee more examples below.\n\nParameters \n\nreactNode: A React node you want to render to HTML. For example, a JSX node like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\n\noptional options: An object with static generation options.\n\noptional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag.\noptional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don‚Äôt want to run React on the client at all.\noptional bootstrapModules: Like bootstrapScripts, but emits <script type=\"module\"> instead.\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.\noptional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted.\noptional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic.\noptional signal: An abort signal that lets you abort prerendering and render the rest on the client.\nReturns \n\nprerender returns a Promise:\n\nIf rendering the is successful, the Promise will resolve to an object containing:\nprelude: a Web Stream of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.\npostponed: a JSON-serializeable, opaque object that can be passed to resume if prerender did not finish. Otherwise null indicating that the prelude contains all the content and no resume is necessary.\nIf rendering fails, the Promise will be rejected. Use this to output a fallback shell.\nCaveats \n\nnonce is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with CSP it would be inappropriate and insecure to include the nonce value in the prerender itself.\n\nNote\nWhen should I use prerender? \n\nThe static prerender API is used for static server-side generation (SSG). Unlike renderToString, prerender waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like renderToReadableStream.\n\nprerender can be aborted and later either continued with resumeAndPrerender or resumed with resume to support partial pre-rendering.\n\nUsage \nRendering a React tree to a stream of static HTML \n\nCall prerender to render your React tree to static HTML into a Readable Web Stream::\n\nimport { prerender } from 'react-dom/static';\n\n\n\nasync function handler(request) {\n\n  const {prelude} = await prerender(<App />, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n  return new Response(prelude, {\n\n    headers: { 'content-type': 'text/html' },\n\n  });\n\n}\n\nAlong with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.\n\nFor example, it might look like this:\n\nexport default function App() {\n\n  return (\n\n    <html>\n\n      <head>\n\n        <meta charSet=\"utf-8\" />\n\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\n        <link rel=\"stylesheet\" href=\"/styles.css\"></link>\n\n        <title>My app</title>\n\n      </head>\n\n      <body>\n\n        <Router />\n\n      </body>\n\n    </html>\n\n  );\n\n}\n\nReact will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:\n\n<!DOCTYPE html>\n\n<html>\n\n  <!-- ... HTML from your components ... -->\n\n</html>\n\n<script src=\"/main.js\" async=\"\"></script>\n\nOn the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:\n\nimport { hydrateRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\n\n\nhydrateRoot(document, <App />);\n\nThis will attach event listeners to the static server-generated HTML and make it interactive.\n\nDEEP DIVE\nReading CSS and JS asset paths from the build output \nShow Details\nRendering a React tree to a string of static HTML \n\nCall prerender to render your app to a static HTML string:\n\nimport { prerender } from 'react-dom/static';\n\n\n\nasync function renderToString() {\n\n  const {prelude} = await prerender(<App />, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n\n\n  const reader = prelude.getReader();\n\n  let content = '';\n\n  while (true) {\n\n    const {done, value} = await reader.read();\n\n    if (done) {\n\n      return content;\n\n    }\n\n    content += Buffer.from(value).toString('utf8');\n\n  }\n\n}\n\nThis will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive.\n\nWaiting for all data to load \n\nprerender waits for all data to load before finishing the static HTML generation and resolving. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Sidebar>\n\n        <Friends />\n\n        <Photos />\n\n      </Sidebar>\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nImagine that <Posts /> needs to load some data, which takes some time. Ideally, you‚Äôd want wait for the posts to finish so it‚Äôs included in the HTML. To do this, you can use Suspense to suspend on the data, and prerender will wait for the suspended content to finish before resolving to the static HTML.\n\nNote\n\nOnly Suspense-enabled data sources will activate the Suspense component. They include:\n\nData fetching with Suspense-enabled frameworks like Relay and Next.js\nLazy-loading component code with lazy\nReading the value of a Promise with use\n\nSuspense does not detect when data is fetched inside an Effect or event handler.\n\nThe exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you‚Äôll find the details in its data fetching documentation.\n\nSuspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.\n\nAborting prerendering \n\nYou can force the prerender to ‚Äúgive up‚Äù after a timeout:\n\nasync function renderToString() {\n\n  const controller = new AbortController();\n\n  setTimeout(() => {\n\n    controller.abort()\n\n  }, 10000);\n\n\n\n  try {\n\n    // the prelude will contain all the HTML that was prerendered\n\n    // before the controller aborted.\n\n    const {prelude} = await prerender(<App />, {\n\n      signal: controller.signal,\n\n    });\n\n    //...\n\nAny Suspense boundaries with incomplete children will be included in the prelude in the fallback state.\n\nThis can be used for partial prerendering together with resume or resumeAndPrerender.\n\nTroubleshooting \nMy stream doesn‚Äôt start until the entire app is rendered \n\nThe prerender response waits for the entire app to finish rendering, including waiting for all Suspense boundaries to resolve, before resolving. It is designed for static site generation (SSG) ahead of time and does not support streaming more content as it loads.\n\nTo stream content as it loads, use a streaming server render API like renderToReadableStream.\n\nPREVIOUS\nStatic APIs\nNEXT\nprerenderToNodeStream"
  },
  {
    "title": "prerenderToNodeStream ‚Äì React",
    "url": "https://react.dev/reference/react-dom/static/prerenderToNodeStream",
    "html": "API REFERENCE\nSTATIC APIS\nprerenderToNodeStream\n\nprerenderToNodeStream renders a React tree to a static HTML string using a Node.js Stream.\n\nconst {prelude, postponed} = await prerenderToNodeStream(reactNode, options?)\nReference\nprerenderToNodeStream(reactNode, options?)\nUsage\nRendering a React tree to a stream of static HTML\nRendering a React tree to a string of static HTML\nWaiting for all data to load\nAborting prerendering\nTroubleshooting\nMy stream doesn‚Äôt start until the entire app is rendered\nNote\n\nThis API is specific to Node.js. Environments with Web Streams, like Deno and modern edge runtimes, should use prerender instead.\n\nReference \nprerenderToNodeStream(reactNode, options?) \n\nCall prerenderToNodeStream to render your app to static HTML.\n\nimport { prerenderToNodeStream } from 'react-dom/static';\n\n\n\n// The route handler syntax depends on your backend framework\n\napp.use('/', async (request, response) => {\n\n  const { prelude } = await prerenderToNodeStream(<App />, {\n\n    bootstrapScripts: ['/main.js'],\n\n  });\n\n\n\n  response.setHeader('Content-Type', 'text/plain');\n\n  prelude.pipe(response);\n\n});\n\nOn the client, call hydrateRoot to make the server-generated HTML interactive.\n\nSee more examples below.\n\nParameters \n\nreactNode: A React node you want to render to HTML. For example, a JSX node like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\n\noptional options: An object with static generation options.\n\noptional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag.\noptional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don‚Äôt want to run React on the client at all.\noptional bootstrapModules: Like bootstrapScripts, but emits <script type=\"module\"> instead.\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.\noptional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted.\noptional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic.\noptional signal: An abort signal that lets you abort prerendering and render the rest on the client.\nReturns \n\nprerenderToNodeStream returns a Promise:\n\nIf rendering the is successful, the Promise will resolve to an object containing:\nprelude: a Node.js Stream. of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.\npostponed: a JSON-serializeable, opaque object that can be passed to resumeToPipeableStream if prerenderToNodeStream did not finish. Otherwise null indicating that the prelude contains all the content and no resume is necessary.\nIf rendering fails, the Promise will be rejected. Use this to output a fallback shell.\nCaveats \n\nnonce is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with CSP it would be inappropriate and insecure to include the nonce value in the prerender itself.\n\nNote\nWhen should I use prerenderToNodeStream? \n\nThe static prerenderToNodeStream API is used for static server-side generation (SSG). Unlike renderToString, prerenderToNodeStream waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like renderToReadableStream.\n\nprerenderToNodeStream can be aborted and resumed later with resumeToPipeableStream to support partial pre-rendering.\n\nUsage \nRendering a React tree to a stream of static HTML \n\nCall prerenderToNodeStream to render your React tree to static HTML into a Node.js Stream:\n\nimport { prerenderToNodeStream } from 'react-dom/static';\n\n\n\n// The route handler syntax depends on your backend framework\n\napp.use('/', async (request, response) => {\n\n  const { prelude } = await prerenderToNodeStream(<App />, {\n\n    bootstrapScripts: ['/main.js'],\n\n  });\n\n\n\n  response.setHeader('Content-Type', 'text/plain');\n\n  prelude.pipe(response);\n\n});\n\nAlong with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.\n\nFor example, it might look like this:\n\nexport default function App() {\n\n  return (\n\n    <html>\n\n      <head>\n\n        <meta charSet=\"utf-8\" />\n\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\n        <link rel=\"stylesheet\" href=\"/styles.css\"></link>\n\n        <title>My app</title>\n\n      </head>\n\n      <body>\n\n        <Router />\n\n      </body>\n\n    </html>\n\n  );\n\n}\n\nReact will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:\n\n<!DOCTYPE html>\n\n<html>\n\n  <!-- ... HTML from your components ... -->\n\n</html>\n\n<script src=\"/main.js\" async=\"\"></script>\n\nOn the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:\n\nimport { hydrateRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\n\n\nhydrateRoot(document, <App />);\n\nThis will attach event listeners to the static server-generated HTML and make it interactive.\n\nDEEP DIVE\nReading CSS and JS asset paths from the build output \nShow Details\nRendering a React tree to a string of static HTML \n\nCall prerenderToNodeStream to render your app to a static HTML string:\n\nimport { prerenderToNodeStream } from 'react-dom/static';\n\n\n\nasync function renderToString() {\n\n  const {prelude} = await prerenderToNodeStream(<App />, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n\n\n  return new Promise((resolve, reject) => {\n\n    let data = '';\n\n    prelude.on('data', chunk => {\n\n      data += chunk;\n\n    });\n\n    prelude.on('end', () => resolve(data));\n\n    prelude.on('error', reject);\n\n  });\n\n}\n\nThis will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive.\n\nWaiting for all data to load \n\nprerenderToNodeStream waits for all data to load before finishing the static HTML generation and resolving. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Sidebar>\n\n        <Friends />\n\n        <Photos />\n\n      </Sidebar>\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nImagine that <Posts /> needs to load some data, which takes some time. Ideally, you‚Äôd want wait for the posts to finish so it‚Äôs included in the HTML. To do this, you can use Suspense to suspend on the data, and prerenderToNodeStream will wait for the suspended content to finish before resolving to the static HTML.\n\nNote\n\nOnly Suspense-enabled data sources will activate the Suspense component. They include:\n\nData fetching with Suspense-enabled frameworks like Relay and Next.js\nLazy-loading component code with lazy\nReading the value of a Promise with use\n\nSuspense does not detect when data is fetched inside an Effect or event handler.\n\nThe exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you‚Äôll find the details in its data fetching documentation.\n\nSuspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.\n\nAborting prerendering \n\nYou can force the prerender to ‚Äúgive up‚Äù after a timeout:\n\nasync function renderToString() {\n\n  const controller = new AbortController();\n\n  setTimeout(() => {\n\n    controller.abort()\n\n  }, 10000);\n\n\n\n  try {\n\n    // the prelude will contain all the HTML that was prerendered\n\n    // before the controller aborted.\n\n    const {prelude} = await prerenderToNodeStream(<App />, {\n\n      signal: controller.signal,\n\n    });\n\n    //...\n\nAny Suspense boundaries with incomplete children will be included in the prelude in the fallback state.\n\nThis can be used for partial prerendering together with resumeToPipeableStream or resumeAndPrerenderToNodeStream.\n\nTroubleshooting \nMy stream doesn‚Äôt start until the entire app is rendered \n\nThe prerenderToNodeStream response waits for the entire app to finish rendering, including waiting for all Suspense boundaries to resolve, before resolving. It is designed for static site generation (SSG) ahead of time and does not support streaming more content as it loads.\n\nTo stream content as it loads, use a streaming server render API like renderToPipeableStream.\n\nPREVIOUS\nprerender\nNEXT\nresumeAndPrerender"
  },
  {
    "title": "resumeAndPrerender ‚Äì React",
    "url": "https://react.dev/reference/react-dom/static/resumeAndPrerender",
    "html": "API REFERENCE\nSTATIC APIS\nresumeAndPrerender\n\nresumeAndPrerender continues a prerendered React tree to a static HTML string using a Web Stream.\n\nconst { prelude,postpone } = await resumeAndPrerender(reactNode, postponedState, options?)\nReference\nresumeAndPrerender(reactNode, postponedState, options?)\nUsage\nFurther reading\nNote\n\nThis API depends on Web Streams. For Node.js, use resumeAndPrerenderToNodeStream instead.\n\nReference \nresumeAndPrerender(reactNode, postponedState, options?) \n\nCall resumeAndPrerender to continue a prerendered React tree to a static HTML string.\n\nimport { resumeAndPrerender } from 'react-dom/static';\n\nimport { getPostponedState } from 'storage';\n\n\n\nasync function handler(request, response) {\n\n  const postponedState = getPostponedState(request);\n\n  const { prelude } = await resumeAndPrerender(<App />, postponedState, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n  return new Response(prelude, {\n\n    headers: { 'content-type': 'text/html' },\n\n  });\n\n}\n\nOn the client, call hydrateRoot to make the server-generated HTML interactive.\n\nSee more examples below.\n\nParameters \nreactNode: The React node you called prerender (or a previous resumeAndPrerender) with. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\npostponedState: The opaque postpone object returned from a prerender API, loaded from wherever you stored it (e.g. redis, a file, or S3).\noptional options: An object with streaming options.\noptional signal: An abort signal that lets you abort server rendering and render the rest on the client.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error.\nReturns \n\nprerender returns a Promise:\n\nIf rendering the is successful, the Promise will resolve to an object containing:\nprelude: a Web Stream of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.\npostponed: an JSON-serializeable, opaque object that can be passed to resume or resumeAndPrerender if prerender is aborted.\nIf rendering fails, the Promise will be rejected. Use this to output a fallback shell.\nCaveats \n\nnonce is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with CSP it would be inappropriate and insecure to include the nonce value in the prerender itself.\n\nNote\nWhen should I use resumeAndPrerender? \n\nThe static resumeAndPrerender API is used for static server-side generation (SSG). Unlike renderToString, resumeAndPrerender waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like renderToReadableStream.\n\nresumeAndPrerender can be aborted and later either continued with another resumeAndPrerender or resumed with resume to support partial pre-rendering.\n\nUsage \nFurther reading \n\nresumeAndPrerender behaves similarly to prerender but can be used to continue a previously started prerendering process that was aborted.\nFor more information about resuming a prerendered tree, see the resume documentation.\n\nPREVIOUS\nprerenderToNodeStream\nNEXT\nresumeAndPrerenderToNodeStream"
  },
  {
    "title": "resumeAndPrerenderToNodeStream ‚Äì React",
    "url": "https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream",
    "html": "API REFERENCE\nSTATIC APIS\nresumeAndPrerenderToNodeStream\n\nresumeAndPrerenderToNodeStream continues a prerendered React tree to a static HTML string using a a Node.js Stream..\n\nconst {prelude, postponed} = await resumeAndPrerenderToNodeStream(reactNode, postponedState, options?)\nReference\nresumeAndPrerenderToNodeStream(reactNode, postponedState, options?)\nUsage\nFurther reading\nNote\n\nThis API is specific to Node.js. Environments with Web Streams, like Deno and modern edge runtimes, should use prerender instead.\n\nReference \nresumeAndPrerenderToNodeStream(reactNode, postponedState, options?) \n\nCall resumeAndPrerenderToNodeStream to continue a prerendered React tree to a static HTML string.\n\nimport { resumeAndPrerenderToNodeStream } from 'react-dom/static';\n\nimport { getPostponedState } from 'storage';\n\n\n\nasync function handler(request, writable) {\n\n  const postponedState = getPostponedState(request);\n\n  const { prelude } = await resumeAndPrerenderToNodeStream(<App />, JSON.parse(postponedState));\n\n  prelude.pipe(writable);\n\n}\n\nOn the client, call hydrateRoot to make the server-generated HTML interactive.\n\nSee more examples below.\n\nParameters \nreactNode: The React node you called prerender (or a previous resumeAndPrerenderToNodeStream) with. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\npostponedState: The opaque postpone object returned from a prerender API, loaded from wherever you stored it (e.g. redis, a file, or S3).\noptional options: An object with streaming options.\noptional signal: An abort signal that lets you abort server rendering and render the rest on the client.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error.\nReturns \n\nresumeAndPrerenderToNodeStream returns a Promise:\n\nIf rendering the is successful, the Promise will resolve to an object containing:\nprelude: a Web Stream of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.\npostponed: an JSON-serializeable, opaque object that can be passed to resumeToNodeStream or resumeAndPrerenderToNodeStream if resumeAndPrerenderToNodeStream is aborted.\nIf rendering fails, the Promise will be rejected. Use this to output a fallback shell.\nCaveats \n\nnonce is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with CSP it would be inappropriate and insecure to include the nonce value in the prerender itself.\n\nNote\nWhen should I use resumeAndPrerenderToNodeStream? \n\nThe static resumeAndPrerenderToNodeStream API is used for static server-side generation (SSG). Unlike renderToString, resumeAndPrerenderToNodeStream waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like renderToReadableStream.\n\nresumeAndPrerenderToNodeStream can be aborted and later either continued with another resumeAndPrerenderToNodeStream or resumed with resume to support partial pre-rendering.\n\nUsage \nFurther reading \n\nresumeAndPrerenderToNodeStream behaves similarly to prerender but can be used to continue a previously started prerendering process that was aborted.\nFor more information about resuming a prerendered tree, see the resume documentation.\n\nPREVIOUS\nresumeAndPrerender"
  },
  {
    "title": "Legacy React APIs ‚Äì React",
    "url": "https://react.dev/reference/react/legacy",
    "html": "API REFERENCE\nLegacy React APIs\n\nThese APIs are exported from the react package, but they are not recommended for use in newly written code. See the linked individual API pages for the suggested alternatives.\n\nLegacy APIs \nChildren lets you manipulate and transform the JSX received as the children prop. See alternatives.\ncloneElement lets you create a React element using another element as a starting point. See alternatives.\nComponent lets you define a React component as a JavaScript class. See alternatives.\ncreateElement lets you create a React element. Typically, you‚Äôll use JSX instead.\ncreateRef creates a ref object which can contain arbitrary value. See alternatives.\nforwardRef lets your component expose a DOM node to parent component with a ref.\nisValidElement checks whether a value is a React element. Typically used with cloneElement.\nPureComponent is similar to Component, but it skip re-renders with same props. See alternatives.\nRemoved APIs \n\nThese APIs were removed in React 19:\n\ncreateFactory: use JSX instead.\nClass Components: static contextTypes: use static contextType instead.\nClass Components: static childContextTypes: use static contextType instead.\nClass Components: static getChildContext: use Context instead.\nClass Components: static propTypes: use a type system like TypeScript instead.\nClass Components: this.refs: use createRef instead.\nNEXT\nChildren"
  },
  {
    "title": "Children ‚Äì React",
    "url": "https://react.dev/reference/react/Children",
    "html": "API REFERENCE\nLEGACY REACT APIS\nChildren\nPitfall\n\nUsing Children is uncommon and can lead to fragile code. See common alternatives.\n\nChildren lets you manipulate and transform the JSX you received as the children prop.\n\nconst mappedChildren = Children.map(children, child =>\n\n  <div className=\"Row\">\n\n    {child}\n\n  </div>\n\n);\nReference\nChildren.count(children)\nChildren.forEach(children, fn, thisArg?)\nChildren.map(children, fn, thisArg?)\nChildren.only(children)\nChildren.toArray(children)\nUsage\nTransforming children\nRunning some code for each child\nCounting children\nConverting children to an array\nAlternatives\nExposing multiple components\nAccepting an array of objects as a prop\nCalling a render prop to customize rendering\nTroubleshooting\nI pass a custom component, but the Children methods don‚Äôt show its render result\nReference \nChildren.count(children) \n\nCall Children.count(children) to count the number of children in the children data structure.\n\nimport { Children } from 'react';\n\n\n\nfunction RowList({ children }) {\n\n  return (\n\n    <>\n\n      <h1>Total rows: {Children.count(children)}</h1>\n\n      ...\n\n    </>\n\n  );\n\n}\n\nSee more examples below.\n\nParameters \nchildren: The value of the children prop received by your component.\nReturns \n\nThe number of nodes inside these children.\n\nCaveats \nEmpty nodes (null, undefined, and Booleans), strings, numbers, and React elements count as individual nodes. Arrays don‚Äôt count as individual nodes, but their children do. The traversal does not go deeper than React elements: they don‚Äôt get rendered, and their children aren‚Äôt traversed. Fragments don‚Äôt get traversed.\nChildren.forEach(children, fn, thisArg?) \n\nCall Children.forEach(children, fn, thisArg?) to run some code for each child in the children data structure.\n\nimport { Children } from 'react';\n\n\n\nfunction SeparatorList({ children }) {\n\n  const result = [];\n\n  Children.forEach(children, (child, index) => {\n\n    result.push(child);\n\n    result.push(<hr key={index} />);\n\n  });\n\n  // ...\n\nSee more examples below.\n\nParameters \nchildren: The value of the children prop received by your component.\nfn: The function you want to run for each child, similar to the array forEach method callback. It will be called with the child as the first argument and its index as the second argument. The index starts at 0 and increments on each call.\noptional thisArg: The this value with which the fn function should be called. If omitted, it‚Äôs undefined.\nReturns \n\nChildren.forEach returns undefined.\n\nCaveats \nEmpty nodes (null, undefined, and Booleans), strings, numbers, and React elements count as individual nodes. Arrays don‚Äôt count as individual nodes, but their children do. The traversal does not go deeper than React elements: they don‚Äôt get rendered, and their children aren‚Äôt traversed. Fragments don‚Äôt get traversed.\nChildren.map(children, fn, thisArg?) \n\nCall Children.map(children, fn, thisArg?) to map or transform each child in the children data structure.\n\nimport { Children } from 'react';\n\n\n\nfunction RowList({ children }) {\n\n  return (\n\n    <div className=\"RowList\">\n\n      {Children.map(children, child =>\n\n        <div className=\"Row\">\n\n          {child}\n\n        </div>\n\n      )}\n\n    </div>\n\n  );\n\n}\n\nSee more examples below.\n\nParameters \nchildren: The value of the children prop received by your component.\nfn: The mapping function, similar to the array map method callback. It will be called with the child as the first argument and its index as the second argument. The index starts at 0 and increments on each call. You need to return a React node from this function. This may be an empty node (null, undefined, or a Boolean), a string, a number, a React element, or an array of other React nodes.\noptional thisArg: The this value with which the fn function should be called. If omitted, it‚Äôs undefined.\nReturns \n\nIf children is null or undefined, returns the same value.\n\nOtherwise, returns a flat array consisting of the nodes you‚Äôve returned from the fn function. The returned array will contain all nodes you returned except for null and undefined.\n\nCaveats \n\nEmpty nodes (null, undefined, and Booleans), strings, numbers, and React elements count as individual nodes. Arrays don‚Äôt count as individual nodes, but their children do. The traversal does not go deeper than React elements: they don‚Äôt get rendered, and their children aren‚Äôt traversed. Fragments don‚Äôt get traversed.\n\nIf you return an element or an array of elements with keys from fn, the returned elements‚Äô keys will be automatically combined with the key of the corresponding original item from children. When you return multiple elements from fn in an array, their keys only need to be unique locally amongst each other.\n\nChildren.only(children) \n\nCall Children.only(children) to assert that children represent a single React element.\n\nfunction Box({ children }) {\n\n  const element = Children.only(children);\n\n  // ...\nParameters \nchildren: The value of the children prop received by your component.\nReturns \n\nIf children is a valid element, returns that element.\n\nOtherwise, throws an error.\n\nCaveats \nThis method always throws if you pass an array (such as the return value of Children.map) as children. In other words, it enforces that children is a single React element, not that it‚Äôs an array with a single element.\nChildren.toArray(children) \n\nCall Children.toArray(children) to create an array out of the children data structure.\n\nimport { Children } from 'react';\n\n\n\nexport default function ReversedList({ children }) {\n\n  const result = Children.toArray(children);\n\n  result.reverse();\n\n  // ...\nParameters \nchildren: The value of the children prop received by your component.\nReturns \n\nReturns a flat array of elements in children.\n\nCaveats \nEmpty nodes (null, undefined, and Booleans) will be omitted in the returned array. The returned elements‚Äô keys will be calculated from the original elements‚Äô keys and their level of nesting and position. This ensures that flattening the array does not introduce changes in behavior.\nUsage \nTransforming children \n\nTo transform the children JSX that your component receives as the children prop, call Children.map:\n\nimport { Children } from 'react';\n\n\n\nfunction RowList({ children }) {\n\n  return (\n\n    <div className=\"RowList\">\n\n      {Children.map(children, child =>\n\n        <div className=\"Row\">\n\n          {child}\n\n        </div>\n\n      )}\n\n    </div>\n\n  );\n\n}\n\nIn the example above, the RowList wraps every child it receives into a <div className=\"Row\"> container. For example, let‚Äôs say the parent component passes three <p> tags as the children prop to RowList:\n\n<RowList>\n\n  <p>This is the first item.</p>\n\n  <p>This is the second item.</p>\n\n  <p>This is the third item.</p>\n\n</RowList>\n\nThen, with the RowList implementation above, the final rendered result will look like this:\n\n<div className=\"RowList\">\n\n  <div className=\"Row\">\n\n    <p>This is the first item.</p>\n\n  </div>\n\n  <div className=\"Row\">\n\n    <p>This is the second item.</p>\n\n  </div>\n\n  <div className=\"Row\">\n\n    <p>This is the third item.</p>\n\n  </div>\n\n</div>\n\nChildren.map is similar to to transforming arrays with map(). The difference is that the children data structure is considered opaque. This means that even if it‚Äôs sometimes an array, you should not assume it‚Äôs an array or any other particular data type. This is why you should use Children.map if you need to transform it.\n\nApp.js\nRowList.js\nReload\nClear\nFork\nimport { Children } from 'react';\n\nexport default function RowList({ children }) {\n  return (\n    <div className=\"RowList\">\n      {Children.map(children, child =>\n        <div className=\"Row\">\n          {child}\n        </div>\n      )}\n    </div>\n  );\n}\n\n\nDEEP DIVE\nWhy is the children prop not always an array? \nShow Details\nPitfall\n\nThe children data structure does not include rendered output of the components you pass as JSX. In the example below, the children received by the RowList only contains two items rather than three:\n\n<p>This is the first item.</p>\n<MoreRows />\n\nThis is why only two row wrappers are generated in this example:\n\nApp.js\nRowList.js\nReload\nClear\nFork\nimport RowList from './RowList.js';\n\nexport default function App() {\n  return (\n    <RowList>\n      <p>This is the first item.</p>\n      <MoreRows />\n    </RowList>\n  );\n}\n\nfunction MoreRows() {\n  return (\n    <>\n      <p>This is the second item.</p>\n      <p>This is the third item.</p>\n    </>\n  );\n}\n\n\nShow more\n\nThere is no way to get the rendered output of an inner component like <MoreRows /> when manipulating children. This is why it‚Äôs usually better to use one of the alternative solutions.\n\nRunning some code for each child \n\nCall Children.forEach to iterate over each child in the children data structure. It does not return any value and is similar to the array forEach method. You can use it to run custom logic like constructing your own array.\n\nApp.js\nSeparatorList.js\nReload\nClear\nFork\nimport { Children } from 'react';\n\nexport default function SeparatorList({ children }) {\n  const result = [];\n  Children.forEach(children, (child, index) => {\n    result.push(child);\n    result.push(<hr key={index} />);\n  });\n  result.pop(); // Remove the last separator\n  return result;\n}\n\n\nPitfall\n\nAs mentioned earlier, there is no way to get the rendered output of an inner component when manipulating children. This is why it‚Äôs usually better to use one of the alternative solutions.\n\nCounting children \n\nCall Children.count(children) to calculate the number of children.\n\nApp.js\nRowList.js\nReload\nClear\nFork\nimport { Children } from 'react';\n\nexport default function RowList({ children }) {\n  return (\n    <div className=\"RowList\">\n      <h1 className=\"RowListHeader\">\n        Total rows: {Children.count(children)}\n      </h1>\n      {Children.map(children, child =>\n        <div className=\"Row\">\n          {child}\n        </div>\n      )}\n    </div>\n  );\n}\n\n\nShow more\nPitfall\n\nAs mentioned earlier, there is no way to get the rendered output of an inner component when manipulating children. This is why it‚Äôs usually better to use one of the alternative solutions.\n\nConverting children to an array \n\nCall Children.toArray(children) to turn the children data structure into a regular JavaScript array. This lets you manipulate the array with built-in array methods like filter, sort, or reverse.\n\nApp.js\nReversedList.js\nReload\nClear\nFork\nimport { Children } from 'react';\n\nexport default function ReversedList({ children }) {\n  const result = Children.toArray(children);\n  result.reverse();\n  return result;\n}\n\n\nPitfall\n\nAs mentioned earlier, there is no way to get the rendered output of an inner component when manipulating children. This is why it‚Äôs usually better to use one of the alternative solutions.\n\nAlternatives \nNote\n\nThis section describes alternatives to the Children API (with capital C) that‚Äôs imported like this:\n\nimport { Children } from 'react';\n\nDon‚Äôt confuse it with using the children prop (lowercase c), which is good and encouraged.\n\nExposing multiple components \n\nManipulating children with the Children methods often leads to fragile code. When you pass children to a component in JSX, you don‚Äôt usually expect the component to manipulate or transform the individual children.\n\nWhen you can, try to avoid using the Children methods. For example, if you want every child of RowList to be wrapped in <div className=\"Row\">, export a Row component, and manually wrap every row into it like this:\n\nApp.js\nRowList.js\nReload\nClear\nFork\nimport { RowList, Row } from './RowList.js';\n\nexport default function App() {\n  return (\n    <RowList>\n      <Row>\n        <p>This is the first item.</p>\n      </Row>\n      <Row>\n        <p>This is the second item.</p>\n      </Row>\n      <Row>\n        <p>This is the third item.</p>\n      </Row>\n    </RowList>\n  );\n}\n\n\nShow more\n\nUnlike using Children.map, this approach does not wrap every child automatically. However, this approach has a significant benefit compared to the earlier example with Children.map because it works even if you keep extracting more components. For example, it still works if you extract your own MoreRows component:\n\nApp.js\nRowList.js\nReload\nClear\nFork\nimport { RowList, Row } from './RowList.js';\n\nexport default function App() {\n  return (\n    <RowList>\n      <Row>\n        <p>This is the first item.</p>\n      </Row>\n      <MoreRows />\n    </RowList>\n  );\n}\n\nfunction MoreRows() {\n  return (\n    <>\n      <Row>\n        <p>This is the second item.</p>\n      </Row>\n      <Row>\n        <p>This is the third item.</p>\n      </Row>\n    </>\n  );\n}\n\n\nShow more\n\nThis wouldn‚Äôt work with Children.map because it would ‚Äúsee‚Äù <MoreRows /> as a single child (and a single row).\n\nAccepting an array of objects as a prop \n\nYou can also explicitly pass an array as a prop. For example, this RowList accepts a rows array as a prop:\n\nApp.js\nRowList.js\nReload\nClear\nFork\nimport { RowList, Row } from './RowList.js';\n\nexport default function App() {\n  return (\n    <RowList rows={[\n      { id: 'first', content: <p>This is the first item.</p> },\n      { id: 'second', content: <p>This is the second item.</p> },\n      { id: 'third', content: <p>This is the third item.</p> }\n    ]} />\n  );\n}\n\n\n\nSince rows is a regular JavaScript array, the RowList component can use built-in array methods like map on it.\n\nThis pattern is especially useful when you want to be able to pass more information as structured data together with children. In the below example, the TabSwitcher component receives an array of objects as the tabs prop:\n\nApp.js\nTabSwitcher.js\nReload\nClear\nFork\nimport TabSwitcher from './TabSwitcher.js';\n\nexport default function App() {\n  return (\n    <TabSwitcher tabs={[\n      {\n        id: 'first',\n        header: 'First',\n        content: <p>This is the first item.</p>\n      },\n      {\n        id: 'second',\n        header: 'Second',\n        content: <p>This is the second item.</p>\n      },\n      {\n        id: 'third',\n        header: 'Third',\n        content: <p>This is the third item.</p>\n      }\n    ]} />\n  );\n}\n\n\nShow more\n\nUnlike passing the children as JSX, this approach lets you associate some extra data like header with each item. Because you are working with the tabs directly, and it is an array, you do not need the Children methods.\n\nCalling a render prop to customize rendering \n\nInstead of producing JSX for every single item, you can also pass a function that returns JSX, and call that function when necessary. In this example, the App component passes a renderContent function to the TabSwitcher component. The TabSwitcher component calls renderContent only for the selected tab:\n\nApp.js\nTabSwitcher.js\nReload\nClear\nFork\nimport TabSwitcher from './TabSwitcher.js';\n\nexport default function App() {\n  return (\n    <TabSwitcher\n      tabIds={['first', 'second', 'third']}\n      getHeader={tabId => {\n        return tabId[0].toUpperCase() + tabId.slice(1);\n      }}\n      renderContent={tabId => {\n        return <p>This is the {tabId} item.</p>;\n      }}\n    />\n  );\n}\n\n\n\nA prop like renderContent is called a render prop because it is a prop that specifies how to render a piece of the user interface. However, there is nothing special about it: it is a regular prop which happens to be a function.\n\nRender props are functions, so you can pass information to them. For example, this RowList component passes the id and the index of each row to the renderRow render prop, which uses index to highlight even rows:\n\nApp.js\nRowList.js\nReload\nClear\nFork\nimport { RowList, Row } from './RowList.js';\n\nexport default function App() {\n  return (\n    <RowList\n      rowIds={['first', 'second', 'third']}\n      renderRow={(id, index) => {\n        return (\n          <Row isHighlighted={index % 2 === 0}>\n            <p>This is the {id} item.</p>\n          </Row> \n        );\n      }}\n    />\n  );\n}\n\n\nShow more\n\nThis is another example of how parent and child components can cooperate without manipulating the children.\n\nTroubleshooting \nI pass a custom component, but the Children methods don‚Äôt show its render result \n\nSuppose you pass two children to RowList like this:\n\n<RowList>\n\n  <p>First item</p>\n\n  <MoreRows />\n\n</RowList>\n\nIf you do Children.count(children) inside RowList, you will get 2. Even if MoreRows renders 10 different items, or if it returns null, Children.count(children) will still be 2. From the RowList‚Äôs perspective, it only ‚Äúsees‚Äù the JSX it has received. It does not ‚Äúsee‚Äù the internals of the MoreRows component.\n\nThe limitation makes it hard to extract a component. This is why alternatives are preferred to using Children.\n\nPREVIOUS\nLegacy React APIs\nNEXT\ncloneElement"
  },
  {
    "title": "cloneElement ‚Äì React",
    "url": "https://react.dev/reference/react/cloneElement",
    "html": "API REFERENCE\nLEGACY REACT APIS\ncloneElement\nPitfall\n\nUsing cloneElement is uncommon and can lead to fragile code. See common alternatives.\n\ncloneElement lets you create a new React element using another element as a starting point.\n\nconst clonedElement = cloneElement(element, props, ...children)\nReference\ncloneElement(element, props, ...children)\nUsage\nOverriding props of an element\nAlternatives\nPassing data with a render prop\nPassing data through context\nExtracting logic into a custom Hook\nReference \ncloneElement(element, props, ...children) \n\nCall cloneElement to create a React element based on the element, but with different props and children:\n\nimport { cloneElement } from 'react';\n\n\n\n// ...\n\nconst clonedElement = cloneElement(\n\n  <Row title=\"Cabbage\">\n\n    Hello\n\n  </Row>,\n\n  { isHighlighted: true },\n\n  'Goodbye'\n\n);\n\n\n\nconsole.log(clonedElement); // <Row title=\"Cabbage\" isHighlighted={true}>Goodbye</Row>\n\nSee more examples below.\n\nParameters \n\nelement: The element argument must be a valid React element. For example, it could be a JSX node like <Something />, the result of calling createElement, or the result of another cloneElement call.\n\nprops: The props argument must either be an object or null. If you pass null, the cloned element will retain all of the original element.props. Otherwise, for every prop in the props object, the returned element will ‚Äúprefer‚Äù the value from props over the value from element.props. The rest of the props will be filled from the original element.props. If you pass props.key or props.ref, they will replace the original ones.\n\noptional ...children: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers, portals, empty nodes (null, undefined, true, and false), and arrays of React nodes. If you don‚Äôt pass any ...children arguments, the original element.props.children will be preserved.\n\nReturns \n\ncloneElement returns a React element object with a few properties:\n\ntype: Same as element.type.\nprops: The result of shallowly merging element.props with the overriding props you have passed.\nref: The original element.ref, unless it was overridden by props.ref.\nkey: The original element.key, unless it was overridden by props.key.\n\nUsually, you‚Äôll return the element from your component or make it a child of another element. Although you may read the element‚Äôs properties, it‚Äôs best to treat every element as opaque after it‚Äôs created, and only render it.\n\nCaveats \n\nCloning an element does not modify the original element.\n\nYou should only pass children as multiple arguments to cloneElement if they are all statically known, like cloneElement(element, null, child1, child2, child3). If your children are dynamic, pass the entire array as the third argument: cloneElement(element, null, listItems). This ensures that React will warn you about missing keys for any dynamic lists. For static lists this is not necessary because they never reorder.\n\ncloneElement makes it harder to trace the data flow, so try the alternatives instead.\n\nUsage \nOverriding props of an element \n\nTo override the props of some React element, pass it to cloneElement with the props you want to override:\n\nimport { cloneElement } from 'react';\n\n\n\n// ...\n\nconst clonedElement = cloneElement(\n\n  <Row title=\"Cabbage\" />,\n\n  { isHighlighted: true }\n\n);\n\nHere, the resulting cloned element will be <Row title=\"Cabbage\" isHighlighted={true} />.\n\nLet‚Äôs walk through an example to see when it‚Äôs useful.\n\nImagine a List component that renders its children as a list of selectable rows with a ‚ÄúNext‚Äù button that changes which row is selected. The List component needs to render the selected Row differently, so it clones every <Row> child that it has received, and adds an extra isHighlighted: true or isHighlighted: false prop:\n\nexport default function List({ children }) {\n\n  const [selectedIndex, setSelectedIndex] = useState(0);\n\n  return (\n\n    <div className=\"List\">\n\n      {Children.map(children, (child, index) =>\n\n        cloneElement(child, {\n\n          isHighlighted: index === selectedIndex \n\n        })\n\n      )}\n\nLet‚Äôs say the original JSX received by List looks like this:\n\n<List>\n\n  <Row title=\"Cabbage\" />\n\n  <Row title=\"Garlic\" />\n\n  <Row title=\"Apple\" />\n\n</List>\n\nBy cloning its children, the List can pass extra information to every Row inside. The result looks like this:\n\n<List>\n\n  <Row\n\n    title=\"Cabbage\"\n\n    isHighlighted={true} \n\n  />\n\n  <Row\n\n    title=\"Garlic\"\n\n    isHighlighted={false} \n\n  />\n\n  <Row\n\n    title=\"Apple\"\n\n    isHighlighted={false} \n\n  />\n\n</List>\n\nNotice how pressing ‚ÄúNext‚Äù updates the state of the List, and highlights a different row:\n\nApp.js\nList.js\nRow.js\ndata.js\nReload\nClear\nFork\nimport { Children, cloneElement, useState } from 'react';\n\nexport default function List({ children }) {\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  return (\n    <div className=\"List\">\n      {Children.map(children, (child, index) =>\n        cloneElement(child, {\n          isHighlighted: index === selectedIndex \n        })\n      )}\n      <hr />\n      <button onClick={() => {\n        setSelectedIndex(i =>\n          (i + 1) % Children.count(children)\n        );\n      }}>\n        Next\n      </button>\n    </div>\n  );\n}\n\n\nShow more\n\nTo summarize, the List cloned the <Row /> elements it received and added an extra prop to them.\n\nPitfall\n\nCloning children makes it hard to tell how the data flows through your app. Try one of the alternatives.\n\nAlternatives \nPassing data with a render prop \n\nInstead of using cloneElement, consider accepting a render prop like renderItem. Here, List receives renderItem as a prop. List calls renderItem for every item and passes isHighlighted as an argument:\n\nexport default function List({ items, renderItem }) {\n\n  const [selectedIndex, setSelectedIndex] = useState(0);\n\n  return (\n\n    <div className=\"List\">\n\n      {items.map((item, index) => {\n\n        const isHighlighted = index === selectedIndex;\n\n        return renderItem(item, isHighlighted);\n\n      })}\n\nThe renderItem prop is called a ‚Äúrender prop‚Äù because it‚Äôs a prop that specifies how to render something. For example, you can pass a renderItem implementation that renders a <Row> with the given isHighlighted value:\n\n<List\n\n  items={products}\n\n  renderItem={(product, isHighlighted) =>\n\n    <Row\n\n      key={product.id}\n\n      title={product.title}\n\n      isHighlighted={isHighlighted}\n\n    />\n\n  }\n\n/>\n\nThe end result is the same as with cloneElement:\n\n<List>\n\n  <Row\n\n    title=\"Cabbage\"\n\n    isHighlighted={true} \n\n  />\n\n  <Row\n\n    title=\"Garlic\"\n\n    isHighlighted={false} \n\n  />\n\n  <Row\n\n    title=\"Apple\"\n\n    isHighlighted={false} \n\n  />\n\n</List>\n\nHowever, you can clearly trace where the isHighlighted value is coming from.\n\nApp.js\nList.js\nRow.js\ndata.js\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function List({ items, renderItem }) {\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  return (\n    <div className=\"List\">\n      {items.map((item, index) => {\n        const isHighlighted = index === selectedIndex;\n        return renderItem(item, isHighlighted);\n      })}\n      <hr />\n      <button onClick={() => {\n        setSelectedIndex(i =>\n          (i + 1) % items.length\n        );\n      }}>\n        Next\n      </button>\n    </div>\n  );\n}\n\n\nShow more\n\nThis pattern is preferred to cloneElement because it is more explicit.\n\nPassing data through context \n\nAnother alternative to cloneElement is to pass data through context.\n\nFor example, you can call createContext to define a HighlightContext:\n\nexport const HighlightContext = createContext(false);\n\nYour List component can wrap every item it renders into a HighlightContext provider:\n\nexport default function List({ items, renderItem }) {\n\n  const [selectedIndex, setSelectedIndex] = useState(0);\n\n  return (\n\n    <div className=\"List\">\n\n      {items.map((item, index) => {\n\n        const isHighlighted = index === selectedIndex;\n\n        return (\n\n          <HighlightContext key={item.id} value={isHighlighted}>\n\n            {renderItem(item)}\n\n          </HighlightContext>\n\n        );\n\n      })}\n\nWith this approach, Row does not need to receive an isHighlighted prop at all. Instead, it reads the context:\n\nexport default function Row({ title }) {\n\n  const isHighlighted = useContext(HighlightContext);\n\n  // ...\n\nThis allows the calling component to not know or worry about passing isHighlighted to <Row>:\n\n<List\n\n  items={products}\n\n  renderItem={product =>\n\n    <Row title={product.title} />\n\n  }\n\n/>\n\nInstead, List and Row coordinate the highlighting logic through context.\n\nApp.js\nList.js\nRow.js\nHighlightContext.js\ndata.js\nReload\nClear\nFork\nimport { useState } from 'react';\nimport { HighlightContext } from './HighlightContext.js';\n\nexport default function List({ items, renderItem }) {\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  return (\n    <div className=\"List\">\n      {items.map((item, index) => {\n        const isHighlighted = index === selectedIndex;\n        return (\n          <HighlightContext\n            key={item.id}\n            value={isHighlighted}\n          >\n            {renderItem(item)}\n          </HighlightContext>\n        );\n      })}\n      <hr />\n      <button onClick={() => {\n        setSelectedIndex(i =>\n          (i + 1) % items.length\n        );\n      }}>\n        Next\n      </button>\n    </div>\n  );\n}\n\n\nShow more\n\nLearn more about passing data through context.\n\nExtracting logic into a custom Hook \n\nAnother approach you can try is to extract the ‚Äúnon-visual‚Äù logic into your own Hook, and use the information returned by your Hook to decide what to render. For example, you could write a useList custom Hook like this:\n\nimport { useState } from 'react';\n\n\n\nexport default function useList(items) {\n\n  const [selectedIndex, setSelectedIndex] = useState(0);\n\n\n\n  function onNext() {\n\n    setSelectedIndex(i =>\n\n      (i + 1) % items.length\n\n    );\n\n  }\n\n\n\n  const selected = items[selectedIndex];\n\n  return [selected, onNext];\n\n}\n\nThen you could use it like this:\n\nexport default function App() {\n\n  const [selected, onNext] = useList(products);\n\n  return (\n\n    <div className=\"List\">\n\n      {products.map(product =>\n\n        <Row\n\n          key={product.id}\n\n          title={product.title}\n\n          isHighlighted={selected === product}\n\n        />\n\n      )}\n\n      <hr />\n\n      <button onClick={onNext}>\n\n        Next\n\n      </button>\n\n    </div>\n\n  );\n\n}\n\nThe data flow is explicit, but the state is inside the useList custom Hook that you can use from any component:\n\nApp.js\nuseList.js\nRow.js\ndata.js\nReload\nClear\nFork\nimport Row from './Row.js';\nimport useList from './useList.js';\nimport { products } from './data.js';\n\nexport default function App() {\n  const [selected, onNext] = useList(products);\n  return (\n    <div className=\"List\">\n      {products.map(product =>\n        <Row\n          key={product.id}\n          title={product.title}\n          isHighlighted={selected === product}\n        />\n      )}\n      <hr />\n      <button onClick={onNext}>\n        Next\n      </button>\n    </div>\n  );\n}\n\n\nShow more\n\nThis approach is particularly useful if you want to reuse this logic between different components.\n\nPREVIOUS\nChildren\nNEXT\nComponent"
  },
  {
    "title": "Component ‚Äì React",
    "url": "https://react.dev/reference/react/Component",
    "html": "API REFERENCE\nLEGACY REACT APIS\nComponent\nPitfall\n\nWe recommend defining components as functions instead of classes. See how to migrate.\n\nComponent is the base class for the React components defined as JavaScript classes. Class components are still supported by React, but we don‚Äôt recommend using them in new code.\n\nclass Greeting extends Component {\n\n  render() {\n\n    return <h1>Hello, {this.props.name}!</h1>;\n\n  }\n\n}\nReference\nComponent\ncontext\nprops\nstate\nconstructor(props)\ncomponentDidCatch(error, info)\ncomponentDidMount()\ncomponentDidUpdate(prevProps, prevState, snapshot?)\ncomponentWillMount()\ncomponentWillReceiveProps(nextProps)\ncomponentWillUpdate(nextProps, nextState)\ncomponentWillUnmount()\nforceUpdate(callback?)\ngetSnapshotBeforeUpdate(prevProps, prevState)\nrender()\nsetState(nextState, callback?)\nshouldComponentUpdate(nextProps, nextState, nextContext)\nUNSAFE_componentWillMount()\nUNSAFE_componentWillReceiveProps(nextProps, nextContext)\nUNSAFE_componentWillUpdate(nextProps, nextState)\nstatic contextType\nstatic defaultProps\nstatic getDerivedStateFromError(error)\nstatic getDerivedStateFromProps(props, state)\nUsage\nDefining a class component\nAdding state to a class component\nAdding lifecycle methods to a class component\nCatching rendering errors with an Error Boundary\nAlternatives\nMigrating a simple component from a class to a function\nMigrating a component with state from a class to a function\nMigrating a component with lifecycle methods from a class to a function\nMigrating a component with context from a class to a function\nReference \nComponent \n\nTo define a React component as a class, extend the built-in Component class and define a render method:\n\nimport { Component } from 'react';\n\n\n\nclass Greeting extends Component {\n\n  render() {\n\n    return <h1>Hello, {this.props.name}!</h1>;\n\n  }\n\n}\n\nOnly the render method is required, other methods are optional.\n\nSee more examples below.\n\ncontext \n\nThe context of a class component is available as this.context. It is only available if you specify which context you want to receive using static contextType.\n\nA class component can only read one context at a time.\n\nclass Button extends Component {\n\n  static contextType = ThemeContext;\n\n\n\n  render() {\n\n    const theme = this.context;\n\n    const className = 'button-' + theme;\n\n    return (\n\n      <button className={className}>\n\n        {this.props.children}\n\n      </button>\n\n    );\n\n  }\n\n}\nNote\n\nReading this.context in class components is equivalent to useContext in function components.\n\nSee how to migrate.\n\nprops \n\nThe props passed to a class component are available as this.props.\n\nclass Greeting extends Component {\n\n  render() {\n\n    return <h1>Hello, {this.props.name}!</h1>;\n\n  }\n\n}\n\n\n\n<Greeting name=\"Taylor\" />\nNote\n\nReading this.props in class components is equivalent to declaring props in function components.\n\nSee how to migrate.\n\nstate \n\nThe state of a class component is available as this.state. The state field must be an object. Do not mutate the state directly. If you wish to change the state, call setState with the new state.\n\nclass Counter extends Component {\n\n  state = {\n\n    age: 42,\n\n  };\n\n\n\n  handleAgeChange = () => {\n\n    this.setState({\n\n      age: this.state.age + 1 \n\n    });\n\n  };\n\n\n\n  render() {\n\n    return (\n\n      <>\n\n        <button onClick={this.handleAgeChange}>\n\n        Increment age\n\n        </button>\n\n        <p>You are {this.state.age}.</p>\n\n      </>\n\n    );\n\n  }\n\n}\nNote\n\nDefining state in class components is equivalent to calling useState in function components.\n\nSee how to migrate.\n\nconstructor(props) \n\nThe constructor runs before your class component mounts (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and bind your class methods to the class instance:\n\nclass Counter extends Component {\n\n  constructor(props) {\n\n    super(props);\n\n    this.state = { counter: 0 };\n\n    this.handleClick = this.handleClick.bind(this);\n\n  }\n\n\n\n  handleClick() {\n\n    // ...\n\n  }\n\nIf you use modern JavaScript syntax, constructors are rarely needed. Instead, you can rewrite this code above using the public class field syntax which is supported both by modern browsers and tools like Babel:\n\nclass Counter extends Component {\n\n  state = { counter: 0 };\n\n\n\n  handleClick = () => {\n\n    // ...\n\n  }\n\nA constructor should not contain any side effects or subscriptions.\n\nParameters \nprops: The component‚Äôs initial props.\nReturns \n\nconstructor should not return anything.\n\nCaveats \n\nDo not run any side effects or subscriptions in the constructor. Instead, use componentDidMount for that.\n\nInside a constructor, you need to call super(props) before any other statement. If you don‚Äôt do that, this.props will be undefined while the constructor runs, which can be confusing and cause bugs.\n\nConstructor is the only place where you can assign this.state directly. In all other methods, you need to use this.setState() instead. Do not call setState in the constructor.\n\nWhen you use server rendering, the constructor will run on the server too, followed by the render method. However, lifecycle methods like componentDidMount or componentWillUnmount will not run on the server.\n\nWhen Strict Mode is on, React will call constructor twice in development and then throw away one of the instances. This helps you notice the accidental side effects that need to be moved out of the constructor.\n\nNote\n\nThere is no exact equivalent for constructor in function components. To declare state in a function component, call useState. To avoid recalculating the initial state, pass a function to useState.\n\ncomponentDidCatch(error, info) \n\nIf you define componentDidCatch, React will call it when some child component (including distant children) throws an error during rendering. This lets you log that error to an error reporting service in production.\n\nTypically, it is used together with static getDerivedStateFromError which lets you update state in response to an error and display an error message to the user. A component with these methods is called an Error Boundary.\n\nSee an example.\n\nParameters \n\nerror: The error that was thrown. In practice, it will usually be an instance of Error but this is not guaranteed because JavaScript allows to throw any value, including strings or even null.\n\ninfo: An object containing additional information about the error. Its componentStack field contains a stack trace with the component that threw, as well as the names and source locations of all its parent components. In production, the component names will be minified. If you set up production error reporting, you can decode the component stack using sourcemaps the same way as you would do for regular JavaScript error stacks.\n\nReturns \n\ncomponentDidCatch should not return anything.\n\nCaveats \n\nIn the past, it was common to call setState inside componentDidCatch in order to update the UI and display the fallback error message. This is deprecated in favor of defining static getDerivedStateFromError.\n\nProduction and development builds of React slightly differ in the way componentDidCatch handles errors. In development, the errors will bubble up to window, which means that any window.onerror or window.addEventListener('error', callback) will intercept the errors that have been caught by componentDidCatch. In production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught by componentDidCatch.\n\nNote\n\nThere is no direct equivalent for componentDidCatch in function components yet. If you‚Äôd like to avoid creating class components, write a single ErrorBoundary component like above and use it throughout your app. Alternatively, you can use the react-error-boundary package which does that for you.\n\ncomponentDidMount() \n\nIf you define the componentDidMount method, React will call it when your component is added (mounted) to the screen. This is a common place to start data fetching, set up subscriptions, or manipulate the DOM nodes.\n\nIf you implement componentDidMount, you usually need to implement other lifecycle methods to avoid bugs. For example, if componentDidMount reads some state or props, you also have to implement componentDidUpdate to handle their changes, and componentWillUnmount to clean up whatever componentDidMount was doing.\n\nclass ChatRoom extends Component {\n\n  state = {\n\n    serverUrl: 'https://localhost:1234'\n\n  };\n\n\n\n  componentDidMount() {\n\n    this.setupConnection();\n\n  }\n\n\n\n  componentDidUpdate(prevProps, prevState) {\n\n    if (\n\n      this.props.roomId !== prevProps.roomId ||\n\n      this.state.serverUrl !== prevState.serverUrl\n\n    ) {\n\n      this.destroyConnection();\n\n      this.setupConnection();\n\n    }\n\n  }\n\n\n\n  componentWillUnmount() {\n\n    this.destroyConnection();\n\n  }\n\n\n\n  // ...\n\n}\n\nSee more examples.\n\nParameters \n\ncomponentDidMount does not take any parameters.\n\nReturns \n\ncomponentDidMount should not return anything.\n\nCaveats \n\nWhen Strict Mode is on, in development React will call componentDidMount, then immediately call componentWillUnmount, and then call componentDidMount again. This helps you notice if you forgot to implement componentWillUnmount or if its logic doesn‚Äôt fully ‚Äúmirror‚Äù what componentDidMount does.\n\nAlthough you may call setState immediately in componentDidMount, it‚Äôs best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the render will be called twice in this case, the user won‚Äôt see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the constructor instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n\nNote\n\nFor many use cases, defining componentDidMount, componentDidUpdate, and componentWillUnmount together in class components is equivalent to calling useEffect in function components. In the rare cases where it‚Äôs important for the code to run before browser paint, useLayoutEffect is a closer match.\n\nSee how to migrate.\n\ncomponentDidUpdate(prevProps, prevState, snapshot?) \n\nIf you define the componentDidUpdate method, React will call it immediately after your component has been re-rendered with updated props or state.  This method is not called for the initial render.\n\nYou can use it to manipulate the DOM after an update. This is also a common place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed). Typically, you‚Äôd use it together with componentDidMount and componentWillUnmount:\n\nclass ChatRoom extends Component {\n\n  state = {\n\n    serverUrl: 'https://localhost:1234'\n\n  };\n\n\n\n  componentDidMount() {\n\n    this.setupConnection();\n\n  }\n\n\n\n  componentDidUpdate(prevProps, prevState) {\n\n    if (\n\n      this.props.roomId !== prevProps.roomId ||\n\n      this.state.serverUrl !== prevState.serverUrl\n\n    ) {\n\n      this.destroyConnection();\n\n      this.setupConnection();\n\n    }\n\n  }\n\n\n\n  componentWillUnmount() {\n\n    this.destroyConnection();\n\n  }\n\n\n\n  // ...\n\n}\n\nSee more examples.\n\nParameters \n\nprevProps: Props before the update. Compare prevProps to this.props to determine what changed.\n\nprevState: State before the update. Compare prevState to this.state to determine what changed.\n\nsnapshot: If you implemented getSnapshotBeforeUpdate, snapshot will contain the value you returned from that method. Otherwise, it will be undefined.\n\nReturns \n\ncomponentDidUpdate should not return anything.\n\nCaveats \n\ncomponentDidUpdate will not get called if shouldComponentUpdate is defined and returns false.\n\nThe logic inside componentDidUpdate should usually be wrapped in conditions comparing this.props with prevProps, and this.state with prevState. Otherwise, there‚Äôs a risk of creating infinite loops.\n\nAlthough you may call setState immediately in componentDidUpdate, it‚Äôs best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the render will be called twice in this case, the user won‚Äôt see the intermediate state. This pattern often causes performance issues, but it may be necessary for rare cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n\nNote\n\nFor many use cases, defining componentDidMount, componentDidUpdate, and componentWillUnmount together in class components is equivalent to calling useEffect in function components. In the rare cases where it‚Äôs important for the code to run before browser paint, useLayoutEffect is a closer match.\n\nSee how to migrate.\n\ncomponentWillMount() \nDeprecated\n\nThis API has been renamed from componentWillMount to UNSAFE_componentWillMount. The old name has been deprecated. In a future major version of React, only the new name will work.\n\nRun the rename-unsafe-lifecycles codemod to automatically update your components.\n\ncomponentWillReceiveProps(nextProps) \nDeprecated\n\nThis API has been renamed from componentWillReceiveProps to UNSAFE_componentWillReceiveProps. The old name has been deprecated. In a future major version of React, only the new name will work.\n\nRun the rename-unsafe-lifecycles codemod to automatically update your components.\n\ncomponentWillUpdate(nextProps, nextState) \nDeprecated\n\nThis API has been renamed from componentWillUpdate to UNSAFE_componentWillUpdate. The old name has been deprecated. In a future major version of React, only the new name will work.\n\nRun the rename-unsafe-lifecycles codemod to automatically update your components.\n\ncomponentWillUnmount() \n\nIf you define the componentWillUnmount method, React will call it before your component is removed (unmounted) from the screen. This is a common place to cancel data fetching or remove subscriptions.\n\nThe logic inside componentWillUnmount should ‚Äúmirror‚Äù the logic inside componentDidMount. For example, if componentDidMount sets up a subscription, componentWillUnmount should clean up that subscription. If the cleanup logic in your componentWillUnmount reads some props or state, you will usually also need to implement componentDidUpdate to clean up resources (such as subscriptions) corresponding to the old props and state.\n\nclass ChatRoom extends Component {\n\n  state = {\n\n    serverUrl: 'https://localhost:1234'\n\n  };\n\n\n\n  componentDidMount() {\n\n    this.setupConnection();\n\n  }\n\n\n\n  componentDidUpdate(prevProps, prevState) {\n\n    if (\n\n      this.props.roomId !== prevProps.roomId ||\n\n      this.state.serverUrl !== prevState.serverUrl\n\n    ) {\n\n      this.destroyConnection();\n\n      this.setupConnection();\n\n    }\n\n  }\n\n\n\n  componentWillUnmount() {\n\n    this.destroyConnection();\n\n  }\n\n\n\n  // ...\n\n}\n\nSee more examples.\n\nParameters \n\ncomponentWillUnmount does not take any parameters.\n\nReturns \n\ncomponentWillUnmount should not return anything.\n\nCaveats \nWhen Strict Mode is on, in development React will call componentDidMount, then immediately call componentWillUnmount, and then call componentDidMount again. This helps you notice if you forgot to implement componentWillUnmount or if its logic doesn‚Äôt fully ‚Äúmirror‚Äù what componentDidMount does.\nNote\n\nFor many use cases, defining componentDidMount, componentDidUpdate, and componentWillUnmount together in class components is equivalent to calling useEffect in function components. In the rare cases where it‚Äôs important for the code to run before browser paint, useLayoutEffect is a closer match.\n\nSee how to migrate.\n\nforceUpdate(callback?) \n\nForces a component to re-render.\n\nUsually, this is not necessary. If your component‚Äôs render method only reads from this.props, this.state, or this.context, it will re-render automatically when you call setState inside your component or one of its parents. However, if your component‚Äôs render method reads directly from an external data source, you have to tell React to update the user interface when that data source changes. That‚Äôs what forceUpdate lets you do.\n\nTry to avoid all uses of forceUpdate and only read from this.props and this.state in render.\n\nParameters \noptional callback If specified, React will call the callback you‚Äôve provided after the update is committed.\nReturns \n\nforceUpdate does not return anything.\n\nCaveats \nIf you call forceUpdate, React will re-render without calling shouldComponentUpdate.\nNote\n\nReading an external data source and forcing class components to re-render in response to its changes with forceUpdate has been superseded by useSyncExternalStore in function components.\n\ngetSnapshotBeforeUpdate(prevProps, prevState) \n\nIf you implement getSnapshotBeforeUpdate, React will call it immediately before React updates the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to componentDidUpdate.\n\nFor example, you can use it in a UI like a chat thread that needs to preserve its scroll position during updates:\n\nclass ScrollingList extends React.Component {\n\n  constructor(props) {\n\n    super(props);\n\n    this.listRef = React.createRef();\n\n  }\n\n\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n\n    // Are we adding new items to the list?\n\n    // Capture the scroll position so we can adjust scroll later.\n\n    if (prevProps.list.length < this.props.list.length) {\n\n      const list = this.listRef.current;\n\n      return list.scrollHeight - list.scrollTop;\n\n    }\n\n    return null;\n\n  }\n\n\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n\n    // If we have a snapshot value, we've just added new items.\n\n    // Adjust scroll so these new items don't push the old ones out of view.\n\n    // (snapshot here is the value returned from getSnapshotBeforeUpdate)\n\n    if (snapshot !== null) {\n\n      const list = this.listRef.current;\n\n      list.scrollTop = list.scrollHeight - snapshot;\n\n    }\n\n  }\n\n\n\n  render() {\n\n    return (\n\n      <div ref={this.listRef}>{/* ...contents... */}</div>\n\n    );\n\n  }\n\n}\n\nIn the above example, it is important to read the scrollHeight property directly in getSnapshotBeforeUpdate. It is not safe to read it in render, UNSAFE_componentWillReceiveProps, or UNSAFE_componentWillUpdate because there is a potential time gap between these methods getting called and React updating the DOM.\n\nParameters \n\nprevProps: Props before the update. Compare prevProps to this.props to determine what changed.\n\nprevState: State before the update. Compare prevState to this.state to determine what changed.\n\nReturns \n\nYou should return a snapshot value of any type that you‚Äôd like, or null. The value you returned will be passed as the third argument to componentDidUpdate.\n\nCaveats \ngetSnapshotBeforeUpdate will not get called if shouldComponentUpdate is defined and returns false.\nNote\n\nAt the moment, there is no equivalent to getSnapshotBeforeUpdate for function components. This use case is very uncommon, but if you have the need for it, for now you‚Äôll have to write a class component.\n\nrender() \n\nThe render method is the only required method in a class component.\n\nThe render method should specify what you want to appear on the screen, for example:\n\nimport { Component } from 'react';\n\n\n\nclass Greeting extends Component {\n\n  render() {\n\n    return <h1>Hello, {this.props.name}!</h1>;\n\n  }\n\n}\n\nReact may call render at any moment, so you shouldn‚Äôt assume that it runs at a particular time. Usually, the render method should return a piece of JSX, but a few other return types (like strings) are supported. To calculate the returned JSX, the render method can read this.props, this.state, and this.context.\n\nYou should write the render method as a pure function, meaning that it should return the same result if props, state, and context are the same. It also shouldn‚Äôt contain side effects (like setting up subscriptions) or interact with the browser APIs. Side effects should happen either in event handlers or methods like componentDidMount.\n\nParameters \n\nrender does not take any parameters.\n\nReturns \n\nrender can return any valid React node. This includes React elements such as <div />, strings, numbers, portals, empty nodes (null, undefined, true, and false), and arrays of React nodes.\n\nCaveats \n\nrender should be written as a pure function of props, state, and context. It should not have side effects.\n\nrender will not get called if shouldComponentUpdate is defined and returns false.\n\nWhen Strict Mode is on, React will call render twice in development and then throw away one of the results. This helps you notice the accidental side effects that need to be moved out of the render method.\n\nThere is no one-to-one correspondence between the render call and the subsequent componentDidMount or componentDidUpdate call. Some of the render call results may be discarded by React when it‚Äôs beneficial.\n\nsetState(nextState, callback?) \n\nCall setState to update the state of your React component.\n\nclass Form extends Component {\n\n  state = {\n\n    name: 'Taylor',\n\n  };\n\n\n\n  handleNameChange = (e) => {\n\n    const newName = e.target.value;\n\n    this.setState({\n\n      name: newName\n\n    });\n\n  }\n\n\n\n  render() {\n\n    return (\n\n      <>\n\n        <input value={this.state.name} onChange={this.handleNameChange} />\n\n        <p>Hello, {this.state.name}.</p>\n\n      </>\n\n    );\n\n  }\n\n}\n\nsetState enqueues changes to the component state. It tells React that this component and its children need to re-render with the new state. This is the main way you‚Äôll update the user interface in response to interactions.\n\nPitfall\n\nCalling setState does not change the current state in the already executing code:\n\nfunction handleClick() {\n\n  console.log(this.state.name); // \"Taylor\"\n\n  this.setState({\n\n    name: 'Robin'\n\n  });\n\n  console.log(this.state.name); // Still \"Taylor\"!\n\n}\n\nIt only affects what this.state will return starting from the next render.\n\nYou can also pass a function to setState. It lets you update state based on the previous state:\n\n  handleIncreaseAge = () => {\n\n    this.setState(prevState => {\n\n      return {\n\n        age: prevState.age + 1\n\n      };\n\n    });\n\n  }\n\nYou don‚Äôt have to do this, but it‚Äôs handy if you want to update state multiple times during the same event.\n\nParameters \n\nnextState: Either an object or a function.\n\nIf you pass an object as nextState, it will be shallowly merged into this.state.\nIf you pass a function as nextState, it will be treated as an updater function. It must be pure, should take the pending state and props as arguments, and should return the object to be shallowly merged into this.state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.\n\noptional callback: If specified, React will call the callback you‚Äôve provided after the update is committed.\n\nReturns \n\nsetState does not return anything.\n\nCaveats \n\nThink of setState as a request rather than an immediate command to update the component. When multiple components update their state in response to an event, React will batch their updates and re-render them together in a single pass at the end of the event. In the rare case that you need to force a particular state update to be applied synchronously, you may wrap it in flushSync, but this may hurt performance.\n\nsetState does not update this.state immediately. This makes reading this.state right after calling setState a potential pitfall. Instead, use componentDidUpdate or the setState callback argument, either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, you can pass a function to nextState as described above.\n\nNote\n\nCalling setState in class components is similar to calling a set function in function components.\n\nSee how to migrate.\n\nshouldComponentUpdate(nextProps, nextState, nextContext) \n\nIf you define shouldComponentUpdate, React will call it to determine whether a re-render can be skipped.\n\nIf you are confident you want to write it by hand, you may compare this.props with nextProps and this.state with nextState and return false to tell React the update can be skipped.\n\nclass Rectangle extends Component {\n\n  state = {\n\n    isHovered: false\n\n  };\n\n\n\n  shouldComponentUpdate(nextProps, nextState) {\n\n    if (\n\n      nextProps.position.x === this.props.position.x &&\n\n      nextProps.position.y === this.props.position.y &&\n\n      nextProps.size.width === this.props.size.width &&\n\n      nextProps.size.height === this.props.size.height &&\n\n      nextState.isHovered === this.state.isHovered\n\n    ) {\n\n      // Nothing has changed, so a re-render is unnecessary\n\n      return false;\n\n    }\n\n    return true;\n\n  }\n\n\n\n  // ...\n\n}\n\nReact calls shouldComponentUpdate before rendering when new props or state are being received. Defaults to true. This method is not called for the initial render or when forceUpdate is used.\n\nParameters \nnextProps: The next props that the component is about to render with. Compare nextProps to this.props to determine what changed.\nnextState: The next state that the component is about to render with. Compare nextState to this.state to determine what changed.\nnextContext: The next context that the component is about to render with. Compare nextContext to this.context to determine what changed. Only available if you specify static contextType.\nReturns \n\nReturn true if you want the component to re-render. That‚Äôs the default behavior.\n\nReturn false to tell React that re-rendering can be skipped.\n\nCaveats \n\nThis method only exists as a performance optimization. If your component breaks without it, fix that first.\n\nConsider using PureComponent instead of writing shouldComponentUpdate by hand. PureComponent shallowly compares props and state, and reduces the chance that you‚Äôll skip a necessary update.\n\nWe do not recommend doing deep equality checks or using JSON.stringify in shouldComponentUpdate. It makes performance unpredictable and dependent on the data structure of every prop and state. In the best case, you risk introducing multi-second stalls to your application, and in the worst case you risk crashing it.\n\nReturning false does not prevent child components from re-rendering when their state changes.\n\nReturning false does not guarantee that the component will not re-render. React will use the return value as a hint but it may still choose to re-render your component if it makes sense to do for other reasons.\n\nNote\n\nOptimizing class components with shouldComponentUpdate is similar to optimizing function components with memo. Function components also offer more granular optimization with useMemo.\n\nUNSAFE_componentWillMount() \n\nIf you define UNSAFE_componentWillMount, React will call it immediately after the constructor. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n\nTo initialize state, declare state as a class field or set this.state inside the constructor.\nIf you need to run a side effect or set up a subscription, move that logic to componentDidMount instead.\n\nSee examples of migrating away from unsafe lifecycles.\n\nParameters \n\nUNSAFE_componentWillMount does not take any parameters.\n\nReturns \n\nUNSAFE_componentWillMount should not return anything.\n\nCaveats \n\nUNSAFE_componentWillMount will not get called if the component implements static getDerivedStateFromProps or getSnapshotBeforeUpdate.\n\nDespite its naming, UNSAFE_componentWillMount does not guarantee that the component will get mounted if your app uses modern React features like Suspense. If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. This is why this method is ‚Äúunsafe‚Äù. Code that relies on mounting (like adding a subscription) should go into componentDidMount.\n\nUNSAFE_componentWillMount is the only lifecycle method that runs during server rendering. For all practical purposes, it is identical to constructor, so you should use the constructor for this type of logic instead.\n\nNote\n\nCalling setState inside UNSAFE_componentWillMount in a class component to initialize state is equivalent to passing that state as the initial state to useState in a function component.\n\nUNSAFE_componentWillReceiveProps(nextProps, nextContext) \n\nIf you define UNSAFE_componentWillReceiveProps, React will call it when the component receives new props. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n\nIf you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop changes, move that logic to componentDidUpdate instead.\nIf you need to avoid re-computing some data only when a prop changes, use a memoization helper instead.\nIf you need to ‚Äúreset‚Äù some state when a prop changes, consider either making a component fully controlled or fully uncontrolled with a key instead.\nIf you need to ‚Äúadjust‚Äù some state when a prop changes, check whether you can compute all the necessary information from props alone during rendering. If you can‚Äôt, use static getDerivedStateFromProps instead.\n\nSee examples of migrating away from unsafe lifecycles.\n\nParameters \nnextProps: The next props that the component is about to receive from its parent component. Compare nextProps to this.props to determine what changed.\nnextContext: The next context that the component is about to receive from the closest provider. Compare nextContext to this.context to determine what changed. Only available if you specify static contextType.\nReturns \n\nUNSAFE_componentWillReceiveProps should not return anything.\n\nCaveats \n\nUNSAFE_componentWillReceiveProps will not get called if the component implements static getDerivedStateFromProps or getSnapshotBeforeUpdate.\n\nDespite its naming, UNSAFE_componentWillReceiveProps does not guarantee that the component will receive those props if your app uses modern React features like Suspense. If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props might be different. This is why this method is ‚Äúunsafe‚Äù. Code that should run only for committed updates (like resetting a subscription) should go into componentDidUpdate.\n\nUNSAFE_componentWillReceiveProps does not mean that the component has received different props than the last time. You need to compare nextProps and this.props yourself to check if something changed.\n\nReact doesn‚Äôt call UNSAFE_componentWillReceiveProps with initial props during mounting. It only calls this method if some of component‚Äôs props are going to be updated. For example, calling setState doesn‚Äôt generally trigger UNSAFE_componentWillReceiveProps inside the same component.\n\nNote\n\nCalling setState inside UNSAFE_componentWillReceiveProps in a class component to ‚Äúadjust‚Äù state is equivalent to calling the set function from useState during rendering in a function component.\n\nUNSAFE_componentWillUpdate(nextProps, nextState) \n\nIf you define UNSAFE_componentWillUpdate, React will call it before rendering with the new props or state. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n\nIf you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop or state changes, move that logic to componentDidUpdate instead.\nIf you need to read some information from the DOM (for example, to save the current scroll position) so that you can use it in componentDidUpdate later, read it inside getSnapshotBeforeUpdate instead.\n\nSee examples of migrating away from unsafe lifecycles.\n\nParameters \nnextProps: The next props that the component is about to render with. Compare nextProps to this.props to determine what changed.\nnextState: The next state that the component is about to render with. Compare nextState to this.state to determine what changed.\nReturns \n\nUNSAFE_componentWillUpdate should not return anything.\n\nCaveats \n\nUNSAFE_componentWillUpdate will not get called if shouldComponentUpdate is defined and returns false.\n\nUNSAFE_componentWillUpdate will not get called if the component implements static getDerivedStateFromProps or getSnapshotBeforeUpdate.\n\nIt‚Äôs not supported to call setState (or any method that leads to setState being called, like dispatching a Redux action) during componentWillUpdate.\n\nDespite its naming, UNSAFE_componentWillUpdate does not guarantee that the component will update if your app uses modern React features like Suspense. If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props and state might be different. This is why this method is ‚Äúunsafe‚Äù. Code that should run only for committed updates (like resetting a subscription) should go into componentDidUpdate.\n\nUNSAFE_componentWillUpdate does not mean that the component has received different props or state than the last time. You need to compare nextProps with this.props and nextState with this.state yourself to check if something changed.\n\nReact doesn‚Äôt call UNSAFE_componentWillUpdate with initial props and state during mounting.\n\nNote\n\nThere is no direct equivalent to UNSAFE_componentWillUpdate in function components.\n\nstatic contextType \n\nIf you want to read this.context from your class component, you must specify which context it needs to read. The context you specify as the static contextType must be a value previously created by createContext.\n\nclass Button extends Component {\n\n  static contextType = ThemeContext;\n\n\n\n  render() {\n\n    const theme = this.context;\n\n    const className = 'button-' + theme;\n\n    return (\n\n      <button className={className}>\n\n        {this.props.children}\n\n      </button>\n\n    );\n\n  }\n\n}\nNote\n\nReading this.context in class components is equivalent to useContext in function components.\n\nSee how to migrate.\n\nstatic defaultProps \n\nYou can define static defaultProps to set the default props for the class. They will be used for undefined and missing props, but not for null props.\n\nFor example, here is how you define that the color prop should default to 'blue':\n\nclass Button extends Component {\n\n  static defaultProps = {\n\n    color: 'blue'\n\n  };\n\n\n\n  render() {\n\n    return <button className={this.props.color}>click me</button>;\n\n  }\n\n}\n\nIf the color prop is not provided or is undefined, it will be set by default to 'blue':\n\n<>\n\n  {/* this.props.color is \"blue\" */}\n\n  <Button />\n\n\n\n  {/* this.props.color is \"blue\" */}\n\n  <Button color={undefined} />\n\n\n\n  {/* this.props.color is null */}\n\n  <Button color={null} />\n\n\n\n  {/* this.props.color is \"red\" */}\n\n  <Button color=\"red\" />\n\n</>\nNote\n\nDefining defaultProps in class components is similar to using default values in function components.\n\nstatic getDerivedStateFromError(error) \n\nIf you define static getDerivedStateFromError, React will call it when a child component (including distant children) throws an error during rendering. This lets you display an error message instead of clearing the UI.\n\nTypically, it is used together with componentDidCatch which lets you send the error report to some analytics service. A component with these methods is called an Error Boundary.\n\nSee an example.\n\nParameters \nerror: The error that was thrown. In practice, it will usually be an instance of Error but this is not guaranteed because JavaScript allows to throw any value, including strings or even null.\nReturns \n\nstatic getDerivedStateFromError should return the state telling the component to display the error message.\n\nCaveats \nstatic getDerivedStateFromError should be a pure function. If you want to perform a side effect (for example, to call an analytics service), you need to also implement componentDidCatch.\nNote\n\nThere is no direct equivalent for static getDerivedStateFromError in function components yet. If you‚Äôd like to avoid creating class components, write a single ErrorBoundary component like above and use it throughout your app. Alternatively, use the react-error-boundary package which does that.\n\nstatic getDerivedStateFromProps(props, state) \n\nIf you define static getDerivedStateFromProps, React will call it right before calling render, both on the initial mount and on subsequent updates. It should return an object to update the state, or null to update nothing.\n\nThis method exists for rare use cases where the state depends on changes in props over time. For example, this Form component resets the email state when the userID prop changes:\n\nclass Form extends Component {\n\n  state = {\n\n    email: this.props.defaultEmail,\n\n    prevUserID: this.props.userID\n\n  };\n\n\n\n  static getDerivedStateFromProps(props, state) {\n\n    // Any time the current user changes,\n\n    // Reset any parts of state that are tied to that user.\n\n    // In this simple example, that's just the email.\n\n    if (props.userID !== state.prevUserID) {\n\n      return {\n\n        prevUserID: props.userID,\n\n        email: props.defaultEmail\n\n      };\n\n    }\n\n    return null;\n\n  }\n\n\n\n  // ...\n\n}\n\nNote that this pattern requires you to keep a previous value of the prop (like userID) in state (like prevUserID).\n\nPitfall\n\nDeriving state leads to verbose code and makes your components difficult to think about. Make sure you‚Äôre familiar with simpler alternatives:\n\nIf you need to perform a side effect (for example, data fetching or an animation) in response to a change in props, use componentDidUpdate method instead.\nIf you want to re-compute some data only when a prop changes, use a memoization helper instead.\nIf you want to ‚Äúreset‚Äù some state when a prop changes, consider either making a component fully controlled or fully uncontrolled with a key instead.\nParameters \nprops: The next props that the component is about to render with.\nstate: The next state that the component is about to render with.\nReturns \n\nstatic getDerivedStateFromProps return an object to update the state, or null to update nothing.\n\nCaveats \n\nThis method is fired on every render, regardless of the cause. This is different from UNSAFE_componentWillReceiveProps, which only fires when the parent causes a re-render and not as a result of a local setState.\n\nThis method doesn‚Äôt have access to the component instance. If you‚Äôd like, you can reuse some code between static getDerivedStateFromProps and the other class methods by extracting pure functions of the component props and state outside the class definition.\n\nNote\n\nImplementing static getDerivedStateFromProps in a class component is equivalent to calling the set function from useState during rendering in a function component.\n\nUsage \nDefining a class component \n\nTo define a React component as a class, extend the built-in Component class and define a render method:\n\nimport { Component } from 'react';\n\n\n\nclass Greeting extends Component {\n\n  render() {\n\n    return <h1>Hello, {this.props.name}!</h1>;\n\n  }\n\n}\n\nReact will call your render method whenever it needs to figure out what to display on the screen. Usually, you will return some JSX from it. Your render method should be a pure function: it should only calculate the JSX.\n\nSimilarly to function components, a class component can receive information by props from its parent component. However, the syntax for reading props is different. For example, if the parent component renders <Greeting name=\"Taylor\" />, then you can read the name prop from this.props, like this.props.name:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { Component } from 'react';\n\nclass Greeting extends Component {\n  render() {\n    return <h1>Hello, {this.props.name}!</h1>;\n  }\n}\n\nexport default function App() {\n  return (\n    <>\n      <Greeting name=\"Sara\" />\n      <Greeting name=\"Cahal\" />\n      <Greeting name=\"Edite\" />\n    </>\n  );\n}\n\n\nShow more\n\nNote that Hooks (functions starting with use, like useState) are not supported inside class components.\n\nPitfall\n\nWe recommend defining components as functions instead of classes. See how to migrate.\n\nAdding state to a class component \n\nTo add state to a class, assign an object to a property called state. To update state, call this.setState.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { Component } from 'react';\n\nexport default class Counter extends Component {\n  state = {\n    name: 'Taylor',\n    age: 42,\n  };\n\n  handleNameChange = (e) => {\n    this.setState({\n      name: e.target.value\n    });\n  }\n\n  handleAgeChange = () => {\n    this.setState({\n      age: this.state.age + 1 \n    });\n  };\n\n  render() {\n    return (\n      <>\n        <input\n          value={this.state.name}\n          onChange={this.handleNameChange}\n        />\n        <button onClick={this.handleAgeChange}>\n          Increment age\n        </button>\n        <p>Hello, {this.state.name}. You are {this.state.age}.</p>\n      </>\n    );\n  }\n}\n\n\nShow more\nPitfall\n\nWe recommend defining components as functions instead of classes. See how to migrate.\n\nAdding lifecycle methods to a class component \n\nThere are a few special methods you can define on your class.\n\nIf you define the componentDidMount method, React will call it when your component is added (mounted) to the screen. React will call componentDidUpdate after your component re-renders due to changed props or state. React will call componentWillUnmount after your component has been removed (unmounted) from the screen.\n\nIf you implement componentDidMount, you usually need to implement all three lifecycles to avoid bugs. For example, if componentDidMount reads some state or props, you also have to implement componentDidUpdate to handle their changes, and componentWillUnmount to clean up whatever componentDidMount was doing.\n\nFor example, this ChatRoom component keeps a chat connection synchronized with props and state:\n\nApp.js\nChatRoom.js\nchat.js\nReload\nClear\nFork\nimport { Component } from 'react';\nimport { createConnection } from './chat.js';\n\nexport default class ChatRoom extends Component {\n  state = {\n    serverUrl: 'https://localhost:1234'\n  };\n\n  componentDidMount() {\n    this.setupConnection();\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (\n      this.props.roomId !== prevProps.roomId ||\n      this.state.serverUrl !== prevState.serverUrl\n    ) {\n      this.destroyConnection();\n      this.setupConnection();\n    }\n  }\n\n  componentWillUnmount() {\n    this.destroyConnection();\n  }\n\n  setupConnection() {\n    this.connection = createConnection(\n      this.state.serverUrl,\n      this.props.roomId\n    );\n    this.connection.connect();    \n  }\n\n  destroyConnection() {\n    this.connection.disconnect();\n    this.connection = null;\n  }\n\n  render() {\n    return (\n      <>\n        <label>\n          Server URL:{' '}\n          <input\n            value={this.state.serverUrl}\n            onChange={e => {\n              this.setState({\n                serverUrl: e.target.value\n              });\n            }}\n          />\n        </label>\n        <h1>Welcome to the {this.props.roomId} room!</h1>\n      </>\n    );\n  }\n}\n\n\nShow more\n\nNote that in development when Strict Mode is on, React will call componentDidMount, immediately call componentWillUnmount, and then call componentDidMount again. This helps you notice if you forgot to implement componentWillUnmount or if its logic doesn‚Äôt fully ‚Äúmirror‚Äù what componentDidMount does.\n\nPitfall\n\nWe recommend defining components as functions instead of classes. See how to migrate.\n\nCatching rendering errors with an Error Boundary \n\nBy default, if your application throws an error during rendering, React will remove its UI from the screen. To prevent this, you can wrap a part of your UI into an Error Boundary. An Error Boundary is a special component that lets you display some fallback UI instead of the part that crashed‚Äîfor example, an error message.\n\nTo implement an Error Boundary component, you need to provide static getDerivedStateFromError which lets you update state in response to an error and display an error message to the user. You can also optionally implement componentDidCatch to add some extra logic, for example, to log the error to an analytics service.\n\nWith captureOwnerStack you can include the Owner Stack during development.\n\nimport * as React from 'react';\n\n\n\nclass ErrorBoundary extends React.Component {\n\n  constructor(props) {\n\n    super(props);\n\n    this.state = { hasError: false };\n\n  }\n\n\n\n  static getDerivedStateFromError(error) {\n\n    // Update state so the next render will show the fallback UI.\n\n    return { hasError: true };\n\n  }\n\n\n\n  componentDidCatch(error, info) {\n\n    logErrorToMyService(\n\n      error,\n\n      // Example \"componentStack\":\n\n      //   in ComponentThatThrows (created by App)\n\n      //   in ErrorBoundary (created by App)\n\n      //   in div (created by App)\n\n      //   in App\n\n      info.componentStack,\n\n      // Warning: `captureOwnerStack` is not available in production.\n\n      React.captureOwnerStack(),\n\n    );\n\n  }\n\n\n\n  render() {\n\n    if (this.state.hasError) {\n\n      // You can render any custom fallback UI\n\n      return this.props.fallback;\n\n    }\n\n\n\n    return this.props.children;\n\n  }\n\n}\n\nThen you can wrap a part of your component tree with it:\n\n<ErrorBoundary fallback={<p>Something went wrong</p>}>\n\n  <Profile />\n\n</ErrorBoundary>\n\nIf Profile or its child component throws an error, ErrorBoundary will ‚Äúcatch‚Äù that error, display a fallback UI with the error message you‚Äôve provided, and send a production error report to your error reporting service.\n\nYou don‚Äôt need to wrap every component into a separate Error Boundary. When you think about the granularity of Error Boundaries, consider where it makes sense to display an error message. For example, in a messaging app, it makes sense to place an Error Boundary around the list of conversations. It also makes sense to place one around every individual message. However, it wouldn‚Äôt make sense to place a boundary around every avatar.\n\nNote\n\nThere is currently no way to write an Error Boundary as a function component. However, you don‚Äôt have to write the Error Boundary class yourself. For example, you can use react-error-boundary instead.\n\nAlternatives \nMigrating a simple component from a class to a function \n\nTypically, you will define components as functions instead.\n\nFor example, suppose you‚Äôre converting this Greeting class component to a function:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { Component } from 'react';\n\nclass Greeting extends Component {\n  render() {\n    return <h1>Hello, {this.props.name}!</h1>;\n  }\n}\n\nexport default function App() {\n  return (\n    <>\n      <Greeting name=\"Sara\" />\n      <Greeting name=\"Cahal\" />\n      <Greeting name=\"Edite\" />\n    </>\n  );\n}\n\n\nShow more\n\nDefine a function called Greeting. This is where you will move the body of your render function.\n\nfunction Greeting() {\n\n  // ... move the code from the render method here ...\n\n}\n\nInstead of this.props.name, define the name prop using the destructuring syntax and read it directly:\n\nfunction Greeting({ name }) {\n\n  return <h1>Hello, {name}!</h1>;\n\n}\n\nHere is a complete example:\n\nApp.js\nDownload\nReload\nClear\nFork\nfunction Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}\n\nexport default function App() {\n  return (\n    <>\n      <Greeting name=\"Sara\" />\n      <Greeting name=\"Cahal\" />\n      <Greeting name=\"Edite\" />\n    </>\n  );\n}\n\n\nMigrating a component with state from a class to a function \n\nSuppose you‚Äôre converting this Counter class component to a function:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { Component } from 'react';\n\nexport default class Counter extends Component {\n  state = {\n    name: 'Taylor',\n    age: 42,\n  };\n\n  handleNameChange = (e) => {\n    this.setState({\n      name: e.target.value\n    });\n  }\n\n  handleAgeChange = (e) => {\n    this.setState({\n      age: this.state.age + 1 \n    });\n  };\n\n  render() {\n    return (\n      <>\n        <input\n          value={this.state.name}\n          onChange={this.handleNameChange}\n        />\n        <button onClick={this.handleAgeChange}>\n          Increment age\n        </button>\n        <p>Hello, {this.state.name}. You are {this.state.age}.</p>\n      </>\n    );\n  }\n}\n\n\nShow more\n\nStart by declaring a function with the necessary state variables:\n\nimport { useState } from 'react';\n\n\n\nfunction Counter() {\n\n  const [name, setName] = useState('Taylor');\n\n  const [age, setAge] = useState(42);\n\n  // ...\n\nNext, convert the event handlers:\n\nfunction Counter() {\n\n  const [name, setName] = useState('Taylor');\n\n  const [age, setAge] = useState(42);\n\n\n\n  function handleNameChange(e) {\n\n    setName(e.target.value);\n\n  }\n\n\n\n  function handleAgeChange() {\n\n    setAge(age + 1);\n\n  }\n\n  // ...\n\nFinally, replace all references starting with this with the variables and functions you defined in your component. For example, replace this.state.age with age, and replace this.handleNameChange with handleNameChange.\n\nHere is a fully converted component:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [name, setName] = useState('Taylor');\n  const [age, setAge] = useState(42);\n\n  function handleNameChange(e) {\n    setName(e.target.value);\n  }\n\n  function handleAgeChange() {\n    setAge(age + 1);\n  }\n\n  return (\n    <>\n      <input\n        value={name}\n        onChange={handleNameChange}\n      />\n      <button onClick={handleAgeChange}>\n        Increment age\n      </button>\n      <p>Hello, {name}. You are {age}.</p>\n    </>\n  )\n}\n\n\nShow more\nMigrating a component with lifecycle methods from a class to a function \n\nSuppose you‚Äôre converting this ChatRoom class component with lifecycle methods to a function:\n\nApp.js\nChatRoom.js\nchat.js\nReload\nClear\nFork\nimport { Component } from 'react';\nimport { createConnection } from './chat.js';\n\nexport default class ChatRoom extends Component {\n  state = {\n    serverUrl: 'https://localhost:1234'\n  };\n\n  componentDidMount() {\n    this.setupConnection();\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (\n      this.props.roomId !== prevProps.roomId ||\n      this.state.serverUrl !== prevState.serverUrl\n    ) {\n      this.destroyConnection();\n      this.setupConnection();\n    }\n  }\n\n  componentWillUnmount() {\n    this.destroyConnection();\n  }\n\n  setupConnection() {\n    this.connection = createConnection(\n      this.state.serverUrl,\n      this.props.roomId\n    );\n    this.connection.connect();    \n  }\n\n  destroyConnection() {\n    this.connection.disconnect();\n    this.connection = null;\n  }\n\n  render() {\n    return (\n      <>\n        <label>\n          Server URL:{' '}\n          <input\n            value={this.state.serverUrl}\n            onChange={e => {\n              this.setState({\n                serverUrl: e.target.value\n              });\n            }}\n          />\n        </label>\n        <h1>Welcome to the {this.props.roomId} room!</h1>\n      </>\n    );\n  }\n}\n\n\nShow more\n\nFirst, verify that your componentWillUnmount does the opposite of componentDidMount. In the above example, that‚Äôs true: it disconnects the connection that componentDidMount sets up. If such logic is missing, add it first.\n\nNext, verify that your componentDidUpdate method handles changes to any props and state you‚Äôre using in componentDidMount. In the above example, componentDidMount calls setupConnection which reads this.state.serverUrl and this.props.roomId. This is why componentDidUpdate checks whether this.state.serverUrl and this.props.roomId have changed, and resets the connection if they did. If your componentDidUpdate logic is missing or doesn‚Äôt handle changes to all relevant props and state, fix that first.\n\nIn the above example, the logic inside the lifecycle methods connects the component to a system outside of React (a chat server). To connect a component to an external system, describe this logic as a single Effect:\n\nimport { useState, useEffect } from 'react';\n\n\n\nfunction ChatRoom({ roomId }) {\n\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.connect();\n\n    return () => {\n\n      connection.disconnect();\n\n    };\n\n  }, [serverUrl, roomId]);\n\n\n\n  // ...\n\n}\n\nThis useEffect call is equivalent to the logic in the lifecycle methods above. If your lifecycle methods do multiple unrelated things, split them into multiple independent Effects. Here is a complete example you can play with:\n\nApp.js\nChatRoom.js\nchat.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nexport default function ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.connect();\n    return () => {\n      connection.disconnect();\n    };\n  }, [roomId, serverUrl]);\n\n  return (\n    <>\n      <label>\n        Server URL:{' '}\n        <input\n          value={serverUrl}\n          onChange={e => setServerUrl(e.target.value)}\n        />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n    </>\n  );\n}\n\n\nShow more\nNote\n\nIf your component does not synchronize with any external systems, you might not need an Effect.\n\nMigrating a component with context from a class to a function \n\nIn this example, the Panel and Button class components read context from this.context:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { createContext, Component } from 'react';\n\nconst ThemeContext = createContext(null);\n\nclass Panel extends Component {\n  static contextType = ThemeContext;\n\n  render() {\n    const theme = this.context;\n    const className = 'panel-' + theme;\n    return (\n      <section className={className}>\n        <h1>{this.props.title}</h1>\n        {this.props.children}\n      </section>\n    );    \n  }\n}\n\nclass Button extends Component {\n  static contextType = ThemeContext;\n\n  render() {\n    const theme = this.context;\n    const className = 'button-' + theme;\n    return (\n      <button className={className}>\n        {this.props.children}\n      </button>\n    );\n  }\n}\n\nfunction Form() {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n    </Panel>\n  );\n}\n\nexport default function MyApp() {\n  return (\n    <ThemeContext value=\"dark\">\n      <Form />\n    </ThemeContext>\n  )\n}\n\n\nShow more\n\nWhen you convert them to function components, replace this.context with useContext calls:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext(null);\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      <h1>{title}</h1>\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className}>\n      {children}\n    </button>\n  );\n}\n\nfunction Form() {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n    </Panel>\n  );\n}\n\nexport default function MyApp() {\n  return (\n    <ThemeContext value=\"dark\">\n      <Form />\n    </ThemeContext>\n  )\n}\n\n\nShow more\nPREVIOUS\ncloneElement\nNEXT\ncreateElement"
  },
  {
    "title": "createElement ‚Äì React",
    "url": "https://react.dev/reference/react/createElement",
    "html": "API REFERENCE\nLEGACY REACT APIS\ncreateElement\n\ncreateElement lets you create a React element. It serves as an alternative to writing JSX.\n\nconst element = createElement(type, props, ...children)\nReference\ncreateElement(type, props, ...children)\nUsage\nCreating an element without JSX\nReference \ncreateElement(type, props, ...children) \n\nCall createElement to create a React element with the given type, props, and children.\n\nimport { createElement } from 'react';\n\n\n\nfunction Greeting({ name }) {\n\n  return createElement(\n\n    'h1',\n\n    { className: 'greeting' },\n\n    'Hello'\n\n  );\n\n}\n\nSee more examples below.\n\nParameters \n\ntype: The type argument must be a valid React component type. For example, it could be a tag name string (such as 'div' or 'span'), or a React component (a function, a class, or a special component like Fragment).\n\nprops: The props argument must either be an object or null. If you pass null, it will be treated the same as an empty object. React will create an element with props matching the props you have passed. Note that ref and key from your props object are special and will not be available as element.props.ref and element.props.key on the returned element. They will be available as element.ref and element.key.\n\noptional ...children: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers, portals, empty nodes (null, undefined, true, and false), and arrays of React nodes.\n\nReturns \n\ncreateElement returns a React element object with a few properties:\n\ntype: The type you have passed.\nprops: The props you have passed except for ref and key.\nref: The ref you have passed. If missing, null.\nkey: The key you have passed, coerced to a string. If missing, null.\n\nUsually, you‚Äôll return the element from your component or make it a child of another element. Although you may read the element‚Äôs properties, it‚Äôs best to treat every element as opaque after it‚Äôs created, and only render it.\n\nCaveats \n\nYou must treat React elements and their props as immutable and never change their contents after creation. In development, React will freeze the returned element and its props property shallowly to enforce this.\n\nWhen you use JSX, you must start a tag with a capital letter to render your own custom component. In other words, <Something /> is equivalent to createElement(Something), but <something /> (lowercase) is equivalent to createElement('something') (note it‚Äôs a string, so it will be treated as a built-in HTML tag).\n\nYou should only pass children as multiple arguments to createElement if they are all statically known, like createElement('h1', {}, child1, child2, child3). If your children are dynamic, pass the entire array as the third argument: createElement('ul', {}, listItems). This ensures that React will warn you about missing keys for any dynamic lists. For static lists this is not necessary because they never reorder.\n\nUsage \nCreating an element without JSX \n\nIf you don‚Äôt like JSX or can‚Äôt use it in your project, you can use createElement as an alternative.\n\nTo create an element without JSX, call createElement with some type, props, and children:\n\nimport { createElement } from 'react';\n\n\n\nfunction Greeting({ name }) {\n\n  return createElement(\n\n    'h1',\n\n    { className: 'greeting' },\n\n    'Hello ',\n\n    createElement('i', null, name),\n\n    '. Welcome!'\n\n  );\n\n}\n\nThe children are optional, and you can pass as many as you need (the example above has three children). This code will display a <h1> header with a greeting. For comparison, here is the same example rewritten with JSX:\n\nfunction Greeting({ name }) {\n\n  return (\n\n    <h1 className=\"greeting\">\n\n      Hello <i>{name}</i>. Welcome!\n\n    </h1>\n\n  );\n\n}\n\nTo render your own React component, pass a function like Greeting as the type instead of a string like 'h1':\n\nexport default function App() {\n\n  return createElement(Greeting, { name: 'Taylor' });\n\n}\n\nWith JSX, it would look like this:\n\nexport default function App() {\n\n  return <Greeting name=\"Taylor\" />;\n\n}\n\nHere is a complete example written with createElement:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { createElement } from 'react';\n\nfunction Greeting({ name }) {\n  return createElement(\n    'h1',\n    { className: 'greeting' },\n    'Hello ',\n    createElement('i', null, name),\n    '. Welcome!'\n  );\n}\n\nexport default function App() {\n  return createElement(\n    Greeting,\n    { name: 'Taylor' }\n  );\n}\n\n\nShow more\n\nAnd here is the same example written using JSX:\n\nApp.js\nDownload\nReload\nClear\nFork\nfunction Greeting({ name }) {\n  return (\n    <h1 className=\"greeting\">\n      Hello <i>{name}</i>. Welcome!\n    </h1>\n  );\n}\n\nexport default function App() {\n  return <Greeting name=\"Taylor\" />;\n}\n\n\n\nBoth coding styles are fine, so you can use whichever one you prefer for your project. The main benefit of using JSX compared to createElement is that it‚Äôs easy to see which closing tag corresponds to which opening tag.\n\nDEEP DIVE\nWhat is a React element, exactly? \nShow Details\nPREVIOUS\nComponent\nNEXT\ncreateRef"
  },
  {
    "title": "createRef ‚Äì React",
    "url": "https://react.dev/reference/react/createRef",
    "html": "API REFERENCE\nLEGACY REACT APIS\ncreateRef\nPitfall\n\ncreateRef is mostly used for class components. Function components typically rely on useRef instead.\n\ncreateRef creates a ref object which can contain arbitrary value.\n\nclass MyInput extends Component {\n\n  inputRef = createRef();\n\n  // ...\n\n}\nReference\ncreateRef()\nUsage\nDeclaring a ref in a class component\nAlternatives\nMigrating from a class with createRef to a function with useRef\nReference \ncreateRef() \n\nCall createRef to declare a ref inside a class component.\n\nimport { createRef, Component } from 'react';\n\n\n\nclass MyComponent extends Component {\n\n  intervalRef = createRef();\n\n  inputRef = createRef();\n\n  // ...\n\nSee more examples below.\n\nParameters \n\ncreateRef takes no parameters.\n\nReturns \n\ncreateRef returns an object with a single property:\n\ncurrent: Initially, it‚Äôs set to the null. You can later set it to something else. If you pass the ref object to React as a ref attribute to a JSX node, React will set its current property.\nCaveats \ncreateRef always returns a different object. It‚Äôs equivalent to writing { current: null } yourself.\nIn a function component, you probably want useRef instead which always returns the same object.\nconst ref = useRef() is equivalent to const [ref, _] = useState(() => createRef(null)).\nUsage \nDeclaring a ref in a class component \n\nTo declare a ref inside a class component, call createRef and assign its result to a class field:\n\nimport { Component, createRef } from 'react';\n\n\n\nclass Form extends Component {\n\n  inputRef = createRef();\n\n\n\n  // ...\n\n}\n\nIf you now pass ref={this.inputRef} to an <input> in your JSX, React will populate this.inputRef.current with the input DOM node. For example, here is how you make a button that focuses the input:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { Component, createRef } from 'react';\n\nexport default class Form extends Component {\n  inputRef = createRef();\n\n  handleClick = () => {\n    this.inputRef.current.focus();\n  }\n\n  render() {\n    return (\n      <>\n        <input ref={this.inputRef} />\n        <button onClick={this.handleClick}>\n          Focus the input\n        </button>\n      </>\n    );\n  }\n}\n\n\nShow more\nPitfall\n\ncreateRef is mostly used for class components. Function components typically rely on useRef instead.\n\nAlternatives \nMigrating from a class with createRef to a function with useRef \n\nWe recommend using function components instead of class components in new code. If you have some existing class components using createRef, here is how you can convert them. This is the original code:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { Component, createRef } from 'react';\n\nexport default class Form extends Component {\n  inputRef = createRef();\n\n  handleClick = () => {\n    this.inputRef.current.focus();\n  }\n\n  render() {\n    return (\n      <>\n        <input ref={this.inputRef} />\n        <button onClick={this.handleClick}>\n          Focus the input\n        </button>\n      </>\n    );\n  }\n}\n\n\nShow more\n\nWhen you convert this component from a class to a function, replace calls to createRef with calls to useRef:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useRef } from 'react';\n\nexport default function Form() {\n  const inputRef = useRef(null);\n\n  function handleClick() {\n    inputRef.current.focus();\n  }\n\n  return (\n    <>\n      <input ref={inputRef} />\n      <button onClick={handleClick}>\n        Focus the input\n      </button>\n    </>\n  );\n}\n\n\nShow more\nPREVIOUS\ncreateElement\nNEXT\nforwardRef"
  },
  {
    "title": "forwardRef ‚Äì React",
    "url": "https://react.dev/reference/react/forwardRef",
    "html": "API REFERENCE\nLEGACY REACT APIS\nforwardRef\nDeprecated\n\nIn React 19, forwardRef is no longer necessary. Pass ref as a prop instead.\n\nforwardRef will be deprecated in a future release. Learn more here.\n\nforwardRef lets your component expose a DOM node to the parent component with a ref.\n\nconst SomeComponent = forwardRef(render)\nReference\nforwardRef(render)\nrender function\nUsage\nExposing a DOM node to the parent component\nForwarding a ref through multiple components\nExposing an imperative handle instead of a DOM node\nTroubleshooting\nMy component is wrapped in forwardRef, but the ref to it is always null\nReference \nforwardRef(render) \n\nCall forwardRef() to let your component receive a ref and forward it to a child component:\n\nimport { forwardRef } from 'react';\n\n\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\n  // ...\n\n});\n\nSee more examples below.\n\nParameters \nrender: The render function for your component. React calls this function with the props and ref that your component received from its parent. The JSX you return will be the output of your component.\nReturns \n\nforwardRef returns a React component that you can render in JSX. Unlike React components defined as plain functions, a component returned by forwardRef is also able to receive a ref prop.\n\nCaveats \nIn Strict Mode, React will call your render function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your render function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored.\nrender function \n\nforwardRef accepts a render function as an argument. React calls this function with props and ref:\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\n  return (\n\n    <label>\n\n      {props.label}\n\n      <input ref={ref} />\n\n    </label>\n\n  );\n\n});\nParameters \n\nprops: The props passed by the parent component.\n\nref:  The ref attribute passed by the parent component. The ref can be an object or a function. If the parent component has not passed a ref, it will be null. You should either pass the ref you receive to another component, or pass it to useImperativeHandle.\n\nReturns \n\nforwardRef returns a React component that you can render in JSX. Unlike React components defined as plain functions, the component returned by forwardRef is able to take a ref prop.\n\nUsage \nExposing a DOM node to the parent component \n\nBy default, each component‚Äôs DOM nodes are private. However, sometimes it‚Äôs useful to expose a DOM node to the parent‚Äîfor example, to allow focusing it. To opt in, wrap your component definition into forwardRef():\n\nimport { forwardRef } from 'react';\n\n\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\n  const { label, ...otherProps } = props;\n\n  return (\n\n    <label>\n\n      {label}\n\n      <input {...otherProps} />\n\n    </label>\n\n  );\n\n});\n\nYou will receive a ref as the second argument after props. Pass it to the DOM node that you want to expose:\n\nimport { forwardRef } from 'react';\n\n\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\n  const { label, ...otherProps } = props;\n\n  return (\n\n    <label>\n\n      {label}\n\n      <input {...otherProps} ref={ref} />\n\n    </label>\n\n  );\n\n});\n\nThis lets the parent Form component access the <input> DOM node exposed by MyInput:\n\nfunction Form() {\n\n  const ref = useRef(null);\n\n\n\n  function handleClick() {\n\n    ref.current.focus();\n\n  }\n\n\n\n  return (\n\n    <form>\n\n      <MyInput label=\"Enter your name:\" ref={ref} />\n\n      <button type=\"button\" onClick={handleClick}>\n\n        Edit\n\n      </button>\n\n    </form>\n\n  );\n\n}\n\nThis Form component passes a ref to MyInput. The MyInput component forwards that ref to the <input> browser tag. As a result, the Form component can access that <input> DOM node and call focus() on it.\n\nKeep in mind that exposing a ref to the DOM node inside your component makes it harder to change your component‚Äôs internals later. You will typically expose DOM nodes from reusable low-level components like buttons or text inputs, but you won‚Äôt do it for application-level components like an avatar or a comment.\n\nExamples of forwarding a ref\n1. Focusing a text input\n2. Playing and pausing a video\nExample 1 of 2: Focusing a text input \n\nClicking the button will focus the input. The Form component defines a ref and passes it to the MyInput component. The MyInput component forwards that ref to the browser <input>. This lets the Form component focus the <input>.\n\nApp.js\nMyInput.js\nReload\nClear\nFork\nimport { useRef } from 'react';\nimport MyInput from './MyInput.js';\n\nexport default function Form() {\n  const ref = useRef(null);\n\n  function handleClick() {\n    ref.current.focus();\n  }\n\n  return (\n    <form>\n      <MyInput label=\"Enter your name:\" ref={ref} />\n      <button type=\"button\" onClick={handleClick}>\n        Edit\n      </button>\n    </form>\n  );\n}\n\n\nShow more\nNext Example\nForwarding a ref through multiple components \n\nInstead of forwarding a ref to a DOM node, you can forward it to your own component like MyInput:\n\nconst FormField = forwardRef(function FormField(props, ref) {\n\n  // ...\n\n  return (\n\n    <>\n\n      <MyInput ref={ref} />\n\n      ...\n\n    </>\n\n  );\n\n});\n\nIf that MyInput component forwards a ref to its <input>, a ref to FormField will give you that <input>:\n\nfunction Form() {\n\n  const ref = useRef(null);\n\n\n\n  function handleClick() {\n\n    ref.current.focus();\n\n  }\n\n\n\n  return (\n\n    <form>\n\n      <FormField label=\"Enter your name:\" ref={ref} isRequired={true} />\n\n      <button type=\"button\" onClick={handleClick}>\n\n        Edit\n\n      </button>\n\n    </form>\n\n  );\n\n}\n\nThe Form component defines a ref and passes it to FormField. The FormField component forwards that ref to MyInput, which forwards it to a browser <input> DOM node. This is how Form accesses that DOM node.\n\nApp.js\nFormField.js\nMyInput.js\nReload\nClear\nFork\nimport { useRef } from 'react';\nimport FormField from './FormField.js';\n\nexport default function Form() {\n  const ref = useRef(null);\n\n  function handleClick() {\n    ref.current.focus();\n  }\n\n  return (\n    <form>\n      <FormField label=\"Enter your name:\" ref={ref} isRequired={true} />\n      <button type=\"button\" onClick={handleClick}>\n        Edit\n      </button>\n    </form>\n  );\n}\n\n\nShow more\nExposing an imperative handle instead of a DOM node \n\nInstead of exposing an entire DOM node, you can expose a custom object, called an imperative handle, with a more constrained set of methods. To do this, you‚Äôd need to define a separate ref to hold the DOM node:\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\n  const inputRef = useRef(null);\n\n\n\n  // ...\n\n\n\n  return <input {...props} ref={inputRef} />;\n\n});\n\nPass the ref you received to useImperativeHandle and specify the value you want to expose to the ref:\n\nimport { forwardRef, useRef, useImperativeHandle } from 'react';\n\n\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\n  const inputRef = useRef(null);\n\n\n\n  useImperativeHandle(ref, () => {\n\n    return {\n\n      focus() {\n\n        inputRef.current.focus();\n\n      },\n\n      scrollIntoView() {\n\n        inputRef.current.scrollIntoView();\n\n      },\n\n    };\n\n  }, []);\n\n\n\n  return <input {...props} ref={inputRef} />;\n\n});\n\nIf some component gets a ref to MyInput, it will only receive your { focus, scrollIntoView } object instead of the DOM node. This lets you limit the information you expose about your DOM node to the minimum.\n\nApp.js\nMyInput.js\nReload\nClear\nFork\nimport { useRef } from 'react';\nimport MyInput from './MyInput.js';\n\nexport default function Form() {\n  const ref = useRef(null);\n\n  function handleClick() {\n    ref.current.focus();\n    // This won't work because the DOM node isn't exposed:\n    // ref.current.style.opacity = 0.5;\n  }\n\n  return (\n    <form>\n      <MyInput placeholder=\"Enter your name\" ref={ref} />\n      <button type=\"button\" onClick={handleClick}>\n        Edit\n      </button>\n    </form>\n  );\n}\n\n\nShow more\n\nRead more about using imperative handles.\n\nPitfall\n\nDo not overuse refs. You should only use refs for imperative behaviors that you can‚Äôt express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on.\n\nIf you can express something as a prop, you should not use a ref. For example, instead of exposing an imperative handle like { open, close } from a Modal component, it is better to take isOpen as a prop like <Modal isOpen={isOpen} />. Effects can help you expose imperative behaviors via props.\n\nTroubleshooting \nMy component is wrapped in forwardRef, but the ref to it is always null \n\nThis usually means that you forgot to actually use the ref that you received.\n\nFor example, this component doesn‚Äôt do anything with its ref:\n\nconst MyInput = forwardRef(function MyInput({ label }, ref) {\n\n  return (\n\n    <label>\n\n      {label}\n\n      <input />\n\n    </label>\n\n  );\n\n});\n\nTo fix it, pass the ref down to a DOM node or another component that can accept a ref:\n\nconst MyInput = forwardRef(function MyInput({ label }, ref) {\n\n  return (\n\n    <label>\n\n      {label}\n\n      <input ref={ref} />\n\n    </label>\n\n  );\n\n});\n\nThe ref to MyInput could also be null if some of the logic is conditional:\n\nconst MyInput = forwardRef(function MyInput({ label, showInput }, ref) {\n\n  return (\n\n    <label>\n\n      {label}\n\n      {showInput && <input ref={ref} />}\n\n    </label>\n\n  );\n\n});\n\nIf showInput is false, then the ref won‚Äôt be forwarded to any node, and a ref to MyInput will remain empty. This is particularly easy to miss if the condition is hidden inside another component, like Panel in this example:\n\nconst MyInput = forwardRef(function MyInput({ label, showInput }, ref) {\n\n  return (\n\n    <label>\n\n      {label}\n\n      <Panel isExpanded={showInput}>\n\n        <input ref={ref} />\n\n      </Panel>\n\n    </label>\n\n  );\n\n});\nPREVIOUS\ncreateRef\nNEXT\nisValidElement"
  },
  {
    "title": "isValidElement ‚Äì React",
    "url": "https://react.dev/reference/react/isValidElement",
    "html": "API REFERENCE\nLEGACY REACT APIS\nisValidElement\n\nisValidElement checks whether a value is a React element.\n\nconst isElement = isValidElement(value)\nReference\nisValidElement(value)\nUsage\nChecking if something is a React element\nReference \nisValidElement(value) \n\nCall isValidElement(value) to check whether value is a React element.\n\nimport { isValidElement, createElement } from 'react';\n\n\n\n// ‚úÖ React elements\n\nconsole.log(isValidElement(<p />)); // true\n\nconsole.log(isValidElement(createElement('p'))); // true\n\n\n\n// ‚ùå Not React elements\n\nconsole.log(isValidElement(25)); // false\n\nconsole.log(isValidElement('Hello')); // false\n\nconsole.log(isValidElement({ age: 42 })); // false\n\nSee more examples below.\n\nParameters \nvalue: The value you want to check. It can be any a value of any type.\nReturns \n\nisValidElement returns true if the value is a React element. Otherwise, it returns false.\n\nCaveats \nOnly JSX tags and objects returned by createElement are considered to be React elements. For example, even though a number like 42 is a valid React node (and can be returned from a component), it is not a valid React element. Arrays and portals created with createPortal are also not considered to be React elements.\nUsage \nChecking if something is a React element \n\nCall isValidElement to check if some value is a React element.\n\nReact elements are:\n\nValues produced by writing a JSX tag\nValues produced by calling createElement\n\nFor React elements, isValidElement returns true:\n\nimport { isValidElement, createElement } from 'react';\n\n\n\n// ‚úÖ JSX tags are React elements\n\nconsole.log(isValidElement(<p />)); // true\n\nconsole.log(isValidElement(<MyComponent />)); // true\n\n\n\n// ‚úÖ Values returned by createElement are React elements\n\nconsole.log(isValidElement(createElement('p'))); // true\n\nconsole.log(isValidElement(createElement(MyComponent))); // true\n\nAny other values, such as strings, numbers, or arbitrary objects and arrays, are not React elements.\n\nFor them, isValidElement returns false:\n\n// ‚ùå These are *not* React elements\n\nconsole.log(isValidElement(null)); // false\n\nconsole.log(isValidElement(25)); // false\n\nconsole.log(isValidElement('Hello')); // false\n\nconsole.log(isValidElement({ age: 42 })); // false\n\nconsole.log(isValidElement([<div />, <div />])); // false\n\nconsole.log(isValidElement(MyComponent)); // false\n\nIt is very uncommon to need isValidElement. It‚Äôs mostly useful if you‚Äôre calling another API that only accepts elements (like cloneElement does) and you want to avoid an error when your argument is not a React element.\n\nUnless you have some very specific reason to add an isValidElement check, you probably don‚Äôt need it.\n\nDEEP DIVE\nReact elements vs React nodes \nShow Details\nPREVIOUS\nforwardRef\nNEXT\nPureComponent"
  },
  {
    "title": "PureComponent ‚Äì React",
    "url": "https://react.dev/reference/react/PureComponent",
    "html": "API REFERENCE\nLEGACY REACT APIS\nPureComponent\nPitfall\n\nWe recommend defining components as functions instead of classes. See how to migrate.\n\nPureComponent is similar to Component but it skips re-renders for same props and state. Class components are still supported by React, but we don‚Äôt recommend using them in new code.\n\nclass Greeting extends PureComponent {\n\n  render() {\n\n    return <h1>Hello, {this.props.name}!</h1>;\n\n  }\n\n}\nReference\nPureComponent\nUsage\nSkipping unnecessary re-renders for class components\nAlternatives\nMigrating from a PureComponent class component to a function\nReference \nPureComponent \n\nTo skip re-rendering a class component for same props and state, extend PureComponent instead of Component:\n\nimport { PureComponent } from 'react';\n\n\n\nclass Greeting extends PureComponent {\n\n  render() {\n\n    return <h1>Hello, {this.props.name}!</h1>;\n\n  }\n\n}\n\nPureComponent is a subclass of Component and supports all the Component APIs. Extending PureComponent is equivalent to defining a custom shouldComponentUpdate method that shallowly compares props and state.\n\nSee more examples below.\n\nUsage \nSkipping unnecessary re-renders for class components \n\nReact normally re-renders a component whenever its parent re-renders. As an optimization, you can create a component that React will not re-render when its parent re-renders so long as its new props and state are the same as the old props and state. Class components can opt into this behavior by extending PureComponent:\n\nclass Greeting extends PureComponent {\n\n  render() {\n\n    return <h1>Hello, {this.props.name}!</h1>;\n\n  }\n\n}\n\nA React component should always have pure rendering logic. This means that it must return the same output if its props, state, and context haven‚Äôt changed. By using PureComponent, you are telling React that your component complies with this requirement, so React doesn‚Äôt need to re-render as long as its props and state haven‚Äôt changed. However, your component will still re-render if a context that it‚Äôs using changes.\n\nIn this example, notice that the Greeting component re-renders whenever name is changed (because that‚Äôs one of its props), but not when address is changed (because it‚Äôs not passed to Greeting as a prop):\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { PureComponent, useState } from 'react';\n\nclass Greeting extends PureComponent {\n  render() {\n    console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n    return <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>;\n  }\n}\n\nexport default function MyApp() {\n  const [name, setName] = useState('');\n  const [address, setAddress] = useState('');\n  return (\n    <>\n      <label>\n        Name{': '}\n        <input value={name} onChange={e => setName(e.target.value)} />\n      </label>\n      <label>\n        Address{': '}\n        <input value={address} onChange={e => setAddress(e.target.value)} />\n      </label>\n      <Greeting name={name} />\n    </>\n  );\n}\n\n\nShow more\nPitfall\n\nWe recommend defining components as functions instead of classes. See how to migrate.\n\nAlternatives \nMigrating from a PureComponent class component to a function \n\nWe recommend using function components instead of class components in new code. If you have some existing class components using PureComponent, here is how you can convert them. This is the original code:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { PureComponent, useState } from 'react';\n\nclass Greeting extends PureComponent {\n  render() {\n    console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n    return <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>;\n  }\n}\n\nexport default function MyApp() {\n  const [name, setName] = useState('');\n  const [address, setAddress] = useState('');\n  return (\n    <>\n      <label>\n        Name{': '}\n        <input value={name} onChange={e => setName(e.target.value)} />\n      </label>\n      <label>\n        Address{': '}\n        <input value={address} onChange={e => setAddress(e.target.value)} />\n      </label>\n      <Greeting name={name} />\n    </>\n  );\n}\n\n\nShow more\n\nWhen you convert this component from a class to a function, wrap it in memo:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { memo, useState } from 'react';\n\nconst Greeting = memo(function Greeting({ name }) {\n  console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n  return <h3>Hello{name && ', '}{name}!</h3>;\n});\n\nexport default function MyApp() {\n  const [name, setName] = useState('');\n  const [address, setAddress] = useState('');\n  return (\n    <>\n      <label>\n        Name{': '}\n        <input value={name} onChange={e => setName(e.target.value)} />\n      </label>\n      <label>\n        Address{': '}\n        <input value={address} onChange={e => setAddress(e.target.value)} />\n      </label>\n      <Greeting name={name} />\n    </>\n  );\n}\n\n\nShow more\nNote\n\nUnlike PureComponent, memo does not compare the new and the old state. In function components, calling the set function with the same state already prevents re-renders by default, even without memo.\n\nPREVIOUS\nisValidElement"
  },
  {
    "title": "Not Found ‚Äì React",
    "url": "https://react.dev/reference/react-dom/static/index",
    "html": "LEARN REACT\nNot Found\n\nThis page doesn‚Äôt exist.\n\nIf this is a mistake, let us know, and we will try to fix it!"
  }
]
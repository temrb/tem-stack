[
  {
    "title": "Basic usage | Zod",
    "url": "https://zod.dev/basics",
    "html": "Basic usage\nCopy markdown\nEdit this page\n\nThis page will walk you through the basics of creating schemas, parsing data, and using inferred types. For complete documentation on Zod's schema API, refer to Defining schemas.\n\nDefining a schema\n\nBefore you can do anything else, you need to define a schema. For the purposes of this guide, we'll use a simple object schema.\n\nZod\nZod Mini\nimport * as z from \"zod\"; \n \nconst Player = z.object({ \n  username: z.string(),\n  xp: z.number()\n});\nParsing data\n\nGiven any Zod schema, use .parse to validate an input. If it's valid, Zod returns a strongly-typed deep clone of the input.\n\nPlayer.parse({ username: \"billie\", xp: 100 }); \n// => returns { username: \"billie\", xp: 100 }\n\nNote — If your schema uses certain asynchronous APIs like async refinements or transforms, you'll need to use the .parseAsync() method instead.\n\nawait Player.parseAsync({ username: \"billie\", xp: 100 }); \nHandling errors\n\nWhen validation fails, the .parse() method will throw a ZodError instance with granular information about the validation issues.\n\nZod\nZod Mini\ntry {\n  Player.parse({ username: 42, xp: \"100\" });\n} catch(error){\n  if(error instanceof z.ZodError){\n    error.issues; \n    /* [\n      {\n        expected: 'string',\n        code: 'invalid_type',\n        path: [ 'username' ],\n        message: 'Invalid input: expected string'\n      },\n      {\n        expected: 'number',\n        code: 'invalid_type',\n        path: [ 'xp' ],\n        message: 'Invalid input: expected number'\n      }\n    ] */\n  }\n}\n\nTo avoid a try/catch block, you can use the .safeParse() method to get back a plain result object containing either the successfully parsed data or a ZodError. The result type is a discriminated union, so you can handle both cases conveniently.\n\nconst result = Player.safeParse({ username: 42, xp: \"100\" });\nif (!result.success) {\n  result.error;   // ZodError instance\n} else {\n  result.data;    // { username: string; xp: number }\n}\n\nNote — If your schema uses certain asynchronous APIs like async refinements or transforms, you'll need to use the .safeParseAsync() method instead.\n\nawait schema.safeParseAsync(\"hello\");\nInferring types\n\nZod infers a static type from your schema definitions. You can extract this type with the z.infer<> utility and use it however you like.\n\nconst Player = z.object({ \n  username: z.string(),\n  xp: z.number()\n});\n \n// extract the inferred type\ntype Player = z.infer<typeof Player>;\n \n// use it in your code\nconst player: Player = { username: \"billie\", xp: 100 };\n\nIn some cases, the input & output types of a schema can diverge. For instance, the .transform() API can convert the input from one type to another. In these cases, you can extract the input and output types independently:\n\nconst mySchema = z.string().transform((val) => val.length);\n \ntype MySchemaIn = z.input<typeof mySchema>;\n// => string\n \ntype MySchemaOut = z.output<typeof mySchema>; // equivalent to z.infer<typeof mySchema>\n// number\n\nNow that we have the basics covered, let's jump into the Schema API.\n\nIntro\n\nIntroduction to Zod - TypeScript-first schema validation library with static type inference\n\nDefining schemas\n\nComplete API reference for all Zod schema types, methods, and validation features"
  },
  {
    "title": "Intro | Zod",
    "url": "https://zod.dev/",
    "html": "Zod\n\nTypeScript-first schema validation with static type inference\nby @colinhacks\n\n\n\nWebsite\n  •  \nDiscord\n  •  \n𝕏\n  •  \nBluesky\n\n\n\n\n\nZod 4 is now stable! Read the release notes here.\n\n\n\n\n\nFeatured sponsor: Jazz\n\nInterested in featuring? Get in touch.\n\nIntroduction\n\nZod is a TypeScript-first validation library. Using Zod, you can define schemas you can use to validate data, from a simple string to a complex nested object.\n\nimport * as z from \"zod\";\n \nconst User = z.object({\n  name: z.string(),\n});\n \n// some untrusted data...\nconst input = { /* stuff */ };\n \n// the parsed result is validated and type safe!\nconst data = User.parse(input);\n \n// so you can use it with confidence :)\nconsole.log(data.name);\nFeatures\nZero external dependencies\nWorks in Node.js and all modern browsers\nTiny: 2kb core bundle (gzipped)\nImmutable API: methods return a new instance\nConcise interface\nWorks with TypeScript and plain JS\nBuilt-in JSON Schema conversion\nExtensive ecosystem\nInstallation\nnpm install zod\n\nZod is also available as @zod/zod on jsr.io.\n\nZod provides an MCP server that can be used by agents to search Zod's docs. To add to your editor, follow these instructions. Zod also provides an llms.txt file.\n\nRequirements\n\nZod is tested against TypeScript v5.5 and later. Older versions may work but are not officially supported.\n\n\"strict\"\n\nYou must enable strict mode in your tsconfig.json. This is a best practice for all TypeScript projects.\n\n// tsconfig.json\n{\n  // ...\n  \"compilerOptions\": {\n    // ...\n    \"strict\": true\n  }\n}\nEcosystem\n\nZod has a thriving ecosystem of libraries, tools, and integrations. Refer to the Ecosystem page for a complete list of libraries that support Zod or are built on top of it.\n\nResources\nAPI Libraries\nForm Integrations\nZod to X\nX to Zod\nMocking Libraries\nPowered by Zod\n\nI also contribute to the following projects, which I'd like to highlight:\n\ntRPC - End-to-end typesafe APIs, with support for Zod schemas\nReact Hook Form - Hook-based form validation with a Zod resolver\nzshy - Originally created as Zod's internal build tool. Bundler-free, batteries-included build tool for TypeScript libraries. Powered by tsc.\nSponsors\n\nSponsorship at any level is appreciated and encouraged. If you built a paid product using Zod, consider one of the corporate tiers.\n\nPlatinum\n\nCut code review time & bugs in half\n\ncoderabbit.ai\n\n\n\nGold\n\nThe API platform for sending notifications\n\ncourier.com\n\nGenerate better SDKs for your APIs\n\nliblab.com\n\nServerless Postgres — Ship faster\n\nneon.tech\n\nBuild AI apps and workflows with Retool AI\n\nretool.com\n\nGenerate best-in-class SDKs\n\nstainlessapi.com\n\nSDKs & Terraform providers for your API\n\nspeakeasy.com\n\n\nSilver\nsubtotal.com\njuno.build\nnitric.io\npropelauth.com\ncerbos.dev\nscalar.com\ntrigger.dev\ntransloadit.com\ninfisical.com\nwhop.com\ncryptojobslist.com\nplain.com\ninngest.com\nstoryblok.com\nmux.link/zod\n\n\nBronze\n\n\n\nMigration guide\n\nComplete changelog and migration guide for upgrading from Zod 3 to Zod 4\n\nBasic usage\n\nBasic usage guide covering schema definition, parsing data, error handling, and type inference"
  },
  {
    "title": "Defining schemas | Zod",
    "url": "https://zod.dev/api",
    "html": "Defining schemas\nCopy markdown\nEdit this page\n\nTo validate data, you must first define a schema. Schemas represent types, from simple primitive values to complex nested objects and arrays.\n\nPrimitives\nimport * as z from \"zod\";\n \n// primitive types\nz.string();\nz.number();\nz.bigint();\nz.boolean();\nz.symbol();\nz.undefined();\nz.null();\nCoercion\n\nTo coerce input data to the appropriate type, use z.coerce instead:\n\nz.coerce.string();    // String(input)\nz.coerce.number();    // Number(input)\nz.coerce.boolean();   // Boolean(input)\nz.coerce.bigint();    // BigInt(input)\n\nThe coerced variant of these schemas attempts to convert the input value to the appropriate type.\n\nconst schema = z.coerce.string();\n \nschema.parse(\"tuna\");    // => \"tuna\"\nschema.parse(42);        // => \"42\"\nschema.parse(true);      // => \"true\"\nschema.parse(null);      // => \"null\"\n\nThe input type of these coerced schemas is unknown by default. To specify a more specific input type, pass a generic parameter:\n\nconst A = z.coerce.number();\ntype AInput = z.input<typeof A>; // => unknown\n \nconst B = z.coerce.number<number>();\ntype BInput = z.input<typeof B>; // => number\nHow coercion works in Zod\nCustomizing the input type\nLiterals\n\nLiteral schemas represent a literal type, like \"hello world\" or 5.\n\nconst tuna = z.literal(\"tuna\");\nconst twelve = z.literal(12);\nconst twobig = z.literal(2n);\nconst tru = z.literal(true);\n\nTo represent the JavaScript literals null and undefined:\n\nz.null();\nz.undefined();\nz.void(); // equivalent to z.undefined()\n\nTo allow multiple literal values:\n\nconst colors = z.literal([\"red\", \"green\", \"blue\"]);\n \ncolors.parse(\"green\"); // ✅\ncolors.parse(\"yellow\"); // ❌\n\nTo extract the set of allowed values from a literal schema:\n\nZod\nZod Mini\ncolors.values; // => Set<\"red\" | \"green\" | \"blue\">\nStrings\n\nZod provides a handful of built-in string validation and transform APIs. To perform some common string validations:\n\nZod\nZod Mini\nz.string().max(5);\nz.string().min(5);\nz.string().length(5);\nz.string().regex(/^[a-z]+$/);\nz.string().startsWith(\"aaa\");\nz.string().endsWith(\"zzz\");\nz.string().includes(\"---\");\nz.string().uppercase();\nz.string().lowercase();\n\nTo perform some simple string transforms:\n\nZod\nZod Mini\nz.string().trim(); // trim whitespace\nz.string().toLowerCase(); // toLowerCase\nz.string().toUpperCase(); // toUpperCase\nz.string().normalize(); // normalize unicode characters\nString formats\n\nTo validate against some common string formats:\n\nz.email();\nz.uuid();\nz.url();\nz.httpUrl();       // http or https URLs only\nz.hostname();\nz.emoji();         // validates a single emoji character\nz.base64();\nz.base64url();\nz.hex();\nz.jwt();\nz.nanoid();\nz.cuid();\nz.cuid2();\nz.ulid();\nz.ipv4();\nz.ipv6();\nz.cidrv4();        // ipv4 CIDR block\nz.cidrv6();        // ipv6 CIDR block\nz.hash(\"sha256\");  // or \"sha1\", \"sha384\", \"sha512\", \"md5\"\nz.iso.date();\nz.iso.time();\nz.iso.datetime();\nz.iso.duration();\nEmails\n\nTo validate email addresses:\n\nz.email();\n\nBy default, Zod uses a comparatively strict email regex designed to validate normal email addresses containing common characters. It's roughly equivalent to the rules enforced by Gmail. To learn more about this regex, refer to this post.\n\n/^(?!\\.)(?!.*\\.\\.)([a-z0-9_'+\\-\\.]*)[a-z0-9_+-]@([a-z0-9][a-z0-9\\-]*\\.)+[a-z]{2,}$/i\n\nTo customize the email validation behavior, you can pass a custom regular expression to the pattern param.\n\nz.email({ pattern: /your regex here/ });\n\nZod exports several useful regexes you could use.\n\n// Zod's default email regex\nz.email();\nz.email({ pattern: z.regexes.email }); // equivalent\n \n// the regex used by browsers to validate input[type=email] fields\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email\nz.email({ pattern: z.regexes.html5Email });\n \n// the classic emailregex.com regex (RFC 5322)\nz.email({ pattern: z.regexes.rfc5322Email });\n \n// a loose regex that allows Unicode (good for intl emails)\nz.email({ pattern: z.regexes.unicodeEmail });\nUUIDs\n\nTo validate UUIDs:\n\nz.uuid();\n\nTo specify a particular UUID version:\n\n// supports \"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\", \"v8\"\nz.uuid({ version: \"v4\" });\n \n// for convenience\nz.uuidv4();\nz.uuidv6();\nz.uuidv7();\n\nThe RFC 9562/4122 UUID spec requires the first two bits of byte 8 to be 10. Other UUID-like identifiers do not enforce this constraint. To validate any UUID-like identifier:\n\nz.guid();\nURLs\n\nTo validate any WHATWG-compatible URL:\n\nconst schema = z.url();\n \nschema.parse(\"https://example.com\"); // ✅\nschema.parse(\"http://localhost\"); // ✅\nschema.parse(\"mailto:noreply@zod.dev\"); // ✅\n\nAs you can see this is quite permissive. Internally this uses the new URL() constructor to validate inputs; this behavior may differ across platforms and runtimes but it's the mostly rigorous way to validate URIs/URLs on any given JS runtime/engine.\n\nTo validate the hostname against a specific regex:\n\nconst schema = z.url({ hostname: /^example\\.com$/ });\n \nschema.parse(\"https://example.com\"); // ✅\nschema.parse(\"https://zombo.com\"); // ❌\n\nTo validate the protocol against a specific regex, use the protocol param.\n\nconst schema = z.url({ protocol: /^https$/ });\n \nschema.parse(\"https://example.com\"); // ✅\nschema.parse(\"http://example.com\"); // ❌\n\nWeb URLs — In many cases, you'll want to validate Web URLs specifically. Here's the recommended schema for doing so:\n\nconst httpUrl = z.url({\n  protocol: /^https?$/,\n  hostname: z.regexes.domain\n});\n\nThis restricts the protocol to http/https and ensures the hostname is a valid domain name with the z.regexes.domain regular expression:\n\n/^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$/\n\nTo normalize URLs, use the normalize flag. This will overwrite the input value with the normalized URL returned by new URL().\n\nnew URL(\"HTTP://ExAmPle.com:80/./a/../b?X=1#f oo\").href\n// => \"http://example.com/b?X=1#f%20oo\"\nISO datetimes\n\nAs you may have noticed, Zod string includes a few date/time related validations. These validations are regular expression based, so they are not as strict as a full date/time library. However, they are very convenient for validating user input.\n\nThe z.iso.datetime() method enforces ISO 8601; by default, no timezone offsets are allowed:\n\nconst datetime = z.iso.datetime();\n \ndatetime.parse(\"2020-01-01T06:15:00Z\"); // ✅\ndatetime.parse(\"2020-01-01T06:15:00.123Z\"); // ✅\ndatetime.parse(\"2020-01-01T06:15:00.123456Z\"); // ✅ (arbitrary precision)\ndatetime.parse(\"2020-01-01T06:15:00+02:00\"); // ❌ (offsets not allowed)\ndatetime.parse(\"2020-01-01T06:15:00\"); // ❌ (local not allowed)\n\nTo allow timezone offsets:\n\nconst datetime = z.iso.datetime({ offset: true });\n \n// allows timezone offsets\ndatetime.parse(\"2020-01-01T06:15:00+02:00\"); // ✅\n \n// basic offsets not allowed\ndatetime.parse(\"2020-01-01T06:15:00+02\");    // ❌\ndatetime.parse(\"2020-01-01T06:15:00+0200\");  // ❌\n \n// Z is still supported\ndatetime.parse(\"2020-01-01T06:15:00Z\"); // ✅ \n\nTo allow unqualified (timezone-less) datetimes:\n\nconst schema = z.iso.datetime({ local: true });\nschema.parse(\"2020-01-01T06:15:01\"); // ✅\nschema.parse(\"2020-01-01T06:15\"); // ✅ seconds optional\n\nTo constrain the allowable time precision. By default, seconds are optional and arbitrary sub-second precision is allowed.\n\nconst a = z.iso.datetime();\na.parse(\"2020-01-01T06:15Z\"); // ✅\na.parse(\"2020-01-01T06:15:00Z\"); // ✅\na.parse(\"2020-01-01T06:15:00.123Z\"); // ✅\n \nconst b = z.iso.datetime({ precision: -1 }); // minute precision (no seconds)\nb.parse(\"2020-01-01T06:15Z\"); // ✅\nb.parse(\"2020-01-01T06:15:00Z\"); // ❌\nb.parse(\"2020-01-01T06:15:00.123Z\"); // ❌\n \nconst c = z.iso.datetime({ precision: 0 }); // second precision only\nc.parse(\"2020-01-01T06:15Z\"); // ❌\nc.parse(\"2020-01-01T06:15:00Z\"); // ✅\nc.parse(\"2020-01-01T06:15:00.123Z\"); // ❌\n \nconst d = z.iso.datetime({ precision: 3 }); // millisecond precision only\nd.parse(\"2020-01-01T06:15Z\"); // ❌\nd.parse(\"2020-01-01T06:15:00Z\"); // ❌\nd.parse(\"2020-01-01T06:15:00.123Z\"); // ✅\nISO dates\n\nThe z.iso.date() method validates strings in the format YYYY-MM-DD.\n\nconst date = z.iso.date();\n \ndate.parse(\"2020-01-01\"); // ✅\ndate.parse(\"2020-1-1\"); // ❌\ndate.parse(\"2020-01-32\"); // ❌\nISO times\n\nThe z.iso.time() method validates strings in the format HH:MM[:SS[.s+]]. By default seconds are optional, as are sub-second deciams.\n\nconst time = z.iso.time();\n \ntime.parse(\"03:15\"); // ✅\ntime.parse(\"03:15:00\"); // ✅\ntime.parse(\"03:15:00.9999999\"); // ✅ (arbitrary precision)\n\nNo offsets of any kind are allowed.\n\ntime.parse(\"03:15:00Z\"); // ❌ (no `Z` allowed)\ntime.parse(\"03:15:00+02:00\"); // ❌ (no offsets allowed)\n\nUse the precision parameter to constrain the allowable decimal precision.\n\nz.iso.time({ precision: -1 }); // HH:MM (minute precision)\nz.iso.time({ precision: 0 }); // HH:MM:SS (second precision)\nz.iso.time({ precision: 1 }); // HH:MM:SS.s (decisecond precision)\nz.iso.time({ precision: 2 }); // HH:MM:SS.ss (centisecond precision)\nz.iso.time({ precision: 3 }); // HH:MM:SS.sss (millisecond precision)\nIP addresses\nconst ipv4 = z.ipv4();\nipv4.parse(\"192.168.0.0\"); // ✅\n \nconst ipv6 = z.ipv6();\nipv6.parse(\"2001:db8:85a3::8a2e:370:7334\"); // ✅\nIP blocks (CIDR)\n\nValidate IP address ranges specified with CIDR notation.\n\nconst cidrv4 = z.string().cidrv4();\ncidrv4.parse(\"192.168.0.0/24\"); // ✅\n \nconst cidrv6 = z.string().cidrv6();\ncidrv6.parse(\"2001:db8::/32\"); // ✅\nJWTs\n\nValidate JSON Web Tokens.\n\nz.jwt();\nz.jwt({ alg: \"HS256\" });\nHashes\n\nTo validate cryptographic hash values:\n\nz.hash(\"md5\");\nz.hash(\"sha1\");\nz.hash(\"sha256\");\nz.hash(\"sha384\");\nz.hash(\"sha512\");\n\nBy default, z.hash() expects hexadecimal encoding, as is conventional. You can specify a different encoding with the enc parameter:\n\nz.hash(\"sha256\", { enc: \"hex\" });       // default\nz.hash(\"sha256\", { enc: \"base64\" });    // base64 encoding\nz.hash(\"sha256\", { enc: \"base64url\" }); // base64url encoding (no padding)\nExpected lengths and padding\nCustom formats\n\nTo define your own string formats:\n\nconst coolId = z.stringFormat(\"cool-id\", ()=>{\n  // arbitrary validation here\n  return val.length === 100 && val.startsWith(\"cool-\");\n});\n \n// a regex is also accepted\nz.stringFormat(\"cool-id\", /^cool-[a-z0-9]{95}$/);\n\nThis schema will produce \"invalid_format\" issues, which are more descriptive than the \"custom\" errors produced by refinements or z.custom().\n\nmyFormat.parse(\"invalid input!\");\n// ZodError: [\n//   {\n//     \"code\": \"invalid_format\",\n//     \"format\": \"cool-id\",\n//     \"path\": [],\n//     \"message\": \"Invalid cool-id\"\n//   }\n// ]\nTemplate literals\n\nNew — Introduced in zod@4.0.\n\nTo define a template literal schema:\n\nconst schema = z.templateLiteral([ \"hello, \", z.string(), \"!\" ]);\n// `hello, ${string}!`\n\nThe z.templateLiteral API can handle any number of string literals (e.g. \"hello\") and schemas. Any schema with an inferred type that's assignable to string | number | bigint | boolean | null | undefined can be passed.\n\nz.templateLiteral([ \"hi there\" ]);\n// `hi there`\n \nz.templateLiteral([ \"email: \", z.string() ]);\n// `email: ${string}`\n \nz.templateLiteral([ \"high\", z.literal(5) ]);\n// `high5`\n \nz.templateLiteral([ z.nullable(z.literal(\"grassy\")) ]);\n// `grassy` | `null`\n \nz.templateLiteral([ z.number(), z.enum([\"px\", \"em\", \"rem\"]) ]);\n// `${number}px` | `${number}em` | `${number}rem`\nNumbers\n\nUse z.number() to validate numbers. It allows any finite number.\n\nconst schema = z.number();\n \nschema.parse(3.14);      // ✅\nschema.parse(NaN);       // ❌\nschema.parse(Infinity);  // ❌\n\nZod implements a handful of number-specific validations:\n\nZod\nZod Mini\nz.number().gt(5);\nz.number().gte(5);                     // alias .min(5)\nz.number().lt(5);\nz.number().lte(5);                     // alias .max(5)\nz.number().positive();       \nz.number().nonnegative();    \nz.number().negative(); \nz.number().nonpositive(); \nz.number().multipleOf(5);              // alias .step(5)\n\nIf (for some reason) you want to validate NaN, use z.nan().\n\nz.nan().parse(NaN);              // ✅\nz.nan().parse(\"anything else\");  // ❌\nIntegers\n\nTo validate integers:\n\nz.int();     // restricts to safe integer range\nz.int32();   // restrict to int32 range\nBigInts\n\nTo validate BigInts:\n\nz.bigint();\n\nZod includes a handful of bigint-specific validations.\n\nZod\nZod Mini\nz.bigint().gt(5n);\nz.bigint().gte(5n);                    // alias `.min(5n)`\nz.bigint().lt(5n);\nz.bigint().lte(5n);                    // alias `.max(5n)`\nz.bigint().positive(); \nz.bigint().nonnegative(); \nz.bigint().negative(); \nz.bigint().nonpositive(); \nz.bigint().multipleOf(5n);             // alias `.step(5n)`\nBooleans\n\nTo validate boolean values:\n\nz.boolean().parse(true); // => true\nz.boolean().parse(false); // => false\nDates\n\nUse z.date() to validate Date instances.\n\nz.date().safeParse(new Date()); // success: true\nz.date().safeParse(\"2022-01-12T06:15:00.000Z\"); // success: false\n\nTo customize the error message:\n\nz.date({\n  error: issue => issue.input === undefined ? \"Required\" : \"Invalid date\"\n});\n\nZod provides a handful of date-specific validations.\n\nZod\nZod Mini\nz.date().min(new Date(\"1900-01-01\"), { error: \"Too old!\" });\nz.date().max(new Date(), { error: \"Too young!\" });\nEnums\n\nUse z.enum to validate inputs against a fixed set of allowable string values.\n\nconst FishEnum = z.enum([\"Salmon\", \"Tuna\", \"Trout\"]);\n \nFishEnum.parse(\"Salmon\"); // => \"Salmon\"\nFishEnum.parse(\"Swordfish\"); // => ❌\n\nCareful — If you declare your string array as a variable, Zod won't be able to properly infer the exact values of each element.\n\nconst fish = [\"Salmon\", \"Tuna\", \"Trout\"];\n \nconst FishEnum = z.enum(fish);\ntype FishEnum = z.infer<typeof FishEnum>; // string\n\nTo fix this, always pass the array directly into the z.enum() function, or use as const.\n\nconst fish = [\"Salmon\", \"Tuna\", \"Trout\"] as const;\n \nconst FishEnum = z.enum(fish);\ntype FishEnum = z.infer<typeof FishEnum>; // \"Salmon\" | \"Tuna\" | \"Trout\"\n\nEnum-like object literals ({ [key: string]: string | number }) are supported.\n\nconst Fish = {\n  Salmon: \"Salmon\",\n  Tuna: \"Tuna\"\n} as const\n \nconst FishEnum = z.enum(Fish)\nFishEnum.parse(\"Salmon\"); // => \"Salmon\"\nFishEnum.parse(\"Swordfish\"); // => ❌\n\nYou can also pass in an externally-declared TypeScript enum.\n\nZod 4 — This replaces the z.nativeEnum() API in Zod 3.\n\nNote that using TypeScript's enum keyword is not recommended.\n\nenum Fish {\n  Salmon = \"Salmon\",\n  Tuna = \"Tuna\",\n  Trout = \"Trout\",\n}\n \nconst FishEnum = z.enum(Fish);\n.enum\n\nTo extract the schema's values as an enum-like object:\n\nZod\nZod Mini\nconst FishEnum = z.enum([\"Salmon\", \"Tuna\", \"Trout\"]);\n \nFishEnum.enum;\n// => { Salmon: \"Salmon\", Tuna: \"Tuna\", Trout: \"Trout\" }\n.exclude()\n\nTo create a new enum schema, excluding certain values:\n\nZod\nZod Mini\nconst FishEnum = z.enum([\"Salmon\", \"Tuna\", \"Trout\"]);\nconst TunaOnly = FishEnum.exclude([\"Salmon\", \"Trout\"]);\n.extract()\n\nTo create a new enum schema, extracting certain values:\n\nZod\nZod Mini\nconst FishEnum = z.enum([\"Salmon\", \"Tuna\", \"Trout\"]);\nconst SalmonAndTroutOnly = FishEnum.extract([\"Salmon\", \"Trout\"]);\nStringbools\n\n💎 New in Zod 4\n\nIn some cases (e.g. parsing environment variables) it's valuable to parse certain string \"boolish\" values to a plain boolean value. To support this, Zod 4 introduces z.stringbool():\n\nconst strbool = z.stringbool();\n \nstrbool.parse(\"true\")         // => true\nstrbool.parse(\"1\")            // => true\nstrbool.parse(\"yes\")          // => true\nstrbool.parse(\"on\")           // => true\nstrbool.parse(\"y\")            // => true\nstrbool.parse(\"enabled\")      // => true\n \nstrbool.parse(\"false\");       // => false\nstrbool.parse(\"0\");           // => false\nstrbool.parse(\"no\");          // => false\nstrbool.parse(\"off\");         // => false\nstrbool.parse(\"n\");           // => false\nstrbool.parse(\"disabled\");    // => false\n \nstrbool.parse(/* anything else */); // ZodError<[{ code: \"invalid_value\" }]>\n\nTo customize the truthy and falsy values:\n\n// these are the defaults\nz.stringbool({\n  truthy: [\"true\", \"1\", \"yes\", \"on\", \"y\", \"enabled\"],\n  falsy: [\"false\", \"0\", \"no\", \"off\", \"n\", \"disabled\"],\n});\n\nBy default the schema is case-insensitive; all inputs are converted to lowercase before comparison to the truthy/falsy values. To make it case-sensitive:\n\nz.stringbool({\n  case: \"sensitive\"\n});\nOptionals\n\nTo make a schema optional (that is, to allow undefined inputs).\n\nZod\nZod Mini\nz.optional(z.literal(\"yoda\")); // or z.literal(\"yoda\").optional()\n\nThis returns a ZodOptional instance that wraps the original schema. To extract the inner schema:\n\nZod\nZod Mini\noptionalYoda.unwrap(); // ZodLiteral<\"yoda\">\nNullables\n\nTo make a schema nullable (that is, to allow null inputs).\n\nZod\nZod Mini\nz.nullable(z.literal(\"yoda\")); // or z.literal(\"yoda\").nullable()\n\nThis returns a ZodNullable instance that wraps the original schema. To extract the inner schema:\n\nZod\nZod Mini\nnullableYoda.unwrap(); // ZodLiteral<\"yoda\">\nNullish\n\nTo make a schema nullish (both optional and nullable):\n\nZod\nZod Mini\nconst nullishYoda = z.nullish(z.literal(\"yoda\"));\n\nRefer to the TypeScript manual for more about the concept of nullish.\n\nUnknown\n\nZod aims to mirror TypeScript's type system one-to-one. As such, Zod provides APIs to represent the following special types:\n\n// allows any values\nz.any(); // inferred type: `any`\nz.unknown(); // inferred type: `unknown`\nNever\n\nNo value will pass validation.\n\nz.never(); // inferred type: `never`\nObjects\n\nTo define an object type:\n\n  // all properties are required by default\n  const Person = z.object({\n    name: z.string(),\n    age: z.number(),\n  });\n \n  type Person = z.infer<typeof Person>;\n  // => { name: string; age: number; }\n\nBy default, all properties are required. To make certain properties optional:\n\nZod\nZod Mini\nconst Dog = z.object({\n  name: z.string(),\n  age: z.number().optional(),\n});\n \nDog.parse({ name: \"Yeller\" }); // ✅\n\nBy default, unrecognized keys are stripped from the parsed result:\n\nDog.parse({ name: \"Yeller\", extraKey: true });\n// => { name: \"Yeller\" }\nz.strictObject\n\nTo define a strict schema that throws an error when unknown keys are found:\n\nconst StrictDog = z.strictObject({\n  name: z.string(),\n});\n \nStrictDog.parse({ name: \"Yeller\", extraKey: true });\n// ❌ throws\nz.looseObject\n\nTo define a loose schema that allows unknown keys to pass through:\n\nconst LooseDog = z.looseObject({\n  name: z.string(),\n});\n \nLooseDog.parse({ name: \"Yeller\", extraKey: true });\n// => { name: \"Yeller\", extraKey: true }\n.catchall()\n\nTo define a catchall schema that will be used to validate any unrecognized keys:\n\nZod\nZod Mini\nconst DogWithStrings = z.object({\n  name: z.string(),\n  age: z.number().optional(),\n}).catchall(z.string());\n \nDogWithStrings.parse({ name: \"Yeller\", extraKey: \"extraValue\" }); // ✅\nDogWithStrings.parse({ name: \"Yeller\", extraKey: 42 }); // ❌\n.shape\n\nTo access the internal schemas:\n\nZod\nZod Mini\nDog.shape.name; // => string schema\nDog.shape.age; // => number schema\n.keyof()\n\nTo create a ZodEnum schema from the keys of an object schema:\n\nZod\nZod Mini\nconst keySchema = Dog.keyof();\n// => ZodEnum<[\"name\", \"age\"]>\n.extend()\n\nTo add additional fields to an object schema:\n\nZod\nZod Mini\nconst DogWithBreed = Dog.extend({\n  breed: z.string(),\n});\n\nThis API can be used to overwrite existing fields! Be careful with this power! If the two schemas share keys, B will override A.\n\nAlternative: spread syntax — You can alternatively avoid .extend() altogether by creating a new object schema entirely. This makes the strictness level of the resulting schema visually obvious.\n\nconst DogWithBreed = z.object({ // or z.strictObject() or z.looseObject()...\n  ...Dog.shape,\n  breed: z.string(),\n});\n\nYou can also use this to merge multiple objects in one go.\n\nconst DogWithBreed = z.object({\n  ...Animal.shape,\n  ...Pet.shape,\n  breed: z.string(),\n});\n\nThis approach has a few advantages:\n\nIt uses language-level features (spread syntax) instead of library-specific APIs\nThe same syntax works in Zod and Zod Mini\nIt's more tsc-efficient — the .extend() method can be expensive on large schemas, and due to a TypeScript limitation it gets quadratically more expensive when calls are chained\nIf you wish, you can change the strictness level of the resulting schema by using z.strictObject() or z.looseObject()\n.safeExtend()\n\nThe .safeExtend() method works similarly to .extend(), but it won't let you overwrite an existing properly with a non-assignable schema. In other words, the result of .safeExtend() will have an inferred type that extends the original (in the TypeScript sense).\n\nz.object({ a: z.string() }).safeExtend({ a: z.string().min(5) }); // ✅\nz.object({ a: z.string() }).safeExtend({ a: z.any() }); // ✅\nz.object({ a: z.string() }).safeExtend({ a: z.number() });\n//                                       ^  ❌ ZodNumber is not assignable \n\nUse .safeExtend() to extend schemas that contain refinements. (Regular .extend() will throw an error when used on schemas with refinements.)\n\nZod\nZod Mini\nconst Base = z.object({\n  a: z.string(),\n  b: z.string()\n}).refine(user => user.a === user.b);\n \n// Extended inherits the refinements of Base\nconst Extended = Base.safeExtend({\n  a: z.string().min(10)\n});\n.pick()\n\nInspired by TypeScript's built-in Pick and Omit utility types, Zod provides dedicated APIs for picking and omitting certain keys from an object schema.\n\nStarting from this initial schema:\n\nconst Recipe = z.object({\n  title: z.string(),\n  description: z.string().optional(),\n  ingredients: z.array(z.string()),\n});\n// { title: string; description?: string | undefined; ingredients: string[] }\n\nTo pick certain keys:\n\nZod\nZod Mini\nconst JustTheTitle = Recipe.pick({ title: true });\n.omit()\n\nTo omit certain keys:\n\nZod\nZod Mini\nconst RecipeNoId = Recipe.omit({ id: true });\n.partial()\n\nFor convenience, Zod provides a dedicated API for making some or all properties optional, inspired by the built-in TypeScript utility type Partial.\n\nTo make all fields optional:\n\nZod\nZod Mini\nconst PartialRecipe = Recipe.partial();\n// { title?: string | undefined; description?: string | undefined; ingredients?: string[] | undefined }\n\nTo make certain properties optional:\n\nZod\nZod Mini\nconst RecipeOptionalIngredients = Recipe.partial({\n  ingredients: true,\n});\n// { title: string; description?: string | undefined; ingredients?: string[] | undefined }\n.required()\n\nZod provides an API for making some or all properties required, inspired by TypeScript's Required utility type.\n\nTo make all properties required:\n\nZod\nZod Mini\nconst RequiredRecipe = Recipe.required();\n// { title: string; description: string; ingredients: string[] }\n\nTo make certain properties required:\n\nZod\nZod Mini\nconst RecipeRequiredDescription = Recipe.required({description: true});\n// { title: string; description: string; ingredients: string[] }\nRecursive objects\n\nTo define a self-referential type, use a getter on the key. This lets JavaScript resolve the cyclical schema at runtime.\n\nconst Category = z.object({\n  name: z.string(),\n  get subcategories(){\n    return z.array(Category)\n  }\n});\n \ntype Category = z.infer<typeof Category>;\n// { name: string; subcategories: Category[] }\n\nThough recursive schemas are supported, passing cyclical data into Zod will cause an infinite loop.\n\nYou can also represent mutually recursive types:\n\nconst User = z.object({\n  email: z.email(),\n  get posts(){\n    return z.array(Post)\n  }\n});\n \nconst Post = z.object({\n  title: z.string(),\n  get author(){\n    return User\n  }\n});\n\nAll object APIs (.pick(), .omit(), .required(), .partial(), etc.) work as you'd expect.\n\nCircularity errors\n\nDue to TypeScript limitations, recursive type inference can be finicky, and it only works in certain scenarios. Some more complicated types may trigger recursive type errors like this:\n\nconst Activity = z.object({\n  name: z.string(),\n  get subactivities() {\n    // ^ ❌ 'subactivities' implicitly has return type 'any' because it does not\n    // have a return type annotation and is referenced directly or indirectly\n    // in one of its return expressions.ts(7023)\n \n    return z.nullable(z.array(Activity));\n  },\n});\n\nIn these cases, you can resolve the error with a type annotation on the offending getter:\n\nconst Activity = z.object({\n  name: z.string(),\n  get subactivities(): z.ZodNullable<z.ZodArray<typeof Activity>> {\n    return z.nullable(z.array(Activity));\n  },\n});\nArrays\n\nTo define an array schema:\n\nZod\nZod Mini\nconst stringArray = z.array(z.string()); // or z.string().array()\n\nTo access the inner schema for an element of the array.\n\nZod\nZod Mini\nstringArray.unwrap(); // => string schema\n\nZod implements a number of array-specific validations:\n\nZod\nZod Mini\nz.array(z.string()).min(5); // must contain 5 or more items\nz.array(z.string()).max(5); // must contain 5 or fewer items\nz.array(z.string()).length(5); // must contain 5 items exactly\nTuples\n\nUnlike arrays, tuples are typically fixed-length arrays that specify different schemas for each index.\n\nconst MyTuple = z.tuple([\n  z.string(),\n  z.number(),\n  z.boolean()\n]);\n \ntype MyTuple = z.infer<typeof MyTuple>;\n// [string, number, boolean]\n\nTo add a variadic (\"rest\") argument:\n\nconst variadicTuple = z.tuple([z.string()], z.number());\n// => [string, ...number[]];\nUnions\n\nUnion types (A | B) represent a logical \"OR\". Zod union schemas will check the input against each option in order. The first value that validates successfully is returned.\n\nconst stringOrNumber = z.union([z.string(), z.number()]);\n// string | number\n \nstringOrNumber.parse(\"foo\"); // passes\nstringOrNumber.parse(14); // passes\n\nTo extract the internal option schemas:\n\nZod\nZod Mini\nstringOrNumber.options; // [ZodString, ZodNumber]\nDiscriminated unions\n\nA discriminated union is a special kind of union in which a) all the options are object schemas that b) share a particular key (the \"discriminator\"). Based on the value of the discriminator key, TypeScript is able to \"narrow\" the type signature as you'd expect.\n\ntype MyResult =\n  | { status: \"success\"; data: string }\n  | { status: \"failed\"; error: string };\n \nfunction handleResult(result: MyResult){\n  if(result.status === \"success\"){\n    result.data; // string\n  } else {\n    result.error; // string\n  }\n}\n\nYou could represent it with a regular z.union(). But regular unions are naive—they check the input against each option in order and return the first one that passes. This can be slow for large unions.\n\nSo Zod provides a z.discriminatedUnion() API that uses a discriminator key to make parsing more efficient.\n\nconst MyResult = z.discriminatedUnion(\"status\", [\n  z.object({ status: z.literal(\"success\"), data: z.string() }),\n  z.object({ status: z.literal(\"failed\"), error: z.string() }),\n]);\n\nEach option should be an object schema whose discriminator prop (status in the example above) corresponds to some literal value or set of values, usually z.enum(), z.literal(), z.null(), or z.undefined().\n\nNesting discriminated unions\nIntersections\n\nIntersection types (A & B) represent a logical \"AND\".\n\nconst a = z.union([z.number(), z.string()]);\nconst b = z.union([z.number(), z.boolean()]);\nconst c = z.intersection(a, b);\n \ntype c = z.infer<typeof c>; // => number\n\nThis can be useful for intersecting two object types.\n\nconst Person = z.object({ name: z.string() });\ntype Person = z.infer<typeof Person>;\n \nconst Employee = z.object({ role: z.string() });\ntype Employee = z.infer<typeof Employee>;\n \nconst EmployedPerson = z.intersection(Person, Employee);\ntype EmployedPerson = z.infer<typeof EmployedPerson>;\n// Person & Employee\n\nWhen merging object schemas, prefer A.extend(B) over intersections. Using .extend() will give you a new object schema, whereas z.intersection(A, B) returns a ZodIntersection instance which lacks common object methods like pick and omit.\n\nRecords\n\nRecord schemas are used to validate types such as Record<string, string>.\n\nconst IdCache = z.record(z.string(), z.string());\ntype IdCache = z.infer<typeof IdCache>; // Record<string, string>\n \nIdCache.parse({\n  carlotta: \"77d2586b-9e8e-4ecf-8b21-ea7e0530eadd\",\n  jimmie: \"77d2586b-9e8e-4ecf-8b21-ea7e0530eadd\",\n});\n\nThe key schema can be any Zod schema that is assignable to string | number | symbol.\n\nconst Keys = z.union([z.string(), z.number(), z.symbol()]);\nconst AnyObject = z.record(Keys, z.unknown());\n// Record<string | number | symbol, unknown>\n\nTo create an object schemas containing keys defined by an enum:\n\nconst Keys = z.enum([\"id\", \"name\", \"email\"]);\nconst Person = z.record(Keys, z.string());\n// { id: string; name: string; email: string }\n\nZod 4 — In Zod 4, if you pass a z.enum as the first argument to z.record(), Zod will exhaustively check that all enum values exist in the input as keys. This behavior agrees with TypeScript:\n\ntype MyRecord = Record<\"a\" | \"b\", string>;\nconst myRecord: MyRecord = { a: \"foo\", b: \"bar\" }; // ✅\nconst myRecord: MyRecord = { a: \"foo\" }; // ❌ missing required key `b`\n\nIn Zod 3, exhaustiveness was not checked. To replicate the old behavior, use z.partialRecord().\n\nIf you want a partial record type, use z.partialRecord(). This skips the special exhaustiveness checks Zod normally runs with z.enum() and z.literal() key schemas.\n\nconst Keys = z.enum([\"id\", \"name\", \"email\"]).or(z.never()); \nconst Person = z.partialRecord(Keys, z.string());\n// { id?: string; name?: string; email?: string }\nA note on numeric keys\nMaps\nconst StringNumberMap = z.map(z.string(), z.number());\ntype StringNumberMap = z.infer<typeof StringNumberMap>; // Map<string, number>\n \nconst myMap: StringNumberMap = new Map();\nmyMap.set(\"one\", 1);\nmyMap.set(\"two\", 2);\n \nStringNumberMap.parse(myMap);\nSets\nconst NumberSet = z.set(z.number());\ntype NumberSet = z.infer<typeof NumberSet>; // Set<number>\n \nconst mySet: NumberSet = new Set();\nmySet.add(1);\nmySet.add(2);\nNumberSet.parse(mySet);\n\nSet schemas can be further constrained with the following utility methods.\n\nZod\nZod Mini\nz.set(z.string()).min(5); // must contain 5 or more items\nz.set(z.string()).max(5); // must contain 5 or fewer items\nz.set(z.string()).size(5); // must contain 5 items exactly\nFiles\n\nTo validate File instances:\n\nZod\nZod Mini\nconst fileSchema = z.file();\n \nfileSchema.min(10_000); // minimum .size (bytes)\nfileSchema.max(1_000_000); // maximum .size (bytes)\nfileSchema.mime(\"image/png\"); // MIME type\nfileSchema.mime([\"image/png\", \"image/jpeg\"]); // multiple MIME types\nPromises\n\nDeprecated — z.promise() is deprecated in Zod 4. There are vanishingly few valid uses cases for a Promise schema. If you suspect a value might be a Promise, simply await it before parsing it with Zod.\n\nSee z.promise() documentation\nInstanceof\n\nYou can use z.instanceof to check that the input is an instance of a class. This is useful to validate inputs against classes that are exported from third-party libraries.\n\nclass Test {\n  name: string;\n}\n \nconst TestSchema = z.instanceof(Test);\n \nTestSchema.parse(new Test()); // ✅\nTestSchema.parse(\"whatever\"); // ❌\nProperty\n\nTo validate a particular property of a class instance against a Zod schema:\n\nconst blobSchema = z.instanceof(URL).check(\n  z.property(\"protocol\", z.literal(\"https:\" as string, \"Only HTTPS allowed\"))\n);\n \nblobSchema.parse(new URL(\"https://example.com\")); // ✅\nblobSchema.parse(new URL(\"http://example.com\")); // ❌\n\nThe z.property() API works with any data type (but it's most useful when used in conjunction with z.instanceof()).\n\nconst blobSchema = z.string().check(\n  z.property(\"length\", z.number().min(10))\n);\n \nblobSchema.parse(\"hello there!\"); // ✅\nblobSchema.parse(\"hello.\"); // ❌\nRefinements\n\nEvery Zod schema stores an array of refinements. Refinements are a way to perform custom validation that Zod doesn't provide a native API for.\n\n.refine()\nZod\nZod Mini\nconst myString = z.string().refine((val) => val.length <= 255);\n\nRefinement functions should never throw. Instead they should return a falsy value to signal failure. Thrown errors are not caught by Zod.\n\nerror\n\nTo customize the error message:\n\nZod\nZod Mini\nconst myString = z.string().refine((val) => val.length > 8, { \n  error: \"Too short!\" \n});\nabort\n\nBy default, validation issues from checks are considered continuable; that is, Zod will execute all checks in sequence, even if one of them causes a validation error. This is usually desirable, as it means Zod can surface as many errors as possible in one go.\n\nZod\nZod Mini\nconst myString = z.string()\n  .refine((val) => val.length > 8, { error: \"Too short!\" })\n  .refine((val) => val === val.toLowerCase(), { error: \"Must be lowercase\" });\n  \n \nconst result = myString.safeParse(\"OH NO\");\nresult.error?.issues;\n/* [\n  { \"code\": \"custom\", \"message\": \"Too short!\" },\n  { \"code\": \"custom\", \"message\": \"Must be lowercase\" }\n] */\n\nTo mark a particular refinement as non-continuable, use the abort parameter. Validation will terminate if the check fails.\n\nZod\nZod Mini\nconst myString = z.string()\n  .refine((val) => val.length > 8, { error: \"Too short!\", abort: true })\n  .refine((val) => val === val.toLowerCase(), { error: \"Must be lowercase\", abort: true });\n \n \nconst result = myString.safeParse(\"OH NO\");\nresult.error?.issues;\n// => [{ \"code\": \"custom\", \"message\": \"Too short!\" }]\npath\n\nTo customize the error path, use the path parameter. This is typically only useful in the context of object schemas.\n\nZod\nZod Mini\nconst passwordForm = z\n  .object({\n    password: z.string(),\n    confirm: z.string(),\n  })\n  .refine((data) => data.password === data.confirm, {\n    message: \"Passwords don't match\",\n    path: [\"confirm\"], // path of error\n  });\n\nThis will set the path parameter in the associated issue:\n\nZod\nZod Mini\nconst result = passwordForm.safeParse({ password: \"asdf\", confirm: \"qwer\" });\nresult.error.issues;\n/* [{\n  \"code\": \"custom\",\n  \"path\": [ \"confirm\" ],\n  \"message\": \"Passwords don't match\"\n}] */\n\nTo define an asynchronous refinement, just pass an async function:\n\nconst userId = z.string().refine(async (id) => {\n  // verify that ID exists in database\n  return true;\n});\n\nIf you use async refinements, you must use the .parseAsync method to parse data! Otherwise Zod will throw an error.\n\nZod\nZod Mini\nconst result = await userId.parseAsync(\"abc123\");\nwhen\n\nNote — This is a power user feature and can absolutely be abused in ways that will increase the probability of uncaught errors originating from inside your refinements.\n\nBy default, refinements don't run if any non-continuable issues have already been encountered. Zod is careful to ensure the type signature of the value is correct before passing it into any refinement functions.\n\nconst schema = z.string().refine((val) => {\n  return val.length > 8\n});\n \nschema.parse(1234); // invalid_type: refinement won't be executed\n\nIn some cases, you want finer control over when refinements run. For instance consider this \"password confirm\" check:\n\nZod\nZod Mini\nconst schema = z\n  .object({\n    password: z.string().min(8),\n    confirmPassword: z.string(),\n    anotherField: z.string(),\n  })\n  .refine((data) => data.password === data.confirmPassword, {\n    message: \"Passwords do not match\",\n    path: [\"confirmPassword\"],\n  });\n \nschema.parse({\n  password: \"asdf\",\n  confirmPassword: \"asdf\",\n  anotherField: 1234 // ❌ this error will prevent the password check from running\n});\n\nAn error on anotherField will prevent the password confirmation check from executing, even though the check doesn't depend on anotherField. To control when a refinement will run, use the when parameter:\n\nZod\nZod Mini\nconst schema = z\n  .object({\n    password: z.string().min(8),\n    confirmPassword: z.string(),\n    anotherField: z.string(),\n  })\n  .refine((data) => data.password === data.confirmPassword, {\n    message: \"Passwords do not match\",\n    path: [\"confirmPassword\"],\n \n    // run if password & confirmPassword are valid\n    when(payload) { \n      return schema \n        .pick({ password: true, confirmPassword: true }) \n        .safeParse(payload.value).success; \n    },  \n  });\n \nschema.parse({\n  password: \"asdf\",\n  confirmPassword: \"asdf\",\n  anotherField: 1234 // ❌ this error will not prevent the password check from running\n});\n.superRefine()\n\nThe regular .refine API only generates a single issue with a \"custom\" error code, but .superRefine() makes it possible to create multiple issues using any of Zod's internal issue types.\n\nZod\nZod Mini\nconst UniqueStringArray = z.array(z.string()).superRefine((val, ctx) => {\n  if (val.length > 3) {\n    ctx.addIssue({\n      code: \"too_big\",\n      maximum: 3,\n      origin: \"array\",\n      inclusive: true,\n      message: \"Too many items 😡\",\n      input: val,\n    });\n  }\n \n  if (val.length !== new Set(val).size) {\n    ctx.addIssue({\n      code: \"custom\",\n      message: `No duplicates allowed.`,\n      input: val,\n    });\n  }\n});\n \n.check()\n\nNote — The .check() API is a more low-level API that's generally more complex than .superRefine(). It can be faster in performance-sensitive code paths, but it's also more verbose.\n\nView example\nCodecs\n\nNew — Introduced in Zod 4.1. Refer to the dedicated Codecs page for more information.\n\nCodecs are a special kind of schema that implement bidirectional transformations between two other schemas.\n\nconst stringToDate = z.codec(\n  z.iso.datetime(),  // input schema: ISO date string\n  z.date(),          // output schema: Date object\n  {\n    decode: (isoString) => new Date(isoString), // ISO string → Date\n    encode: (date) => date.toISOString(),       // Date → ISO string\n  }\n);\n\nA regular .parse() operations performs the forward transform. It calls the codec's decode function.\n\nstringToDate.parse(\"2024-01-15T10:30:00.000Z\"); // => Date\n\nYou can alternatively use the top-level z.decode() function. Unlike .parse() (which accepts unknown input), z.decode() expects a strongly-typed input (string in this example).\n\nz.decode(stringToDate, \"2024-01-15T10:30:00.000Z\"); // => Date\n\nTo perform the reverse transform, use the inverse: z.encode().\n\nz.encode(stringToDate, new Date(\"2024-01-15\")); // => \"2024-01-15T00:00:00.000Z\"\n\nRefer to the dedicated Codecs page for more information. That page contains implementations for commonly-needed codecs that you can copy/paste into your project:\n\nstringToNumber\nstringToInt\nstringToBigInt\nnumberToBigInt\nisoDatetimeToDate\nepochSecondsToDate\nepochMillisToDate\njsonCodec\nutf8ToBytes\nbytesToUtf8\nbase64ToBytes\nbase64urlToBytes\nhexToBytes\nstringToURL\nstringToHttpURL\nuriComponent\nstringToBoolean\nPipes\n\nSchemas can be chained together into \"pipes\". Pipes are primarily useful when used in conjunction with Transforms.\n\nZod\nZod Mini\nconst stringToLength = z.string().pipe(z.transform(val => val.length));\n \nstringToLength.parse(\"hello\"); // => 5\nTransforms\n\nNote — For bi-directional transforms, use codecs.\n\nTransforms are a special kind of schema that perform a unidirectional transformation. Instead of validating input, they accept anything and perform some transformation on the data. To define a transform:\n\nZod\nZod Mini\nconst castToString = z.transform((val) => String(val));\n \ncastToString.parse(\"asdf\"); // => \"asdf\"\ncastToString.parse(123); // => \"123\"\ncastToString.parse(true); // => \"true\"\n\nRefinement functions should never throw. Thrown errors are not caught by Zod.\n\nTo perform validation logic inside a transform, use ctx. To report a validation issue, push a new issue onto ctx.issues (similar to the .check() API).\n\nconst coercedInt = z.transform((val, ctx) => {\n  try {\n    const parsed = Number.parseInt(String(val));\n    return parsed;\n  } catch (e) {\n    ctx.issues.push({\n      code: \"custom\",\n      message: \"Not a number\",\n      input: val,\n    });\n \n    // this is a special constant with type `never`\n    // returning it lets you exit the transform without impacting the inferred return type\n    return z.NEVER;\n  }\n});\n\nMost commonly, transforms are used in conjunction with Pipes. This combination is useful for performing some initial validation, then transforming the parsed data into another form.\n\nZod\nZod Mini\nconst stringToLength = z.string().pipe(z.transform(val => val.length));\n \nstringToLength.parse(\"hello\"); // => 5\n.transform()\n\nPiping some schema into a transform is a common pattern, so Zod provides a convenience .transform() method.\n\nZod\nZod Mini\nconst stringToLength = z.string().transform(val => val.length); \n\nTransforms can also be async:\n\nZod\nZod Mini\nconst idToUser = z\n  .string()\n  .transform(async (id) => {\n    // fetch user from database\n    return db.getUserById(id); \n  });\n \nconst user = await idToUser.parseAsync(\"abc123\");\n\nIf you use async transforms, you must use a .parseAsync or .safeParseAsync when parsing data! Otherwise Zod will throw an error.\n\n.preprocess()\n\nPiping a transform into another schema is another common pattern, so Zod provides a convenience z.preprocess() function.\n\nconst coercedInt = z.preprocess((val) => {\n  if (typeof val === \"string\") {\n    return Number.parseInt(val);\n  }\n  return val;\n}, z.int());\nDefaults\n\nTo set a default value for a schema:\n\nZod\nZod Mini\nconst defaultTuna = z.string().default(\"tuna\");\n \ndefaultTuna.parse(undefined); // => \"tuna\"\n\nAlternatively, you can pass a function which will be re-executed whenever a default value needs to be generated:\n\nZod\nZod Mini\nconst randomDefault = z.number().default(Math.random);\n \nrandomDefault.parse(undefined);    // => 0.4413456736055323\nrandomDefault.parse(undefined);    // => 0.1871840107401901\nrandomDefault.parse(undefined);    // => 0.7223408162401552\nPrefaults\n\nIn Zod, setting a default value will short-circuit the parsing process. If the input is undefined, the default value is eagerly returned. As such, the default value must be assignable to the output type of the schema.\n\nconst schema = z.string().transform(val => val.length).default(0);\nschema.parse(undefined); // => 0\n\nSometimes, it's useful to define a prefault (\"pre-parse default\") value. If the input is undefined, the prefault value will be parsed instead. The parsing process is not short circuited. As such, the prefault value must be assignable to the input type of the schema.\n\nz.string().transform(val => val.length).prefault(\"tuna\");\nschema.parse(undefined); // => 4\n\nThis is also useful if you want to pass some input value through some mutating refinements.\n\nconst a = z.string().trim().toUpperCase().prefault(\"  tuna  \");\na.parse(undefined); // => \"TUNA\"\n \nconst b = z.string().trim().toUpperCase().default(\"  tuna  \");\nb.parse(undefined); // => \"  tuna  \"\nCatch\n\nUse .catch() to define a fallback value to be returned in the event of a validation error:\n\nZod\nZod Mini\nconst numberWithCatch = z.number().catch(42);\n \nnumberWithCatch.parse(5); // => 5\nnumberWithCatch.parse(\"tuna\"); // => 42\n\nAlternatively, you can pass a function which will be re-executed whenever a catch value needs to be generated.\n\nZod\nZod Mini\nconst numberWithRandomCatch = z.number().catch((ctx) => {\n  ctx.error; // the caught ZodError\n  return Math.random();\n});\n \nnumberWithRandomCatch.parse(\"sup\"); // => 0.4413456736055323\nnumberWithRandomCatch.parse(\"sup\"); // => 0.1871840107401901\nnumberWithRandomCatch.parse(\"sup\"); // => 0.7223408162401552\nBranded types\n\nTypeScript's type system is structural, meaning that two types that are structurally equivalent are considered the same.\n\ntype Cat = { name: string };\ntype Dog = { name: string };\n \nconst pluto: Dog = { name: \"pluto\" };\nconst simba: Cat = pluto; // works fine\n\nIn some cases, it can be desirable to simulate nominal typing inside TypeScript. This can be achieved with branded types (also known as \"opaque types\").\n\nconst Cat = z.object({ name: z.string() }).brand<\"Cat\">();\nconst Dog = z.object({ name: z.string() }).brand<\"Dog\">();\n \ntype Cat = z.infer<typeof Cat>; // { name: string } & z.$brand<\"Cat\">\ntype Dog = z.infer<typeof Dog>; // { name: string } & z.$brand<\"Dog\">\n \nconst pluto = Dog.parse({ name: \"pluto\" });\nconst simba: Cat = pluto; // ❌ not allowed\n\nUnder the hood, this works by attaching a \"brand\" to the schema's inferred type.\n\nconst Cat = z.object({ name: z.string() }).brand<\"Cat\">();\ntype Cat = z.infer<typeof Cat>; // { name: string } & z.$brand<\"Cat\">\n\nWith this brand, any plain (unbranded) data structures are no longer assignable to the inferred type. You have to parse some data with the schema to get branded data.\n\nNote that branded types do not affect the runtime result of .parse. It is a static-only construct.\n\nReadonly\n\nTo mark a schema as readonly:\n\nZod\nZod Mini\nconst ReadonlyUser = z.object({ name: z.string() }).readonly();\ntype ReadonlyUser = z.infer<typeof ReadonlyUser>;\n// Readonly<{ name: string }>\n\nThe inferred type of the new schemas will be marked as readonly. Note that in TypeScript, this only affects objects, arrays, tuples, Set, and Map:\n\nZod\nZod Mini\nz.object({ name: z.string() }).readonly(); // { readonly name: string }\nz.array(z.string()).readonly(); // readonly string[]\nz.tuple([z.string(), z.number()]).readonly(); // readonly [string, number]\nz.map(z.string(), z.date()).readonly(); // ReadonlyMap<string, Date>\nz.set(z.string()).readonly(); // ReadonlySet<string>\n\nInputs will be parsed like normal, then the result will be frozen with Object.freeze() to prevent modifications.\n\nZod\nZod Mini\nconst result = ReadonlyUser.parse({ name: \"fido\" });\nresult.name = \"simba\"; // throws TypeError\nJSON\n\nTo validate any JSON-encodable value:\n\nconst jsonSchema = z.json();\n\nThis is a convenience API that returns the following union schema:\n\nconst jsonSchema = z.lazy(() => {\n  return z.union([\n    z.string(params), \n    z.number(), \n    z.boolean(), \n    z.null(), \n    z.array(jsonSchema), \n    z.record(z.string(), jsonSchema)\n  ]);\n});\nFunctions\n\nZod provides a z.function() utility for defining Zod-validated functions. This way, you can avoid intermixing validation code with your business logic.\n\nconst MyFunction = z.function({\n  input: [z.string()], // parameters (must be an array or a ZodTuple)\n  output: z.number()  // return type\n});\n \ntype MyFunction = z.infer<typeof MyFunction>;\n// (input: string) => number\n\nFunction schemas have an .implement() method which accepts a function and returns a new function that automatically validates its inputs and outputs.\n\nconst computeTrimmedLength = MyFunction.implement((input) => {\n  // TypeScript knows input is a string!\n  return input.trim().length;\n});\n \ncomputeTrimmedLength(\"sandwich\"); // => 8\ncomputeTrimmedLength(\" asdf \"); // => 4\n\nThis function will throw a ZodError if the input is invalid:\n\ncomputeTrimmedLength(42); // throws ZodError\n\nIf you only care about validating inputs, you can omit the output field.\n\nconst MyFunction = z.function({\n  input: [z.string()], // parameters (must be an array or a ZodTuple)\n});\n \nconst computeTrimmedLength = MyFunction.implement((input) => input.trim.length);\n\nUse the .implementAsync() method to create an async function.\n\nconst computeTrimmedLengthAsync = MyFunction.implementAsync(\n  async (input) => input.trim().length\n);\n \ncomputeTrimmedLengthAsync(\"sandwich\"); // => Promise<8>\nCustom\n\nYou can create a Zod schema for any TypeScript type by using z.custom(). This is useful for creating schemas for types that are not supported by Zod out of the box, such as template string literals.\n\nconst px = z.custom<`${number}px`>((val) => {\n  return typeof val === \"string\" ? /^\\d+px$/.test(val) : false;\n});\n \ntype px = z.infer<typeof px>; // `${number}px`\n \npx.parse(\"42px\"); // \"42px\"\npx.parse(\"42vw\"); // throws;\n\nIf you don't provide a validation function, Zod will allow any value. This can be dangerous!\n\nz.custom<{ arg: string }>(); // performs no validation\n\nYou can customize the error message and other options by passing a second argument. This parameter works the same way as the params parameter of .refine.\n\nz.custom<...>((val) => ..., \"custom error message\");\n\nBasic usage\n\nBasic usage guide covering schema definition, parsing data, error handling, and type inference\n\nCustomizing errors\n\nGuide to customizing validation error messages and error handling patterns"
  },
  {
    "title": "Customizing errors | Zod",
    "url": "https://zod.dev/error-customization",
    "html": "Customizing errors\nCopy markdown\nEdit this page\n\nIn Zod, validation errors are surfaced as instances of the z.core.$ZodError class.\n\nThe ZodError class in the zod package is a subclass that implements some additional convenience methods.\n\nInstances of $ZodError contain an .issues array. Each issue contains a human-readable message and additional structured metadata about the issue.\n\nZod\nZod Mini\nimport * as z from \"zod\";\n \nconst result = z.string().safeParse(12); // { success: false, error: ZodError }\nresult.error.issues;\n// [\n//   {\n//     expected: 'string',\n//     code: 'invalid_type',\n//     path: [],\n//     message: 'Invalid input: expected string, received number'\n//   }\n// ]\n\nEvery issue contains a message property with a human-readable error message. Error messages can be customized in a number of ways.\n\nThe error param\n\nVirtually every Zod API accepts an optional error message.\n\nz.string(\"Not a string!\");\n\nThis custom error will show up as the message property of any validation issues that originate from this schema.\n\nz.string(\"Not a string!\").parse(12);\n// ❌ throws ZodError {\n//   issues: [\n//     {\n//       expected: 'string',\n//       code: 'invalid_type',\n//       path: [],\n//       message: 'Not a string!'   <-- 👀 custom error message\n//     }\n//   ]\n// }\n\nAll z functions and schema methods accept custom errors.\n\nZod\nZod Mini\nz.string(\"Bad!\");\nz.string().min(5, \"Too short!\");\nz.uuid(\"Bad UUID!\");\nz.iso.date(\"Bad date!\");\nz.array(z.string(), \"Not an array!\");\nz.array(z.string()).min(5, \"Too few items!\");\nz.set(z.string(), \"Bad set!\");\n\nIf you prefer, you can pass a params object with an error parameter instead.\n\nZod\nZod Mini\nz.string({ error: \"Bad!\" });\nz.string().min(5, { error: \"Too short!\" });\nz.uuid({ error: \"Bad UUID!\" });\nz.iso.date({ error: \"Bad date!\" });\nz.array(z.string(), { error: \"Bad array!\" });\nz.array(z.string()).min(5, { error: \"Too few items!\" });\nz.set(z.string(), { error: \"Bad set!\" });\n\nThe error param optionally accepts a function. An error customization function is known as an error map in Zod terminology. The error map will run at parse time if a validation error occurs.\n\nz.string({ error: ()=>`[${Date.now()}]: Validation failure.` });\n\nNote — In Zod v3, there were separate params for message (a string) and errorMap (a function). These have been unified in Zod 4 as error.\n\nThe error map receives a context object you can use to customize the error message based on the validation issue.\n\nz.string({\n  error: (iss) => iss.input === undefined ? \"Field is required.\" : \"Invalid input.\"\n});\n\nFor advanced cases, the iss object provides additional information you can use to customize the error.\n\nz.string({\n  error: (iss) => {\n    iss.code; // the issue code\n    iss.input; // the input data\n    iss.inst; // the schema/check that originated this issue\n    iss.path; // the path of the error\n  },\n});\n\nDepending on the API you are using, there may be additional properties available. Use TypeScript's autocomplete to explore the available properties.\n\nz.string().min(5, {\n  error: (iss) => {\n    // ...the same as above\n    iss.minimum; // the minimum value\n    iss.inclusive; // whether the minimum is inclusive\n    return `Password must have ${iss.minimum} characters or more`;\n  },\n});\n\nReturn undefined to avoid customizing the error message and fall back to the default message. (More specifically, Zod will yield control to the next error map in the precedence chain.) This is useful for selectively customizing certain error messages but not others.\n\nz.int64({\n  error: (issue) => {\n    // override too_big error message\n    if (issue.code === \"too_big\") {\n      return { message: `Value must be <${issue.maximum}` };\n    }\n \n    //  defer to default\n    return undefined;\n  },\n});\nPer-parse error customization\n\nTo customize errors on a per-parse basis, pass an error map into the parse method:\n\nconst schema = z.string();\n \nschema.parse(12, {\n  error: iss => \"per-parse custom error\"\n});\n\nThis has lower precedence than any schema-level custom messages.\n\nconst schema = z.string({ error: \"highest priority\" });\nconst result = schema.safeParse(12, {\n  error: (iss) => \"lower priority\",\n});\n \nresult.error.issues;\n// [{ message: \"highest priority\", ... }]\n\nThe iss object is a discriminated union of all possible issue types. Use the code property to discriminate between them.\n\nFor a breakdown of all Zod issue codes, see the zod/v4/core documentation.\n\nconst result = schema.safeParse(12, {\n  error: (iss) => {\n    if (iss.code === \"invalid_type\") {\n      return `invalid type, expected ${iss.expected}`;\n    }\n    if (iss.code === \"too_small\") {\n      return `minimum is ${iss.minimum}`;\n    }\n    // ...\n  }\n});\nInclude input in issues\n\nBy default, Zod does not include input data in issues. This is to prevent unintentional logging of potentially sensitive input data. To include the input data in each issue, use the reportInput flag:\n\nz.string().parse(12, {\n  reportInput: true\n})\n \n// ZodError: [\n//   {\n//     \"expected\": \"string\",\n//     \"code\": \"invalid_type\",\n//     \"input\": 12, // 👀\n//     \"path\": [],\n//     \"message\": \"Invalid input: expected string, received number\"\n//   }\n// ]\nGlobal error customization\n\nTo specify a global error map, use z.config() to set Zod's customError configuration setting:\n\nz.config({\n  customError: (iss) => {\n    return \"globally modified error\";\n  },\n});\n\nGlobal error messages have lower precedence than schema-level or per-parse error messages.\n\nThe iss object is a discriminated union of all possible issue types. Use the code property to discriminate between them.\n\nFor a breakdown of all Zod issue codes, see the zod/v4/core documentation.\n\nconst result = schema.safeParse(12, {\n  error: (iss) => {\n    if (iss.code === \"invalid_type\") {\n      return `invalid type, expected ${iss.expected}`;\n    }\n    if (iss.code === \"too_small\") {\n      return `minimum is ${iss.minimum}`;\n    }\n    // ...\n  }\n})\nInternationalization\n\nTo support internationalization of error message, Zod provides several built-in locales. These are exported from the zod/v4/core package.\n\nNote — The regular zod library automatically loads the en locale automatically. Zod Mini does not load any locale by default; instead all error messages default to Invalid input.\n\nZod\nZod Mini\nimport * as z from \"zod\";\nimport { en } from \"zod/locales\"\n \nz.config(en());\n\nTo lazily load a locale, consider dynamic imports:\n\nimport * as z from \"zod\";\n \nasync function loadLocale(locale: string) {\n  const { default: locale } = await import(`zod/v4/locales/${locale}.js`);\n  z.config(locale());\n};\n \nawait loadLocale(\"fr\");\n\nFor convenience, all locales are exported as z.locales from \"zod\". In some bundlers, this may not be tree-shakable.\n\nZod\nZod Mini\nimport * as z from \"zod\";\n \nz.config(z.locales.en());\nLocales\n\nThe following locales are available:\n\nar — Arabic\naz — Azerbaijani\nbe — Belarusian\nbg — Bulgarian\nca — Catalan\ncs — Czech\nda — Danish\nde — German\nen — English\neo — Esperanto\nes — Spanish\nfa — Farsi\nfi — Finnish\nfr — French\nfrCA — Canadian French\nhe — Hebrew\nhu — Hungarian\nid — Indonesian\nis — Icelandic\nit — Italian\nja — Japanese\nka — Georgian\nkm — Khmer\nko — Korean\nlt — Lithuanian\nmk — Macedonian\nms — Malay\nnl — Dutch\nno — Norwegian\nota — Türkî\nps — Pashto\npl — Polish\npt — Portuguese\nru — Russian\nsl — Slovenian\nsv — Swedish\nta — Tamil\nth — Thai\ntr — Türkçe\nuk — Ukrainian\nur — Urdu\nvi — Tiếng Việt\nzhCN — Simplified Chinese\nzhTW — Traditional Chinese\nyo — Yorùbá\nError precedence\n\nBelow is a quick reference for determining error precedence: if multiple error customizations have been defined, which one takes priority? From highest to lowest priority:\n\nSchema-level error — Any error message \"hard coded\" into a schema definition.\nz.string(\"Not a string!\");\nPer-parse error — A custom error map passed into the .parse() method.\nz.string().parse(12, {\n  error: (iss) => \"My custom error\"\n});\nGlobal error map — A custom error map passed into z.config().\nz.config({\n  customError: (iss) => \"My custom error\"\n});\nLocale error map — A custom error map passed into z.config().\nz.config(z.locales.en());\n\nDefining schemas\n\nComplete API reference for all Zod schema types, methods, and validation features\n\nFormatting errors\n\nUtilities for formatting and displaying Zod errors"
  },
  {
    "title": "Formatting errors | Zod",
    "url": "https://zod.dev/error-formatting",
    "html": "Formatting errors\nCopy markdown\nEdit this page\n\nZod emphasizes completeness and correctness in its error reporting. In many cases, it's helpful to convert the $ZodError to a more useful format. Zod provides some utilities for this.\n\nConsider this simple object schema.\n\nimport * as z from \"zod\";\n \nconst schema = z.strictObject({\n  username: z.string(),\n  favoriteNumbers: z.array(z.number()),\n});\n\nAttempting to parse this invalid data results in an error containing three issues.\n\nconst result = schema.safeParse({\n  username: 1234,\n  favoriteNumbers: [1234, \"4567\"],\n  extraKey: 1234,\n});\n \nresult.error!.issues;\n[\n  {\n    expected: 'string',\n    code: 'invalid_type',\n    path: [ 'username' ],\n    message: 'Invalid input: expected string, received number'\n  },\n  {\n    expected: 'number',\n    code: 'invalid_type',\n    path: [ 'favoriteNumbers', 1 ],\n    message: 'Invalid input: expected number, received string'\n  },\n  {\n    code: 'unrecognized_keys',\n    keys: [ 'extraKey' ],\n    path: [],\n    message: 'Unrecognized key: \"extraKey\"'\n  }\n];\nz.treeifyError()\n\nTo convert (\"treeify\") this error into a nested object, use z.treeifyError().\n\nconst tree = z.treeifyError(result.error);\n \n// =>\n{\n  errors: [ 'Unrecognized key: \"extraKey\"' ],\n  properties: {\n    username: { errors: [ 'Invalid input: expected string, received number' ] },\n    favoriteNumbers: {\n      errors: [],\n      items: [\n        undefined,\n        {\n          errors: [ 'Invalid input: expected number, received string' ]\n        }\n      ]\n    }\n  }\n}\n\nThe result is a nested structure that mirrors the schema itself. You can easily access the errors that occurred at a particular path. The errors field contains the error messages at a given path, and the special properties properties and items let you traverse deeper into the tree.\n\ntree.properties?.username?.errors;\n// => [\"Invalid input: expected string, received number\"]\n \ntree.properties?.favoriteNumbers?.items?.[1]?.errors;\n// => [\"Invalid input: expected number, received string\"];\n\nBe sure to use optional chaining (?.) to avoid errors when accessing nested properties.\n\nz.prettifyError()\n\nThe z.prettifyError() provides a human-readable string representation of the error.\n\nconst pretty = z.prettifyError(result.error);\n\nThis returns the following string:\n\n✖ Unrecognized key: \"extraKey\"\n✖ Invalid input: expected string, received number\n  → at username\n✖ Invalid input: expected number, received string\n  → at favoriteNumbers[1]\nz.formatError()\n\nThis has been deprecated in favor of z.treeifyError().\n\nShow docs\nz.flattenError()\n\nWhile z.treeifyError() is useful for traversing a potentially complex nested structure, the majority of schemas are flat—just one level deep. In this case, use z.flattenError() to retrieve a clean, shallow error object.\n\nconst flattened = z.flattenError(result.error);\n// { errors: string[], properties: { [key: string]: string[] } }\n \n{\n  formErrors: [ 'Unrecognized key: \"extraKey\"' ],\n  fieldErrors: {\n    username: [ 'Invalid input: expected string, received number' ],\n    favoriteNumbers: [ 'Invalid input: expected number, received string' ]\n  }\n}\n\nThe formErrors array contains any top-level errors (where path is []). The fieldErrors object provides an array of errors for each field in the schema.\n\nflattened.fieldErrors.username; // => [ 'Invalid input: expected string, received number' ]\nflattened.fieldErrors.favoriteNumbers; // => [ 'Invalid input: expected number, received string' ]\n\nCustomizing errors\n\nGuide to customizing validation error messages and error handling patterns\n\nMetadata and registries\n\nAttaching and manipulatinvg metadata on Zod schemas"
  },
  {
    "title": "Metadata and registries | Zod",
    "url": "https://zod.dev/metadata",
    "html": "Metadata and registries\nCopy markdown\nEdit this page\n\nIt's often useful to associate a schema with some additional metadata for documentation, code generation, AI structured outputs, form validation, and other purposes.\n\nRegistries\n\nMetadata in Zod is handled via registries. Registries are collections of schemas, each associated with some strongly-typed metadata. To create a simple registry:\n\nimport * as z from \"zod\";\n \nconst myRegistry = z.registry<{ description: string }>();\n\nTo register, lookup, and remove schemas from this registry:\n\nconst mySchema = z.string();\n \nmyRegistry.add(mySchema, { description: \"A cool schema!\"});\nmyRegistry.has(mySchema); // => true\nmyRegistry.get(mySchema); // => { description: \"A cool schema!\" }\nmyRegistry.remove(mySchema);\nmyRegistry.clear(); // wipe registry\n\nTypeScript enforces that the metadata for each schema matches the registry's metadata type.\n\nmyRegistry.add(mySchema, { description: \"A cool schema!\" }); // ✅\nmyRegistry.add(mySchema, { description: 123 }); // ❌\n\nSpecial handling for id — Zod registries treat the id property specially. An Error will be thrown if multiple schemas are registered with the same id value. This is true for all registries, including the global registry.\n\n.register()\n\nNote — This method is special in that it does not return a new schema; instead, it returns the original schema. No other Zod method does this! That includes .meta() and .describe() (documented below) which return a new instance.\n\nSchemas provide a .register() method to more conveniently add it to a registry.\n\nconst mySchema = z.string();\n \nmySchema.register(myRegistry, { description: \"A cool schema!\" });\n// => mySchema\n\nThis lets you define metadata \"inline\" in your schemas.\n\nconst mySchema = z.object({\n  name: z.string().register(myRegistry, { description: \"The user's name\" }),\n  age: z.number().register(myRegistry, { description: \"The user's age\" }),\n})\n\nIf a registry is defined without a metadata type, you can use it as a generic \"collection\", no metadata required.\n\nconst myRegistry = z.registry();\n \nmyRegistry.add(z.string());\nmyRegistry.add(z.number());\nMetadata\nz.globalRegistry\n\nFor convenience, Zod provides a global registry (z.globalRegistry) that can be used to store metadata for JSON Schema generation or other purposes. It accepts the following metadata:\n\nexport interface GlobalMeta {\n  id?: string ;\n  title?: string ;\n  description?: string;\n  deprecated?: boolean;\n  [k: string]: unknown;\n}\n\nTo register some metadata in z.globalRegistry for a schema:\n\nimport * as z from \"zod\";\n \nconst emailSchema = z.email().register(z.globalRegistry, { \n  id: \"email_address\",\n  title: \"Email address\",\n  description: \"Your email address\",\n  examples: [\"first.last@example.com\"]\n});\n\nTo globally augment the GlobalMeta interface, use declaration merging. Add the following anywhere in your codebase. Creating a zod.d.ts file in your project root is a common convention.\n\ndeclare module \"zod\" {\n  interface GlobalMeta {\n    // add new fields here\n    examples?: unknown[];\n  }\n}\n.meta()\n\nFor a more convenient approach, use the .meta() method to register a schema in z.globalRegistry.\n\nZod\nZod Mini\nconst emailSchema = z.email().meta({ \n  id: \"email_address\",\n  title: \"Email address\",\n  description: \"Please enter a valid email address\",\n});\n\nCalling .meta() without an argument will retrieve the metadata for a schema.\n\nemailSchema.meta();\n// => { id: \"email_address\", title: \"Email address\", ... }\n\nMetadata is associated with a specific schema instance. This is important to keep in mind, especially since Zod methods are immutable—they always return a new instance.\n\nconst A = z.string().meta({ description: \"A cool string\" });\nA.meta(); // => { description: \"A cool string\" }\n \nconst B = A.refine(_ => true);\nB.meta(); // => undefined\n.describe()\n\nThe .describe() method still exists for compatibility with Zod 3, but .meta() is now the recommended approach.\n\nThe .describe() method is a shorthand for registering a schema in z.globalRegistry with just a description field.\n\nZod\nZod Mini\nconst emailSchema = z.email();\nemailSchema.describe(\"An email address\");\n \n// equivalent to\nemailSchema.meta({ description: \"An email address\" });\nCustom registries\n\nYou've already seen a simple example of a custom registry:\n\nimport * as z from \"zod\";\n \nconst myRegistry = z.registry<{ description: string };>();\n\nLet's look at some more advanced patterns.\n\nReferencing inferred types\n\nIt's often valuable for the metadata type to reference the inferred type of a schema. For instance, you may want an examples field to contain examples of the schema's output.\n\nimport * as z from \"zod\";\n \ntype MyMeta = { examples: z.$output[] };\nconst myRegistry = z.registry<MyMeta>();\n \nmyRegistry.add(z.string(), { examples: [\"hello\", \"world\"] });\nmyRegistry.add(z.number(), { examples: [1, 2, 3] });\n\nThe special symbol z.$output is a reference to the schemas inferred output type (z.infer<typeof schema>). Similarly you can use z.$input to reference the input type.\n\nConstraining schema types\n\nPass a second generic to z.registry() to constrain the schema types that can be added to a registry. This registry only accepts string schemas.\n\nimport * as z from \"zod\";\n \nconst myRegistry = z.registry<{ description: string }, z.ZodString>();\n \nmyRegistry.add(z.string(), { description: \"A number\" }); // ✅\nmyRegistry.add(z.number(), { description: \"A number\" }); // ❌ \n//             ^ 'ZodNumber' is not assignable to parameter of type 'ZodString' \n\nFormatting errors\n\nUtilities for formatting and displaying Zod errors\n\nJSON Schema\n\nHow to convert Zod schemas to JSON Schema"
  },
  {
    "title": "Codecs | Zod",
    "url": "https://zod.dev/codecs",
    "html": "Codecs\nCopy markdown\nEdit this page\n\n✨ New — Introduced in zod@4.1\n\nAll Zod schemas can process inputs in both the forward and backward direction:\n\nForward: Input to Output\n.parse()\n.decode()\nBackward: Output to Input\n.encode()\n\nIn most cases, this is a distinction without a difference. The input and output types are identical, so there's no difference between \"forward\" and \"backward\".\n\nZod\nZod Mini\nconst schema = z.string();\n \ntype Input = z.input<typeof schema>;    // string\ntype Output = z.output<typeof schema>;  // string\n \nschema.parse(\"asdf\");   // => \"asdf\"\nschema.decode(\"asdf\");  // => \"asdf\"\nschema.encode(\"asdf\");  // => \"asdf\"\n\nHowever, some schema types cause the input and output types to diverge, notably z.codec(). Codecs are a special type of schema that defines a bi-directional transformation between two other schemas.\n\nconst stringToDate = z.codec(\n  z.iso.datetime(),  // input schema: ISO date string\n  z.date(),          // output schema: Date object\n  {\n    decode: (isoString) => new Date(isoString), // ISO string → Date\n    encode: (date) => date.toISOString(),       // Date → ISO string\n  }\n);\n\nIn these cases, z.decode() and z.encode() behave quite differently.\n\nZod\nZod Mini\nstringToDate.decode(\"2024-01-15T10:30:00.000Z\")\n// => Date\n \nstringToDate.encode(new Date(\"2024-01-15T10:30:00.000Z\"))\n// => string\n\nNote —There's nothing special about the directions or terminology here. Instead of encoding with an A -> B codec, you could instead decode with a B -> A codec. The use of the terms \"decode\" and \"encode\" is just a convention.\n\nThis is particularly useful when parsing data at a network boundary. You can share a single Zod schema between your client and server, then use this single schema to convert between a network-friendly format (say, JSON) and a richer JavaScript representation.\n\nComposability\n\nNote — You can use z.encode() and z.decode() with any schema. It doesn't have to be a ZodCodec.\n\nCodecs are a schema like any other. You can nest them inside objects, arrays, pipes, etc. There are no rules on where you can use them!\n\nconst payloadSchema = z.object({ \n  startDate: stringToDate \n});\n \npayloadSchema.decode({\n  startDate: \"2024-01-15T10:30:00.000Z\"\n}); // => { startDate: Date }\nType-safe inputs\n\nWhile .parse() and .decode() behave identically at runtime, they have different type signatures. The .parse() method accepts unknown as input, and returns a value that matches the schema's inferred output type. By constrast, the z.decode() and z.encode() functions have strongly-typed inputs.\n\nstringToDate.parse(12345); \n// no complaints from TypeScript (fails at runtime)\n \nstringToDate.decode(12345); \n// ❌ TypeScript error: Argument of type 'number' is not assignable to parameter of type 'string'.\n \nstringToDate.encode(12345); \n// ❌ TypeScript error: Argument of type 'number' is not assignable to parameter of type 'Date'.\n\nWhy the difference? Encoding and decoding imply transformation. In many cases, the inputs to these methods Here's a diagram demonstrating the differences between the type signatures for parse(), decode(), and encode().\n\nAsync and safe variants\n\nAs with .transform() and .refine(), codecs support async transforms.\n\nconst asyncCodec = z.codec(z.string(), z.number(), {\n  decode: async (str) => Number(str),\n  encode: async (num) => num.toString(),\n});\n\nAs with regular parse(), there are \"safe\" and \"async\" variants of decode() and encode().\n\nstringToDate.decode(\"2024-01-15T10:30:00.000Z\"); \n// => Date\n \nstringToDate.decodeAsync(\"2024-01-15T10:30:00.000Z\"); \n// => Promise<Date>\n \nstringToDate.decodeSafe(\"2024-01-15T10:30:00.000Z\"); \n// => { success: true, data: Date } | { success: false, error: ZodError }\n \nstringToDate.decodeSafeAsync(\"2024-01-15T10:30:00.000Z\"); \n// => Promise<{ success: true, data: Date } | { success: false, error: ZodError }>\nHow encoding works\n\nThere are some subtleties to how certain Zod schemas \"reverse\" their parse behavior.\n\nCodecs\n\nThis one is fairly self-explanatory. Codecs encapsulate a bi-directional transformation between two types. During z.decode(), the decode transform is executed. During z.encode(), the encode transform is executed.\n\nconst stringToDate = z.codec(\n  z.iso.datetime(),  // input schema: ISO date string\n  z.date(),          // output schema: Date object\n  {\n    decode: (isoString) => new Date(isoString), // ISO string → Date\n    encode: (date) => date.toISOString(),       // Date → ISO string\n  }\n);\n \nstringToDate.decode(\"2024-01-15T10:30:00.000Z\"); \n// => Date\n \nstringToDate.encode(new Date(\"2024-01-15\")); \n// => string\nPipes\n\nFun fact — Codecs are actually implemented internally as subclass of pipes that have been augmented with \"interstitial\" transform logic.\n\nDuring regular decoding, a ZodPipe<A, B> schema will first parse the data with A, then pass it into B. As you might expect, during encoding, the data is first encoded with B, then passed into A.\n\nRefinements\n\nAll checks (.refine(), .min(), .max(), etc.) are still executed in both directions.\n\nconst schema = stringToDate.refine((date) => date.getFullYear() >= 2000, \"Must be this millenium\");\n \nschema.encode(new Date(\"2000-01-01\"));\n// => Date\n \nschema.encode(new Date(\"1999-01-01\"));\n// => ❌ ZodError: [\n//   {\n//     \"code\": \"custom\",\n//     \"path\": [],\n//     \"message\": \"Must be this millenium\"\n//   }\n// ]\n\nTo avoid unexpected errors in your custom .refine() logic, Zod performs two \"passes\" during z.encode(). The first pass ensures the input type conforms to the expected type (no invalid_type errors). If that passes, Zod performs the second pass which executes the refinement logic.\n\nThis approach also supports \"mutating transforms\" like z.string().trim() or z.string().toLowerCase():\n\nconst schema = z.string().trim();\n \nschema.decode(\"  hello  \");\n// => \"hello\"\n \nschema.encode(\"  hello  \");\n// => \"hello\"\nDefaults and prefaults\n\nDefaults and prefaults are only applied in the \"forward\" direction.\n\nconst stringWithDefault = z.string().default(\"hello\");\n \nstringWithDefault.decode(undefined); \n// => \"hello\"\n \nstringWithDefault.encode(undefined); \n// => ZodError: Expected string, received undefined\n\nWhen you attach a default value to a schema, the input becomes optional (| undefined) but the output does not. As such, undefined is not a valid input to z.encode() and defaults/prefaults will not be applied.\n\nCatch\n\nSimilarly, .catch() is only applied in the \"forward\" direction.\n\nconst stringWithCatch = z.string().catch(\"hello\");\n \nstringWithCatch.decode(1234); \n// => \"hello\"\n \nstringWithCatch.encode(1234); \n// => ZodError: Expected string, received number\nStringbool\n\nNote — Stringbool pre-dates the introduction of codecs in Zod. It has since been internally re-implemented as a codec.\n\nThe z.stringbool() API converts string values (\"true\", \"false\", \"yes\", \"no\", etc.) into boolean. By default, it will convert true to \"true\" and false to \"false\" during z.encode()..\n\nconst stringbool = z.stringbool();\n \nstringbool.decode(\"true\");  // => true\nstringbool.decode(\"false\"); // => false\n \nstringbool.encode(true);    // => \"true\"\nstringbool.encode(false);   // => \"false\"\n\nIf you specify a custom set of truthy and falsy values, the first element in the array will be used instead.\n\nconst stringbool = z.stringbool({ truthy: [\"yes\", \"y\"], falsy: [\"no\", \"n\"] });\n \nstringbool.encode(true);    // => \"yes\"\nstringbool.encode(false);   // => \"no\"\nTransforms\n\n⚠️ — The .transform() API implements a unidirectional transformation. If any .transform() exists anywhere in your schema, attempting a z.encode() operation will throw a runtime error (not a ZodError).\n\nconst schema = z.string().transform(val => val.length);\n \nschema.encode(1234); \n// ❌ Error: Encountered unidirectional transform during encode: ZodTransform\nUseful codecs\n\nBelow are implementations for a bunch of commonly-needed codecs. For the sake of customizability, these are not included as first-class APIs in Zod itself. Instead, you should copy/paste them into your project and modify them as needed.\n\nNote — All of these codec implementations have been tested for correctness.\n\nstringToNumber\n\nConverts string representations of numbers to JavaScript number type using parseFloat().\n\nconst stringToNumber = z.codec(z.string().regex(z.regexes.number), z.number(), {\n  decode: (str) => Number.parseFloat(str),\n  encode: (num) => num.toString(),\n});\n \nstringToNumber.decode(\"42.5\");  // => 42.5\nstringToNumber.encode(42.5);    // => \"42.5\"\nstringToInt\n\nConverts string representations of integers to JavaScript number type using parseInt().\n\nconst stringToInt = z.codec(z.string().regex(z.regexes.integer), z.int(), {\n  decode: (str) => Number.parseInt(str, 10),\n  encode: (num) => num.toString(),\n});\n \nstringToInt.decode(\"42\");  // => 42\nstringToInt.encode(42);    // => \"42\"\nstringToBigInt\n\nConverts string representations to JavaScript bigint type.\n\nconst stringToBigInt = z.codec(z.string(), z.bigint(), {\n  decode: (str) => BigInt(str),\n  encode: (bigint) => bigint.toString(),\n});\n \nstringToBigInt.decode(\"12345\");  // => 12345n\nstringToBigInt.encode(12345n);   // => \"12345\"\nnumberToBigInt\n\nConverts JavaScript number to bigint type.\n\nconst numberToBigInt = z.codec(z.int(), z.bigint(), {\n  decode: (num) => BigInt(num),\n  encode: (bigint) => Number(bigint),\n});\n \nnumberToBigInt.decode(42);   // => 42n\nnumberToBigInt.encode(42n);  // => 42\nisoDatetimeToDate\n\nConverts ISO datetime strings to JavaScript Date objects.\n\nconst isoDatetimeToDate = z.codec(z.iso.datetime(), z.date(), {\n  decode: (isoString) => new Date(isoString),\n  encode: (date) => date.toISOString(),\n});\n \nisoDatetimeToDate.decode(\"2024-01-15T10:30:00.000Z\");  // => Date object\nisoDatetimeToDate.encode(new Date(\"2024-01-15\"));       // => \"2024-01-15T00:00:00.000Z\"\nepochSecondsToDate\n\nConverts Unix timestamps (seconds since epoch) to JavaScript Date objects.\n\nconst epochSecondsToDate = z.codec(z.int().min(0), z.date(), {\n  decode: (seconds) => new Date(seconds * 1000),\n  encode: (date) => Math.floor(date.getTime() / 1000),\n});\n \nepochSecondsToDate.decode(1705314600);  // => Date object\nepochSecondsToDate.encode(new Date());  // => Unix timestamp in seconds\nepochMillisToDate\n\nConverts Unix timestamps (milliseconds since epoch) to JavaScript Date objects.\n\nconst epochMillisToDate = z.codec(z.int().min(0), z.date(), {\n  decode: (millis) => new Date(millis),\n  encode: (date) => date.getTime(),\n});\n \nepochMillisToDate.decode(1705314600000);  // => Date object\nepochMillisToDate.encode(new Date());     // => Unix timestamp in milliseconds\njson(schema)\n\nParses JSON strings into structured data and serializes back to JSON. This generic function accepts an output schema to validate the parsed JSON data.\n\nconst jsonCodec = <T extends z.core.$ZodType>(schema: T) =>\n  z.codec(z.string(), schema, {\n    decode: (jsonString, ctx) => {\n      try {\n        return JSON.parse(jsonString);\n      } catch (err: any) {\n        ctx.issues.push({\n          code: \"invalid_format\",\n          format: \"json\",\n          input: jsonString,\n          message: err.message,\n        });\n        return z.NEVER;\n      }\n    },\n    encode: (value) => JSON.stringify(value),\n  });\n\nUsage example with a specific schema:\n\nconst jsonToObject = jsonCodec(z.object({ name: z.string(), age: z.number() }));\n \njsonToObject.decode('{\"name\":\"Alice\",\"age\":30}');  \n// => { name: \"Alice\", age: 30 }\n \njsonToObject.encode({ name: \"Bob\", age: 25 });     \n// => '{\"name\":\"Bob\",\"age\":25}'\n \njsonToObject.decode('~~invalid~~'); \n// ZodError: [\n//   {\n//     \"code\": \"invalid_format\",\n//     \"format\": \"json\",\n//     \"path\": [],\n//     \"message\": \"Unexpected token '~', \\\"~~invalid~~\\\" is not valid JSON\"\n//   }\n// ]\nutf8ToBytes\n\nConverts UTF-8 strings to Uint8Array byte arrays.\n\nconst utf8ToBytes = z.codec(z.string(), z.instanceof(Uint8Array), {\n  decode: (str) => new TextEncoder().encode(str),\n  encode: (bytes) => new TextDecoder().decode(bytes),\n});\n \nutf8ToBytes.decode(\"Hello, 世界!\");  // => Uint8Array\nutf8ToBytes.encode(bytes);          // => \"Hello, 世界!\"\nbytesToUtf8\n\nConverts Uint8Array byte arrays to UTF-8 strings.\n\nconst bytesToUtf8 = z.codec(z.instanceof(Uint8Array), z.string(), {\n  decode: (bytes) => new TextDecoder().decode(bytes),\n  encode: (str) => new TextEncoder().encode(str),\n});\n \nbytesToUtf8.decode(bytes);          // => \"Hello, 世界!\"\nbytesToUtf8.encode(\"Hello, 世界!\");  // => Uint8Array\nbase64ToBytes\n\nConverts base64 strings to Uint8Array byte arrays and vice versa.\n\nconst base64ToBytes = z.codec(z.base64(), z.instanceof(Uint8Array), {\n  decode: (base64String) => z.util.base64ToUint8Array(base64String),\n  encode: (bytes) => z.util.uint8ArrayToBase64(bytes),\n});\n \nbase64ToBytes.decode(\"SGVsbG8=\");  // => Uint8Array([72, 101, 108, 108, 111])\nbase64ToBytes.encode(bytes);       // => \"SGVsbG8=\"\nbase64urlToBytes\n\nConverts base64url strings (URL-safe base64) to Uint8Array byte arrays.\n\nconst base64urlToBytes = z.codec(z.base64url(), z.instanceof(Uint8Array), {\n  decode: (base64urlString) => z.util.base64urlToUint8Array(base64urlString),\n  encode: (bytes) => z.util.uint8ArrayToBase64url(bytes),\n});\n \nbase64urlToBytes.decode(\"SGVsbG8\");  // => Uint8Array([72, 101, 108, 108, 111])\nbase64urlToBytes.encode(bytes);      // => \"SGVsbG8\"\nhexToBytes\n\nConverts hexadecimal strings to Uint8Array byte arrays and vice versa.\n\nconst hexToBytes = z.codec(z.hex(), z.instanceof(Uint8Array), {\n  decode: (hexString) => z.util.hexToUint8Array(hexString),\n  encode: (bytes) => z.util.uint8ArrayToHex(bytes),\n});\n \nhexToBytes.decode(\"48656c6c6f\");     // => Uint8Array([72, 101, 108, 108, 111])\nhexToBytes.encode(bytes);            // => \"48656c6c6f\"\nstringToURL\n\nConverts URL strings to JavaScript URL objects.\n\nconst stringToURL = z.codec(z.url(), z.instanceof(URL), {\n  decode: (urlString) => new URL(urlString),\n  encode: (url) => url.href,\n});\n \nstringToURL.decode(\"https://example.com/path\");  // => URL object\nstringToURL.encode(new URL(\"https://example.com\"));  // => \"https://example.com/\"\nstringToHttpURL\n\nConverts HTTP/HTTPS URL strings to JavaScript URL objects.\n\nconst stringToHttpURL = z.codec(z.httpUrl(), z.instanceof(URL), {\n  decode: (urlString) => new URL(urlString),\n  encode: (url) => url.href,\n});\n \nstringToHttpURL.decode(\"https://api.example.com/v1\");  // => URL object\nstringToHttpURL.encode(url);                           // => \"https://api.example.com/v1\"\nuriComponent\n\nEncodes and decodes URI components using encodeURIComponent() and decodeURIComponent().\n\nconst uriComponent = z.codec(z.string(), z.string(), {\n  decode: (encodedString) => decodeURIComponent(encodedString),\n  encode: (decodedString) => encodeURIComponent(decodedString),\n});\n \nuriComponent.decode(\"Hello%20World%21\");  // => \"Hello World!\"\nuriComponent.encode(\"Hello World!\");      // => \"Hello%20World!\"\n\nJSON Schema\n\nHow to convert Zod schemas to JSON Schema\n\nEcosystem\n\nOverview of the Zod ecosystem including integrations, tools, and community resources"
  },
  {
    "title": "JSON Schema | Zod",
    "url": "https://zod.dev/json-schema",
    "html": "JSON Schema\nCopy markdown\nEdit this page\n💎\n\nNew — Zod 4 introduces a new feature: native JSON Schema conversion. JSON Schema is a standard for describing the structure of JSON (with JSON). It's widely used in OpenAPI definitions and defining structured outputs for AI.\n\nTo convert a Zod schema to JSON Schema, use the z.toJSONSchema() function.\n\nimport * as z from \"zod\";\n \nconst schema = z.object({\n  name: z.string(),\n  age: z.number(),\n});\n \nz.toJSONSchema(schema)\n// => {\n//   type: 'object',\n//   properties: { name: { type: 'string' }, age: { type: 'number' } },\n//   required: [ 'name', 'age' ],\n//   additionalProperties: false,\n// }\n\nAll schema & checks are converted to their closest JSON Schema equivalent. Some types have no analog and cannot be reasonably represented. See the unrepresentable section below for more information on handling these cases.\n\nz.bigint(); // ❌\nz.int64(); // ❌\nz.symbol(); // ❌\nz.void(); // ❌\nz.date(); // ❌\nz.map(); // ❌\nz.set(); // ❌\nz.transform(); // ❌\nz.nan(); // ❌\nz.custom(); // ❌\nString formats\n\nZod converts the following schema types to the equivalent JSON Schema format:\n\n// Supported via `format`\nz.email(); // => { type: \"string\", format: \"email\" }\nz.iso.datetime(); // => { type: \"string\", format: \"date-time\" }\nz.iso.date(); // => { type: \"string\", format: \"date\" }\nz.iso.time(); // => { type: \"string\", format: \"time\" }\nz.iso.duration(); // => { type: \"string\", format: \"duration\" }\nz.ipv4(); // => { type: \"string\", format: \"ipv4\" }\nz.ipv6(); // => { type: \"string\", format: \"ipv6\" }\nz.uuid(); // => { type: \"string\", format: \"uuid\" }\nz.guid(); // => { type: \"string\", format: \"uuid\" }\nz.url(); // => { type: \"string\", format: \"uri\" }\n\nThese schemas are supported via contentEncoding:\n\nz.base64(); // => { type: \"string\", contentEncoding: \"base64\" }\n\nAll other string formats are supported via pattern:\n\nz.base64url();\nz.cuid();\nz.emoji();\nz.nanoid();\nz.cuid2();\nz.ulid();\nz.cidrv4();\nz.cidrv6();\nNumeric types\n\nZod converts the following numeric types to JSON Schema:\n\n// number\nz.number(); // => { type: \"number\" }\nz.float32(); // => { type: \"number\", exclusiveMinimum: ..., exclusiveMaximum: ... }\nz.float64(); // => { type: \"number\", exclusiveMinimum: ..., exclusiveMaximum: ... }\n \n// integer\nz.int(); // => { type: \"integer\" }\nz.int32(); // => { type: \"integer\", exclusiveMinimum: ..., exclusiveMaximum: ... }\nObject schemas\n\nBy default, z.object() schemas contain additionalProperties: \"false\". This is an accurate representation of Zod's default behavior, as plain z.object() schema strip additional properties.\n\nimport * as z from \"zod\";\n \nconst schema = z.object({\n  name: z.string(),\n  age: z.number(),\n});\n \nz.toJSONSchema(schema)\n// => {\n//   type: 'object',\n//   properties: { name: { type: 'string' }, age: { type: 'number' } },\n//   required: [ 'name', 'age' ],\n//   additionalProperties: false,\n// }\n\nWhen converting to JSON Schema in \"input\" mode, additionalProperties is not set. See the io docs for more information.\n\nimport * as z from \"zod\";\n \nconst schema = z.object({\n  name: z.string(),\n  age: z.number(),\n});\n \nz.toJSONSchema(schema, { io: \"input\" });\n// => {\n//   type: 'object',\n//   properties: { name: { type: 'string' }, age: { type: 'number' } },\n//   required: [ 'name', 'age' ],\n// }\n\nBy contrast:\n\nz.looseObject() will never set additionalProperties: false\nz.strictObject() will always set additionalProperties: false\nFile schemas\n\nZod converts z.file() to the following OpenAPI-friendly schema:\n\nz.file();\n// => { type: \"string\", format: \"binary\", contentEncoding: \"binary\" }\n\nSize and MIME checks are also represented:\n\nz.file().min(1).max(1024 * 1024).mime(\"image/png\");\n// => {\n//   type: \"string\",\n//   format: \"binary\",\n//   contentEncoding: \"binary\",\n//   contentMediaType: \"image/png\",\n//   minLength: 1,\n//   maxLength: 1048576,\n// }\nNullability\n\nZod converts both undefined/null to { type: \"null\" } in JSON Schema.\n\nz.null(); \n// => { type: \"null\" }\n \nz.undefined(); \n// => { type: \"null\" }\n\nSimilarly, nullable is represented via a union with null::\n\nz.nullable(z.string());\n// => { oneOf: [{ type: \"string\" }, { type: \"null\" }] }\n\nOptional schemas are represented as-is, though they are decorated with an optional annotation.\n\nz.optional(z.string());\n// => { type: \"string\" }\nConfiguration\n\nA second argument can be used to customize the conversion logic.\n\nz.toJSONSchema(schema, {\n  // ...params\n})\n\nBelow is a quick reference for each supported parameter. Each one is explained in more detail below.\n\ninterface ToJSONSchemaParams {\n  /** The JSON Schema version to target.\n   * - `\"draft-2020-12\"` — Default. JSON Schema Draft 2020-12\n   * - `\"draft-7\"` — JSON Schema Draft 7\n   * - `\"draft-4\"` — JSON Schema Draft 4\n   * - `\"openapi-3.0\"` — OpenAPI 3.0 Schema Object */\n  target?: \"draft-4\" | \"draft-7\" | \"draft-2020-12\" | \"openapi-3.0\";\n \n  /** A registry used to look up metadata for each schema. \n   * Any schema with an `id` property will be extracted as a $def. */\n  metadata?: $ZodRegistry<Record<string, any>>;\n \n  /** How to handle unrepresentable types.\n   * - `\"throw\"` — Default. Unrepresentable types throw an error\n   * - `\"any\"` — Unrepresentable types become `{}` */\n  unrepresentable?: \"throw\" | \"any\";\n \n  /** How to handle cycles.\n   * - `\"ref\"` — Default. Cycles will be broken using $defs\n   * - `\"throw\"` — Cycles will throw an error if encountered */\n  cycles?: \"ref\" | \"throw\";\n \n  /* How to handle reused schemas.\n   * - `\"inline\"` — Default. Reused schemas will be inlined\n   * - `\"ref\"` — Reused schemas will be extracted as $defs */\n  reused?: \"ref\" | \"inline\";\n \n  /** A function used to convert `id` values to URIs to be used in *external* $refs.\n   *\n   * Default is `(id) => id`.\n   */\n  uri?: (id: string) => string;\n}\ntarget\n\nTo set the target JSON Schema version, use the target parameter. By default, Zod will target Draft 2020-12.\n\nz.toJSONSchema(schema, { target: \"draft-7\" });\nz.toJSONSchema(schema, { target: \"draft-2020-12\" });\nz.toJSONSchema(schema, { target: \"draft-4\" });\nz.toJSONSchema(schema, { target: \"openapi-3.0\" });\nmetadata\n\nIf you haven't already, read through the Metadata and registries page for context on storing metadata in Zod.\n\nIn Zod, metadata is stored in registries. Zod exports a global registry z.globalRegistry that can be used to store common metadata fields like id, title, description, and examples.\n\nZod\nZod Mini\nimport * as z from \"zod\";\n \n// `.meta()` is a convenience method for registering a schema in `z.globalRegistry`\nconst emailSchema = z.string().meta({ \n  title: \"Email address\",\n  description: \"Your email address\",\n});\n \nz.toJSONSchema(emailSchema);\n// => { type: \"string\", title: \"Email address\", description: \"Your email address\", ... } \n\nAll metadata fields get copied into the resulting JSON Schema.\n\nconst schema = z.string().meta({\n  whatever: 1234\n});\n \nz.toJSONSchema(schema);\n// => { type: \"string\", whatever: 1234 }\nunrepresentable\n\nThe following APIs are not representable in JSON Schema. By default, Zod will throw an error if they are encountered. It is unsound to attempt a conversion to JSON Schema; you should modify your schemas as they have no equivalent in JSON. An error will be thrown if any of these are encountered.\n\nz.bigint(); // ❌\nz.int64(); // ❌\nz.symbol(); // ❌\nz.void(); // ❌\nz.date(); // ❌\nz.map(); // ❌\nz.set(); // ❌\nz.transform(); // ❌\nz.nan(); // ❌\nz.custom(); // ❌\n\nBy default, Zod will throw an error if any of these are encountered.\n\nz.toJSONSchema(z.bigint());\n// => throws Error\n\nYou can change this behavior by setting the unrepresentable option to \"any\". This will convert any unrepresentable types to {} (the equivalent of unknown in JSON Schema).\n\nz.toJSONSchema(z.bigint(), { unrepresentable: \"any\" });\n// => {}\ncycles\n\nHow to handle cycles. If a cycle is encountered as z.toJSONSchema() traverses the schema, it will be represented using $ref.\n\nconst User = z.object({\n  name: z.string(),\n  get friend() {\n    return User;\n  },\n});\n \nz.toJSONSchema(User);\n// => {\n//   type: 'object',\n//   properties: { name: { type: 'string' }, friend: { '$ref': '#' } },\n//   required: [ 'name', 'friend' ],\n//   additionalProperties: false,\n// }\n\nIf instead you want to throw an error, set the cycles option to \"throw\".\n\nz.toJSONSchema(User, { cycles: \"throw\" });\n// => throws Error\nreused\n\nHow to handle schemas that occur multiple times in the same schema. By default, Zod will inline these schemas.\n\nconst name = z.string();\nconst User = z.object({\n  firstName: name,\n  lastName: name,\n});\n \nz.toJSONSchema(User);\n// => {\n//   type: 'object',\n//   properties: { \n//     firstName: { type: 'string' }, \n//     lastName: { type: 'string' } \n//   },\n//   required: [ 'firstName', 'lastName' ],\n//   additionalProperties: false,\n// }\n\nInstead you can set the reused option to \"ref\" to extract these schemas into $defs.\n\nz.toJSONSchema(User, { reused: \"ref\" });\n// => {\n//   type: 'object',\n//   properties: {\n//     firstName: { '$ref': '#/$defs/__schema0' },\n//     lastName: { '$ref': '#/$defs/__schema0' }\n//   },\n//   required: [ 'firstName', 'lastName' ],\n//   additionalProperties: false,\n//   '$defs': { __schema0: { type: 'string' } }\n// }\noverride\n\nTo define some custom override logic, use override. The provided callback has access to the original Zod schema and the default JSON Schema. This function should directly modify ctx.jsonSchema.\n\nconst mySchema = /* ... */\nz.toJSONSchema(mySchema, {\n  override: (ctx)=>{\n    ctx.zodSchema; // the original Zod schema\n    ctx.jsonSchema; // the default JSON Schema\n \n    // directly modify\n    ctx.jsonSchema.whatever = \"sup\";\n  }\n});\n\nNote that unrepresentable types will throw an Error before this functions is called. If you are trying to define custom behavior for an unrepresentable type, you'll need to use set the unrepresentable: \"any\" alongside override.\n\n// support z.date() as ISO datetime strings\nconst result = z.toJSONSchema(z.date(), {\n  unrepresentable: \"any\",\n  override: (ctx) => {\n    const def = ctx.zodSchema._zod.def;\n    if(def.type ===\"date\"){\n      ctx.jsonSchema.type = \"string\";\n      ctx.jsonSchema.format = \"date-time\";\n    }\n  },\n});\nio\n\nSome schema types have different input and output types, e.g. ZodPipe, ZodDefault, and coerced primitives. By default, the result of z.toJSONSchema represents the output type; use \"io\": \"input\" to extract the input type instead.\n\nconst mySchema = z.string().transform(val => val.length).pipe(z.number());\n// ZodPipe\n \nconst jsonSchema = z.toJSONSchema(mySchema); \n// => { type: \"number\" }\n \nconst jsonSchema = z.toJSONSchema(mySchema, { io: \"input\" }); \n// => { type: \"string\" }\nRegistries\n\nPassing a schema into z.toJSONSchema() will return a self-contained JSON Schema.\n\nIn other cases, you may have a set of Zod schemas you'd like to represent using multiple interlinked JSON Schemas, perhaps to write to .json files and serve from a web server.\n\nimport * as z from \"zod\";\n \nconst User = z.object({\n  name: z.string(),\n  get posts(){\n    return z.array(Post);\n  }\n});\n \nconst Post = z.object({\n  title: z.string(),\n  content: z.string(),\n  get author(){\n    return User;\n  }\n});\n \nz.globalRegistry.add(User, {id: \"User\"});\nz.globalRegistry.add(Post, {id: \"Post\"});\n\nTo achieve this, you can pass a registry into z.toJSONSchema().\n\nImportant — All schemas should have a registered id property in the registry! Any schemas without an id will be ignored.\n\nz.toJSONSchema(z.globalRegistry);\n// => {\n//   schemas: {\n//     User: {\n//       id: 'User',\n//       type: 'object',\n//       properties: {\n//         name: { type: 'string' },\n//         posts: { type: 'array', items: { '$ref': 'Post' } }\n//       },\n//       required: [ 'name', 'posts' ],\n//       additionalProperties: false,\n//     },\n//     Post: {\n//       id: 'Post',\n//       type: 'object',\n//       properties: {\n//         title: { type: 'string' },\n//         content: { type: 'string' },\n//         author: { '$ref': 'User' }\n//       },\n//       required: [ 'title', 'content', 'author' ],\n//       additionalProperties: false,\n//     }\n//   }\n// }\n\nBy default, the $ref URIs are simple relative paths like \"User\". To make these absolute URIs, use the uri option. This expects a function that converts an id to a fully-qualified URI.\n\nz.toJSONSchema(z.globalRegistry, {\n  uri: (id) => `https://example.com/${id}.json`\n});\n// => {\n//   schemas: {\n//     User: {\n//       id: 'User',\n//       type: 'object',\n//       properties: {\n//         name: { type: 'string' },\n//         posts: {\n//           type: 'array',\n//           items: { '$ref': 'https://example.com/Post.json' }\n//         }\n//       },\n//       required: [ 'name', 'posts' ],\n//       additionalProperties: false,\n//     },\n//     Post: {\n//       id: 'Post',\n//       type: 'object',\n//       properties: {\n//         title: { type: 'string' },\n//         content: { type: 'string' },\n//         author: { '$ref': 'https://example.com/User.json' }\n//       },\n//       required: [ 'title', 'content', 'author' ],\n//       additionalProperties: false,\n//     }\n//   }\n// }\n\nMetadata and registries\n\nAttaching and manipulatinvg metadata on Zod schemas\n\nCodecs\n\nBidirectional transformations with encode and decode"
  },
  {
    "title": "Zod Mini | Zod",
    "url": "https://zod.dev/packages/mini",
    "html": "Zod Mini\nCopy markdown\nEdit this page\n\nNote — The docs for Zod Mini are interleaved with the regular Zod docs via tabbed code blocks. This page is designed to explain why Zod Mini exists, when to use it, and some key differences from regular Zod.\n\nZod Mini variant was introduced with the release of Zod 4. To try it:\n\nnpm install zod@^4.0.0\n\nTo import it:\n\nimport * as z from \"zod/mini\";\n\nZod Mini implements the exact same functionality as zod, but using a functional, tree-shakable API. If you're coming from zod, this means you generally will use functions in place of methods.\n\n// regular Zod\nconst mySchema = z.string().optional().nullable();\n \n// Zod Mini\nconst mySchema = z.nullable(z.optional(z.string()));\nTree-shaking\n\nTree-shaking is a technique used by modern bundlers to remove unused code from the final bundle. It's also referred to as dead-code elimination.\n\nIn regular Zod, schemas provide a range of convenience methods to perform some common operations (e.g. .min() on string schemas). Bundlers are generally not able to remove (\"treeshake\") unused method implementations from your bundle, but they are able to remove unused top-level functions. As such, the API of Zod Mini uses more functions than methods.\n\n// regular Zod\nz.string().min(5).max(10).trim()\n \n// Zod Mini\nz.string().check(z.minLength(5), z.maxLength(10), z.trim());\n\nTo give a general idea about the bundle size reduction, consider this simple script:\n\nz.boolean().parse(true)\n\nBundling this with Zod and Zod Mini results in the following bundle sizes. Zod Mini results in a 64% reduction.\n\nPackage\tBundle size (gzip)\nZod Mini\t2.12kb\nZod\t5.91kb\n\nWith a marginally more complex schema that involves object types:\n\nconst schema = z.object({ a: z.string(), b: z.number(), c: z.boolean() });\n \nschema.parse({\n  a: \"asdf\",\n  b: 123,\n  c: true,\n});\nPackage\tBundle size (gzip)\nZod Mini\t4.0kb\nZod\t13.1kb\n\nThis gives you a sense of the bundle sizes involved. Look closely at these numbers and run your own benchmarks to determine if using Zod Mini is worth it for your use case.\n\nWhen (not) to use Zod Mini\n\nIn general you should probably use regular Zod unless you have uncommonly strict constraints around bundle size. Many developers massively overestimate the importance of bundle size to application performance. In practice, bundle size on the scale of Zod (5-10kb typically) is only a meaningful concern when optimizing front-end bundles for a user base with slow mobile network connections in rural or developing areas.\n\nLet's run through some considerations:\n\nDX\n\nThe API of Zod Mini is more verbose and less discoverable. The methods in Zod's API are much easier to discover & autocomplete through Intellisense than the top-level functions in Zod Mini. It isn't possible to quickly build a schema with chained APIs. (Speaking as the creator of Zod: I spent a lot of time designing the Zod Mini API to be as ergonomic as possible, but I still have a strong preference the standard Zod API.)\n\nBackend development\n\nIf you are using Zod on the backend, bundle size on the scale of Zod is not meaningful. This is true even in resource-constrained environments like Lambda. This post benchmarks cold start times with bundles of various sizes. Here is a subset of the results:\n\nBundle size\tLambda cold start time\n1kb\t171ms\n17kb (size of gzipped non-Mini Zod)\t171.6ms (interpolated)\n128kb\t176ms\n256kb\t182ms\n512kb\t279ms\n1mb\t557ms\n\nThe minimum cold start time for a negligible 1kb bundle is 171ms. The next bundle size tested is 128kb, which added only 5ms. When gzipped, the bundle size for the entirely of regular Zod is roughly 17kb, which would correspond to a 0.6ms increase in startup time.\n\nInternet speed\n\nGenerally, the round trip time to the server (100-200ms) will dwarf the time required to download an additional 10kb. Only on slow 3G connections (sub-1Mbps) does the download time for an additional 10kb become more significant. If you aren't optimizing specifically for users in rural or developing areas, your time is likely better spent optimizing something else.\n\nZodMiniType\n\nAll Zod Mini schemas extend the z.ZodMiniType base class, which in turn extends z.core.$ZodType from zod/v4/core. While this class implements far fewer methods than ZodType in zod, some particularly useful methods remain.\n\n.parse\n\nThis is an obvious one. All Zod Mini schemas implement the same parsing methods as zod.\n\nimport * as z from \"zod/mini\"\n \nconst mySchema = z.string();\n \nmySchema.parse('asdf')\nawait mySchema.parseAsync('asdf')\nmySchema.safeParse('asdf')\nawait mySchema.safeParseAsync('asdf')\n.check()\n\nIn regular Zod there are dedicated methods on schema subclasses for performing common checks:\n\nimport * as z from \"zod\";\n \nz.string()\n  .min(5)\n  .max(10)\n  .refine(val => val.includes(\"@\"))\n  .trim()\n\nIn Zod Mini such methods aren't implemented. Instead you pass these checks into schemas using the .check() method:\n\nimport * as z from \"zod/mini\"\n \nz.string().check(\n  z.minLength(5), \n  z.maxLength(10),\n  z.refine(val => val.includes(\"@\")),\n  z.trim()\n);\n\nThe following checks are implemented. Some of these checks only apply to schemas of certain types (e.g. strings or numbers). The APIs are all type-safe; TypeScript won't let you add an unsupported check to your schema.\n\nz.lt(value);\nz.lte(value); // alias: z.maximum()\nz.gt(value);\nz.gte(value); // alias: z.minimum()\nz.positive();\nz.negative();\nz.nonpositive();\nz.nonnegative();\nz.multipleOf(value);\nz.maxSize(value);\nz.minSize(value);\nz.size(value);\nz.maxLength(value);\nz.minLength(value);\nz.length(value);\nz.regex(regex);\nz.lowercase();\nz.uppercase();\nz.includes(value);\nz.startsWith(value);\nz.endsWith(value);\nz.property(key, schema);\nz.mime(value);\n \n// custom checks\nz.refine()\nz.check()   // replaces .superRefine()\n \n// mutations (these do not change the inferred types)\nz.overwrite(value => newValue);\nz.normalize();\nz.trim();\nz.toLowerCase();\nz.toUpperCase();\n.register()\n\nFor registering a schema in a registry.\n\nconst myReg = z.registry<{title: string}>();\n \nz.string().register(myReg, { title: \"My cool string schema\" });\n.brand()\n\nFor branding a schema. Refer to the Branded types docs for more information.\n\nimport * as z from \"zod/mini\"\n \nconst USD = z.string().brand(\"USD\");\n.clone(def)\n\nReturns an identical clone of the current schema using the provided def.\n\nconst mySchema = z.string()\n \nmySchema.clone(mySchema._zod.def);\nNo default locale\n\nWhile regular Zod automatically loads the English (en) locale, Zod Mini does not. This reduces the bundle size in scenarios where error messages are unnecessary, localized to a non-English language, or otherwise customized.\n\nThis means, by default the message property of all issues will simply read \"Invalid input\". To load the English locale:\n\nimport * as z from \"zod/mini\"\n \nz.config(z.locales.en());\n\nRefer to the Locales docs for more on localization.\n\nZod\n\nInternals and structure of the Zod library\n\nZod Core\n\nZod Core package - minimal core functionality for custom implementations"
  },
  {
    "title": "Zod | Zod",
    "url": "https://zod.dev/packages/zod",
    "html": "Zod\nCopy markdown\nEdit this page\n\nThe zod/v4 package is the \"flagship\" library of the Zod ecosystem. It strikes a balance between developer experience and bundle size that's ideal for the vast majority of applications.\n\nIf you have uncommonly strict constraints around bundle size, consider Zod Mini.\n\nZod aims to provide a schema API that maps one-to-one to TypeScript's type system.\n\nimport * as z from \"zod\";\n \nconst schema = z.object({\n  name: z.string(),\n  age: z.number().int().positive(),\n  email: z.string().email(),\n});\n\nThe API relies on methods to provide a concise, chainable, autocomplete-friendly way to define complex types.\n\nz.string()\n  .min(5)\n  .max(10)\n  .toLowerCase();\n\nAll schemas extend the z.ZodType base class, which in turn extends z.$ZodType from zod/v4/core. All instance of ZodType implement the following methods:\n\nimport * as z from \"zod\";\n \nconst mySchema = z.string();\n \n// parsing\nmySchema.parse(data);\nmySchema.safeParse(data);\nmySchema.parseAsync(data);\nmySchema.safeParseAsync(data);\n \n \n// refinements\nmySchema.refine(refinementFunc);\nmySchema.superRefine(refinementFunc); // deprecated, use `.check()`\nmySchema.overwrite(overwriteFunc);\n \n// wrappers\nmySchema.optional();\nmySchema.nonoptional();\nmySchema.nullable();\nmySchema.nullish();\nmySchema.default(defaultValue);\nmySchema.array();\nmySchema.or(otherSchema);\nmySchema.transform(transformFunc);\nmySchema.catch(catchValue);\nmySchema.pipe(otherSchema);\nmySchema.readonly();\n \n// metadata and registries\nmySchema.register(registry, metadata);\nmySchema.describe(description);\nmySchema.meta(metadata);\n \n// utilities\nmySchema.check(checkOrFunction);\nmySchema.clone(def);\nmySchema.brand<T>();\nmySchema.isOptional(); // boolean\nmySchema.isNullable(); // boolean\n\nFor library authors\n\nGuidelines and best practices for library authors integrating with Zod\n\nZod Mini\n\nZod Mini - a tree-shakable Zod"
  },
  {
    "title": "Zod Core | Zod",
    "url": "https://zod.dev/packages/core",
    "html": "Zod Core\nCopy markdown\nEdit this page\n\nThis sub-package exports the core classes and utilities that are consumed by Zod and Zod Mini. It is not intended to be used directly; instead it's designed to be extended by other packages. It implements:\n\nimport * as z from \"zod/v4/core\";\n \n// the base class for all Zod schemas\nz.$ZodType;\n \n// subclasses of $ZodType that implement common parsers\nz.$ZodString\nz.$ZodObject\nz.$ZodArray\n// ...\n \n// the base class for all Zod checks\nz.$ZodCheck;\n \n// subclasses of $ZodCheck that implement common checks\nz.$ZodCheckMinLength\nz.$ZodCheckMaxLength\n \n// the base class for all Zod errors\nz.$ZodError;\n \n// issue formats (types only)\n{} as z.$ZodIssue;\n \n// utils\nz.util.isValidJWT(...);\nSchemas\n\nThe base class for all Zod schemas is $ZodType. It accepts two generic parameters: Output and Input.\n\nexport class $ZodType<Output = unknown, Input = unknown> {\n  _zod: { /* internals */}\n}\n\nzod/v4/core exports a number of subclasses that implement some common parsers. A union of all first-party subclasses is exported as z.$ZodTypes.\n\nexport type $ZodTypes =\n  | $ZodString\n  | $ZodNumber\n  | $ZodBigInt\n  | $ZodBoolean\n  | $ZodDate\n  | $ZodSymbol\n  | $ZodUndefined\n  | $ZodNullable\n  | $ZodNull\n  | $ZodAny\n  | $ZodUnknown\n  | $ZodNever\n  | $ZodVoid\n  | $ZodArray\n  | $ZodObject\n  | $ZodUnion // $ZodDiscriminatedUnion extends this\n  | $ZodIntersection\n  | $ZodTuple\n  | $ZodRecord\n  | $ZodMap\n  | $ZodSet\n  | $ZodLiteral\n  | $ZodEnum\n  | $ZodPromise\n  | $ZodLazy\n  | $ZodOptional\n  | $ZodDefault\n  | $ZodTemplateLiteral\n  | $ZodCustom\n  | $ZodTransform\n  | $ZodNonOptional\n  | $ZodReadonly\n  | $ZodNaN\n  | $ZodPipe // $ZodCodec extends this\n  | $ZodSuccess\n  | $ZodCatch\n  | $ZodFile;\nInheritance diagram\nInternals\n\nAll zod/v4/core subclasses only contain a single property: _zod. This property is an object containing the schemas internals. The goal is to make zod/v4/core as extensible and unopinionated as possible. Other libraries can \"build their own Zod\" on top of these classes without zod/v4/core cluttering up the interface. Refer to the implementations of zod and zod/mini for examples of how to extend these classes.\n\nThe _zod internals property contains some notable properties:\n\n.def — The schema's definition: this is the object you pass into the class's constructor to create an instance. It completely describes the schema, and it's JSON-serializable.\n.def.type — A string representing the schema's type, e.g. \"string\", \"object\", \"array\", etc.\n.def.checks — An array of checks that are executed by the schema after parsing.\n.input — A virtual property that \"stores\" the schema's inferred input type.\n.output — A virtual property that \"stores\" the schema's inferred output type.\n.run() — The schema's internal parser implementation.\n\nIf you are implementing a tool (say, a code generator) that must traverse Zod schemas, you can cast any schema to $ZodTypes and use the def property to discriminate between these classes.\n\nexport function walk(_schema: z.$ZodType) {\n  const schema = _schema as z.$ZodTypes;\n  const def = schema._zod.def;\n  switch (def.type) {\n    case \"string\": {\n      // ...\n      break;\n    }\n    case \"object\": {\n      // ...\n      break;\n    }\n  }\n}\n\nThere are a number of subclasses of $ZodString that implement various string formats. These are exported as z.$ZodStringFormatTypes.\n\nexport type $ZodStringFormatTypes =\n  | $ZodGUID\n  | $ZodUUID\n  | $ZodEmail\n  | $ZodURL\n  | $ZodEmoji\n  | $ZodNanoID\n  | $ZodCUID\n  | $ZodCUID2\n  | $ZodULID\n  | $ZodXID\n  | $ZodKSUID\n  | $ZodISODateTime\n  | $ZodISODate\n  | $ZodISOTime\n  | $ZodISODuration\n  | $ZodIPv4\n  | $ZodIPv6\n  | $ZodCIDRv4\n  | $ZodCIDRv6\n  | $ZodBase64\n  | $ZodBase64URL\n  | $ZodE164\n  | $ZodJWT\nParsing\n\nAs the Zod Core schema classes have no methods, there are top-level functions for parsing data.\n\nimport * as z from \"zod/v4/core\";\n \nconst schema = new z.$ZodString({ type: \"string\" });\nz.parse(schema, \"hello\");\nz.safeParse(schema, \"hello\");\nawait z.parseAsync(schema, \"hello\");\nawait z.safeParseAsync(schema, \"hello\");\nChecks\n\nEvery Zod schema contains an array of checks. These perform post-parsing refinements (and occasionally mutations) that do not affect the inferred type.\n\nconst schema = z.string().check(z.email()).check(z.min(5));\n// => $ZodString\n \nschema._zod.def.checks;\n// => [$ZodCheckEmail, $ZodCheckMinLength]\n\nThe base class for all Zod checks is $ZodCheck. It accepts a single generic parameter T.\n\nexport class $ZodCheck<in T = unknown> {\n  _zod: { /* internals */}\n}\n\nThe _zod internals property contains some notable properties:\n\n.def — The check's definition: this is the object you pass into the class's constructor to create the check. It completely describes the check, and it's JSON-serializable.\n.def.check — A string representing the check's type, e.g. \"min_length\", \"less_than\", \"string_format\", etc.\n.check() — Contains the check's validation logic.\n\nzod/v4/core exports a number of subclasses that perform some common refinements. All first-party subclasses are exported as a union called z.$ZodChecks.\n\nexport type $ZodChecks =\n  | $ZodCheckLessThan\n  | $ZodCheckGreaterThan\n  | $ZodCheckMultipleOf\n  | $ZodCheckNumberFormat\n  | $ZodCheckBigIntFormat\n  | $ZodCheckMaxSize\n  | $ZodCheckMinSize\n  | $ZodCheckSizeEquals\n  | $ZodCheckMaxLength\n  | $ZodCheckMinLength\n  | $ZodCheckLengthEquals\n  | $ZodCheckProperty\n  | $ZodCheckMimeType\n  | $ZodCheckOverwrite\n  | $ZodCheckStringFormat\n\nYou can use the ._zod.def.check property to discriminate between these classes.\n\nconst check = {} as z.$ZodChecks;\nconst def = check._zod.def;\n \nswitch (def.check) {\n  case \"less_than\":\n  case \"greater_than\":\n    // ...\n    break;\n}\n\nAs with schema types, there are a number of subclasses of $ZodCheckStringFormat that implement various string formats.\n\nexport type $ZodStringFormatChecks =\n  | $ZodCheckRegex\n  | $ZodCheckLowerCase\n  | $ZodCheckUpperCase\n  | $ZodCheckIncludes\n  | $ZodCheckStartsWith\n  | $ZodCheckEndsWith\n  | $ZodGUID\n  | $ZodUUID\n  | $ZodEmail\n  | $ZodURL\n  | $ZodEmoji\n  | $ZodNanoID\n  | $ZodCUID\n  | $ZodCUID2\n  | $ZodULID\n  | $ZodXID\n  | $ZodKSUID\n  | $ZodISODateTime\n  | $ZodISODate\n  | $ZodISOTime\n  | $ZodISODuration\n  | $ZodIPv4\n  | $ZodIPv6\n  | $ZodCIDRv4\n  | $ZodCIDRv6\n  | $ZodBase64\n  | $ZodBase64URL\n  | $ZodE164\n  | $ZodJWT;\n\nUse a nested switch to discriminate between the different string format checks.\n\nconst check = {} as z.$ZodChecks;\nconst def = check._zod.def;\n \nswitch (def.check) {\n  case \"less_than\":\n  case \"greater_than\":\n  // ...\n  case \"string_format\":\n    {\n      const formatCheck = check as z.$ZodStringFormatChecks;\n      const formatCheckDef = formatCheck._zod.def;\n \n      switch (formatCheckDef.format) {\n        case \"email\":\n        case \"url\":\n          // do stuff\n      }\n    }\n    break;\n}\n\nYou'll notice some of these string format checks overlap with the string format types above. That's because these classes implement both the $ZodCheck and $ZodType interfaces. That is, they can be used as either a check or a type. In these cases, both ._zod.parse (the schema parser) and ._zod.check (the check validation) are executed during parsing. In effect, the instance is prepended to its own checks array (though it won't actually exist in ._zod.def.checks).\n\n// as a type\nz.email().parse(\"user@example.com\");\n \n// as a check\nz.string().check(z.email()).parse(\"user@example.com\")\nErrors\n\nThe base class for all errors in Zod is $ZodError.\n\nFor performance reasons, $ZodError does not extend the built-in Error class! So using instanceof Error will return false.\n\nThe zod package implements a subclass of $ZodError called ZodError with some additional convenience methods.\nThe zod/mini sub-package directly uses $ZodError\nexport class $ZodError<T = unknown> implements Error {\n public issues: $ZodIssue[];\n}\nIssues\n\nThe issues property corresponds to an array of $ZodIssue objects. All issues extend the z.$ZodIssueBase interface.\n\nexport interface $ZodIssueBase {\n  readonly code?: string;\n  readonly input?: unknown;\n  readonly path: PropertyKey[];\n  readonly message: string;\n}\n\nZod defines the following issue subtypes:\n\nexport type $ZodIssue =\n  | $ZodIssueInvalidType\n  | $ZodIssueTooBig\n  | $ZodIssueTooSmall\n  | $ZodIssueInvalidStringFormat\n  | $ZodIssueNotMultipleOf\n  | $ZodIssueUnrecognizedKeys\n  | $ZodIssueInvalidUnion\n  | $ZodIssueInvalidKey\n  | $ZodIssueInvalidElement\n  | $ZodIssueInvalidValue\n  | $ZodIssueCustom;\n\nFor details on each type, refer to the implementation.\n\nZod Mini\n\nZod Mini - a tree-shakable Zod"
  }
]
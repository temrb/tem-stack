[
  {
    "title": "Reference | Prisma Documentation",
    "url": "https://www.prisma.io/docs/orm/reference",
    "html": "ORM\nReference\n\nThe reference section of the documentation is a collection of reference pages that describe the Prisma ORM APIs and database implementations.\n\nIn this section​\nPrisma Client API\n\nIf Prisma ORM's Rust engine binaries cause large bundle sizes, slow builds, or deployment issues (for example, in serverless or edge environments), you can use it without them using this configuration of your generator block:\n\nPrisma Schema\n\ndatasource\n\nPrisma CLI\n\nThis document describes the Prisma CLI commands, arguments, and options.\n\nErrors\n\nFor more information about how to work with exceptions and error codes, see Handling exceptions and errors.\n\nEnvironment variables\n\nThis document describes different environment variables and their use cases.\n\nPrisma Config\n\nOverview\n\nDatabase features matrix\n\nThis page gives an overview of the features which are provided by the databases that Prisma ORM supports. Additionally, it explains how each of these features can be used in Prisma ORM with pointers to further documentation.\n\nSupported databases\n\nPrisma ORM currently supports the following databases.\n\nConnection URLs\n\nPrisma ORM needs a connection URL to be able to connect to your database, e.g. when sending queries with Prisma Client or when changing the database schema with Prisma Migrate.\n\nSystem requirements\n\nThis page provides an overview of the system requirements for Prisma ORM.\n\nPreview features"
  },
  {
    "title": "Prisma Client API | Prisma Documentation",
    "url": "https://www.prisma.io/docs/orm/reference/prisma-client-reference",
    "html": "ORMReference\nPrisma Client API reference\nUSE PRISMA ORM WITHOUT RUST BINARIES\n\nIf Prisma ORM's Rust engine binaries cause large bundle sizes, slow builds, or deployment issues (for example, in serverless or edge environments), you can use it without them using this configuration of your generator block:\n\ngenerator client {\n\n  provider   = \"prisma-client-js\" // or \"prisma-client\"\n\n  engineType = \"client\"\n\n}\n\n\nPrisma ORM without Rust binaries has been Generally Available since v6.16.0\n.\n\nNote that you need to use a driver adapter in this case.\n\nWhen using this architecture:\n\nNo Rust query engine binary is downloaded or shipped.\nThe database connection pool is maintained by the native JS database driver you install (e.g., @prisma/adapter-pg for PostgreSQL).\n\nThis setup can simplify deployments in serverless or edge runtimes. Learn more in the docs here.\n\nCurious why we moved away from the Rust engine? Take a look at why we transitioned from Rust binary engines to an all-TypeScript approach for a faster, lighter Prisma ORM in this blog post.\n\nThe Prisma Client API reference documentation is based on the following schema:\n\nmodel User {\n\n  id           Int              @id @default(autoincrement())\n\n  name         String?\n\n  email        String           @unique\n\n  profileViews Int              @default(0)\n\n  role         Role             @default(USER)\n\n  coinflips    Boolean[]\n\n  posts        Post[]\n\n  city         String\n\n  country      String\n\n  profile      ExtendedProfile?\n\n  pets         Json\n\n}\n\n\n\nmodel ExtendedProfile {\n\n  id     Int     @id @default(autoincrement())\n\n  userId Int?    @unique\n\n  bio    String?\n\n  User   User?   @relation(fields: [userId], references: [id])\n\n}\n\n\n\nmodel Post {\n\n  id        Int     @id @default(autoincrement())\n\n  title     String\n\n  published Boolean @default(true)\n\n  author    User    @relation(fields: [authorId], references: [id])\n\n  authorId  Int\n\n  comments  Json\n\n  views     Int     @default(0)\n\n  likes     Int     @default(0)\n\n}\n\n\n\nenum Role {\n\n  USER\n\n  ADMIN\n\n}\n\n\nAll example generated types (such as UserSelect and UserWhereUniqueInput) are based on the User model.\n\nPrismaClient​\n\nThis section describes the PrismaClient constructor and its parameters.\n\nRemarks​\nParameters are validated at runtime.\ndatasources​\n\nProgrammatically overrides properties of the datasource block in the schema.prisma file - for example, as part of an integration test. See also: Data sources\n\nFrom version 5.2.0 and upwards, you can also use the datasourceUrl property to programmatically override the database connection string.\n\nProperties​\nExample property\tExample value\tDescription\ndb\t{ url: 'file:./dev_qa.db' }\tThe database connection URL.\nRemarks​\nYou must re-generate Prisma Client each time you add or rename a data source. Datasource names are included in the generated client.\nIf you named your datasource block something else in the schema, replace db with the name of your datasource block.\nExamples​\nProgrammatically override a datasource url​\nimport { PrismaClient } from '@prisma/client';\n\n\n\nconst prisma = new PrismaClient({\n\n  datasources: {\n\n    db: {\n\n      url: 'file:./dev_qa.db',\n\n    },\n\n  },\n\n});\n\n\nBased on the following datasource block:\n\ndatasource db {\n\n  provider = \"sqlite\"\n\n  url      = env(\"DATABASE_URL\")\n\n}\n\ndatasourceUrl​\n\nProgrammatically overrides the datasource block in the schema.prisma file.\n\nProperty​\nOption\tExample value\tDescription\nDatabase connection string\t'file:./dev_qa.db'\tThe database connection URL.\nExamples​\nimport { PrismaClient } from '@prisma/client';\n\n\n\nconst prisma = new PrismaClient({\n\n  datasourceUrl: 'postgresql://johndoe:randompassword@localhost:5432/mydb',\n\n});\n\nlog​\n\nDetermines the type and level of logging. See also: Logging\n\nOptions​\nOption\tExample\nArray of log levels\t[ \"info\", \"query\" ]\nArray of log definitions\t[ { level: \"info\", emit: \"event\" }, { level: \"warn\", emit: \"stdout\" }]\nLog levels​\nName\tExample\nquery\tLogs all queries run by Prisma.\n\nFor relational databases this logs all SQL queries. Example:\nprisma:query SELECT \"public\".\"User\".\"id\", \"public\".\"User\".\"email\" FROM \"public\".\"User\" WHERE (\"public\".\"User\".\"id\") IN (SELECT \"t0\".\"id\" FROM \"public\".\"User\" AS \"t0\" INNER JOIN \"public\".\"Post\" AS \"j0\" ON (\"j0\".\"authorId\") = (\"t0\".\"id\") WHERE (\"j0\".\"views\" > $1 AND \"t0\".\"id\" IS NOT NULL)) OFFSET $2\n\nFor MongoDB this logs queries using the \nmongosh\nshell\n format. Example:\nprisma:query db.User.deleteMany({ _id: ( $in: [ “6221ce49f756b0721fc00542”, ], }, })\ninfo\tExample:\nprisma:info Started http server on http://127.0.0.1:58471\nwarn\tWarnings.\nerror\tErrors.\nEmit formats​\nName\tDescription\nstdout\tSee: stdout\n\nevent\tRaises an event that you can subscribe to.\nEvent types​\n\nThe query event type:\n\nindex.d.ts\nexport type QueryEvent = {\n\n  timestamp: Date;\n\n  query: string; // Query sent to the database\n\n  params: string; // Query parameters\n\n  duration: number; // Time elapsed (in milliseconds) between client issuing query and database responding - not only time taken to run query\n\n  target: string;\n\n};\n\n\nNote that for MongoDB, the params and duration fields will be undefined.\n\nAll other log level event types:\n\nindex.d.ts\nexport type LogEvent = {\n\n  timestamp: Date;\n\n  message: string;\n\n  target: string;\n\n};\n\nExamples​\nLog query and info to stdout​\nimport { PrismaClient } from '@prisma/client';\n\n\n\nconst prisma = new PrismaClient({ log: ['query', 'info'] });\n\n\n\nasync function main() {\n\n  const countUsers = await prisma.user.count({});\n\n}\n\n\n\nmain()\n\n  .then(async () => {\n\n    await prisma.$disconnect();\n\n  })\n\n  .catch(async (e) => {\n\n    console.error(e);\n\n    await prisma.$disconnect();\n\n    process.exit(1);\n\n  });\n\nShow CLI results\nLog a query event to console​\nimport { PrismaClient } from '@prisma/client';\n\n\n\nconst prisma = new PrismaClient({\n\n  log: [{ level: 'query', emit: 'event' }],\n\n});\n\n\n\nprisma.$on('query', (e) => {\n\n  console.log(e);\n\n});\n\n\n\nasync function main() {\n\n  const countUsers = await prisma.user.count({});\n\n}\n\n\n\nmain()\n\n  .then(async () => {\n\n    await prisma.$disconnect();\n\n  })\n\n  .catch(async (e) => {\n\n    console.error(e);\n\n    await prisma.$disconnect();\n\n    process.exit(1);\n\n  });\n\nShow CLI results\nLog info, warn, and error events to console​\nimport { PrismaClient } from '@prisma/client';\n\n\n\nconst prisma = new PrismaClient({\n\n  log: [\n\n    { level: 'warn', emit: 'event' },\n\n    { level: 'info', emit: 'event' },\n\n    { level: 'error', emit: 'event' },\n\n  ],\n\n});\n\n\n\nprisma.$on('warn', (e) => {\n\n  console.log(e);\n\n});\n\n\n\nprisma.$on('info', (e) => {\n\n  console.log(e);\n\n});\n\n\n\nprisma.$on('error', (e) => {\n\n  console.log(e);\n\n});\n\n\n\nasync function main() {\n\n  const countUsers = await prisma.user.count({});\n\n}\n\n\n\nmain()\n\n  .then(async () => {\n\n    await prisma.$disconnect();\n\n  })\n\n  .catch(async (e) => {\n\n    console.error(e);\n\n    await prisma.$disconnect();\n\n    process.exit(1);\n\n  });\n\nShow CLI results\nerrorFormat​\n\nDetermines the level and formatting of errors returned by Prisma Client.\n\nError formats​\nName\tDescription\nundefined\tIf it's not defined, the default is colorless.\npretty\tEnables pretty error formatting.\ncolorless (default)\tEnables colorless error formatting.\nminimal\tEnables minimal error formatting.\nExamples​\nNo error formatting​\nconst prisma = new PrismaClient({\n\n  // Defaults to colorless\n\n});\n\npretty error formatting​\nconst prisma = new PrismaClient({\n\n  errorFormat: 'pretty',\n\n});\n\ncolorless error formatting​\nconst prisma = new PrismaClient({\n\n  errorFormat: 'colorless',\n\n});\n\nminimal error formatting​\nconst prisma = new PrismaClient({\n\n  errorFormat: 'minimal',\n\n});\n\nadapter​\n\nDefines an instance of a driver adapter. See also Database drivers .\n\nINFO\n\nThis is available from version 5.4.0 and newer as a Preview feature behind the driverAdapters feature flag. It has been Generally Available since 6.16.0.\n\nExample​\n\nThe example below uses the Neon driver adapter\n\nimport { PrismaNeon } from '@prisma/adapter-neon';\n\nimport { PrismaClient } from '@prisma/client';\n\nimport dotenv from 'dotenv';\n\n\n\ndotenv.config();\n\nconst connectionString = `${process.env.DATABASE_URL}`;\n\n\n\nconst adapter = new PrismaNeon({ connectionString });\n\nconst prisma = new PrismaClient({ adapter });\n\nrejectOnNotFound​\nINFO\n\nNote: rejectOnNotFound was removed in v5.0.0.\n\nDeprecated: rejectOnNotFound is deprecated in v4.0.0. From v4.0.0, use the queries findUniqueOrThrow or findFirstOrThrow.\n\nUse the rejectOnNotFound parameter to configure findUnique() and/or findFirst to throw an error if the record was not found. By default, both operations return null if the record is not found.\n\nRemarks​\nYou can configure rejectOnNotFound on a per-request level for both findUnique() and findFirst\nOptions​\nOption\tDescription\nRejectOnNotFound\tEnable globally (true / false) or throw a custom error.\nRejectPerOperation\tEnable per operation (true / false) or throw a custom error per operation, per model.\nExamples​\nEnable globally for findUnique() and findFirst​\nconst prisma = new PrismaClient({\n\n  rejectOnNotFound: true,\n\n});\n\nEnable globally for a specific operation​\nconst prisma = new PrismaClient({\n\n  rejectOnNotFound: {\n\n    findUnique: true,\n\n  },\n\n});\n\nThrow a custom error per model and operation if record is not found​\nconst prisma = new PrismaClient({\n\n  rejectOnNotFound: {\n\n    findFirst: {\n\n      User: (err) => new Error('User error'),\n\n      Post: (err) => new Error('Post error!'),\n\n    },\n\n    findUnique: {\n\n      User: (err) => new Error('User error'),\n\n      Post: (err) => new Error('Post error!'),\n\n    },\n\n  },\n\n});\n\ntransactionOptions​\nINFO\n\nNote: transactionOptions was introduced in v5.10.0.\n\nAllows to set transaction options globally on the constructor level.\n\nRemarks​\nThe transaction levels can be overridden on a per-transaction level.\nOptions​\nOption\tDescription\nmaxWait\tThe maximum amount of time Prisma Client will wait to acquire a transaction from the database. The default value is 2 seconds.\ntimeout\tThe maximum amount of time the interactive transaction can run before being canceled and rolled back. The default value is 5 seconds.\nisolationLevel\tSets the transaction isolation level. By default this is set to the value currently configured in your database. The available can vary depending on the database you use.\nExample​\nconst prisma = new PrismaClient({\n\n  transactionOptions: {\n\n    isolationLevel: Prisma.TransactionIsolationLevel.Serializable,\n\n    maxWait: 5000, // default: 2000\n\n    timeout: 10000, // default: 5000\n\n  },\n\n});\n\nModel queries​\n\nUse model queries to perform CRUD operations on your models. See also: CRUD\n\nNote: It's a best practice to always validate and sanitize any untrusted user data before passing it into Prisma queries. Failure to do so can lead to SQL injection or other injection vulnerabilities if the type checks are bypassed. Make sure user-supplied values cannot inadvertently bypass critical checks. We strongly recommend performing type checking and input validation at the application layer. For more details, see Custom Validation section.\n\nfindUnique()​\n\nfindUnique() query lets you retrieve a single database record:\n\nBy ID\nBy a unique attribute\n\nfindUnique() replaced findOne in version 2.12.0\n.\n\nRemarks​\nPrisma Client's dataloader automatically batches findUnique() queries with the same select and where parameters.\nIf you want the query to throw an error if the record is not found, then consider using findUniqueOrThrow instead.\nYou cannot use filter conditions (e.g. equals, contains, not) to filter fields of the JSON data type. Using filter conditions will likely result in a null response for that field.\nOptions​\nName\tExample type (User)\tRequired\tDescription\nwhere\tUserWhereUniqueInput\tYes\tWraps all fields of a model so that a record can be selected (learn more).\nBefore version 4.5.0, this type only wraps unique fields of a model.\nselect\tXOR<UserSelect, null>\tNo\tSpecifies which properties to include on the returned object.\ninclude\tXOR<UserInclude, null>\tNo\tSpecifies which relations should be eagerly loaded on the returned object.\nomit\tXOR<UserOmit, null>\tNo\tSpecifies which properties to exclude on the returned object. In Preview since 5.13.0\nrelationLoadStrategy\t'join' or 'query'\tNo\tDefault: join. Specifies the load strategy for a relation query. Only available in combination with include (or select on a relation field). In Preview since 5.9.0.\nReturn type​\nReturn type\tExample\tDescription\nJavaScript object (typed)\tUser\t\nJavaScript object (plain)\t{ title: \"Hello world\" }\tUse select and include to determine which fields to return.\nnull\tnull\tRecord not found\nExamples​\nGet the User record with an id of 42​\nconst result = await prisma.user.findUnique({\n\n  where: {\n\n    id: 42,\n\n  },\n\n});\n\nGet the User record with an email of alice@prisma.io​\nconst result = await prisma.user.findUnique({\n\n  where: {\n\n    email: 'alice@prisma.io',\n\n  },\n\n});\n\nGet the User record with firstName of Alice and lastName of Smith (@@unique)​\nExpand for example User model with a @@unique block\nconst result = await prisma.user.findUnique({\n\n  where: {\n\n    fullname: {\n\n      // name property of @@unique attribute - default is firstname_lastname\n\n      firstName: 'Alice',\n\n      lastName: 'Smith',\n\n    },\n\n  },\n\n});\n\nGet the User record with firstName of Alice and lastName of Smith (@@id)​\nExpand for example User model with an @@id block\nconst result = await prisma.user.findUnique({\n\n  where: {\n\n    firstName_lastName: {\n\n      firstName: 'Alice',\n\n      lastName: 'Smith',\n\n    },\n\n  },\n\n});\n\nfindUniqueOrThrow()​\n\nfindUniqueOrThrow() retrieves a single record in the same way as findUnique(). However, if the query does not find the requested record, it throws a PrismaClientKnownRequestError.\n\nNote that before Prisma v6, it would throw a NotFoundError: No User found error.\n\nHere’s an example of its usage:\n\nawait prisma.user.findUniqueOrThrow({\n\n  where: { id: 1 },\n\n});\n\n\nfindUniqueOrThrow() differs from findUnique() as follows:\n\nIts return type is non-nullable. For example, post.findUnique() can return post or null, but post.findUniqueOrThrow() always returns post.\n\nIt is not compatible with sequential operations in the $transaction API. If the query throws a PrismaClientKnownRequestError, then the API will not roll back any operations in the array of calls. As a workaround, you can use interactive transactions with the $transaction API, as follows:\n\n $transaction(async (prisma) => {\n\n   await prisma.model.create({ data: { ... });\n\n   await prisma.model.findUniqueOrThrow();\n\n })\n\nfindFirst()​\n\nfindFirst returns the first record in a list that matches your criteria.\n\nRemarks​\nIf you want the query to throw an error if the record is not found, then consider using findFirstOrThrow instead.\nOptions​\nName\tExample type (User)\tRequired\tDescription\nselect\tXOR<UserSelect, null>\tNo\tSpecifies which properties to include on the returned object.\ninclude\tXOR<UserInclude, null>\tNo\tSpecifies which relations should be eagerly loaded on the returned object.\nomit\tXOR<UserOmit, null>\tNo\tSpecifies which properties to exclude on the returned object. In Preview since 5.13.0.\nrelationLoadStrategy\t'join' or 'query'\tNo\tDefault: join. Specifies the load strategy for a relation query. Only available in combination with include (or select on a relation field). In Preview since 5.9.0.\nwhere\tUserWhereInput\tNo\tWraps all model fields in a type so that the list can be filtered by any property.\norderBy\tXOR<Enumerable<UserOrderByInput>, UserOrderByInput>\tNo\tLets you order the returned list by any property.\nReturn type​\nReturn type\tExample\tDescription\nJavaScript object (typed)\tUser\tSpecifies which properties to include on the returned object.\nJavaScript object (plain)\t{ title: \"Hello world\" }\tUse select and include to determine which fields to return.\nnull\tnull\tRecord not found\nRemarks​\nfindFirst calls findMany behind the scenes and accepts the same query options.\nPassing in a negative take value when you use a findFirst query reverses the order of the list.\nExamples​\n\nSee Filter conditions and operators for examples of how to filter results.\n\nGet the first User record where the name is Alice​\nconst user = await prisma.user.findFirst({\n\n  where: { name: 'Alice' },\n\n});\n\nGet the first Post record where the title starts with A test, reverse the list with take​\nimport { PrismaClient } from '@prisma/client';\n\n\n\nconst prisma = new PrismaClient({});\n\n\n\nasync function main() {\n\n  const a = await prisma.post.create({\n\n    data: {\n\n      title: 'A test 1',\n\n    },\n\n  });\n\n\n\n  const b = await prisma.post.create({\n\n    data: {\n\n      title: 'A test 2',\n\n    },\n\n  });\n\n\n\n  const c = await prisma.post.findFirst({\n\n    where: {\n\n      title: {\n\n        startsWith: 'A test',\n\n      },\n\n    },\n\n    orderBy: {\n\n      title: 'asc',\n\n    },\n\n    take: -1, // Reverse the list\n\n  });\n\n}\n\n\n\nmain();\n\nfindFirstOrThrow()​\n\nfindFirstOrThrow() retrieves a single data record in the same way as findFirst(). However, if the query does not find a record, it throws a PrismaClientKnownRequestError.\n\nNote that before Prisma v6, it would throw a NotFoundError: No User found error.\n\nfindFirstOrThrow() differs from findFirst() as follows:\n\nIts return type is non-nullable. For example, post.findFirst() can return post or null, but post.findFirstOrThrow always returns post.\n\nIt is not compatible with sequential operations in the $transaction API. If the query returns PrismaClientKnownRequestError, then the API will not roll back any operations in the array of calls. As a workaround, you can use interactive transactions with the $transaction API, as follows:\n\nprisma.$transaction(async (tx) => {\n\n  await tx.model.create({ data: { ... });\n\n  await tx.model.findFirstOrThrow();\n\n})\n\nfindMany()​\n\nfindMany returns a list of records.\n\nOptions​\nName\tType\tRequired\tDescription\nselect\tXOR<PostSelect, null>\tNo\tSpecifies which properties to include on the returned object.\ninclude\tXOR<PostInclude, null>\tNo\tSpecifies which relations should be eagerly loaded on the returned object.\nomit\tXOR<PostOmit, null>\tNo\tSpecifies which properties to exclude on the returned object. In Preview since 5.13.0\nrelationLoadStrategy\t'join' or 'query'\tNo\tDefault: join. Specifies the load strategy for a relation query. Only available in combination with include (or select on a relation field). In Preview since 5.9.0.\nwhere\tUserWhereInput\tNo\tWraps all model fields in a type so that the list can be filtered by any property.\norderBy\tXOR<Enumerable<PostOrder\nByInput>, PostOrderByInput>\tNo\tLets you order the returned list by any property.\ncursor\tUserWhereUniqueInput\tNo\tSpecifies the position for the list (the value typically specifies an id or another unique value).\ntake\tnumber\tNo\tSpecifies how many objects should be returned in the list (as seen from the beginning (positive value) or end (negative value) either of the list or from the cursor position if mentioned)\nskip\tnumber\tNo\tSpecifies how many of the returned objects in the list should be skipped.\ndistinct\tEnumerable<UserDistinctFieldEnum>\tNo\tLets you filter out duplicate rows by a specific field - for example, return only distinct Post titles.\nReturn type​\nReturn type\tExample\tDescription\nJavaScript array object (typed)\tUser[]\t\nJavaScript array object (plain)\t[{ title: \"Hello world\" }]\tUse select and include to determine which fields to return.\nEmpty array\t[]\tNo matching records found.\nExamples​\n\nSee Filter conditions and operators for examples of how to filter results.\n\nGet all User records where the name is Alice​\nconst user = await prisma.user.findMany({\n\n  where: { name: 'Alice' },\n\n});\n\ncreate()​\n\ncreate creates a new database record.\n\nOptions​\nName\tType\tRequired\tDescription\ndata\tXOR<UserCreateInput,\nUserUncheckedCreateInput>\tYes\tWraps all the model fields in a type so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional.\nselect\tXOR<UserSelect, null>\tNo\tSpecifies which properties to include on the returned object.\ninclude\tXOR<UserInclude, null>\tNo\tSpecifies which relations should be eagerly loaded on the returned object.\nomit\tXOR<UserOmit, null>\tNo\tSpecifies which properties to exclude on the returned object. In Preview since 5.13.0\nrelationLoadStrategy\t'join' or 'query'\tNo\tDefault: join. Specifies the load strategy for a relation query. Only available in combination with include (or select on a relation field). In Preview since 5.9.0.\nReturn type​\nReturn type\tExample\tDescription\nJavaScript object (typed)\tUser\t\nJavaScript object (plain)\t{ name: \"Alice Wonderland\" }\tUse select and include to determine which fields to return.\nRemarks​\nYou can also perform a nested create - for example, add a User and two Post records at the same time.\nExamples​\nCreate a single new record with the only required field email​\nconst user = await prisma.user.create({\n\n  data: { email: 'alice@prisma.io' },\n\n});\n\nCreate multiple new records​\n\nIn most cases, you can carry out batch inserts with the createMany() or createManyAndReturn() queries. However, there are scenarios where create() is the best option to insert multiple records.\n\nThe following example results in two INSERT statements:\n\nimport { Prisma, PrismaClient } from '@prisma/client';\n\n\n\nconst prisma = new PrismaClient({ log: ['query'] });\n\n\n\nasync function main() {\n\n  let users: Prisma.UserCreateInput[] = [\n\n    {\n\n      email: 'ariana@prisma.io',\n\n      name: 'Ari',\n\n      profileViews: 20,\n\n      coinflips: [true, false, false],\n\n      role: 'ADMIN',\n\n    },\n\n    {\n\n      email: 'elsa@prisma.io',\n\n      name: 'Elsa',\n\n      profileViews: 20,\n\n      coinflips: [true, false, false],\n\n      role: 'ADMIN',\n\n    },\n\n  ];\n\n\n\n  await Promise.all(\n\n    users.map(async (user) => {\n\n      await prisma.user.create({\n\n        data: user,\n\n      });\n\n    })\n\n  );\n\n}\n\n\n\nmain()\n\n  .then(async () => {\n\n    await prisma.$disconnect();\n\n  })\n\n  .catch(async (e) => {\n\n    console.error(e);\n\n    await prisma.$disconnect();\n\n    process.exit(1);\n\n  });\n\nShow CLI results\nprisma:query BEGIN\n\nprisma:query INSERT INTO \"public\".\"User\" (\"name\",\"email\",\"profileViews\",\"role\",\"coinflips\") VALUES ($1,$2,$3,$4,$5) RETURNING \"public\".\"User\".\"id\"\n\nprisma:query SELECT \"public\".\"User\".\"id\", \"public\".\"User\".\"name\", \"public\".\"User\".\"email\", \"public\".\"User\".\"profileViews\", \"public\".\"User\".\"role\", \"public\".\"User\".\"coinflips\" FROM \"public\".\"User\" WHERE \"public\".\"User\".\"id\" = $1 LIMIT $2 OFFSET $3\n\nprisma:query INSERT INTO \"public\".\"User\" (\"name\",\"email\",\"profileViews\",\"role\",\"coinflips\") VALUES ($1,$2,$3,$4,$5) RETURNING \"public\".\"User\".\"id\"\n\nprisma:query COMMIT\n\nprisma:query SELECT \"public\".\"User\".\"id\", \"public\".\"User\".\"name\", \"public\".\"User\".\"email\", \"public\".\"User\".\"profileViews\", \"public\".\"User\".\"role\", \"public\".\"User\".\"coinflips\" FROM \"public\".\"User\" WHERE \"public\".\"User\".\"id\" = $1 LIMIT $2 OFFSET $3\n\nprisma:query COMMIT\n\nupdate()​\n\nupdate updates an existing database record.\n\nOptions​\nName\tType\tRequired\tDescription\ndata\tXOR<UserUpdateInput\nUserUncheckedUpdateInput>\tYes\tWraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional.\nwhere\tUserWhereUniqueInput\tYes\tWraps all fields of a model so that a record can be selected (learn more).\nBefore version 4.5.0, this type only wraps unique fields of a model.\nselect\tXOR<UserSelect, null>\tNo\tSpecifies which properties to include on the returned object.\ninclude\tXOR<UserInclude, null>\tNo\tSpecifies which relations should be eagerly loaded on the returned object.\nomit\tXOR<UserOmit, null>\tNo\tSpecifies which properties to exclude on the returned object. In Preview since 5.13.0.\nrelationLoadStrategy\t'join' or 'query'\tNo\tDefault: join. Specifies the load strategy for a relation query. Only available in combination with include (or select on a relation field). In Preview since 5.9.0.\nReturn type​\nReturn type\tExample\tDescription\nJavaScript object (typed)\tUser\t\nJavaScript object (plain)\t{ name: \"Alice Wonderland\" }\tUse select and include to determine which fields to return.\nPrismaClientKnownRequestError (code P2025)\t\tThrown if the record to update does not exist. See Error reference\nRemarks​\nTo perform arithmetic operations on update (add, subtract, multiply, divide), use atomic updates to prevent race conditions.\nYou can also perform a nested update - for example, update a user and that user's posts at the same time.\nExamples​\nUpdate the email of the User record with id of 1 to alice@prisma.io​\nconst user = await prisma.user.update({\n\n  where: { id: 1 },\n\n  data: { email: 'alice@prisma.io' },\n\n});\n\nupsert()​\nINFO\n\nThis section covers the usage of the upsert() operation. To learn about using nested upsert queries within update(), reference the linked documentation.\n\nupsert does the following:\n\nIf an existing database record satisfies the where condition, it updates that record\nIf no database record satisfies the where condition, it creates a new database record\nOptions​\nName\tType\tRequired\tDescription\ncreate\tXOR<UserCreateInput,\nUserUncheckedCreateInput>\tYes\tWraps all the fields of the model so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional.\nupdate\tXOR<UserUpdateInput,\nUserUncheckedUpdateInput>\tYes\tWraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional.\nwhere\tUserWhereUniqueInput\tYes\tWraps all fields of a model so that a record can be selected (learn more).\nBefore version 4.5.0, this type only wraps unique fields of a model.\nselect\tXOR<UserSelect, null>\tNo\tSpecifies which properties to include on the returned object.\ninclude\tXOR<UserInclude, null>\tNo\tSpecifies which relations should be eagerly loaded on the returned object.\nomit\tXOR<UserOmit, null>\tNo\tSpecifies which properties to exclude on the returned object. In Preview since 5.13.0\nrelationLoadStrategy\t'join' or 'query'\tNo\tDefault: join. Specifies the load strategy for a relation query. Only available in combination with include (or select on a relation field). In Preview since 5.9.0.\nReturn type​\nReturn type\tExample\tDescription\nJavaScript object (typed)\tUser\t\nJavaScript object (plain)\t{ name: \"Alice Wonderland\" }\tUse select and include to determine which fields to return.\nRemarks​\nTo perform arithmetic operations on update (add, subtract, multiply, divide), use atomic updates to prevent race conditions.\nIf two or more upsert operations happen at the same time and the record doesn't already exist, then a race condition might happen. As a result, one or more of the upsert operations might throw a unique key constraint error. Your application code can catch this error and retry the operation. Learn more.\nFrom version 4.6.0, Prisma ORM hands over upsert queries to the database where possible. Learn more.\nExamples​\nUpdate (if exists) or create a new User record with an email of alice@prisma.io​\nconst user = await prisma.user.upsert({\n\n  where: { id: 1 },\n\n  update: { email: 'alice@prisma.io' },\n\n  create: { email: 'alice@prisma.io' },\n\n});\n\nUnique key constraint errors on upserts​\nProblem​\n\nIf multiple upsert operations happen at the same time and the record doesn't already exist, then one or more of the operations might return a unique key constraint error.\n\nCause​\n\nWhen Prisma Client does an upsert, it first checks whether that record already exists in the database. To make this check, Prisma Client performs a read operation with the where clause from the upsert operation. This has two possible outcomes, as follows:\n\nIf the record does not exist, then Prisma Client creates that record.\nIf the record exists, then Prisma Client updates it.\n\nWhen your application tries to perform two or more concurrent upsert operations, then a race condition might happen where two or more operations do not find the record and therefore try to create that record. In this situation, one of the operations successfully creates the new record but the other operations fail and return a unique key constraint error.\n\nSolution​\n\nHandle the P2002 error in your application code. When it occurs, retry the upsert operation to update the row.\n\nDatabase upserts​\n\nWhere possible, Prisma Client hands over an upsert query to the database. This is called a database upsert.\n\nDatabase upserts have the following advantages:\n\nThey are faster than upserts handled by Prisma Client\nUnique key constraint errors cannot happen\n\nPrisma Client uses a database upsert automatically when specific criteria are met. When these criteria are not met, Prisma Client handles the upsert.\n\nTo use a database upsert, Prisma Client sends the SQL construction INSERT ... ON CONFLICT SET .. WHERE to the database.\n\nDatabase upsert prerequisites​\n\nPrisma Client can use database upserts if your stack meets the following criteria:\n\nYou use Prisma ORM version 4.6.0 or later\nYour application uses a CockroachDB, PostgreSQL, or SQLite data source\nDatabase upsert query criteria​\n\nPrisma Client uses a database upsert for an upsert query when the query meets the following criteria:\n\nThere are no nested queries in the upsert's create and update options\nThe query does not include a selection that uses a nested read\nThe query modifies only one model\nThere is only one unique field in the upsert's where option\nThe unique field in the where option and the unique field in the create option have the same value\n\nIf your query does not meet these criteria, then Prisma Client handles the upsert itself.\n\nDatabase upsert examples​\n\nThe following examples use this schema:\n\nmodel User {\n\n  id           Int    @id\n\n  profileViews Int\n\n  userName     String @unique\n\n  email        String\n\n\n\n  @@unique([id, profileViews])\n\n}\n\n\nThe following upsert query meets all of the criteria, so Prisma Client uses a database upsert.\n\nprisma.user.upsert({\n\n  where: {\n\n    userName: 'Alice',\n\n  },\n\n  create: {\n\n    id: 1,\n\n    profileViews: 1,\n\n    userName: 'Alice',\n\n    email: 'alice@prisma.io',\n\n  },\n\n  update: {\n\n    email: 'updated@example.com',\n\n  },\n\n});\n\n\nIn this situation, Prisma uses the following SQL query:\n\nINSERT INTO \"public\".\"User\" (\"id\",\"profileViews\",\"userName\",\"email\") VALUES ($1,$2,$3,$4)\n\nON CONFLICT (\"userName\") DO UPDATE\n\nSET \"email\" = $5 WHERE (\"public\".\"User\".\"userName\" = $6 AND 1=1) RETURNING \"public\".\"User\".\"id\", \"public\".\"User\".\"profileViews\", \"public\".\"User\".\"userName\", \"public\".\"User\".\"email\"\n\n\nThe following query has multiple unique values in the where clause, so Prisma Client does not use a database upsert:\n\nprisma.User.upsert({\n\n  where: {\n\n    userName: 'Alice',\n\n    profileViews: 1,\n\n    id: 1,\n\n  },\n\n  create: {\n\n    id: 1,\n\n    profileViews: 1,\n\n    userName: 'Alice',\n\n    email: 'alice@prisma.io',\n\n  },\n\n  update: {\n\n    email: 'updated@example.com',\n\n  },\n\n});\n\n\nIn the following query, the values for userName in the where and create options are different, so Prisma Client does not use a database upsert.\n\nprisma.User.upsert({\n\n  where: {\n\n    userName: 'Alice',\n\n  },\n\n  create: {\n\n    id: 1,\n\n    profileViews: 1,\n\n    userName: 'AliceS',\n\n    email: 'alice@prisma.io',\n\n  },\n\n  update: {\n\n    email: 'updated@example.com',\n\n  },\n\n});\n\n\nIn the following query, the selection on the title field in posts is a nested read, so Prisma Client does not use a database upsert.\n\nprisma.user.upsert({\n\n  select: {\n\n    email: true,\n\n    id: true,\n\n    posts: {\n\n      select: {\n\n        title: true,\n\n      },\n\n    },\n\n  },\n\n  where: {\n\n    userName: 'Alice',\n\n  },\n\n\n\n  create: {\n\n    id: 1,\n\n    profileViews: 1,\n\n    userName: 'Alice',\n\n    email: 'alice@prisma.io',\n\n  },\n\n  update: {\n\n    email: 'updated@example.com',\n\n  },\n\n});\n\ndelete()​\n\ndelete deletes an existing database record. You can delete a record:\n\nBy ID\nBy a unique attribute\n\nTo delete records that match a certain criteria, use deleteMany with a filter.\n\nOptions​\nName\tType\tRequired\tDescription\nwhere\tUserWhereUniqueInput\tYes\tWraps all fields of a model so that a record can be selected (learn more).\nBefore version 4.5.0, this type only wraps unique fields of a model.\nselect\tXOR<UserSelect, null>\tNo\tSpecifies which properties to include on the returned object.\ninclude\tXOR<UserInclude, null>\tNo\tSpecifies which relations should be eagerly loaded on the returned object.\nomit\tXOR<UserOmit, null>\tNo\tSpecifies which properties to exclude on the returned object. In Preview since 5.13.0\nrelationLoadStrategy\t'join' or 'query'\tNo\tDefault: join. Specifies the load strategy for a relation query. Only available in combination with include (or select on a relation field). In Preview since 5.9.0.\nReturn type​\nReturn type\tExample\tDescription\nJavaScript object (typed)\tUser\tThe User record that was deleted.\nJavaScript object (plain)\t{ name: \"Alice Wonderland\" }\tData from the User record that was deleted. Use select and include to determine which fields to return.\nPrismaClientKnownRequestError (code P2025)\t\tThrown if the record to delete does not exist. See Error reference\nRemarks​\nTo delete multiple records based on some criteria (for example, all User records with a prisma.io email address, use deleteMany)\nExamples​\nDelete the User record with an id of 1​\nconst user = await prisma.user.delete({\n\n  where: { id: 1 },\n\n});\n\nDelete the User record where email equals elsa@prisma.io​\n\nThe following query deletes a specific user record and uses select to return the name and email of the deleted user:\n\nconst deleteUser = await prisma.user.delete({\n\n  where: {\n\n    email: 'elsa@prisma.io',\n\n  },\n\n  select: {\n\n    email: true,\n\n    name: true,\n\n  },\n\n});\n\nShow CLI results\n{ \"email\": \"elsa@prisma.io\", \"name\": \"Elsa\" }\n\ncreateMany()​\n\ncreateMany creates multiple records in a transaction.\n\nOptions​\nName\tType\tRequired\tDescription\ndata\tEnumerable<UserCreateManyInput>\tYes\tWraps all the model fields in a type so that they can be provided when creating new records. Fields that are marked as optional or have default values in the datamodel are optional.\nskipDuplicates?\tboolean\tNo\tDo not insert records with unique fields or ID fields that already exist. Only supported by databases that support \nON CONFLICT DO NOTHING\n. This excludes MongoDB and SQLServer\nReturn type​\nReturn type\tExample\tDescription\nBatchPayload\t{ count: 3 }\tA count of the number of records created.\nRemarks​\nAs of Prisma ORM version 5.12.0, createMany() is now supported by SQLite.\nThe skipDuplicates option is not supported by MongoDB, SQLServer, or SQLite.\nYou cannot create or connect relations by using nested create, createMany, connect, connectOrCreate queries inside a top-level createMany() query. See here for a workaround.\nYou can use a nested createMany query inside an update() or create() query - for example, add a User and two Post records with a nested createMany at the same time.\nExamples​\nCreate several new users​\nconst users = await prisma.user.createMany({\n\n  data: [\n\n    { name: 'Sonali', email: 'sonali@prisma.io' },\n\n    { name: 'Alex', email: 'alex@prisma.io' },\n\n  ],\n\n});\n\ncreateManyAndReturn()​\n\ncreateManyAndReturn creates multiple records and returns the resulting objects.\n\nINFO\n\nThis feature is available in Prisma ORM version 5.14.0 and later for PostgreSQL, CockroachDB and SQLite.\n\nOptions​\nName\tType\tRequired\tDescription\ndata\tEnumerable<UserCreateManyInput>\tYes\tWraps all the model fields in a type so that they can be provided when creating new records. Fields that are marked as optional or have default values in the datamodel are optional.\nselect\tXOR<UserSelect, null>\tNo\tSpecifies which properties to include on the returned objects.\nomit\tXOR<UserOmit, null>\tNo\tSpecifies which properties to exclude on the returned objects. In Preview since 5.13.0. Mutually exclusive with select.\ninclude\tXOR<UserInclude, null>\tNo\tSpecifies which relations should be eagerly loaded on the returned objects.\nskipDuplicates?\tboolean\tNo\tDo not insert records with unique fields or ID fields that already exist. Only supported by databases that support \nON CONFLICT DO NOTHING\n. This excludes MongoDB and SQLServer\nRemarks​\nThe skipDuplicates option is not supported by SQLite.\nNote that the order of elements returned by createManyAndReturn is not guaranteed.\nYou cannot create or connect relations by using nested create, createMany, connect, connectOrCreate queries inside a top-level createManyAndReturn() query. See here for a workaround.\nWhen relations are included via include, a separate query is generated per relation.\nrelationLoadStrategy: join is not supported.\nReturn type​\nReturn type\tExample\tDescription\nJavaScript array object (typed)\tUser[]\t\nJavaScript array object (plain)\t[{ name: \"Sonali\" }]\tUse select, omit and include to determine which fields to return.\nExamples​\nCreate and return several new users​\nconst users = await prisma.user.createManyAndReturn({\n\n  data: [\n\n    { name: 'Sonali', email: 'sonali@prisma.io' },\n\n    { name: 'Alex', email: 'alex@prisma.io' },\n\n  ],\n\n})\n\nShow CLI results\n[\n\n  { \"id\": 0, \"name\": \"Sonali\", \"email\": \"sonali@prisma.io\", \"profileViews\": 0 },\n\n  { \"id\": 1, \"name\": \"Alex\", \"email\": \"alex@prisma.io\", \"profileViews\": 0  }\n\n]\n\nupdateMany()​\n\nupdateMany updates a batch of existing database records in bulk and returns the number of updated records.\n\nOptions​\nName\tType\tRequired\tDescription\ndata\tXOR<UserUpdateManyMutationInput,\nUserUncheckedUpdateManyInput>\tYes\tWraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional on data.\nwhere\tUserWhereInput\tNo\tWraps all fields of a model so that the list can be filtered by any property. If you do not filter the list, all records will be updated.\nlimit\tnumber\tNo\tLimits the number of records to update.\nReturn type​\nReturn type\tExample\tDescription\nBatchPayload\t{ count: 4 }\tThe count of updated records.\nexport type BatchPayload = {\n\n  count: number;\n\n};\n\nExamples​\nUpdate all User records where the name is Alice to ALICE​\nconst updatedUserCount = await prisma.user.updateMany({\n\n  where: { name: 'Alice' },\n\n  data: { name: 'ALICE' },\n\n});\n\nUpdate all User records where the email contains prisma.io and at least one related Post has more than 10 likes​\nconst updatedUserCount = await prisma.user.updateMany({\n\n  where: {\n\n    email: {\n\n      contains: 'prisma.io',\n\n    },\n\n    posts: {\n\n      some: {\n\n        likes: {\n\n          gt: 10,\n\n        },\n\n      },\n\n    },\n\n  },\n\n  data: {\n\n    role: 'USER',\n\n  },\n\n});\n\nUpdate User records where the email contains prisma.io, but limit to 5 records updated.​\nconst updatedUserCount = await prisma.user.updateMany({\n\n  where: {\n\n    email: {\n\n      contains: 'prisma.io',\n\n    },\n\n  },\n\n  data: {\n\n    role: 'USER',\n\n  },\n\n  limit: 5,\n\n});\n\nupdateManyAndReturn()​\nINFO\n\nThis feature is available in Prisma ORM version 6.2.0 and later for PostgreSQL, CockroachDB and SQLite.\n\nupdateManyAndReturn updates multiple records and returns the resulting objects.\n\nOptions​\nName\tType\tRequired\tDescription\ndata\tXOR<UserUpdateManyMutationInput,\nUserUncheckedUpdateManyInput>\tYes\tWraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional on data.\nwhere\tUserWhereInput\tNo\tWraps all fields of a model so that the list can be filtered by any property. If you do not filter the list, all records will be updated.\nReturn type​\nReturn type\tExample\tDescription\nJavaScript array object (typed)\tUser[]\t\nJavaScript array object (plain)\t[{ name: \"Sonali\" }]\tUse select, omit and include to determine which fields to return.\nExamples​\nUpdate and return multiple users​\nconst users = await prisma.user.updateManyAndReturn({\n\n  where: {\n\n    email: {\n\n      contains: 'prisma.io',\n\n    }\n\n  },\n\n  data: {\n\n    role: 'ADMIN'\n\n  },\n\n})\n\nShow CLI results\n[\n\n  { \"id\": 0, \"name\": \"Sonali\", \"email\": \"sonali@prisma.io\", \"role\": \"ADMIN\", \"profileViews\": 0 },\n\n  { \"id\": 1, \"name\": \"Alex\", \"email\": \"alex@prisma.io\", \"role\": \"ADMIN\", \"profileViews\": 0  }\n\n]\n\ndeleteMany()​\n\ndeleteMany deletes multiple records in a transaction.\n\nOptions​\nName\tType\tRequired\tDescription\nwhere\tUserWhereInput\tNo\tWraps all fields of a model so that the list can be filtered by any field.\nlimit\tInt\tNo\tLimits the number of records deleted.\nReturn type​\nReturn type\tExample\tDescription\nBatchPayload\t{ count: 4 }\tThe count of deleted records.\nexport type BatchPayload = {\n\n  count: number;\n\n};\n\nExamples​\nDelete all User records​\nconst deletedUserCount = await prisma.user.deleteMany({});\n\nDelete all User records where the name is Alice​\nconst deletedUserCount = await prisma.user.deleteMany({\n\n  where: { name: 'Alice' },\n\n});\n\nDelete all User records where the email contains prisma.io, but limit to 5 records deleted.​\nconst deletedUserCount = await prisma.user.deleteMany({\n\n  where: {\n\n    email: {\n\n      contains: 'prisma.io',\n\n    },\n\n  },\n\n  limit: 5,\n\n});\n\n\nSee Filter conditions and operators for examples of how to filter the records to delete.\n\ncount()​\nOptions​\nName\tType\tRequired\tDescription\nwhere\tUserWhereInput\tNo\tWraps all model fields in a type so that the list can be filtered by any property.\norderBy\tXOR<Enumerable<PostOrder\nByInput>, PostOrderByInput>\tNo\tLets you order the returned list by any property.\ncursor\tUserWhereUniqueInput\tNo\tSpecifies the position for the list (the value typically specifies an id or another unique value).\ntake\tnumber\tNo\tSpecifies how many objects should be returned in the list (as seen from the beginning (positive value) or end (negative value) either of the list or from the cursor position if mentioned)\nskip\tnumber\tNo\tSpecifies how many of the returned objects in the list should be skipped.\nReturn type​\nReturn type\tExample\tDescription\nnumber\t29\tThe count of records.\nUserCountAggregateOutputType\t{ _all: 27, name: 10 }\tReturned if select is used.\nExamples​\nCount all User records​\nconst result = await prisma.user.count();\n\nCount all User records with at least one published Post​\nconst result = await prisma.user.count({\n\n  where: {\n\n    post: {\n\n      some: {\n\n        published: true,\n\n      },\n\n    },\n\n  },\n\n});\n\nUse select to perform three separate counts​\n\nThe following query returns:\n\nA count of all records (_all)\nA count of all records with non-null name fields\nA count of all records with non-null city fields\nconst c = await prisma.user.count({\n\n  select: {\n\n    _all: true,\n\n    city: true,\n\n    name: true,\n\n  },\n\n});\n\naggregate()​\n\nSee also: Aggregation, grouping, and summarizing\n\nOptions​\nName\tType\tRequired\tDescription\nwhere\tUserWhereInput\tNo\tWraps all model fields in a type so that the list can be filtered by any property.\norderBy\tXOR<Enumerable<UserOrderByInput>,\nUserOrderByInput>\tNo\tLets you order the returned list by any property.\ncursor\tUserWhereUniqueInput\tNo\tSpecifies the position for the list (the value typically specifies an id or another unique value).\ntake\tnumber\tNo\tSpecifies how many objects should be returned in the list (as seen from the beginning (positive value) or end (negative value) either of the list or from the cursor position if mentioned)\nskip\tnumber\tNo\tSpecifies how many of the returned objects in the list should be skipped.\n_count\ttrue\tNo\tReturns a count of matching records or non-null fields.\n_avg\tUserAvgAggregateInputType\tNo\tReturns an average of all values of the specified field.\n_sum\tUserSumAggregateInputType\tNo\tReturns the sum of all values of the specified field.\n_min\tUserMinAggregateInputType\tNo\tReturns the smallest available value of the specified field.\n_max\tUserMaxAggregateInputType\tNo\tReturns the largest available value of the specified field.\nExamples​\nReturn _min, _max, and _count of profileViews of all User records​\nconst minMaxAge = await prisma.user.aggregate({\n\n  _count: {\n\n    _all: true,\n\n  },\n\n  _max: {\n\n    profileViews: true,\n\n  },\n\n  _min: {\n\n    profileViews: true,\n\n  },\n\n});\n\nShow CLI results\nReturn _sum of all profileViews for all User records​\nconst setValue = await prisma.user.aggregate({\n\n  _sum: {\n\n    profileViews: true,\n\n  },\n\n});\n\nShow CLI results\ngroupBy()​\n\nSee also: Aggregation, grouping, and summarizing\n\nOptions​\nName\tType\tRequired\tDescription\nwhere\tUserWhereInput\tNo\tWraps all model fields in a type so that the list can be filtered by any property.\norderBy\tXOR<Enumerable<UserOrderByInput>,\nUserOrderByInput>\tNo\tLets you order the returned list by any property that is also present in by.\nby\tArray<UserScalarFieldEnum> | string\tNo\tSpecifies the field or combination of fields to group records by.\nhaving\tUserScalarWhereWithAggregatesInput\tNo\tAllows you to filter groups by an aggregate value - for example, only return groups having an average age less than 50.\ntake\tnumber\tNo\tSpecifies how many objects should be returned in the list (as seen from the beginning (positive value) or end (negative value) either of the list or from the cursor position if mentioned)\nskip\tnumber\tNo\tSpecifies how many of the returned objects in the list should be skipped.\n_count\ttrue | UserCountAggregateInputType\tNo\tReturns a count of matching records or non-null fields.\n_avg\tUserAvgAggregateInputType\tNo\tReturns an average of all values of the specified field.\n_sum\tUserSumAggregateInputType\tNo\tReturns the sum of all values of the specified field.\n_min\tUserMinAggregateInputType\tNo\tReturns the smallest available value of the specified field.\n_max\tUserMaxAggregateInputType\tNo\tReturns the largest available value of the specified field.\nExamples​\nGroup by country/city where the average profileViews is greater than 200, and return the _sum of profileViews for each group​\n\nThe query also returns a count of _all records in each group, and all records with non-null city field values in each group.\n\nconst groupUsers = await prisma.user.groupBy({\n\n  by: ['country', 'city'],\n\n  _count: {\n\n    _all: true,\n\n    city: true,\n\n  },\n\n  _sum: {\n\n    profileViews: true,\n\n  },\n\n  orderBy: {\n\n    country: 'desc',\n\n  },\n\n  having: {\n\n    profileViews: {\n\n      _avg: {\n\n        gt: 200,\n\n      },\n\n    },\n\n  },\n\n});\n\nShow CLI results\n[\n\n  {\n\n    country: 'Denmark',\n\n    city: 'Copenhagen',\n\n    _sum: { profileViews: 490 },\n\n    _count: {\n\n      _all: 70,\n\n      city: 8,\n\n    },\n\n  },\n\n  {\n\n    country: 'Sweden',\n\n    city: 'Stockholm',\n\n    _sum: { profileViews: 500 },\n\n    _count: {\n\n      _all: 50,\n\n      city: 3,\n\n    },\n\n  },\n\n];\n\nfindRaw()​\n\nSee: Using Raw SQL (findRaw()).\n\naggregateRaw()​\n\nSee: Using Raw SQL (aggregateRaw()).\n\nModel query options​\nselect​\n\nselect defines which fields are included in the object that Prisma Client returns. See: Select fields and include relations .\n\nRemarks​\nYou cannot combine select and include on the same level.\nIn 3.0.1\n and later, you can select a _count of relations.\nExamples​\nSelect the name and profileViews fields of a single User record​\nconst result = await prisma.user.findUnique({\n\n  where: { id: 1 },\n\n  select: {\n\n    name: true,\n\n    profileViews: true,\n\n  },\n\n});\n\nShow CLI results\nSelect the email and role fields of a multiple User records​\nconst result = await prisma.user.findMany({\n\n  select: {\n\n    email: true,\n\n    role: true,\n\n  },\n\n});\n\nShow CLI results\nSelect a _count of relations​\nconst usersWithCount = await prisma.user.findMany({\n\n  select: {\n\n    _count: {\n\n      select: { posts: true },\n\n    },\n\n  },\n\n});\n\nShow CLI results\nSelect the 'id' and 'title' fields of related Post records​\nconst result = await prisma.user.findMany({\n\n  select: {\n\n    id: true,\n\n    name: true,\n\n    posts: {\n\n      select: {\n\n        id: true,\n\n        title: true,\n\n      },\n\n    },\n\n  },\n\n});\n\nShow CLI results\ninclude inside select​\nconst result = await prisma.user.findMany({\n\n  select: {\n\n    id: true,\n\n    name: true,\n\n    posts: {\n\n      include: {\n\n        author: true,\n\n      },\n\n    },\n\n  },\n\n});\n\nShow CLI results\nGenerated types for select​\n\nThe following example demonstrates how to use the validator with select:\n\nconst selectNameEmailNotPosts = Prisma.validator<Prisma.UserSelect>()({\n\n  name: true,\n\n  email: true,\n\n  posts: false,\n\n});\n\ninclude​\n\ninclude defines which relations are included in the result that Prisma Client returns. See: Select fields and include relations .\n\nRemarks​\nIn 3.0.1\n and later, you can include a _count of relations\nExamples​\nInclude the posts and profile relation when loading User records​\nconst users = await prisma.user.findMany({\n\n  include: {\n\n    posts: true, // Returns all fields for all posts\n\n    profile: true, // Returns all Profile fields\n\n  },\n\n});\n\nInclude the posts relation on the returned objects when creating a new User record with two Post records​\nconst user = await prisma.user.create({\n\n  data: {\n\n    email: 'alice@prisma.io',\n\n    posts: {\n\n      create: [{ title: 'This is my first post' }, { title: 'Here comes a second post' }],\n\n    },\n\n  },\n\n  include: { posts: true }, // Returns all fields for all posts\n\n});\n\nGenerated types for include​\n\nThe following example demonstrates how to use the validator with include:\n\nconst includePosts = Prisma.validator<Prisma.UserInclude>()({\n\n  posts: true,\n\n});\n\nInclude a _count of relations​\nconst usersWithCount = await prisma.user.findMany({\n\n  include: {\n\n    _count: {\n\n      select: { posts: true },\n\n    },\n\n  },\n\n});\n\nShow CLI results\nomit​\n\nomit defines which fields are excluded in the object that Prisma Client returns.\n\nRemarks​\nYou cannot combine omit and select since they serve opposite purposes\nomit was released into General Availability with Prisma ORM 6.2.0. It was available via the omitApi Preview feature in Prisma ORM versions 5.13.0 through 6.1.0.\nExamples​\nOmit the password field from all User records​\nconst result = await prisma.user.findMany({\n\n  omit: {\n\n    password: true,\n\n  },\n\n});\n\nShow CLI results\nOmit the title fields from all User's posts relation​\nconst results = await prisma.user.findMany({\n\n  omit: {\n\n    password: true,\n\n  },\n\n  include: {\n\n    posts: {\n\n      omit: {\n\n        title: true,\n\n      },\n\n    },\n\n  },\n\n});\n\nShow CLI results\nGenerated types for omit​\n\nThe following example demonstrates how to use the validator with omit:\n\nconst omitPassword = Prisma.validator<Prisma.UserOmit>()({\n\n  password: true,\n\n});\n\nrelationLoadStrategy (Preview)​\n\nrelationLoadStrategy specifies how a relation should be loaded from the database. It has two possible values:\n\njoin (default): Uses a database-level LATERAL JOIN (PostgreSQL) or correlated subqueries (MySQL) and fetches all data with a single query to the database.\nquery: Sends multiple queries to the database (one per table) and joins them on the application level.\n\nNote: Once relationLoadStrategy moves from Preview into General Availability, join will universally become the default for all relation queries.\n\nYou can learn more about join strategies here.\n\nBecause the relationLoadStrategy option is currently in Preview, you need to enable it via the relationJoins preview feature flag in your Prisma schema file:\n\ngenerator client {\n\n  provider        = \"prisma-client-js\"\n\n  previewFeatures = [\"relationJoins\"]\n\n}\n\n\nAfter adding this flag, you need to run prisma generate again to re-generate Prisma Client. The relationJoins feature is currently available on PostgreSQL, CockroachDB and MySQL.\n\nRemarks​\nIn most situations, the default join strategy will be more effective. Use query if you want to save resources on your database server or if you profiling shows that the application-level join is more performant.\nYou can only specify the relationLoadStrategy on the top-level in your query. The top-level choice will affect all nested sub-queries.\nExamples​\nLoad the posts relation via a database-level JOIN when using include​\nconst users = await prisma.user.findMany({\n\n  relationLoadStrategy: 'join',\n\n  include: {\n\n    posts: true,\n\n  },\n\n});\n\nLoad the posts relation via a database-level JOIN when using select​\nconst users = await prisma.user.findMany({\n\n  relationLoadStrategy: 'join',\n\n  select: {\n\n    posts: true,\n\n  },\n\n});\n\nwhere​\n\nwhere defines one or more filters, and can be used to filter on record properties (like a user's email address) or related record properties (like a user's top 10 most recent post titles).\n\nExamples​\nconst results = await prisma.user.findMany({\n\n  where: {\n\n    email: {\n\n      endsWith: 'prisma.io',\n\n    },\n\n  },\n\n});\n\nGenerated types for where​\n\nThe following examples demonstrate how to use the validator with where:\n\nUserWhereInput\n\n// UserWhereInput\n\nconst whereNameIs = Prisma.validator<Prisma.UserWhereInput>()({\n\n  name: 'Rich',\n\n});\n\n\n\n// It can be combined with conditional operators too\n\nconst whereNameIs = Prisma.validator<Prisma.UserWhereInput>()({\n\n  name: 'Rich',\n\n  AND: [\n\n    {\n\n      email: {\n\n        contains: 'rich@boop.com',\n\n      },\n\n    },\n\n  ],\n\n});\n\n\nUserWhereUniqueInput This type works by exposing any unique fields on the model. A field assigned @id is considered unique, as is one assigned @unique.\n\nFrom version 4.5.0, this type exposes all fields on the model. This means that when you filter for a single record based on a unique field, you can check additional non-unique and unique fields at the same time. Learn more.\n\n// UserWhereUniqueInput\n\nconst whereEmailIsUnique = Prisma.validator<Prisma.UserWhereUniqueInput>()({\n\n  email: 'rich@boop.com',\n\n})\n\n\nPostScalarWhereInput\n\nconst whereScalarTitleIs = Prisma.validator<Prisma.PostScalarWhereInput>()({\n\n  title: 'boop',\n\n});\n\n\nPostUpdateWithWhereUniqueWithoutAuthorInput - This type accepts a unique where field (an @id or another assigned @unique) and updates any field on the Post model except the Author. The Author is the scalar field on the Post model.\n\nconst updatePostByIdWithoutAuthor =\n\n  Prisma.validator<Prisma.PostUpdateWithWhereUniqueWithoutAuthorInput>()({\n\n    where: {\n\n      id: 1,\n\n    },\n\n    data: {\n\n      content: 'This is some updated content',\n\n      published: true,\n\n      title: 'This is a new title',\n\n    },\n\n  });\n\n\nPostUpsertWithWhereUniqueWithoutAuthorInput - This type will update the Post records title field where the id matches, if it doesn't exist it will create it instead.\n\nconst updatePostTitleOrCreateIfNotExist =\n\n  Prisma.validator<Prisma.PostUpsertWithWhereUniqueWithoutAuthorInput>()({\n\n    where: {\n\n      id: 1,\n\n    },\n\n    update: {\n\n      title: 'This is a new title',\n\n    },\n\n    create: {\n\n      id: 1,\n\n      title: 'If the title doesnt exist, then create one with this text',\n\n    },\n\n  });\n\n\nPostUpdateManyWithWhereWithoutAuthorInput - This type will update all Post records where published is set to false.\n\nconst publishAllPosts = Prisma.validator<Prisma.PostUpdateManyWithWhereWithoutAuthorInput>()({\n\n  where: {\n\n    published: {\n\n      equals: false,\n\n    },\n\n  },\n\n  data: {\n\n    published: true,\n\n  },\n\n});\n\norderBy​\n\nSorts a list of records. See also: Sorting\n\nRemarks​\n\nIn 2.16.0\n and later, you can order by relation fields - for example, order posts by the author's name.\n\nIn 3.5.0\n and later, in PostgreSQL you can order by relevance. For details, see Sort by relevance.\n\nIn 4.1.0\n and later, you can sort null records first or last. For details, see Sort with nulls first or last.\n\nInputs for sort argument​\nName\tDescription\nasc\tSort ascending (A → Z)\ndesc\tSort descending (Z → A)\nInputs for nulls argument​\n\nNote:\n\nThis argument is optional.\nIt is for use on optional scalar fields only. If you try to sort by nulls on a required or relation field, Prisma Client throws a P2009 error.\nIt is available in version 4.1.0 and later, as a preview feature. See sort with nulls first or last for details of how to enable the feature.\nName\tDescription\nfirst\tSort with null values first.\nlast\tSort with null values last.\nExamples​\nSort User by email field​\n\nThe following example returns all User records sorted by email ascending:\n\nconst users = await prisma.user.findMany({\n\n  orderBy: {\n\n    email: 'asc',\n\n  },\n\n});\n\n\nThe following example returns all User records sorted by email descending:\n\nconst users = await prisma.user.findMany({\n\n  orderBy: {\n\n    email: 'desc',\n\n  },\n\n});\n\nSort Post by the related User record's name​\n\nThe following query orders posts by user name:\n\nconst posts = await prisma.post.findMany({\n\n  orderBy: {\n\n    author: {\n\n      name: 'asc',\n\n    },\n\n  },\n\n});\n\nSort Post by the related User record's name, with null records first​\n\nThe following query orders posts by user name, with null records first:\n\nconst posts = await prisma.post.findMany({\n\n  orderBy: {\n\n    author: {\n\n      name: { sort: 'asc', nulls: 'first' },\n\n    },\n\n  },\n\n});\n\nSort Post by relevance of the title​\nINFO\n\nFor PostgreSQL, this feature is still in Preview. Enable the fullTextSearchPostgres feature flag in order to use it.\n\nThe following query orders posts by relevance of the search term 'database' to the title:\n\nconst posts = await prisma.post.findMany({\n\n  orderBy: {\n\n    _relevance: {\n\n      fields: ['title'],\n\n      search: 'database',\n\n      sort: 'asc'\n\n    },\n\n})\n\nSort User by the posts count​\n\nThe following query orders users by post count:\n\nconst getActiveusers = await prisma.user.findMany({\n\n  orderBy: {\n\n    posts: {\n\n      count: 'desc',\n\n    },\n\n  },\n\n});\n\nSort User by multiple fields - email and role​\n\nThe following example sorts users by two fields - first email, then role:\n\nconst users = await prisma.user.findMany({\n\n  select: {\n\n    email: true,\n\n    role: true,\n\n  },\n\n  orderBy: [\n\n    {\n\n      email: 'desc',\n\n    },\n\n    {\n\n      role: 'desc',\n\n    },\n\n  ],\n\n});\n\nShow CLI results\n\nThe order of sorting parameters matters - the following query sorts by role, then email. Note the difference in the results:\n\nconst users = await prisma.user.findMany({\n\n  select: {\n\n    email: true,\n\n    role: true,\n\n  },\n\n  orderBy: [\n\n    {\n\n      role: 'desc',\n\n    },\n\n    {\n\n      email: 'desc',\n\n    },\n\n  ],\n\n});\n\nShow CLI results\nSort User by email, select name and email​\n\nThe following example returns all the name and email fields of all User records, sorted by email:\n\nconst users3 = await prisma.user.findMany({\n\n  orderBy: {\n\n    email: 'asc',\n\n  },\n\n  select: {\n\n    name: true,\n\n    email: true,\n\n  },\n\n});\n\nShow CLI results\nSort User records by email and sort nested Post records by title​\n\nThe following example:\n\nReturns all User records sorted by email\nFor each User record, returns the title field of all nested Post records sorted by title\nconst usersWithPosts = await prisma.user.findMany({\n\n  orderBy: {\n\n    email: 'asc',\n\n  },\n\n  include: {\n\n    posts: {\n\n      select: {\n\n        title: true,\n\n      },\n\n      orderBy: {\n\n        title: 'asc',\n\n      },\n\n    },\n\n  },\n\n});\n\nShow CLI results\nSort one user's nested list of Post records​\n\nThe following example retrieves a single User record by ID, as well as a list of nested Post records sorted by title:\n\nconst userWithPosts = await prisma.user.findUnique({\n\n  where: {\n\n    id: 1,\n\n  },\n\n  include: {\n\n    posts: {\n\n      orderBy: {\n\n        title: 'desc',\n\n      },\n\n      select: {\n\n        title: true,\n\n        published: true,\n\n      },\n\n    },\n\n  },\n\n});\n\nShow CLI results\nSort by enum​\n\nThe following sorts all User records by role (an enum):\n\nconst sort = await prisma.user.findMany({\n\n  orderBy: {\n\n    role: 'desc',\n\n  },\n\n  select: {\n\n    email: true,\n\n    role: true,\n\n  },\n\n});\n\nShow CLI results\nGenerated types for orderBy​\n\nThe following examples demonstrate how to use the validator with orderBy:\n\nUserOrderByInput\nconst orderEmailsByDescending = Prisma.validator<Prisma.UserOrderByInput>()({\n\n  email: 'desc',\n\n});\n\ndistinct​\n\nDeduplicate a list of records from findMany or findFirst. See also: Aggregation, grouping, and summarizing\n\nExamples​\nSelect distinct on a single field​\n\nThe following example returns all distinct city fields, and selects only the city and country fields:\n\nconst distinctCities = await prisma.user.findMany({\n\n  select: {\n\n    city: true,\n\n    country: true,\n\n  },\n\n  distinct: ['city'],\n\n});\n\nShow CLI results\n[\n\n  { city: 'Paris', country: 'France' },\n\n  { city: 'Lyon', country: 'France' },\n\n];\n\nSelect distinct on multiple fields​\n\nThe following example returns all distinct city and country field combinations, and selects only the city and country fields:\n\nconst distinctCitiesAndCountries = await prisma.user.findMany({\n\n  select: {\n\n    city: true,\n\n    country: true,\n\n  },\n\n  distinct: ['city', 'country'],\n\n});\n\nShow CLI results\n[\n\n  { city: 'Paris', country: 'France' },\n\n  { city: 'Paris', country: 'Denmark' },\n\n  { city: 'Lyon', country: 'France' },\n\n];\n\n\nNote that there is now a \"Paris, Denmark\" in addition to \"Paris, France\":\n\nSelect distinct in combination with a filter​\n\nThe following example returns all distinct city and country field combinations where the user's email contains \"prisma.io\", and selects only the city and country fields:\n\nconst distinctCitiesAndCountries = await prisma.user.findMany({\n\n  where: {\n\n    email: {\n\n      contains: 'prisma.io',\n\n    },\n\n  },\n\n  select: {\n\n    city: true,\n\n    country: true,\n\n  },\n\n  distinct: ['city', 'country'],\n\n});\n\nShow CLI results\nnativeDistinct​\n\nEnabling nativeDistinct in your Prisma schema pushes the distinct operation to the database layer (where supported). This can significantly improve performance. However, note that:\n\nSome databases may not fully support DISTINCT on certain field combinations.\nBehavior can differ among providers.\n\nTo enable nativeDistinct:\n\ngenerator client {\n\n  provider        = \"prisma-client-js\"\n\n  previewFeatures = [\"nativeDistinct\"]\n\n}\n\n\nSee Preview Features for more details.\n\nNested queries​\ncreate​\n\nA nested create query adds a new related record or set of records to a parent record. See: Working with relations\n\nRemarks​\ncreate is available as a nested query when you create() (prisma.user.create(...)) a new parent record or update() (prisma.user.update(...)) an existing parent record.\nYou can use a nested create or a nested createMany to create multiple related records. If you require the skipDuplicates query option you should use createMany.\nExamples​\nCreate a new User record with a new Profile record​\nconst user = await prisma.user.create({\n\n  data: {\n\n    email: 'alice@prisma.io',\n\n    profile: {\n\n      create: { bio: 'Hello World' },\n\n    },\n\n  },\n\n});\n\nCreate a new Profile record with a new User record​\nconst user = await prisma.profile.create({\n\n  data: {\n\n    bio: 'Hello World',\n\n    user: {\n\n      create: { email: 'alice@prisma.io' },\n\n    },\n\n  },\n\n})\n\nCreate a new User record with a new Post record​\nconst user = await prisma.user.create({\n\n  data: {\n\n    email: 'alice@prisma.io',\n\n    posts: {\n\n      create: { title: 'Hello World' },\n\n    },\n\n  },\n\n});\n\nCreate a new User record with two new Post records​\n\nBecause it's a one-to-many relation, you can also create multiple Post records at once by passing an array to create:\n\nconst user = await prisma.user.create({\n\n  data: {\n\n    email: 'alice@prisma.io',\n\n    posts: {\n\n      create: [\n\n        {\n\n          title: 'This is my first post',\n\n        },\n\n        {\n\n          title: 'Here comes a second post',\n\n        },\n\n      ],\n\n    },\n\n  },\n\n});\n\n\nNote: You can also use a nested createMany to achieve the same result.\n\nUpdate an existing User record by creating a new Profile record​\nconst user = await prisma.user.update({\n\n  where: { email: 'alice@prisma.io' },\n\n  data: {\n\n    profile: {\n\n      create: { bio: 'Hello World' },\n\n    },\n\n  },\n\n});\n\nUpdate an existing User record by creating a new Post record​\nconst user = await prisma.user.update({\n\n  where: { email: 'alice@prisma.io' },\n\n  data: {\n\n    posts: {\n\n      create: { title: 'Hello World' },\n\n    },\n\n  },\n\n})\n\ncreateMany​\n\nA nested createMany query adds a new set of records to a parent record. See: Working with relations\n\nRemarks​\ncreateMany is available as a nested query when you create() (prisma.user.create(...)) a new parent record or update() (prisma.user.update(...)) an existing parent record.\nAvailable in the context of a one-to-many relation — for example, you can prisma.user.create(...) a user and use a nested createMany to create multiple posts (posts have one user).\nNot available in the context of a many-to-many relation — for example, you cannot prisma.post.create(...) a post and use a nested createMany to create categories (many posts have many categories).\nYou cannot nest an additional create or createMany.\nAllows setting foreign keys directly — for example, setting the categoryId on a post.\nAs of Prisma ORM version 5.12.0, nested createMany is supported by SQLite.\nYou can use a nested create or a nested createMany to create multiple related records - if you do not need the skipDuplicates query option, you should probably use create.\nOptions​\nName\tType\tRequired\tDescription\ndata\tEnumerable<UserCreateManyInput>\tYes\tWraps all the model fields in a type so that they can be provided when creating new records. Fields that are marked as optional or have default values in the datamodel are optional.\nskipDuplicates?\tboolean\tNo\tDo not insert records with unique fields or ID fields that already exist. Only supported by databases that support \nON CONFLICT DO NOTHING\n. This excludes MongoDB and SQLServer\nExamples​\nUpdate a User and multiple new related Post records​\nconst user = await prisma.user.update({\n\n  where: {\n\n    id: 9,\n\n  },\n\n  data: {\n\n    name: 'Elliott',\n\n    posts: {\n\n      createMany: {\n\n        data: [{ title: 'My first post' }, { title: 'My second post' }],\n\n      },\n\n    },\n\n  },\n\n});\n\nset​\n\nset overwrites the value of a relation - for example, replacing a list of Post records with a different list. See: Working with relations\n\nExamples​\nUpdate an existing User record by disconnecting any previous Post records and connecting two other existing ones​\nconst user = await prisma.user.update({\n\n  where: { email: 'alice@prisma.io' },\n\n  data: {\n\n    posts: {\n\n      set: [{ id: 32 }, { id: 42 }],\n\n    },\n\n  },\n\n});\n\nconnect​\n\nA nested connect query connects a record to an existing related record by specifying an ID or unique identifier. See: Working with relations\n\nRemarks​\n\nconnect is available as a nested query when you create a new parent record or update an existing parent record.\n\nIf the related record does not exist, Prisma Client throws an exception:\n\nThe required connected records were not found. Expected 1 records to be connected, found 0.\n\n\nWhen using set and connect together, the order in which they are applied significantly impacts the result. If set is used before connect, the connected records will only reflect the final state established by the connect operation, as set clears all existing connections before connect establishes new ones. Conversely, if connect is applied before set, the set operation will override the connect action by clearing all connected records and replacing them with its own specified state.\n\nExamples​\nCreate a new Profile record and connect it to an existing User record via unique field​\nconst user = await prisma.profile.create({\n\n  data: {\n\n    bio: 'Hello World',\n\n    user: {\n\n      connect: { email: 'alice@prisma.io' },\n\n    },\n\n  },\n\n});\n\nCreate a new Profile record and connect it to an existing User record via an ID field​\nconst user = await prisma.profile.create({\n\n  data: {\n\n    bio: 'Hello World',\n\n    user: {\n\n      connect: { id: 42 }, // sets userId of Profile record\n\n    },\n\n  },\n\n});\n\n\nIn 2.11.0\n and later, you can set the foreign key directly:\n\nconst user = await prisma.profile.create({\n\n  data: {\n\n    bio: 'Hello World',\n\n    userId: 42,\n\n  },\n\n});\n\n\nHowever, you can't use both the direct approach and the connect approach in the same query. See this issue comment\n for details.\n\nCreate a new Post record and connect it to an existing User record​\nconst user = await prisma.post.create({\n\n  data: {\n\n    title: 'Hello World',\n\n    author: {\n\n      connect: { email: 'alice@prisma.io' },\n\n    },\n\n  },\n\n});\n\nUpdate an existing User record by connecting it to an existing Profile record​\nconst user = await prisma.user.update({\n\n  where: { email: 'alice@prisma.io' },\n\n  data: {\n\n    profile: {\n\n      connect: { id: 24 },\n\n    },\n\n  },\n\n});\n\nUpdate an existing User record by connecting it to two existing Post records​\nconst user = await prisma.user.update({\n\n  where: { email: 'alice@prisma.io' },\n\n  data: {\n\n    posts: {\n\n      connect: [{ id: 24 }, { id: 42 }],\n\n    },\n\n  },\n\n});\n\nconnectOrCreate​\n\nconnectOrCreate either connects a record to an existing related record by ID or unique identifier or creates a new related record if the record does not exist. See: Working with relations\n\nRemarks​\n\nMultiple connectOrCreate queries that run as concurrent transactions can result in a race condition. Consider the following example, where two queries attempt to connectOrCreate a blog post tag named computing at the same time (tag names must be unique):\n\nQuery A\nQuery B\nconst createPost = await prisma.post.create({\n\n  data: {\n\n    title: 'How to create a compiler',\n\n    content: '...',\n\n    author: {\n\n      connect: {\n\n        id: 9,\n\n      },\n\n    },\n\n    tags: {\n\n      connectOrCreate: {\n\n        create: {\n\n          name: 'computing',\n\n        },\n\n        where: {\n\n          name: 'computing',\n\n        },\n\n      },\n\n    },\n\n  },\n\n})\n\n\nIf query A and query B overlap in the following way, query A results in an exception:\n\nQuery A (Fail ❌)\tQuery B (Success ✅)\nQuery hits server, starts transaction A\tQuery hits server, starts transaction B\n\tFind record where tagName equals computing, record not found\nFind record where tagName equals computing, record not found\t\n\tCreate record where tagName equals computing and connect\nCreate record where tagName equals computing\t\nUnique violation, record already created by transaction B\t\n\nTo work around this scenario, we recommend catching the unique violation exception (PrismaClientKnownRequestError, error P2002) and retrying failed queries.\n\nExamples​\nCreate a new Profile record, then connect it to an existing User record or create a new User​\n\nThe following example:\n\nCreates a Profile\nAttempts to connect the profile to a User where the email address is alice@prisma.io\nCreates a new user if a matching user does not exist\nconst user = await prisma.profile.create({\n\n  data: {\n\n    bio: 'The coolest Alice on the planet',\n\n    user: {\n\n      connectOrCreate: {\n\n        where:  { email: 'alice@prisma.io' },\n\n        create: { email: 'alice@prisma.io'}\n\n    },\n\n  },\n\n})\n\nCreate a new Post record and connect it to an existing User record, or create a new User​\nconst user = await prisma.post.create({\n\n  data: {\n\n    title: 'Hello World',\n\n    author: {\n\n      connectOrCreate: {\n\n        where: { email: 'alice@prisma.io' },\n\n        create: { email: 'alice@prisma.io' },\n\n      },\n\n    },\n\n  },\n\n});\n\nUpdate an existing User record by connecting it to an existing Profile record, or creating a new Profile record​\n\nThe following example:\n\nAttempts to connect the user to a Profile with an id of 20\nCreates a new profile if a matching profile does not exist\nconst updateUser = await prisma.user.update({\n\n  where: { email: 'alice@prisma.io' },\n\n  data: {\n\n    profile: {\n\n      connectOrCreate: {\n\n        where: { id: 20 },\n\n        create: {\n\n          bio: 'The coolest Alice in town',\n\n        },\n\n      },\n\n    },\n\n  },\n\n});\n\nUpdate an existing User record by connect it to two existing Post records, or creating two new Post records​\nconst user = await prisma.user.update({\n\n  where: { email: 'alice@prisma.io' },\n\n  data: {\n\n    posts: {\n\n      connectOrCreate: [\n\n        {\n\n          where: { id: 32 },\n\n          create: { title: 'This is my first post' },\n\n        },\n\n        {\n\n          where: { id: 19 },\n\n          create: { title: 'This is my second post' },\n\n        },\n\n      ],\n\n    },\n\n  },\n\n});\n\ndisconnect​\n\nA nested disconnect query breaks the connection between a parent record and a related record, but does not delete either record. See: Working with relations\n\nRemarks​\n\ndisconnect is only available if the relation is optional.\n\nIf the relationship you are attempting to disconnect does not exist:\n\n(In 2.21.0 and later\n), the operation does nothing\n\n(Before 2.21.0\n) Prisma Client throws an exception if the provided ID or unique identifier is not connected:\n\nThe records for relation `PostToUser` between the `User` and `Post` models are not connected.\n\nExamples​\nUpdate an existing User record by disconnecting the Profile record it's connected to​\nconst user = await prisma.user.update({\n\n  where: { email: 'bob@prisma.io' },\n\n  data: {\n\n    profile: {\n\n      disconnect: true,\n\n    },\n\n  },\n\n});\n\nUpdate an existing User record by disconnecting two Post records it's connected to​\nconst user = await prisma.user.update({\n\n  where: { email: 'alice@prisma.io' },\n\n  data: {\n\n    posts: {\n\n      disconnect: [{ id: 44 }, { id: 46 }],\n\n    },\n\n  },\n\n});\n\nupdate​\n\nA nested update query updates one or more related records where the parent record's ID is n. See: Working with relations\n\nRemarks​\n\nNested update queries are only available in the context of a top-level update query (for example, prisma.user.update(...)).\n\nIf the parent record does not exist, Prisma Client throws an exception:\n\nAssertionError(\"Expected a valid parent ID to be present for nested update to-one case.\")\n\n\nIf the related record that you want to update does not exist, Prisma Client throws an exception:\n\nAssertionError(\"Expected a valid parent ID to be present for nested update to-one case.\")\n\nExamples​\nUpdate an existing User record by updating the Profile record it's connected to​\nconst user = await prisma.user.update({\n\n  where: { email: 'alice@prisma.io' },\n\n  data: {\n\n    profile: {\n\n      update: { bio: 'Hello World' },\n\n    },\n\n  },\n\n});\n\nUpdate an existing User record by updating two Post records it's connected to​\nconst user = await prisma.user.update({\n\n  where: { email: 'alice@prisma.io' },\n\n  data: {\n\n    posts: {\n\n      update: [\n\n        {\n\n          data: { published: true },\n\n          where: { id: 32 },\n\n        },\n\n        {\n\n          data: { published: true },\n\n          where: { id: 23 },\n\n        },\n\n      ],\n\n    },\n\n  },\n\n});\n\nupsert​\nINFO\n\nThis section covers the usage of nested upsert within update(). To learn about the upsert() operation, reference the linked documentation.\n\nA nested upsert query updates a related record if it exists, or creates a new related record.\n\nExamples​\nUpdate an existing User record by updating the Profile record it's connected to or creating a new one (upsert)​\nconst user = await prisma.user.update({\n\n  where: { email: 'alice@prisma.io' },\n\n  data: {\n\n    profile: {\n\n      upsert: {\n\n        create: { bio: 'Hello World' },\n\n        update: { bio: 'Hello World' },\n\n      },\n\n    },\n\n  },\n\n});\n\nUpdate an existing User record by updating two Post record it's connected to or creating new ones (upsert)​\nconst user = await prisma.user.update({\n\n  where: { email: 'alice@prisma.io' },\n\n  data: {\n\n    posts: {\n\n      upsert: [\n\n        {\n\n          create: { title: 'This is my first post' },\n\n          update: { title: 'This is my first post' },\n\n          where: { id: 32 },\n\n        },\n\n        {\n\n          create: { title: 'This is my second post' },\n\n          update: { title: 'This is my second post' },\n\n          where: { id: 23 },\n\n        },\n\n      ],\n\n    },\n\n  },\n\n});\n\ndelete​\n\nA nested delete query deletes a related record. The parent record is not deleted.\n\nRemarks​\ndelete is only available if the relation is optional.\nExamples​\nUpdate an existing User record by deleting the Profile record it's connected to​\nconst user = await prisma.user.update({\n\n  where: { email: 'alice@prisma.io' },\n\n  data: {\n\n    profile: {\n\n      delete: true,\n\n    },\n\n  },\n\n});\n\nUpdate an existing User record by deleting two Post records it's connected to​\nconst user = await prisma.user.update({\n\n  where: { email: 'alice@prisma.io' },\n\n  data: {\n\n    posts: {\n\n      delete: [{ id: 34 }, { id: 36 }],\n\n    },\n\n  },\n\n});\n\nupdateMany​\n\nA nested updateMany updates a list of related records and supports filtering - for example, you can update a user's unpublished posts.\n\nExamples​\nUpdate all unpublished posts belonging to a specific user​\nconst result = await prisma.user.update({\n\n  where: {\n\n    id: 2,\n\n  },\n\n  data: {\n\n    posts: {\n\n      updateMany: {\n\n        where: {\n\n          published: false,\n\n        },\n\n        data: {\n\n          likes: 0,\n\n        },\n\n      },\n\n    },\n\n  },\n\n});\n\ndeleteMany​\n\nA nested deleteMany deletes related records and supports filtering. For example, you can delete a user's posts while updating other properties of that user.\n\nExamples​\nDelete all posts belonging to a specific user as part of an update​\nconst result = await prisma.user.update({\n\n  where: {\n\n    id: 2,\n\n  },\n\n  data: {\n\n    name: 'Updated name',\n\n    posts: {\n\n      deleteMany: {},\n\n    },\n\n  },\n\n});\n\nFilter conditions and operators​\nequals​\n\nValue equals n.\n\nExamples​\n\nReturn all users where name equals \"Eleanor\"\n\nconst result = await prisma.user.findMany({\n\n  where: {\n\n    name: {\n\n      equals: 'Eleanor',\n\n    },\n\n  },\n\n});\n\n\nYou can also exclude the equals:\n\nconst result = await prisma.user.findMany({\n\n  where: {\n\n    name: 'Eleanor',\n\n  },\n\n});\n\n\nReturn all products with a quantity lower than the \"warn quantity\" threshold\n\nThis example compares fields of the same model which is available as of version 4.3.0.\n\nconst productsWithLowQuantity = await prisma.product.findMany({\n\n  where: {\n\n    quantity: {\n\n      lte: prisma.product.fields.warnQuantity\n\n    },\n\n  },\n\n});\n\n\nReturn all users that have blue and green as their favorite colors\n\nThis example finds users that have set their favoriteColors field to ['blue', 'green'].\n\nNote that when using equals, order of elements matters. That is to say ['blue', 'green'] is not equal to ['green', 'blue']\n\nconst favoriteColorFriends = await prisma.user.findMany({\n\n  where: {\n\n    favoriteColors: {\n\n      equals: ['blue', 'green'],\n\n    },\n\n  },\n\n});\n\nnot​\n\nValue does not equal n.\n\nExamples​\nReturn all users where name does not equal \"Eleanor\"​\nconst result = await prisma.user.findMany({\n\n  where: {\n\n    name: {\n\n      not: 'Eleanor',\n\n    },\n\n  },\n\n});\n\nWARNING\n\nnot will return all items that do not match a given value. However, if the column is nullable, NULL values will not be returned. If you require null values to be returned, use an OR operator to include NULL values.\n\nReturn all users where name does not equal \"Eleanor\" including users where name is NULL​\nawait prisma.user.findMany({\n\n  where: {\n\n    OR: [\n\n      { name: { not: 'Eleanor' } },\n\n      { name: null }\n\n    ]\n\n  }\n\n})\n\nin​\n\nValue n exists in list.\n\nNOTE\n\nnull values are not returned. For example, if you combine in and NOT to return a user whose name is not in the list, users with null value names are not returned.\n\nExamples​\nGet User records where the id can be found in the following list: [22, 91, 14, 2, 5]​\nconst getUser = await prisma.user.findMany({\n\n  where: {\n\n    id: { in: [22, 91, 14, 2, 5] },\n\n  },\n\n});\n\nGet User records where the name can be found in the following list: ['Saqui', 'Clementine', 'Bob']​\nconst getUser = await prisma.user.findMany({\n\n  where: {\n\n    name: { in: ['Saqui', 'Clementine', 'Bob'] },\n\n  },\n\n});\n\nGet User records where name is not present in the list​\n\nThe following example combines in and NOT. You can also use notIn.\n\nconst getUser = await prisma.user.findMany({\n\n  where: {\n\n    NOT: {\n\n      name: { in: ['Saqui', 'Clementine', 'Bob'] },\n\n    },\n\n  },\n\n});\n\nGet a User record where at least one Post has at least one specified Category​\nconst getUser = await prisma.user.findMany({\n\n  where: {\n\n    // Find users where..\n\n    posts: {\n\n      some: {\n\n        // ..at least one (some) posts..\n\n        categories: {\n\n          some: {\n\n            // .. have at least one category ..\n\n            name: {\n\n              in: ['Food', 'Introductions'], // .. with a name that matches one of the following.\n\n            },\n\n          },\n\n        },\n\n      },\n\n    },\n\n  },\n\n});\n\nnotIn​\n\nValue n does not exist in list.\n\nRemarks​\nnull values are not returned.\nExamples​\nGet User records where the id can not be found in the following list: [22, 91, 14, 2, 5]​\nconst getUser = await prisma.user.findMany({\n\n  where: {\n\n    id: { notIn: [22, 91, 14, 2, 5] },\n\n  },\n\n});\n\nlt​\n\nValue n is less than x.\n\nExamples​\nGet all Post records where likes is less than 9​\nconst getPosts = await prisma.post.findMany({\n\n  where: {\n\n    likes: {\n\n      lt: 9,\n\n    },\n\n  },\n\n});\n\nlte​\n\nValue n is less than or equal to x.\n\nExamples​\nGet all Post records where likes is less or equal to 9​\nconst getPosts = await prisma.post.findMany({\n\n  where: {\n\n    likes: {\n\n      lte: 9,\n\n    },\n\n  },\n\n});\n\ngt​\n\nValue n is greater than x.\n\nExamples​\nGet all Post records where likes is greater than 9​\nconst getPosts = await prisma.post.findMany({\n\n  where: {\n\n    likes: {\n\n      gt: 9,\n\n    },\n\n  },\n\n});\n\ngte​\n\nValue n is greater than or equal to x.\n\nExamples​\nGet all Post records where likes is greater than or equal to 9​\nconst getPosts = await prisma.post.findMany({\n\n  where: {\n\n    likes: {\n\n      gte: 9,\n\n    },\n\n  },\n\n});\n\nExamples​\nGet all Post records where date_created is greater than March 19th, 2020​\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    date_created: {\n\n      gte: new Date('2020-03-19T14:21:00+0200') /* Includes time offset for UTC */,\n\n    },\n\n  },\n\n});\n\ncontains​\n\nValue n contains x.\n\nExamples​\nCount all Post records where content contains databases​\nconst result = await prisma.post.count({\n\n  where: {\n\n    content: {\n\n      contains: 'databases',\n\n    },\n\n  },\n\n});\n\nCount all Post records where content does not contain databases​\nconst result = await prisma.post.count({\n\n  where: {\n\n    NOT: {\n\n      content: {\n\n        contains: 'databases',\n\n      },\n\n    },\n\n  },\n\n});\n\nsearch​\n\nUse Full-Text Search to search within a String field.\n\nINFO\n\nFor PostgreSQL, this feature is still in Preview. Enable the fullTextSearchPostgres feature flag in order to use it.\n\nExamples​\nFind all posts with a title that contains cat or dog.​\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    title: {\n\n      search: 'cat | dog',\n\n    },\n\n  },\n\n});\n\nFind all posts with a title that contains cat and dog.​\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    title: {\n\n      search: 'cat & dog',\n\n    },\n\n  },\n\n});\n\nFind all posts with a title that doesn't contain cat.​\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    title: {\n\n      search: '!cat',\n\n    },\n\n  },\n\n});\n\nmode​\nRemarks​\nSupported by the PostgreSQL and MongoDB connectors only\nExamples​\nGet all Post records where title contains prisma, in a case insensitive way​\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    title: {\n\n      contains: 'prisma',\n\n      mode: 'insensitive',\n\n    },\n\n  },\n\n});\n\nstartsWith​\nExamples​\nGet all Post records where title starts with Pr (such as Prisma)​\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    title: {\n\n      startsWith: 'Pr',\n\n    },\n\n  },\n\n});\n\nendsWith​\nGet all User records where email ends with prisma.io​\nconst result = await prisma.user.findMany({\n\n  where: {\n\n    email: {\n\n      endsWith: 'prisma.io',\n\n    },\n\n  },\n\n});\n\nAND​\n\nAll conditions must return true. Alternatively, pass a list of objects into the where clause - the AND operator is not required.\n\nExamples​\nGet all Post records where the content field contains Prisma and published is false​\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    AND: [\n\n      {\n\n        content: {\n\n          contains: 'Prisma',\n\n        },\n\n      },\n\n      {\n\n        published: {\n\n          equals: false,\n\n        },\n\n      },\n\n    ],\n\n  },\n\n});\n\nGet all Post records where the content field contains Prisma and published is false (no AND)​\n\nThe following format returns the same results as the previous example without the AND operator:\n\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    content: {\n\n      contains: 'Prisma',\n\n    },\n\n    published: {\n\n      equals: false,\n\n    },\n\n  },\n\n});\n\nGet all Post records where the title field contains Prisma or databases, and published is false​\n\nThe following example combines OR and AND:\n\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    OR: [\n\n      {\n\n        title: {\n\n          contains: 'Prisma',\n\n        },\n\n      },\n\n      {\n\n        title: {\n\n          contains: 'databases',\n\n        },\n\n      },\n\n    ],\n\n    AND: {\n\n      published: false,\n\n    },\n\n  },\n\n});\n\nOR​\n\nOne or more conditions must return true.\n\nExamples​\nGet all Post records where the title field contains Prisma or databases​\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    OR: [\n\n      {\n\n        title: {\n\n          contains: 'Prisma',\n\n        },\n\n      },\n\n      {\n\n        title: {\n\n          contains: 'databases',\n\n        },\n\n      },\n\n    ],\n\n  },\n\n});\n\nGet all Post records where the title field contains Prisma or databases, but not SQL​\n\nThe following example combines OR and NOT:\n\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    OR: [\n\n      {\n\n        title: {\n\n          contains: 'Prisma',\n\n        },\n\n      },\n\n      {\n\n        title: {\n\n          contains: 'databases',\n\n        },\n\n      },\n\n    ],\n\n    NOT: {\n\n      title: {\n\n        contains: 'SQL',\n\n      },\n\n    },\n\n  },\n\n});\n\nGet all Post records where the title field contains Prisma or databases, and published is false​\n\nThe following example combines OR and AND:\n\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    OR: [\n\n      {\n\n        title: {\n\n          contains: 'Prisma',\n\n        },\n\n      },\n\n      {\n\n        title: {\n\n          contains: 'databases',\n\n        },\n\n      },\n\n    ],\n\n    AND: {\n\n      published: false,\n\n    },\n\n  },\n\n});\n\nNOT​\n\nAll conditions must return false.\n\nExamples​\nGet all Post records where the title does not contain SQL​\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    NOT: {\n\n      title: {\n\n        contains: 'SQL',\n\n      },\n\n    },\n\n  },\n\n});\n\nGet all Post records where the title field contains Prisma or databases, but not SQL, and the related User record' email address does not contain sarah​\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    OR: [\n\n      {\n\n        title: {\n\n          contains: 'Prisma',\n\n        },\n\n      },\n\n      {\n\n        title: {\n\n          contains: 'databases',\n\n        },\n\n      },\n\n    ],\n\n    NOT: {\n\n      title: {\n\n        contains: 'SQL',\n\n      },\n\n    },\n\n    user: {\n\n      NOT: {\n\n        email: {\n\n          contains: 'sarah',\n\n        },\n\n      },\n\n    },\n\n  },\n\n  include: {\n\n    user: true,\n\n  },\n\n});\n\nRelation filters​\nsome​\n\nReturns all records where one or more (\"some\") related records match filtering criteria.\n\nRemarks​\nYou can use some without parameters to return all records with at least one relation\nExamples​\nGet all User records where some posts mention Prisma​\nconst result = await prisma.user.findMany({\n\n  where: {\n\n    post: {\n\n      some: {\n\n        content: {\n\n          contains: \"Prisma\"\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\nevery​\n\nReturns all records where all (\"every\") related records match filtering criteria.\n\nExamples​\nGet all User records where all posts are published​\nconst result = await prisma.user.findMany({\n\n  where: {\n\n    post: {\n\n      every: {\n\n        published: true\n\n      },\n\n    }\n\n  }\n\n}\n\nnone​\n\nReturns all records where zero related records match filtering criteria.\n\nRemarks​\nYou can use none without parameters to return all records with no relations\nExamples​\nGet all User records with zero posts​\nconst result = await prisma.user.findMany({\n\n  where: {\n\n    post: {\n\n        none: {} // User has no posts\n\n    }\n\n  }\n\n}\n\nGet all User records with zero published posts​\nconst result = await prisma.user.findMany({\n\n  where: {\n\n    post: {\n\n        none: {\n\n          published: true\n\n        }\n\n    }\n\n  }\n\n}\n\nis​\n\nReturns all records where related record matches filtering criteria (for example, user's name is Bob).\n\nExamples​\nGet all Post records where user's name is \"Bob\"​\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    user: {\n\n        is: {\n\n          name: \"Bob\"\n\n        },\n\n    }\n\n  }\n\n}\n\nisNot​\n\nReturns all records where the related record does not match the filtering criteria (for example, user's name isNot Bob).\n\nExamples​\nGet all Post records where user's name is NOT \"Bob\"​\nconst result = await prisma.post.findMany({\n\n  where: {\n\n    user: {\n\n        isNot: {\n\n          name: \"Bob\"\n\n        },\n\n    }\n\n  }\n\n}\n\nScalar list methods​\nset​\n\nUse set to overwrite the value of a scalar list field.\n\nRemarks​\n\nset is optional - you can set the value directly:\n\ntags: ['computers', 'books'];\n\nExamples​\nSet the value of tags to a list of string values​\nconst setTags = await prisma.post.update({\n\n  where: {\n\n    id: 9,\n\n  },\n\n  data: {\n\n    tags: {\n\n      set: ['computing', 'books'],\n\n    },\n\n  },\n\n});\n\nSet tags to a list of values without using the set keyword​\nconst setTags = await prisma.post.update({\n\n  where: {\n\n    id: 9,\n\n  },\n\n  data: {\n\n    tags: ['computing', 'books'],\n\n  },\n\n});\n\nSet the value of tags to a single string value​\nconst setTags = await prisma.post.update({\n\n  where: {\n\n    id: 9,\n\n  },\n\n  data: {\n\n    tags: {\n\n      set: 'computing',\n\n    },\n\n  },\n\n});\n\npush​\n\npush is available in version 2.20.0\n and later. Use push to add one value or multiple values to a scalar list field.\n\nRemarks​\nAvailable for PostgreSQL and MongoDB only.\nYou can push a list of values or only a single value.\nExamples​\nAdd a computing item to the tags list​\nconst addTag = await prisma.post.update({\n\n  where: {\n\n    id: 9,\n\n  },\n\n  data: {\n\n    tags: {\n\n      push: 'computing',\n\n    },\n\n  },\n\n});\n\nconst addTag = await prisma.post.update({\n\n  where: {\n\n    id: 9,\n\n  },\n\n  data: {\n\n    tags: {\n\n      push: ['computing', 'genetics'],\n\n    },\n\n  },\n\n});\n\nunset​\nWARNING\n\nThis method is available on MongoDB only in versions 3.11.1\n and later.\n\nUse unset to unset the value of a scalar list. Unlike set: null, unset removes the list entirely.\n\nExamples​\nUnset the value of tags​\nconst setTags = await prisma.post.update({\n\n  where: {\n\n    id: 9,\n\n  },\n\n  data: {\n\n    tags: {\n\n      unset: true,\n\n    },\n\n  },\n\n});\n\nScalar list filters​\n\nScalar list filters allow you to filter by the contents of a list / array field.\n\nWARNING\n\nAvailable for:\n\nPostgreSQL in versions 2.15.0\n and later\nCockroachDB in versions 3.9.0\n and later\nMongoDB in versions 3.11.0\n and later\nRemarks​\nScalar list / array filters ignore NULL values . Using isEmpty or NOT does not return records with NULL value lists / arrays, and { equals: null } results in an error.\nhas​\n\nThe given value exists in the list.\n\nExamples​\n\nThe following query returns all Post records where the tags list includes \"databases\":\n\nconst posts = await client.post.findMany({\n\n  where: {\n\n    tags: {\n\n      has: 'databases',\n\n    },\n\n  },\n\n});\n\n\nThe following query returns all Post records where the tags list does not include \"databases\":\n\nconst posts = await client.post.findMany({\n\n  where: {\n\n    NOT: {\n\n      tags: {\n\n        has: 'databases',\n\n      },\n\n    },\n\n  },\n\n});\n\nhasEvery​\n\nEvery value exists in the list.\n\nExamples​\n\nThe following query returns all Post records where the tags list includes at least \"databases\" and \"typescript\":\n\nconst posts = await prisma.post.findMany({\n\n  where: {\n\n    tags: {\n\n      hasEvery: ['databases', 'typescript'],\n\n    },\n\n  },\n\n});\n\nhasSome​\n\nAt least one value exists in the list.\n\nExamples​\n\nThe following query returns all Post records where the tags list includes \"databases\" or \"typescript\":\n\nconst posts = await prisma.post.findMany({\n\n  where: {\n\n    tags: {\n\n      hasSome: ['databases', 'typescript'],\n\n    },\n\n  },\n\n});\n\nisEmpty​\n\nThe list is empty.\n\nExamples​\n\nThe following query returns all Post records that have no tags:\n\nconst posts = await prisma.post.findMany({\n\n  where: {\n\n    tags: {\n\n      isEmpty: true,\n\n    },\n\n  },\n\n});\n\nisSet​\nWARNING\n\nThis filter is available on MongoDB only in versions 3.11.1\n and later.\n\nFilter lists to include only results that have been set (either set to a value, or explicitly set to null). Setting this filter to true will exclude undefined results that are not set at all.\n\nExamples​\n\nThe following query returns all Post records where the tags have been set to either null or a value:\n\nconst posts = await prisma.post.findMany({\n\n  where: {\n\n    tags: {\n\n      isSet: true,\n\n    },\n\n  },\n\n});\n\nequals​\n\nThe list matches the given value exactly.\n\nExamples​\n\nThe following query returns all Post records where the tags list includes \"databases\" and \"typescript\" only:\n\nconst posts = await prisma.post.findMany({\n\n  where: {\n\n    tags: {\n\n      equals: ['databases', 'typescript'],\n\n    },\n\n  },\n\n});\n\nComposite type methods​\nWARNING\n\nAvailable for MongoDB only in Prisma 3.10.0 and later.\n\nComposite type methods allow you to create, update and delete composite types.\n\nset​\n\nUse set to overwrite the value of a composite type.\n\nRemarks​\nThe set keyword is optional - you can set the value directly:\nphotos: [\n\n  { height: 100, width: 200, url: '1.jpg' },\n\n  { height: 100, width: 200, url: '2.jpg' },\n\n];\n\nExamples​\nSet the shippingAddress composite type within a new order​\nconst order = await prisma.order.create({\n\n  data: {\n\n    // Normal relation\n\n    product: { connect: { id: 'some-object-id' } },\n\n    color: 'Red',\n\n    size: 'Large',\n\n    // Composite type\n\n    shippingAddress: {\n\n      set: {\n\n        street: '1084 Candycane Lane',\n\n        city: 'Silverlake',\n\n        zip: '84323',\n\n      },\n\n    },\n\n  },\n\n});\n\nSet an optional composite type to null​\nconst order = await prisma.order.create({\n\n  data: {\n\n    // Embedded optional type, set to null\n\n    billingAddress: {\n\n      set: null,\n\n    },\n\n  },\n\n});\n\nunset​\n\nUse unset to unset the value of a composite type. Unlike set: null, this removes the field entirely from the MongoDB document.\n\nExamples​\nRemove the billingAddress from an order​\nconst order = await prisma.order.update({\n\n  where: {\n\n    id: 'some-object-id',\n\n  },\n\n  data: {\n\n    billingAddress: {\n\n      // Unset the billing address\n\n      // Removes \"billingAddress\" field from order\n\n      unset: true,\n\n    },\n\n  },\n\n});\n\nupdate​\n\nUse update to update fields within a required composite type.\n\nRemarks​\n\nThe update method cannot be used on optional types. Instead, use upsert\n\nExamples​\nUpdate the zip field of a shippingAddress composite type​\nconst order = await prisma.order.update({\n\n  where: {\n\n    id: 'some-object-id',\n\n  },\n\n  data: {\n\n    shippingAddress: {\n\n      // Update just the zip field\n\n      update: {\n\n        zip: '41232',\n\n      },\n\n    },\n\n  },\n\n});\n\nupsert​\n\nUse upsert to update an existing optional composite type if it exists, and otherwise set the composite type.\n\nRemarks​\n\nThe upsert method cannot be used on required types. Instead, use update\n\nExamples​\nCreate a new billingAddress if it doesn't exist, and otherwise update it​\nconst order = await prisma.order.update({\n\n  where: {\n\n    id: 'some-object-id',\n\n  },\n\n  data: {\n\n    billingAddress: {\n\n      // Create the address if it doesn't exist,\n\n      // otherwise update it\n\n      upsert: {\n\n        set: {\n\n          street: '1084 Candycane Lane',\n\n          city: 'Silverlake',\n\n          zip: '84323',\n\n        },\n\n        update: {\n\n          zip: '84323',\n\n        },\n\n      },\n\n    },\n\n  },\n\n});\n\npush​\n\nUse push to push values to the end of a list of composite types.\n\nExamples​\nAdd a new photo to the photos list​\nconst product = prisma.product.update({\n\n  where: {\n\n    id: 10,\n\n  },\n\n  data: {\n\n    photos: {\n\n      // Push a photo to the end of the photos list\n\n      push: [{ height: 100, width: 200, url: '1.jpg' }],\n\n    },\n\n  },\n\n});\n\nComposite type filters​\nWARNING\n\nAvailable for MongoDB only in Prisma 3.11.0 and later.\n\nComposite type filters allow you to filter the contents of composite types.\n\nequals​\n\nUse equals to filter results by matching a composite type or a list of composite types. Requires all required fields of the composite type to match.\n\nRemarks​\n\nWhen matching optional fields, you need to distinguish between undefined (missing) fields of the document, and fields that have been explicitly set to null:\n\nIf you omit an optional field, it will match undefined fields, but not fields that have been set to null\nIf you filter for null values of an optional field with equals: { ... exampleField: null ... }, then it will match only documents where the field has been set to null, and not undefined fields\n\nThe ordering of fields and lists matters when using equals:\n\nFor fields, { \"a\": \"1\", \"b\": \"2\" } and { \"b\": \"2\", \"a\": \"1\" } are not considered equal\nFor lists, [ { \"a\": 1 }, { \"a\": 2 } ] and [ { \"a\": 2 }, { \"a\": 1 } ] are not considered equal\nExamples​\nFind orders that exactly match the given shippingAddress​\nconst orders = await prisma.order.findMany({\n\n  where: {\n\n    shippingAddress: {\n\n      equals: {\n\n        street: '555 Candy Cane Lane',\n\n        city: 'Wonderland',\n\n        zip: '52337',\n\n      },\n\n    },\n\n  },\n\n});\n\nFind products with photos that match all of a list of urls​\nconst product = prisma.product.findMany({\n\n  where: {\n\n    equals: {\n\n      photos: [{ url: '1.jpg' }, { url: '2.jpg' }],\n\n    },\n\n  },\n\n});\n\nis​\n\nUse is to filter results by matching specific fields within composite types.\n\nExamples​\nFind orders with a shippingAddress that matches the given street name​\nconst orders = await prisma.order.findMany({\n\n  where: {\n\n    shippingAddress: {\n\n      is: {\n\n        street: '555 Candy Cane Lane',\n\n      },\n\n    },\n\n  },\n\n});\n\nisNot​\n\nUse isNot to filter results for composite type fields that do not match.\n\nExamples​\nFind orders with a shippingAddress that does not match the given zip code​\nconst orders = await prisma.order.findMany({\n\n  where: {\n\n    shippingAddress: {\n\n      isNot: {\n\n        zip: '52337',\n\n      },\n\n    },\n\n  },\n\n});\n\nisEmpty​\n\nUse isEmpty to filter results for an empty list of composite types.\n\nExamples​\nFind products with no photos​\nconst product = prisma.product.findMany({\n\n  where: {\n\n    photos: {\n\n      isEmpty: true,\n\n    },\n\n  },\n\n});\n\nevery​\n\nUse every to filter for lists of composite types where every item in the list matches the condition\n\nExamples​\nFind the first product where every photo has a height of 200​\nconst product = await prisma.product.findFirst({\n\n  where: {\n\n    photos: {\n\n      every: {\n\n        height: 200,\n\n      }\n\n    }\n\n  },\n\n})\n\nsome​\n\nUse some to filter for lists of composite types where one or more items in the list match the condition.\n\nExamples​\nFind the first product where one or more photos have a url of 2.jpg​\nconst product = await prisma.product.findFirst({\n\n  where: {\n\n    photos: {\n\n      some: {\n\n         url: \"2.jpg\",\n\n      }\n\n    }\n\n  },\n\n})\n\nnone​\n\nUse none to filter for lists of composite types where no items in the list match the condition.\n\nExamples​\nFind the first product where no photos have a url of 2.jpg​\nconst product = await prisma.product.findFirst({\n\n  where: {\n\n    photos: {\n\n      none: {\n\n         url: \"2.jpg\",\n\n      }\n\n    }\n\n  },\n\n})\n\nAtomic number operations​\n\nAtomic operations on update is available for number field types (Float and Int). This feature allows you to update a field based on its current value (such as subtracting or dividing) without risking a race condition.\n\nOverview: Race conditions\nOperators​\nOption\tDescription\nincrement\tAdds n to the current value.\ndecrement\tSubtacts n from the current value.\nmultiply\tMultiplies the current value by n.\ndivide\tDivides the current value by n.\nset\tSets the current field value. Identical to { myField : n }.\nRemarks​\nYou can only perform one atomic update per field, per query.\nIf a field is null, it will not be updated by increment, decrement, multiply, or divide.\nExamples​\nIncrement all view and likes fields of all Post records by 1​\nconst updatePosts = await prisma.post.updateMany({\n\n  data: {\n\n    views: {\n\n      increment: 1,\n\n    },\n\n    likes: {\n\n      increment: 1,\n\n    },\n\n  },\n\n});\n\nSet all views fields of all Post records to 0​\nconst updatePosts = await prisma.post.updateMany({\n\n  data: {\n\n    views: {\n\n      set: 0,\n\n    },\n\n  },\n\n});\n\n\nCan also be written as:\n\nconst updatePosts = await prisma.post.updateMany({\n\n  data: {\n\n    views: 0,\n\n  },\n\n});\n\nJson filters​\n\nFor use cases and advanced examples, see: Working with Json fields.\n\nWARNING\n\nSupported by PostgreSQL and MySQL with different syntaxes for the path option. PostgreSQL does not support filtering on object key values in arrays.\n\nThe examples in this section assumes that the value of the pet field is:\n\n{\n\n  \"favorites\": {\n\n    \"catBreed\": \"Turkish van\",\n\n    \"dogBreed\": \"Rottweiler\",\n\n    \"sanctuaries\": [\"RSPCA\", \"Alley Cat Allies\"],\n\n    \"treats\": [\n\n      { \"name\": \"Dreamies\", \"manufacturer\": \"Mars Inc\" },\n\n      { \"name\": \"Treatos\", \"manufacturer\": \"The Dog People\" }\n\n    ]\n\n  },\n\n  \"fostered\": {\n\n    \"cats\": [\"Bob\", \"Alice\", \"Svetlana the Magnificent\", \"Queenie\"]\n\n  },\n\n  \"owned\": {\n\n    \"cats\": [\"Elliott\"]\n\n  }\n\n}\n\nRemarks​\nThe implementation of Json filtering differs between database connectors\nFiltering is case sensitive in PostgreSQL and does not yet support mode\npath​\n\npath represents the location of a specific key. The following query returns all users where the nested favourites > dogBreed key equals \"Rottweiler\".\n\nPostgreSQL\nMySQL\nconst getUsers = await prisma.user.findMany({\n\n  where: {\n\n    pets: {\n\n      path: ['favorites', 'dogBreed'],\n\n      equals: 'Rottweiler',\n\n    },\n\n  },\n\n});\n\n\nThe following query returns all users where the nested owned > cats array contains \"Elliott\".\n\nPostgreSQL\nMySQL\nconst getUsers = await prisma.user.findMany({\n\n  where: {\n\n    pets: {\n\n      path: ['owned', 'cats'],\n\n      array_contains: ['Elliott'],\n\n    },\n\n  },\n\n});\n\nWARNING\n\nFiltering by the key values of objects inside an array (below) is only supported by the MySQL connector.\n\nThe following query returns all users where the nested favorites > treats array contains an object where the name value is \"Dreamies\":\n\nconst getUsers = await prisma.user.findMany({\n\n  where: {\n\n    pets: {\n\n      path: '$.favorites.treats[*].name',\n\n      array_contains: 'Dreamies',\n\n    },\n\n  },\n\n});\n\nstring_contains​\n\nThe following query returns all users where the nested favorites > catBreed key value contains \"Van\":\n\nPostgreSQL\nMySQL\nconst getUsers = await prisma.user.findMany({\n\n  where: {\n\n    pets: {\n\n      path: ['favorites', 'catBreed'],\n\n      string_contains: 'Van',\n\n    },\n\n  },\n\n});\n\nstring_starts_with​\n\nThe following query returns all users where the nested favorites > catBreed key value starts with \"Turkish\":\n\nPostgreSQL\nMySQL\nconst getUsers = await prisma.user.findMany({\n\n  where: {\n\n    pets: {\n\n      path: ['favorites', 'catBreed'],\n\n      string_starts_with: 'Turkish',\n\n    },\n\n  },\n\n});\n\nstring_ends_with​\n\nThe following query returns all users where the nested favorites > catBreed key value ends with \"Van\":\n\nPostgreSQL\nMySQL\nconst getUsers = await prisma.user.findMany({\n\n  where: {\n\n    pets: {\n\n      path: ['favorites', 'catBreed'],\n\n      string_ends_with: 'Van',\n\n    },\n\n  },\n\n});\n\nmode​\n\nSpecify whether the the string filtering should be case sensitive (default) or case insensitive.\n\nThe following query returns all users where the nested favorites > catBreed key value contains \"Van\" or \"van\":\n\nPostgreSQL\nMySQL\nconst getUsers = await prisma.user.findMany({\n\n  where: {\n\n    pets: {\n\n      path: ['favorites', 'catBreed'],\n\n      string_contains: 'Van',\n\n      mode: \"insensitive\",\n\n    },\n\n  },\n\n});\n\narray_contains​\n\nThe following query returns all users where the sanctuaries array contains the value \"RSPCA\":\n\nPostgreSQL\nMySQL\nconst getUsers = await prisma.user.findMany({\n\n  where: {\n\n    pets: {\n\n      path: ['sanctuaries'],\n\n      array_contains: ['RSPCA'],\n\n    },\n\n  },\n\n});\n\nINFO\n\nNote: In PostgreSQL, the value of array_contains must be an array and not a string, even if the array only contains a single value.\n\nThe following query returns all users where the sanctuaries array contains all the values in the given array:\n\nPostgreSQL\nMySQL\nconst getUsers = await prisma.user.findMany({\n\n  where: {\n\n    pets: {\n\n      path: ['sanctuaries'],\n\n      array_contains: ['RSPCA', 'Alley Cat Allies'],\n\n    },\n\n  },\n\n});\n\narray_starts_with​\n\nThe following query returns all users where the sanctuaries array starts with the value \"RSPCA\":\n\nPostgreSQL\nMySQL\nconst getUsers = await prisma.user.findMany({\n\n  where: {\n\n    pets: {\n\n      path: ['sanctuaries'],\n\n      array_starts_with: 'RSPCA',\n\n    },\n\n  },\n\n});\n\narray_ends_with​\n\nThe following query returns all users where the sanctuaries array ends with the value \"Alley Cat Allies\":\n\nPostgreSQL\nMySQL\nconst getUsers = await prisma.user.findMany({\n\n  where: {\n\n    pets: {\n\n      path: ['sanctuaries'],\n\n      array_ends_with: 'Alley Cat Allies',\n\n    },\n\n  },\n\n});\n\nClient methods​\n\nNote: Client-level methods are prefixed by $.\n\nRemarks​\n$on and $use client methods do not exist on extended client instances which are extended using $extends\nWARNING\n\nIn extended clients, Client methods do not necessarily exist. If you are extending your client, make sure to check for existence before using Client methods like $transaction or $connect.\n\nIn addition, if you are using $on or $use, you will need to use these client methods before extending your client as these methods do not exist on extended clients. For $use specifically we recommend transitioning to use query extensions.\n\n$disconnect()​\n\nThe $disconnect() method closes the database connections that were established when $connect was called and stops the process that was running Prisma ORM's query engine. See Connection management for an overview of $connect() and $disconnect().\n\nRemarks​\n$disconnect() returns a Promise, so you should call it inside an async function with the await keyword.\n$connect()​\n\nThe $connect() method establishes a physical connection to the database via Prisma ORM's query engine. See Connection management for an overview of $connect() and $disconnect().\n\nRemarks​\n$connect() returns a Promise, so you should call it inside an async function with the await keyword.\n$on()​\nWARNING\n\n$on is not available in extended clients. Please either migrate to client extensions or use the $on method prior to extending your client.\n\nThe $on() method allows you to subscribe to logging events or the exit hook.\n\n$use()​\nWARNING\n\n$use is not available in extended clients. Please either migrate to query extensions or use the $use method prior to extending your client.\n\nThe $use() method adds middleware :\n\nprisma.$use(async (params, next) => {\n\n  console.log('This is middleware!');\n\n  // Modify or interrogate params here\n\n\n\n  return next(params);\n\n});\n\nnext​\n\nnext represents the \"next level\" in the middleware stack, which could be the next middleware or the Prisma Query, depending on where in the stack you are.\n\nparams​\n\nparams is an object with information to use in your middleware.\n\nParameter\tDescription\naction\tThe query type - for example, create or findMany.\nargs\tArguments that were passed into the query - for example, where, data, or orderBy\ndataPath\tPopulated if you use the fluent API.\nmodel\tThe model type - for example, Post or User.\nrunInTransaction\tReturns true if the query ran in the context of a transaction.\nTIP\n\nIf you need the model property as a string, use: String(params.model)\n\nExample parameter values:\n\n{\n\n  args: { where: { id: 15 } },\n\n  dataPath: [ 'select', 'author', 'select', 'posts' ],\n\n  runInTransaction: false,\n\n  action: 'findMany',\n\n  model: 'Post'\n\n}\n\nExamples​\n\nSee middleware examples.\n\n$queryRawTyped​\n\nSee: Using Raw SQL ($queryRawTyped).\n\n$queryRaw​\n\nSee: Using Raw SQL ($queryRaw).\n\n$queryRawUnsafe()​\n\nSee: Using Raw SQL ($queryRawUnsafe()).\n\n$executeRaw​\n\nSee: Using Raw SQL ($executeRaw).\n\n$executeRawUnsafe()​\n\nSee: Using Raw SQL ($executeRawUnsafe()).\n\n$runCommandRaw()​\n\nSee: Using Raw SQL ($runCommandRaw()).\n\n$transaction()​\n\nSee: Transactions.\n\n$metrics​\n\nPrisma Client metrics give you a detailed insight into how Prisma Client interacts with your database. You can use this insight to help diagnose performance issues with your application. Learn more: Metrics.\n\nPrisma Client metrics has the following methods:\n\n$metrics.json(): Retrieves Prisma Client metrics in JSON format.\n$metrics.prometheus(): Retrieves Prisma Client metrics in Prometheus format.\n$extends​\n\nWith $extends, you can create and use Prisma Client extensions to add functionality to Prisma Client in the following ways:\n\nmodel: add custom methods to your models\nclient: add custom methods to your client\nquery: create custom Prisma Client queries\nresult: add custom fields to your query results\n\nLearn more: Prisma Client extensions.\n\nUtility types​\n\nUtility types are helper functions and types that live on the Prisma namespace. They are useful for keeping your application type safe.\n\nPrisma.validator​\n\nThe validator helps you create re-usable query parameters based on your schema models while making sure that the objects you create are valid. See also: Using Prisma.validator\n\nThere are two ways you can use the validator:\n\nUsing generated Prisma Client types​\n\nUsing types provides a type-level approach to validate data:\n\nPrisma.validator<GeneratedType>({ args });\n\nUsing a \"selector\"​\n\nWhen using the selector pattern, you use an existing Prisma Client instance to create a validator. This pattern allows you to select the model, operation, and query option to validate against.\n\nYou can also use an instance of Prisma Client that has been extended using a Prisma Client extension.\n\nPrisma.validator(PrismaClientInstance, '<model>', '<operation>', '<query option>')({ args });\n\nExamples​\n\nThe following example shows how you can extract and validate the input for the create operation you can reuse within your app:\n\nimport { Prisma } from '@prisma/client';\n\n\n\nconst validateUserAndPostInput = (name, email, postTitle) => {\n\n  return Prisma.validator<Prisma.UserCreateInput>()({\n\n    name,\n\n    email,\n\n    posts: {\n\n      create: {\n\n        title: postTitle,\n\n      },\n\n    },\n\n  });\n\n};\n\n\nHere is an alternative syntax for the same operation:\n\nimport { Prisma } from '@prisma/client';\n\nimport prisma from './prisma';\n\n\n\nconst validateUserAndPostInput = (name, email, postTitle) => {\n\n  return Prisma.validator(\n\n    prisma,\n\n    'user',\n\n    'create',\n\n    'data'\n\n  )({\n\n    name,\n\n    email,\n\n    posts: {\n\n      create: {\n\n        title: postTitle,\n\n      },\n\n    },\n\n  });\n\n};\n\nCompare columns in the same table​\n\nYou can compare columns in the same table directly, for non-unique filters.\n\nThis feature was moved to general availability in version 5.0.0 and was available via the fieldReference Preview feature from Prisma ORM versions 4.3.0 to 4.16.2.\n\nINFO\n\nIn the following situations, you must use raw queries to compare columns in the same table:\n\nIf you use a version earlier than 4.3.0\nIf you want to use a unique filter, such as findUnique or findUniqueOrThrow\nIf you want to compare a field with a unique constraint\nIf you want to use one of the following operators to compare a JSON field in MySQL or MariaDB with another field: gt, gte, lt, or lte. Note that you can use these operators to compare the JSON field with a scalar value. This limitation applies only if you try to compare a JSON field with another field.\n\nTo compare columns in the same table, use the <model>.fields property. In the following example, the query returns all records where the value in the prisma.product.quantity field is less than or equal to the value in the prisma.product.warnQuantity field.\n\nprisma.product.findMany({\n\n  where: { quantity: { lte: prisma.product.fields.warnQuantity } },\n\n});\n\nINFO\n\nfields is a special property of every model. It contains the list of fields for that model.\n\nConsiderations​\nFields must be of the same type​\n\nYou can only make comparisons on fields of the same type. For example, the following causes an error:\n\nawait prisma.order.findMany({\n\n  where: {\n\n    id: { equals: prisma.order.fields.due },\n\n    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n    // Type error: id is a string, while amountDue is an integer\n\n  },\n\n});\n\nFields must be in the same model​\n\nYou can only make comparisons with the fields property on fields in the same model. The following example does not work:\n\nawait prisma.order.findMany({\n\n  where: {\n\n    id: { equals: prisma.user.fields.name },\n\n    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n    // Type error: name is a field on the User model, not Order\n\n  },\n\n});\n\n\nHowever, you can compare fields in separate models with standard queries.\n\nIn groupBy model queries, put your referenced fields in the by argument​\n\nIf you use the groupBy model query with the having option, then you must put your referenced fields in the by argument.\n\nThe following example works:\n\nprisma.user.groupBy({\n\n  by: ['id', 'name'],\n\n  having: { id: { equals: prisma.user.fields.name } },\n\n});\n\n\nThe following example does not work, because name is not in the by argument:\n\nprisma.user.groupBy({\n\n  by: ['id'],\n\n  having: { id: { equals: prisma.user.fields.name } },\n\n  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n  // name is not in the 'by' argument\n\n});\n\nSearch for fields in scalar lists​\n\nIf your data source supports scalar lists (for example in PostgreSQL), then you can search for all records where a specific field is in a list of fields. To do so, reference the scalar list with the in and notIn filters. For example:\n\nawait prisma.user.findMany({\n\n  where: {\n\n    // find all users where 'name' is in a list of tags\n\n    name: { in: prisma.user.fields.tags },\n\n  },\n\n});\n\nFilter on non-unique fields with UserWhereUniqueInput​\n\nFrom version 5.0.0, the generated type UserWhereUniqueInput on where exposes all fields on the model, not just unique fields. This was available under the extendedWhereUnique Preview flag between versions 4.5.0 to 4.16.2\n\nYou must specify at least one unique field in your where statement outside of boolean operators, and you can specify any number of additional unique and non-unique fields. You can use this to add filters to any operation that returns a single record. For example, you can use this feature for the following:\n\nOptimistic concurrency control on updates\nPermission checks\nSoft deletes\n\nFrom version 4.6.0, you can use this feature to filter on optional one-to-one nested reads.\n\nOptimistic concurrency control on updates​\n\nYou can filter on non-unique fields to perform optimistic concurrency control on update operations.\n\nTo perform optimistic concurrency control, we recommend that you use a version field to check whether the data in a record or related record has changed while your code executes. Before version 4.5.0, you could not evaluate the version field in an update operation, because the field is non-unique. From version 4.5.0, you can evaluate the version field.\n\nIn the following example, updateOne and updateTwo first read the same record and then attempt to update it. The database only executes these updates if the value in version is the same as the value when it did the initial read. When the database executes the first of these updates (which might be updateOne or updateTwo, depending on timing), it increments the value in version. This means that the database does not execute the second update because the value in version has changed.\n\nmodel User {\n\n  id      Int    @id @default(autoincrement())\n\n  email   String @unique\n\n  city    String\n\n  version Int\n\n}\n\nfunction updateOne() {\n\n  const user = await prisma.user.findUnique({ id: 1 });\n\n\n\n  await prisma.user.update({\n\n    where: { id: user.id, version: user.version },\n\n    data: { city: 'Berlin', version: { increment: 1 } },\n\n  });\n\n}\n\n\n\nfunction updateTwo() {\n\n  const user = await prisma.user.findUnique({ id: 1 });\n\n\n\n  await prisma.user.update({\n\n    where: { id: user.id, version: user.version },\n\n    data: { city: 'New York', version: { increment: 1 } },\n\n  });\n\n}\n\n\n\nfunction main() {\n\n  await Promise.allSettled([updateOne(), updateTwo()]);\n\n}\n\nPermission checks​\n\nYou can filter on non-unique fields to check permissions during an update.\n\nIn the following example, a user wants to update a post title. The where statement checks the value in authorId to confirm that the user is the author of the post. The application only updates the post title if the user is the post author.\n\nawait prisma.post.update({\n\n  where: { id: 1, authorId: 1 },\n\n  data: { title: 'Updated post title' },\n\n});\n\nSoft deletes​\n\nYou can filter on non-unique fields to handle soft deletes.\n\nIn the following example, we do not want to return a post if it is soft-deleted. The operation only returns the post if the value in isDeleted is false.\n\nprisma.Post.findUnique({ where: { id: postId, isDeleted: false } });\n\nUserWhereUniqueInput considerations​\nBoolean operators with UserWhereUniqueInput​\n\nWith UserWhereUniqueInput, you must specify at least one unique field outside of the boolean operators AND, OR, NOT. You can still use these boolean operators in conjunction with any other unique fields or non-unique fields in your filter.\n\nIn the following example, we test id, a unique field, in conjunction with email. This is valid.\n\nawait prisma.user.update({\n\n  where: { id: 1, OR: [{ email: \"bob@prisma.io\" }, { email: \"alice@prisma.io\" }] },\n\n        // ^^^ Valid: the expression specifies a unique field (`id`) outside of any boolean operators\n\n  data: { ... }\n\n})\n\n\n\n// SQL equivalent:\n\n// WHERE id = 1 AND (email = \"bob@prisma.io\" OR email = \"alice@prisma.io\")\n\n\nThe following example is not valid, because there is no unique field outside of any boolean operators:\n\nawait prisma.user.update({\n\n  where: { OR: [{ email: \"bob@prisma.io\" }, { email: \"alice@prisma.io\" }] },\n\n        // ^^^ Invalid: the expressions does not contain a unique field outside of boolean operators\n\n  data: { ... }\n\n})\n\nOne-to-one relations​\n\nFrom version 4.5.0, you can filter on non-unique fields in the following operations on one-to-one relations:\n\nNested update\nNested upsert\nNested disconnect\nNested delete\n\nPrisma Client automatically uses a unique filter to select the appropriate related record. As a result, you do not need to specify a unique filter in your where statement with a WhereUniqueInput generated type. Instead, the where statement has a WhereInput generated type. You can use this to filter without the restrictions of WhereUniqueInput.\n\nNested update example​\nawait prisma.user.update({\n\n  where: { id: 1, },\n\n  data: {\n\n    to_one: {\n\n      // Before Prisma version 4.5.0\n\n      update: { field: \"updated\" }\n\n      // From Prisma version 4.5.0, you can also do the following:\n\n      update: { where: { /*WhereInput*/ }, data: { field: \"updated\" } } }\n\n    }\n\n  }\n\n})\n\nNested upsert example​\nawait prisma.user.update({\n\n  where: { id: 1, },\n\n  data: {\n\n    to_one: {\n\n      upsert: {\n\n        where: { /* WhereInput */ } // new argument from Prisma 4.5.0\n\n        create: { /* CreateInput */ },\n\n        update: { /* CreateInput */ },\n\n      }\n\n    }\n\n  }\n\n})\n\nNested disconnect example​\nawait prisma.user.update({\n\n  where: { id: 1, },\n\n  data: {\n\n    to_one: {\n\n      // Before Prisma version 4.5.0\n\n      disconnect: true\n\n      // From Prisma version 4.5.0, you can also do the following:\n\n      disconnect: { /* WhereInput */ }\n\n    }\n\n  }\n\n})\n\nNested delete example​\nawait prisma.user.update({\n\n  where: { id: 1, },\n\n  data: {\n\n    to_one: {\n\n      // Before Prisma version 4.5.0\n\n      delete: true\n\n      // From Prisma version 4.5.0, you can also do the following:\n\n      delete: { /* WhereInput */ }\n\n    }\n\n  }\n\n})\n\nPrismaPromise behavior​\n\nAll Prisma Client queries return an instance of PrismaPromise. This is a \"thenable\"\n, meaning a PrismaPromise only executes when you call await or .then() or .catch(). This behavior is different from a regular JavaScript \nPromise\n, which starts executing immediately.\n\nFor example:\n\nconst findPostOperation = prisma.post.findMany({}); // Query not yet executed\n\n\n\nfindPostOperation.then(); // Prisma Client now executes the query\n\n// or\n\nawait findPostOperation; // Prisma Client now executes the query\n\n\nWhen using the $transaction API, this behavior makes it possible for Prisma Client to pass all the queries on to the query engine as a single transaction."
  },
  {
    "title": "Prisma Schema API | Prisma Documentation",
    "url": "https://www.prisma.io/docs/orm/reference/prisma-schema-reference",
    "html": "ORMReference\nPrisma schema reference\ndatasource​\n\nDefines a data source in the Prisma schema.\n\nFields​\n\nA datasource block accepts the following fields:\n\nName\tRequired\tType\tDescription\nprovider\tYes\tString (postgresql, mysql, sqlite, sqlserver, mongodb, cockroachdb)\tDescribes which data source connectors to use.\nurl\tYes\tString (URL)\tConnection URL including authentication info. Most connectors use the syntax provided by the database.\nshadowDatabaseUrl\tNo\tString (URL)\tConnection URL to the shadow database used by Prisma Migrate. Allows you to use a cloud-hosted database as the shadow database.\ndirectUrl\tNo\tString (URL)\tConnection URL for direct connection to the database.\n\nIf you use a connection pooler URL in the url argument (for example, if you use Prisma Accelerate or pgBouncer), Prisma CLI commands that require a direct connection to the database use the URL in the directUrl argument.\n\nThe directUrl property is supported by Prisma Studio from version 5.1.0 upwards.\n\nThe directUrl property is not needed when using Prisma Postgres database.\nrelationMode\tNo\tString (foreignKeys, prisma)\tSets whether referential integrity is enforced by foreign keys in the database or emulated in the Prisma Client.\n\nIn preview in versions 3.1.1 and later. The field is named relationMode in versions 4.5.0 and later, and was previously named referentialIntegrity.\nextensions\tNo\tList of strings (PostgreSQL extension names)\tAllows you to represent PostgreSQL extensions in your schema. Available in preview for PostgreSQL only in Prisma ORM versions 4.5.0 and later.\n\nThe following providers are available:\n\nsqlite\npostgresql\nmysql\nsqlserver\nmongodb\ncockroachdb\nRemarks​\nYou can only have one datasource block in a schema.\ndatasource db is convention - however, you can give your data source any name - for example, datasource mysql or datasource data.\nExamples​\nSpecify a PostgreSQL data source​\n\nIn this example, the target database is available with the following credentials:\n\nUser: johndoe\nPassword: mypassword\nHost: localhost\nPort: 5432\nDatabase name: mydb\nSchema name: public\ndatasource db {\n\n  provider = \"postgresql\"\n\n  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?schema=public\"\n\n}\n\n\nLearn more about PostgreSQL connection strings here.\n\nSpecify a PostgreSQL data source via an environment variable​\n\nIn this example, the target database is available with the following credentials:\n\nUser: johndoe\nPassword: mypassword\nHost: localhost\nPort: 5432\nDatabase name: mydb\nSchema name: public\ndatasource db {\n\n  provider = \"postgresql\"\n\n  url      = env(\"DATABASE_URL\")\n\n}\n\n\nWhen running a Prisma CLI command that needs the database connection URL (e.g. prisma generate), you need to make sure that the DATABASE_URL environment variable is set.\n\nOne way to do so is by creating a \n.env\n file with the following contents. Note that the file must be in the same directory as your schema.prisma file to automatically picked up the Prisma CLI.\n\nDATABASE_URL=postgresql://johndoe:mypassword@localhost:5432/mydb?schema=public\n\nSpecify a MySQL data source​\n\nIn this example, the target database is available with the following credentials:\n\nUser: johndoe\nPassword: mypassword\nHost: localhost\nPort: 3306\nDatabase name: mydb\ndatasource db {\n\n  provider = \"mysql\"\n\n  url      = \"mysql://johndoe:mypassword@localhost:3306/mydb\"\n\n}\n\n\nLearn more about MySQL connection strings here.\n\nSpecify a MongoDB data source​\nUser: root\nPassword: password\nHost: cluster1.test1.mongodb.net\nPort: N/A\nDatabase name: testing\ndatasource db {\n\n  provider = \"mongodb\"\n\n  url      = \"mongodb+srv://root:password@cluster1.test1.mongodb.net/testing?retryWrites=true&w=majority\"\n\n}\n\n\nLearn more about MongoDB connection strings here.\n\nSpecify a SQLite data source​\n\nIn this example, the target database is located in a file called dev.db:\n\ndatasource db {\n\n  provider = \"sqlite\"\n\n  url      = \"file:./dev.db\"\n\n}\n\n\nLearn more about SQLite connection strings here.\n\nSpecify a CockroachDB data source​\n\nIn this example, the target database is available with the following credentials:\n\nUser: johndoe\nPassword: mypassword\nHost: localhost\nPort: 26257\nDatabase name: mydb\nSchema name: public\ndatasource db {\n\n  provider = \"cockroachdb\"\n\n  url      = \"postgresql://johndoe:mypassword@localhost:26257/mydb?schema=public\"\n\n}\n\n\nThe format for connection strings is the same as for PostgreSQL. Learn more about PostgreSQL connection strings here.\n\ngenerator​\n\nDefines a generator in the Prisma schema.\n\nFields for prisma-client-js provider​\n\nThis is the default generator for Prisma ORM 6.x and earlier versions. Learn more about generators.\n\nA generator block accepts the following fields:\n\nName\tRequired\tType\tDescription\nprovider\tYes\tprisma-client-js\tDescribes which generator to use. This can point to a file that implements a generator or specify a built-in generator directly.\noutput\tNo\tString (file path)\tDetermines the location for the generated client, learn more. Default: node_modules/.prisma/client\npreviewFeatures\tNo\tList of Enums\tUse intellisense to see list of currently available Preview features (Ctrl+Space in Visual Studio Code) Default: none\nengineType\tNo\tEnum (library or binary)\tDefines the query engine type to download and use. Default: library\nbinaryTargets\tNo\tList of Enums (see below)\tSpecify the OS on which the Prisma Client will run to ensure compatibility of the query engine. Default: native\nmoduleFormat\tNo\tEnum (cjs or esm)\tDefines the module format of the generated Prisma Client. This field is available only with prisma-client generator.\nIMPORTANT\n\nWe recommend defining a custom output path, adding the path to .gitignore, and then making sure to run prisma generate via a custom build script or postinstall hook.\n\nFields for prisma-client provider​\n\nThe ESM-first client generator that offers greater control and flexibility across different JavaScript environments. It generates plain TypeScript code into a custom directory, providing full visibility over the generated code. Learn more about the new prisma-client generator.\n\nNOTE\n\nThe prisma-client generator will be the default generator in Prisma ORM 7.0 and we recommend migrating to it as soon as possible. It has been Generally Available since v6.16.0\n.\n\nA generator block accepts the following fields:\n\nName\tRequired\tType\tDescription\nprovider\tYes\tprisma-client\tDescribes which generator to use. This can point to a file that implements a generator or specify a built-in generator directly.\noutput\tYes\tString (file path)\tDetermines the location for the generated client, learn more.\npreviewFeatures\tNo\tList of Enums\tUse intellisense to see list of currently available Preview features (Ctrl+Space in Visual Studio Code) Default: none\nruntime\tNo\tEnum (nodejs, deno, bun, workerd (alias cloudflare), vercel-edge (alias edge-light), react-native)\tTarget runtime environment. Default: nodejs\nmoduleFormat\tNo\tEnum (esm or cjs)\tDetermines whether the generated code supports ESM (uses import) or CommonJS (uses require(...)) modules. We always recommend esm unless you have a good reason to use cjs. Default: Inferred from environment.\ngeneratedFileExtension\tNo\tEnum (ts or mts or cts)\tFile extension for generated TypeScript files. Default: ts\nimportFileExtension\tNo\tEnum (ts,mts,cts,js,mjs,cjs, empty (for bare imports))\tFile extension used in import statements Default: Inferred from environment.\nbinaryTargets options​\n\nThe following tables list all supported operating systems with the name of platform to specify in binaryTargets.\n\nUnless specified otherwise, the default supported CPU architecture is x86_64.\n\nmacOS​\nBuild OS\tPrisma engine build name\nmacOS Intel x86_64\tdarwin\nmacOS ARM64\tdarwin-arm64\nWindows​\nBuild OS\tPrisma engine build name\nWindows\twindows\nLinux (Alpine on x86_64 architectures)​\nBuild OS\tPrisma engine build name\tOpenSSL\nAlpine (3.17 and newer)\tlinux-musl-openssl-3.0.x*\t3.0.x\nAlpine (3.16 and older)\tlinux-musl\t1.1.x\n\n* Available in Prisma ORM versions 4.8.0 and later.\n\nLinux (Alpine on ARM64 architectures)​\nBuild OS\tPrisma engine build name\tOpenSSL\nAlpine (3.17 and newer)\tlinux-musl-arm64-openssl-3.0.x*\t3.0.x\nAlpine (3.16 and older)\tlinux-musl-arm64-openssl-1.1.x*\t1.1.x\n\n* Available in Prisma ORM versions 4.10.0 and later.\n\nLinux (Debian), x86_64​\nBuild OS\tPrisma engine build name\tOpenSSL\nDebian 8 (Jessie)\tdebian-openssl-1.0.x\t1.0.x\nDebian 9 (Stretch)\tdebian-openssl-1.1.x\t1.1.x\nDebian 10 (Buster)\tdebian-openssl-1.1.x\t1.1.x\nDebian 11 (Bullseye)\tdebian-openssl-1.1.x\t1.1.x\nDebian 12 (Bookworm)\tdebian-openssl-3.0.x\t3.0.x\nLinux (Ubuntu), x86_64​\nBuild OS\tPrisma engine build name\tOpenSSL\nUbuntu 14.04 (trusty)\tdebian-openssl-1.0.x\t1.0.x\nUbuntu 16.04 (xenial)\tdebian-openssl-1.0.x\t1.0.x\nUbuntu 18.04 (bionic)\tdebian-openssl-1.1.x\t1.1.x\nUbuntu 19.04 (disco)\tdebian-openssl-1.1.x\t1.1.x\nUbuntu 20.04 (focal)\tdebian-openssl-1.1.x\t1.1.x\nUbuntu 21.04 (hirsute)\tdebian-openssl-1.1.x\t1.1.x\nUbuntu 22.04 (jammy)\tdebian-openssl-3.0.x\t3.0.x\nUbuntu 23.04 (lunar)\tdebian-openssl-3.0.x\t3.0.x\nLinux (CentOS), x86_64​\nBuild OS\tPrisma engine build name\tOpenSSL\nCentOS 7\trhel-openssl-1.0.x\t1.0.x\nCentOS 8\trhel-openssl-1.1.x\t1.1.x\nLinux (Fedora), x86_64​\nBuild OS\tPrisma engine build name\tOpenSSL\nFedora 28\trhel-openssl-1.1.x\t1.1.x\nFedora 29\trhel-openssl-1.1.x\t1.1.x\nFedora 30\trhel-openssl-1.1.x\t1.1.x\nFedora 36\trhel-openssl-3.0.x\t3.0.x\nFedora 37\trhel-openssl-3.0.x\t3.0.x\nFedora 38\trhel-openssl-3.0.x\t3.0.x\nLinux (Linux Mint), x86_64​\nBuild OS\tPrisma engine build name\tOpenSSL\nLinux Mint 18\tdebian-openssl-1.0.x\t1.0.x\nLinux Mint 19\tdebian-openssl-1.1.x\t1.1.x\nLinux Mint 20\tdebian-openssl-1.1.x\t1.1.x\nLinux Mint 21\tdebian-openssl-3.0.x\t3.0.x\nLinux (Arch Linux), x86_64​\nBuild OS\tPrisma engine build name\tOpenSSL\nArch Linux 2019.09.01\tdebian-openssl-1.1.x\t1.1.x\nArch Linux 2023.04.23\tdebian-openssl-3.0.x\t3.0.x\nLinux ARM64 (all major distros but Alpine)​\nBuild OS\tPrisma engine build name\tOpenSSL\nLinux ARM64 glibc-based distro\tlinux-arm64-openssl-1.0.x\t1.0.x\nLinux ARM64 glibc-based distro\tlinux-arm64-openssl-1.1.x\t1.1.x\nLinux ARM64 glibc-based distro\tlinux-arm64-openssl-3.0.x\t3.0.x\nExamples​\nSpecify the prisma-client-js generator with the default output, previewFeatures, engineType and binaryTargets​\ngenerator client {\n\n  provider = \"prisma-client-js\"\n\n}\n\n\nNote that the above generator definition is equivalent to the following because it uses the default values for output, engineType and binaryTargets (and implicitly previewFeatures):\n\ngenerator client {\n\n  provider      = \"prisma-client-js\"\n\n  output        = \"node_modules/.prisma/client\"\n\n  engineType    = \"library\"\n\n  binaryTargets = [\"native\"]\n\n}\n\nSpecify a custom output location for Prisma Client​\n\nThis example shows how to define a custom output location of the generated asset to override the default one.\n\ngenerator client {\n\n  provider = \"prisma-client-js\"\n\n  output   = \"../src/generated/client\"\n\n}\n\nSpecify custom binaryTargets to ensure compatibility with the OS​\n\nThis example shows how to configure Prisma Client to run on Ubuntu 19.04 (disco) based on the table above.\n\ngenerator client {\n\n  provider      = \"prisma-client-js\"\n\n  binaryTargets = [\"debian-openssl-1.1.x\"]\n\n}\n\nSpecify a provider pointing to some custom generator implementation​\n\nThis example shows how to use a custom generator that's located in a directory called my-generator.\n\ngenerator client {\n\n  provider = \"./my-generator\"\n\n}\n\nmodel​\n\nDefines a Prisma model .\n\nRemarks​\nEvery record of a model must be uniquely identifiable. You must define at least one of the following attributes per model:\n@unique\n@@unique\n@id\n@@id\nNaming conventions​\nModel names must adhere to the following regular expression: [A-Za-z][A-Za-z0-9_]*\nModel names must start with a letter and are typically spelled in PascalCase\nModel names should use the singular form (for example, User instead of user, users or Users)\nPrisma ORM has a number of reserved words that are being used by Prisma ORM internally and therefore cannot be used as a model name. You can find the reserved words here\n and here\n.\n\nNote: You can use the @@map attribute to map a model (for example, User) to a table with a different name that does not match model naming conventions (for example, users).\n\nOrder of fields​\nIn version 2.3.0 and later, introspection lists model fields in the same order as the corresponding columns in the database. Relation fields are listed after scalar fields.\nExamples​\nA model named User with two scalar fields​\nRelational databases\nMongoDB\nmodel User {\n\n  email String  @unique // `email` can not be optional because it's the only unique field on the model\n\n  name  String?\n\n}\n\nmodel fields​\n\nFields are properties of models.\n\nRemarks​\nNaming conventions​\nMust start with a letter\nTypically spelled in camelCase\nMust adhere to the following regular expression: [A-Za-z][A-Za-z0-9_]*\n\nNote: You can use the @map attribute to map a field name to a column with a different name that does not match field naming conventions: e.g. myField @map(\"my_field\").\n\nmodel field scalar types​\n\nThe data source connector determines what native database type each of Prisma ORM scalar type maps to. Similarly, the generator determines what type in the target programming language each of these types map to.\n\nPrisma models also have model field types that define relations between models.\n\nString​\n\nVariable length text.\n\nDefault type mappings​\nConnector\tDefault mapping\nPostgreSQL\ttext\nSQL Server\tnvarchar(1000)\nMySQL\tvarchar(191)\nMongoDB\tString\nSQLite\tTEXT\nCockroachDB\tSTRING\nPostgreSQL​\nNative database type\tNative database type attribute\tNotes\ntext\t@db.Text\t\nchar(x)\t@db.Char(x)\t\nvarchar(x)\t@db.VarChar(x)\t\nbit(x)\t@db.Bit(x)\t\nvarbit\t@db.VarBit\t\nuuid\t@db.Uuid\t\nxml\t@db.Xml\t\ninet\t@db.Inet\t\ncitext\t@db.Citext\tOnly available if Citext extension is enabled.\nMySQL​\nNative database type\tNative database type attribute\nVARCHAR(x)\t@db.VarChar(x)\nTEXT\t@db.Text\nCHAR(x)\t@db.Char(x)\nTINYTEXT\t@db.TinyText\nMEDIUMTEXT\t@db.MediumText\nLONGTEXT\t@db.LongText\n\nYou can use Prisma Migrate to map @db.Bit(1) to String:\n\nmodel Model {\n\n  /* ... */\n\n  myField String @db.Bit(1)\n\n}\n\nMongoDB​\n\nString\n\nNative database type attribute\tNotes\n@db.String\t\n@db.ObjectId\tRequired if the underlying BSON type is OBJECT_ID (ID fields, relation scalars)\nMicrosoft SQL Server​\nNative database type\tNative database type attribute\nchar(x)\t@db.Char(x)\nnchar(x)\t@db.NChar(x)\nvarchar(x)\t@db.VarChar(x)\nnvarchar(x)\t@db.NVarChar(x)\ntext\t@db.Text\nntext\t@db.NText\nxml\t@db.Xml\nuniqueidentifier\t@db.UniqueIdentifier\nSQLite​\n\nTEXT\n\nCockroachDB​\nNative database type\tNative database type attribute\tNotes\nSTRING(x) | TEXT(x) | VARCHAR(x)\t@db.String(x)\t\nCHAR(x)\t@db.Char(x)\t\n\"char\"\t@db.CatalogSingleChar\t\nBIT(x)\t@db.Bit(x)\t\nVARBIT\t@db.VarBit\t\nUUID\t@db.Uuid\t\nINET\t@db.Inet\t\n\nNote that the xml and citext types supported in PostgreSQL are not currently supported in CockroachDB.\n\nClients​\nPrisma Client JS\nstring\nBoolean​\n\nTrue or false value.\n\nDefault type mappings​\nConnector\tDefault mapping\nPostgreSQL\tboolean\nSQL Server\tbit\nMySQL\tTINYINT(1)\nMongoDB\tBool\nSQLite\tINTEGER\nCockroachDB\tBOOL\nPostgreSQL​\nNative database types\tNative database type attribute\tNotes\nboolean\t@db.Boolean\t\nMySQL​\nNative database types\tNative database type attribute\tNotes\nTINYINT(1)\t@db.TinyInt(1)\tTINYINT maps to Int if the max length is greater than 1 (for example, TINYINT(2)) or the default value is anything other than 1, 0, or NULL\nBIT(1)\t@db.Bit\t\nMongoDB​\n\nBool\n\nMicrosoft SQL Server​\nNative database types\tNative database type attribute\tNotes\nbit\t@db.Bit\t\nSQLite​\n\nINTEGER\n\nCockroachDB​\nNative database types\tNative database type attribute\tNotes\nBOOL\t@db.Bool\t\nClients​\nPrisma Client JS\nboolean\nInt​\nDefault type mappings​\nConnector\tDefault mapping\nPostgreSQL\tinteger\nSQL Server\tint\nMySQL\tINT\nMongoDB\tInt\nSQLite\tINTEGER\nCockroachDB\tINT\nPostgreSQL​\nNative database types\tNative database type attribute\tNotes\ninteger | int, int4\t@db.Integer\t\nsmallint | int2\t@db.SmallInt\t\nsmallserial | serial2\t@db.SmallInt @default(autoincrement())\t\nserial | serial4\t@db.Int @default(autoincrement())\t\noid\t@db.Oid\t\nMySQL​\nNative database types\tNative database type attribute\tNotes\nINT\t@db.Int\t\nINT UNSIGNED\t@db.UnsignedInt\t\nSMALLINT\t@db.SmallInt\t\nSMALLINT UNSIGNED\t@db.UnsignedSmallInt\t\nMEDIUMINT\t@db.MediumInt\t\nMEDIUMINT UNSIGNED\t@db.UnsignedMediumInt\t\nTINYINT\t@db.TinyInt\tTINYINT maps to Int if the max length is greater than 1 (for example, TINYINT(2)) or the default value is anything other than 1, 0, or NULL. TINYINT(1) maps to Boolean.\nTINYINT UNSIGNED\t@db.UnsignedTinyInt\tTINYINT(1) UNSIGNED maps to Int, not Boolean\nYEAR\t@db.Year\t\nMongoDB​\n\nInt\n\nNative database type attribute\tNotes\n@db.Int\t\n@db.Long\t\nMicrosoft SQL Server​\nNative database types\tNative database type attribute\tNotes\nint\t@db.Int\t\nsmallint\t@db.SmallInt\t\ntinyint\t@db.TinyInt\t\nbit\t@db.Bit\t\nSQLite​\n\nINTEGER\n\nCockroachDB​\nNative database types\tNative database type attribute\tNotes\nINTEGER | INT | INT8\t@db.Int8\tNote that this differs from PostgreSQL, where integer and int are aliases for int4 and map to @db.Integer\nINT4\t@db.Int4\t\nINT2 | SMALLINT\t@db.Int2\t\nSMALLSERIAL | SERIAL2\t@db.Int2 @default(autoincrement())\t\nSERIAL | SERIAL4\t@db.Int4 @default(autoincrement())\t\nSERIAL8 | BIGSERIAL\t@db.Int8 @default(autoincrement())\t\nClients​\nPrisma Client JS\nnumber\nBigInt​\n\nBigInt is available in version 2.17.0\n and later.\n\nDefault type mappings​\nConnector\tDefault mapping\nPostgreSQL\tbigint\nSQL Server\tint\nMySQL\tBIGINT\nMongoDB\tLong\nSQLite\tINTEGER\nCockroachDB\tINTEGER\nPostgreSQL​\nNative database types\tNative database type attribute\tNotes\nbigint | int8\t@db.BigInt\t\nbigserial | serial8\t@db.BigInt @default(autoincrement())\t\nMySQL​\nNative database types\tNative database type attribute\tNotes\nBIGINT\t@db.BigInt\t\nSERIAL\t@db.UnsignedBigInt @default(autoincrement())\t\nMongoDB​\n\nLong\n\nMicrosoft SQL Server​\nNative database types\tNative database type attribute\tNotes\nbigint\t@db.BigInt\t\nSQLite​\n\nINTEGER\n\nCockroachDB​\nNative database types\tNative database type attribute\tNotes\nBIGINT | INT | INT8\t@db.Int8\tNote that this differs from PostgreSQL, where int is an alias for int4\nbigserial | serial8\t@db.Int8 @default(autoincrement())\t\nClients​\nClient\tType\tDescription\nPrisma Client JS\t\nBigInt\n\tSee examples of working with BigInt\nFloat​\n\nFloating point number.\n\nFloat maps to Double in 2.17.0\n and later - see release notes\n and Video: Changes to the default mapping of Float in Prisma ORM 2.17.0\n for more information about this change.\n\nDefault type mappings​\nConnector\tDefault mapping\nPostgreSQL\tdouble precision\nSQL Server\tfloat(53)\nMySQL\tDOUBLE\nMongoDB\tDouble\nSQLite\tREAL\nCockroachDB\tDOUBLE PRECISION\nPostgreSQL​\nNative database types\tNative database type attribute\tNotes\ndouble precision\t@db.DoublePrecision\t\nreal\t@db.Real\t\nMySQL​\nNative database types\tNative database type attribute\tNotes\nFLOAT\t@db.Float\t\nDOUBLE\t@db.Double\t\nMongoDB​\n\nDouble\n\nMicrosoft SQL Server​\nNative database types\tNative database type attribute\nfloat\t@db.Float\nmoney\t@db.Money\nsmallmoney\t@db.SmallMoney\nreal\t@db.Real\nSQLite connector​\n\nREAL\n\nCockroachDB​\nNative database types\tNative database type attribute\tNotes\nDOUBLE PRECISION | FLOAT8\t@db.Float8\t\nREAL | FLOAT4 | FLOAT\t@db.Float4\t\nClients​\nPrisma Client JS\nnumber\nDecimal​\nDefault type mappings​\nConnector\tDefault mapping\nPostgreSQL\tdecimal(65,30)\nSQL Server\tdecimal(32,16)\nMySQL\tDECIMAL(65,30)\nMongoDB\tNot supported\n\nSQLite\tDECIMAL\nCockroachDB\tDECIMAL\nPostgreSQL​\nNative database types\tNative database type attribute\tNotes\ndecimal | numeric\t@db.Decimal(p, s)†\t\nmoney\t@db.Money\t\n† p (precision), the maximum total number of decimal digits to be stored. s (scale), the number of decimal digits that are stored to the right of the decimal point.\nMySQL​\nNative database types\tNative database type attribute\tNotes\nDECIMAL | NUMERIC\t@db.Decimal(p, s)†\t\n† p (precision), the maximum total number of decimal digits to be stored. s (scale), the number of decimal digits that are stored to the right of the decimal point.\nMongoDB​\n\nNot supported\n.\n\nMicrosoft SQL Server​\nNative database types\tNative database type attribute\tNotes\ndecimal | numeric\t@db.Decimal(p, s)†\t\n† p (precision), the maximum total number of decimal digits to be stored. s (scale), the number of decimal digits that are stored to the right of the decimal point.\nSQLite​\n\nDECIMAL (changed from REAL in 2.17.0)\n\nCockroachDB​\nNative database types\tNative database type attribute\tNotes\nDECIMAL | DEC | NUMERIC\t@db.Decimal(p, s)†\t\nmoney\tNot yet\tPostgreSQL's money type is not yet supported by CockroachDB\n† p (precision), the maximum total number of decimal digits to be stored. s (scale), the number of decimal digits that are stored to the right of the decimal point.\nClients​\nClient\tType\tDescription\nPrisma Client JS\t\nDecimal\n\tSee examples of working with Decimal\nDateTime​\nRemarks​\nPrisma Client returns all DateTime as native \nDate\n objects.\nCurrently, Prisma ORM does not support\n zero dates\n (0000-00-00 00:00:00, 0000-00-00, 00:00:00) in MySQL.\nThere currently is a bug\n that doesn't allow you to pass in DateTime values as strings and produces a runtime error when you do. DateTime values need to be passed as \nDate\n objects (i.e. new Date('2024-12-04') instead of '2024-12-04').\n\nYou can find more info and examples in this section: Working with DateTime.\n\nDefault type mappings​\nConnector\tDefault mapping\nPostgreSQL\ttimestamp(3)\nSQL Server\tdatetime2\nMySQL\tDATETIME(3)\nMongoDB\tTimestamp\nSQLite\tNUMERIC\nCockroachDB\tTIMESTAMP\nPostgreSQL​\nNative database types\tNative database type attribute\tNotes\ntimestamp(x)\t@db.Timestamp(x)\t\ntimestamptz(x)\t@db.Timestamptz(x)\t\ndate\t@db.Date\t\ntime(x)\t@db.Time(x)\t\ntimetz(x)\t@db.Timetz(x)\t\nMySQL​\nNative database types\tNative database type attribute\tNotes\nDATETIME(x)\t@db.DateTime(x)\t\nDATE(x)\t@db.Date(x)\t\nTIME(x)\t@db.Time(x)\t\nTIMESTAMP(x)\t@db.Timestamp(x)\t\n\nYou can also use MySQL's YEAR type with Int:\n\nyearField     Int    @db.Year\n\nMongoDB​\n\nTimestamp\n\nMicrosoft SQL Server​\nNative database types\tNative database type attribute\tNotes\ndate\t@db.Date\t\ntime\t@db.Time\t\ndatetime\t@db.DateTime\t\ndatetime2\t@db.DateTime2\t\nsmalldatetime\t@db.SmallDateTime\t\ndatetimeoffset\t@db.DateTimeOffset\t\nSQLite​\n\nNUMERIC or STRING. If the underlying data type is STRING, you must use one of the following formats:\n\nRFC 3339\n (1996-12-19T16:39:57-08:00)\nRFC 2822\n (Tue, 1 Jul 2003 10:52:37 +0200)\nCockroachDB​\nNative database types\tNative database type attribute\tNotes\nTIMESTAMP(x)\t@db.Timestamp(x)\t\nTIMESTAMPTZ(x)\t@db.Timestamptz(x)\t\nDATE\t@db.Date\t\nTIME(x)\t@db.Time(x)\t\nTIMETZ(x)\t@db.Timetz(x)\t\nClients​\nPrisma Client JS\nDate\nJson​\n\nA JSON object.\n\nDefault type mappings​\nConnector\tDefault mapping\nPostgreSQL\tjsonb\nSQL Server\tNot supported\n\nMySQL\tJSON\nMongoDB\tA valid\nBSON\nobject (Relaxed mode)\n\nSQLite\tJSONB\nCockroachDB\tJSONB\nPostgreSQL​\nNative database types\tNative database type attribute\tNotes\njson\t@db.Json\t\njsonb\t@db.JsonB\t\nMySQL​\nNative database types\tNative database type attribute\tNotes\nJSON\t@db.Json\t\nMongoDB​\n\nA valid\nBSON\nobject (Relaxed mode)\n\nMicrosoft SQL Server​\n\nMicrosoft SQL Server does not have a specific data type for JSON. However, there are a number of built-in functions for reading and modifying JSON\n.\n\nSQLite​\n\nNot supported\n\nCockroachDB​\nNative database types\tNative database type attribute\tNotes\nJSON | JSONB\t@db.JsonB\t\nClients​\nPrisma Client JS\nobject\nBytes​\n\nBytes is available in version 2.17.0\n and later.\n\nDefault type mappings​\nConnector\tDefault mapping\nPostgreSQL\tbytea\nSQL Server\tvarbinary\nMySQL\tLONGBLOB\nMongoDB\tBinData\nSQLite\tBLOB\nCockroachDB\tBYTES\nPostgreSQL​\nNative database types\tNative database type attribute\nbytea\t@db.ByteA\nMySQL​\nNative database types\tNative database type attribute\tNotes\nLONGBLOB\t@db.LongBlob\t\nBINARY\t@db.Binary\t\nVARBINARY\t@db.VarBinary\t\nTINYBLOB\t@db.TinyBlob\t\nBLOB\t@db.Blob\t\nMEDIUMBLOB\t@db.MediumBlob\t\nBIT\t@db.Bit\t\nMongoDB​\n\nBinData\n\nNative database type attribute\tNotes\n@db.ObjectId\tRequired if the underlying BSON type is OBJECT_ID (ID fields, relation scalars)\n@db.BinData\t\nMicrosoft SQL Server​\nNative database types\tNative database type attribute\tNotes\nbinary\t@db.Binary\t\nvarbinary\t@db.VarBinary\t\nimage\t@db.Image\t\nSQLite​\n\nBLOB\n\nCockroachDB​\nNative database types\tNative database type attribute\nBYTES | BYTEA | BLOB\t@db.Bytes\nClients​\nClient\tType\tDescription\nPrisma Client JS\t\nUint8Array\n\tSee examples of working with Bytes\nPrisma Client JS (before v6)\t\nBuffer\n\tSee examples of working with Bytes\nUnsupported​\nWARNING\n\nNot supported by MongoDB\nThe MongoDB connector does not support the Unsupported type.\n\nThe Unsupported type was introduced in 2.17.0\n and allows you to represent data types in the Prisma schema that are not supported by Prisma Client. Fields of type Unsupported can be created during Introspection with prisma db pull or written by hand, and created in the database with Prisma Migrate or db push.\n\nRemarks​\n\nFields with Unsupported types are not available in the generated client.\n\nIf a model contains a required Unsupported type, prisma.model.create(..), prisma.model.update(...) and prisma.model.upsert(...) are not available in Prisma Client.\n\nWhen you introspect a database that contains unsupported types, Prisma ORM will provide the following warning:\n\n*** WARNING ***\n\n\n\nThese fields are not supported by Prisma Client, because Prisma does not currently support their types.\n\n* Model \"Post\", field: \"circle\", original data type: \"circle\"\n\nExamples​\nmodel Star {\n\n  id       Int                    @id @default(autoincrement())\n\n  position Unsupported(\"circle\")?\n\n  example1 Unsupported(\"circle\")\n\n  circle   Unsupported(\"circle\")? @default(dbgenerated(\"'<(10,4),11>'::circle\"))\n\n}\n\nmodel field type modifiers​\n[] modifier​\n\nMakes a field a list.\n\nRemarks​\nCannot be optional (for example Post[]?).\nRelational databases​\nScalar lists (arrays) are only supported in the data model if your database natively supports them. Currently, scalar lists are therefore only supported when using PostgreSQL or CockroachDB (since MySQL and SQLite don't natively support scalar lists).\nMongoDB​\nScalar lists are supported\nExamples​\nDefine a scalar list​\nRelational databases\nMongoDB\nmodel User {\n\n  id             Int      @id @default(autoincrement())\n\n  favoriteColors String[]\n\n}\n\nDefine a scalar list with a default value​\n\nAvailable in version 4.0.0 and later.\n\nRelational databases\nMongoDB\nmodel User {\n\n  id             Int      @id @default(autoincrement())\n\n  favoriteColors String[] @default([\"red\", \"blue\", \"green\"])\n\n}\n\n? modifier​\n\nMakes a field optional.\n\nRemarks​\nCannot be used with a list field (for example, Posts[])\nExamples​\nOptional name field​\nmodel User {\n\n  id   Int     @id @default(autoincrement())\n\n  name String?\n\n}\n\nAttributes​\n\nAttributes modify the behavior of a field or block (e.g. models). There are two ways to add attributes to your data model:\n\nField attributes are prefixed with @\nBlock attributes are prefixed with @@\n\nSome attributes take arguments. Arguments in attributes are always named, but in most cases the argument name can be omitted.\n\nNote: The leading underscore in a signature means the argument name can be omitted.\n\n@id​\n\nDefines a single-field ID on the model.\n\nRemarks​\nGeneral​\nCannot be defined on a relation field\nCannot be optional\nRelational databases​\n\nCorresponding database construct: PRIMARY KEY\n\nCan be annotated with a @default attribute that uses functions to auto-generate an ID:\n\nautoincrement()\ncuid()\nuuid()\nulid()\n\nCan be defined on any scalar field (String, Int, enum)\n\nMongoDB​\n\nCorresponding database construct: Any valid BSON type, except arrays\n\nEvery model must define an @id field\n\nThe underlying ID field name is always\n_id\n, and must be mapped with @map(\"_id\")\n\nCan be defined on any scalar field (String, Int, enum) unless you want to use ObjectId in your database\n\nTo use an \nObjectId\n as your ID, you must:\n\nUse the String or Bytes field type\n\nAnnotate your field with @db.ObjectId:\n\nid   String  @db.ObjectId  @map(\"_id\")\n\n\nOptionally, annotate your field with a @default attribute that uses the auto() function to auto-generate an ObjectId\n\nid   String  @db.ObjectId  @map(\"_id\") @default(auto())\n\n\ncuid(), uuid() and ulid() are supported but do not generate a valid ObjectId - use auto() instead for @id\n\nautoincrement() is not supported\n\nArguments​\nName\tRequired\tType\tDescription\nmap\tNo\tString\tThe name of the underlying primary key constraint in the database.\n\nNot supported for MySQL or MongoDB.\nlength\tNo\tnumber\tAllows you to specify a maximum length for the subpart of the value to be indexed.\n\nMySQL only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\nsort\tNo\tString\tAllows you to specify in what order the entries of the ID are stored in the database. The available options are Asc and Desc.\n\nSQL Server only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\nclustered\tNo\tBoolean\tDefines whether the ID is clustered or non-clustered. Defaults to true.\n\nSQL Server only. In preview in versions 3.13.0 and later, and in general availability in versions 4.0.0 and later.\nSignature​\n@id(map: String?, length: number?, sort: String?, clustered: Boolean?)\n\n\nNote: Before version 4.0.0, or 3.5.0 with the extendedIndexes Preview feature enabled, the signature was:\n\n@id(map: String?)\n\n\nNote: Before version 3.0.0, the signature was:\n\n@id\n\nExamples​\n\nIn most cases, you want your database to create the ID. To do this, annotate the ID field with the @default attribute and initialize the field with a function.\n\nGenerate autoincrementing integers as IDs (Relational databases only)​\nmodel User {\n\n  id   Int    @id @default(autoincrement())\n\n  name String\n\n}\n\nGenerate ObjectId as IDs (MongoDB only)​\nmodel User {\n\n  id   String @id @default(auto()) @map(\"_id\") @db.ObjectId\n\n  name String\n\n}\n\nGenerate cuid() values as IDs​\nRelational databases\nMongoDB\nmodel User {\n\n  id   String @id @default(cuid())\n\n  name String\n\n}\n\nGenerate uuid() values as IDs​\nRelational databases\nMongoDB\nmodel User {\n\n  id   String @id @default(uuid())\n\n  name String\n\n}\n\nGenerate ulid() values as IDs​\nRelational databases\nMongoDB\nmodel User {\n\n  id   String @id @default(ulid())\n\n  name String\n\n}\n\nSingle-field IDs without default values​\n\nIn the following example, id does not have a default value:\n\nRelational databases\nMongoDB\nmodel User {\n\n  id   String @id\n\n  name String\n\n}\n\n\nNote that in the above case, you must provide your own ID values when creating new records for the User model using Prisma Client, e.g.:\n\nconst newUser = await prisma.user.create({\n\n  data: {\n\n    id: 1,\n\n    name: \"Alice\",\n\n  },\n\n});\n\nSpecify an ID on relation scalar field without a default value​\n\nIn the following example, authorId is a both a relation scalar and the ID of Profile:\n\nRelational databases\nMongoDB\nmodel Profile {\n\n  authorId Int    @id\n\n  author   User   @relation(fields: [authorId], references: [id])\n\n  bio      String\n\n}\n\n\n\nmodel User {\n\n  id      Int      @id\n\n  email   String   @unique\n\n  name    String?\n\n  profile Profile?\n\n}\n\n\nIn this scenario, you cannot create a Profile only - you must use Prisma Client's nested writes create a User or connect the profile to an existing user.\n\nThe following example creates a user and a profile:\n\nconst userWithProfile = await prisma.user.create({\n\n  data: {\n\n    id: 3,\n\n    email: \"bob@prisma.io\",\n\n    name: \"Bob Prismo\",\n\n    profile: {\n\n      create: {\n\n        bio: \"Hello, I'm Bob Prismo and I love apples, blue nail varnish, and the sound of buzzing mosquitoes.\",\n\n      },\n\n    },\n\n  },\n\n});\n\n\nThe following example connects a new profile to a user:\n\nconst profileWithUser = await prisma.profile.create({\n\n  data: {\n\n    bio: \"Hello, I'm Bob and I like nothing at all. Just nothing.\",\n\n    author: {\n\n      connect: {\n\n        id: 22,\n\n      },\n\n    },\n\n  },\n\n});\n\n@@id​\nWARNING\n\nNot supported by MongoDB\nThe MongoDB connector does not support composite IDs.\n\nDefines a multi-field ID (composite ID) on the model.\n\nRemarks​\nCorresponding database type: PRIMARY KEY\nCan be annotated with a @default attribute that uses functions to auto-generate an ID\nCannot be optional\nCan be defined on any scalar field (String, Int, enum)\nCannot be defined on a relation field\nThe name of the composite ID field in Prisma Client has the following pattern: field1_field2_field3\nArguments​\nName\tRequired\tType\tDescription\nfields\tYes\tFieldReference[]\tA list of field names - for example, [\"firstname\", \"lastname\"]\nname\tNo\tString\tThe name that Prisma Client will expose for the argument covering all fields, e.g. fullName in fullName: { firstName: \"First\", lastName: \"Last\"}\nmap\tNo\tString\tThe name of the underlying primary key constraint in the database.\n\nNot supported for MySQL.\nlength\tNo\tnumber\tAllows you to specify a maximum length for the subpart of the value to be indexed.\n\nMySQL only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\nsort\tNo\tString\tAllows you to specify in what order the entries of the ID are stored in the database. The available options are Asc and Desc.\n\nSQL Server only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\nclustered\tNo\tBoolean\tDefines whether the ID is clustered or non-clustered. Defaults to true.\n\nSQL Server only. In preview in versions 3.13.0 and later, and in general availability in versions 4.0.0 and later.\n\nThe name of the fields argument on the @@id attribute can be omitted:\n\n@@id(fields: [title, author])\n\n@@id([title, author])\n\nSignature​\n@@id(_ fields: FieldReference[], name: String?, map: String?)\n\n\nNote: Until version 3.0.0, the signature was:\n\n@@id(_ fields: FieldReference[])\n\nExamples​\nSpecify a multi-field ID on two String fields (Relational databases only)​\nmodel User {\n\n  firstName String\n\n  lastName  String\n\n  email     String  @unique\n\n  isAdmin   Boolean @default(false)\n\n\n\n  @@id([firstName, lastName])\n\n}\n\n\nWhen you create a user, you must provide a unique combination of firstName and lastName:\n\nconst user = await prisma.user.create({\n\n  data: {\n\n    firstName: \"Alice\",\n\n    lastName: \"Smith\",\n\n  },\n\n});\n\n\nTo retrieve a user, use the generated composite ID field (firstName_lastName):\n\nconst user = await prisma.user.findUnique({\n\n  where: {\n\n    firstName_lastName: {\n\n      firstName: \"Alice\",\n\n      lastName: \"Smith\",\n\n    },\n\n  },\n\n});\n\nSpecify a multi-field ID on two String fields and one Boolean field (Relational databases only)​\nmodel User {\n\n  firstName String\n\n  lastName  String\n\n  email     String  @unique\n\n  isAdmin   Boolean @default(false)\n\n\n\n  @@id([firstName, lastName, isAdmin])\n\n}\n\n\nWhen creating new User records, you now must provide a unique combination of values for firstName, lastName and isAdmin:\n\nconst user = await prisma.user.create({\n\n  data: {\n\n    firstName: \"Alice\",\n\n    lastName: \"Smith\",\n\n    isAdmin: true,\n\n  },\n\n});\n\nSpecify a multi-field ID that includes a relation field (Relational databases only)​\nmodel Post {\n\n  title     String\n\n  published Boolean @default(false)\n\n  author    User    @relation(fields: [authorId], references: [id])\n\n  authorId  Int\n\n\n\n  @@id([authorId, title])\n\n}\n\n\n\nmodel User {\n\n  id    Int     @default(autoincrement())\n\n  email String  @unique\n\n  name  String?\n\n  posts Post[]\n\n}\n\n\nWhen creating new Post records, you now must provide a unique combination of values for authorId (foreign key) and title:\n\nconst post = await prisma.post.create({\n\n  data: {\n\n    title: \"Hello World\",\n\n    author: {\n\n      connect: {\n\n        email: \"alice@prisma.io\",\n\n      },\n\n    },\n\n  },\n\n});\n\n@default​\n\nDefines a default value for a field.\n\nRemarks​\nDefault values that cannot yet be represented in the Prisma schema are represented by the dbgenerated() function when you use introspection.\nDefault values are not allowed on relation fields in the Prisma schema. Note however that you can still define default values on the fields backing a relation (the ones listed in the fields argument in the @relation attribute). A default value on the field backing a relation will mean that relation is populated automatically for you.\nDefault values can be used with scalar lists in databases that natively support them.\nRelational databases​\nCorresponding database construct: DEFAULT\nDefault values can be a static value (4, \"hello\") or one of the following functions:\nautoincrement()\nsequence() (CockroachDB only)\ndbgenerated(...)\ncuid()\ncuid(2)\nuuid()\nuuid(4)\nuuid(7)\nulid()\nnanoid()\nnow()\nDefault values that cannot yet be represented in the Prisma schema are represented by the dbgenerated(...) function when you use introspection.\nDefault values are not allowed on relation fields in the Prisma schema. Note however that you can still define default values on the fields backing a relation (the ones listed in the fields argument in the @relation attribute). A default value on the field backing a relation will mean that relation is populated automatically for you.\nDefault values can be used with scalar lists in databases that natively support them.\nJSON data. Note that JSON needs to be enclosed with double-quotes inside the @default attribute, e.g.: @default(\"[]\"). If you want to provide a JSON object, you need to enclose it with double-quotes and then escape any internal double quotes using a backslash, e.g.: @default(\"{ \\\"hello\\\": \\\"world\\\" }\").\nMongoDB​\nDefault values can be a static value (4, \"hello\") or one of the following functions:\nauto() (can only be used with @db.ObjectId to generate an ObjectId in MongoDB)\ncuid()\nuuid()\nulid()\nnow()\nArguments​\nName\tRequired\tType\tDescription\nvalue\tYes\tAn expression (e.g. 5, true, now())\t\nmap\tNo\tString\tSQL Server only.\n\nThe name of the value argument on the @default attribute can be omitted:\n\nid Int @id @default(value: autoincrement())\n\nid Int @id @default(autoincrement())\n\nSignature​\n@default(_ value: Expression, map: String?)\n\n\nNote: Until version 3.0.0, the signature was:\n\n@default(_ value: Expression)\n\nExamples​\nDefault value for an Int​\nRelational databases\nMongoDB\nmodel User {\n\n  email        String @unique\n\n  profileViews Int    @default(0)\n\n}\n\nDefault value for a Float​\nRelational databases\nMongoDB\nmodel User {\n\n  email  String @unique\n\n  number Float  @default(1.1)\n\n}\n\nDefault value for Decimal​\nRelational databases\nMongoDB\nmodel User {\n\n  email  String  @unique\n\n  number Decimal @default(22.99)\n\n}\n\nDefault value for BigInt​\nRelational databases\nMongoDB\nmodel User {\n\n  email  String @unique\n\n  number BigInt @default(34534535435353)\n\n}\n\nDefault value for a String​\nRelational databases\nMongoDB\nmodel User {\n\n  email String @unique\n\n  name  String @default(\"\")\n\n}\n\nDefault value for a Boolean​\nRelational databases\nMongoDB\nmodel User {\n\n  email   String  @unique\n\n  isAdmin Boolean @default(false)\n\n}\n\nDefault value for a DateTime​\n\nNote that static default values for DateTime are based on the ISO 8601\n standard.\n\nRelational databases\nMongoDB\nmodel User {\n\n  email String   @unique\n\n  data  DateTime @default(\"2020-03-19T14:21:00+02:00\")\n\n}\n\nDefault value for a Bytes​\nRelational databases\nMongoDB\nmodel User {\n\n  email  String @unique\n\n  secret Bytes  @default(\"SGVsbG8gd29ybGQ=\")\n\n}\n\nDefault value for an enum​\nRelational databases\nMongoDB\nenum Role {\n\n  USER\n\n  ADMIN\n\n}\n\nmodel User {\n\n  id      Int      @id @default(autoincrement())\n\n  email   String   @unique\n\n  name    String?\n\n  role    Role     @default(USER)\n\n  posts   Post[]\n\n  profile Profile?\n\n}\n\nDefault values for scalar lists​\nRelational databases\nMongoDB\nmodel User {\n\n  id             Int      @id @default(autoincrement())\n\n  posts          Post[]\n\n  favoriteColors String[] @default([\"red\", \"yellow\", \"purple\"])\n\n  roles          Role[]   @default([USER, DEVELOPER])\n\n}\n\n\n\nenum Role {\n\n  USER\n\n  DEVELOPER\n\n  ADMIN\n\n}\n\n@unique​\n\nDefines a unique constraint for this field.\n\nRemarks​\nGeneral​\nA field annotated with @unique can be optional or required\nA field annotated with @unique must be required if it represents the only unique constraint on a model without an @id / @@id\nA model can have any number of unique constraints\nCan be defined on any scalar field\nCannot be defined on a relation field\nRelational databases​\nCorresponding database construct: UNIQUE\nNULL values are considered to be distinct (multiple rows with NULL values in the same column are allowed)\nAdding a unique constraint automatically adds a corresponding unique index to the specified column(s).\nMongoDB​\nEnforced by a unique index in MongoDB\nArguments​\nName\tRequired\tType\tDescription\nmap\tNo\tString\t\nlength\tNo\tnumber\tAllows you to specify a maximum length for the subpart of the value to be indexed.\n\nMySQL only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\nsort\tNo\tString\tAllows you to specify in what order the entries of the constraint are stored in the database. The available options are Asc and Desc.\n\nIn preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\nclustered\tNo\tBoolean\tDefines whether the constraint is clustered or non-clustered. Defaults to false.\n\nSQL Server only. In preview in versions 3.13.0 and later, and in general availability in versions 4.0.0 and later.\n¹ Can be required by some of the index and field types.\nSignature​\n@unique(map: String?, length: number?, sort: String?)\n\n\nNote: Before version 4.0.0, or 3.5.0 with the extendedIndexes Preview feature enabled, the signature was:\n\n@unique(map: String?)\n\n\nNote: Before version 3.0.0, the signature was:\n\n@unique\n\nExamples​\nSpecify a unique attribute on a required String field​\nRelational databases\nMongoDB\nmodel User {\n\n  email String @unique\n\n  name  String\n\n}\n\nSpecify a unique attribute on an optional String field​\nRelational databases\nMongoDB\nmodel User {\n\n  id    Int     @id @default(autoincrement())\n\n  email String? @unique\n\n  name  String\n\n}\n\nSpecify a unique attribute on relation scalar field authorId​\nRelational databases\nMongoDB\nmodel Post {\n\n  author    User    @relation(fields: [authorId], references: [id])\n\n  authorId  Int     @unique\n\n  title     String\n\n  published Boolean @default(false)\n\n}\n\n\n\nmodel User {\n\n  id    Int     @id @default(autoincrement())\n\n  email String? @unique\n\n  name  String\n\n  Post  Post[]\n\n}\n\nSpecify a unique attribute with cuid() values as default values​\nRelational databases\nMongoDB\nmodel User {\n\n  token String @unique @default(cuid())\n\n  name  String\n\n}\n\n@@unique​\n\nDefines a compound unique constraint for the specified fields.\n\nRemarks​\nGeneral​\n\nAll fields that make up the unique constraint must be mandatory fields. The following model is not valid because id could be null:\n\nmodel User {\n\n  firstname Int\n\n  lastname  Int\n\n  id        Int?\n\n\n\n  @@unique([firstname, lastname, id])\n\n}\n\n\nThe reason for this behavior is that all connectors consider null values to be distinct, which means that two rows that look identical are considered unique:\n\n firstname  | lastname | id\n\n -----------+----------+------\n\n John       | Smith    | null\n\n John       | Smith    | null\n\n\nA model can have any number of @@unique blocks\n\nRelational databases​\nCorresponding database construct: UNIQUE\nA @@unique block is required if it represents the only unique constraint on a model without an @id / @@id\nAdding a unique constraint automatically adds a corresponding unique index to the specified column(s)\nMongoDB​\nEnforced by a compound index in MongoDB\nA @@unique block cannot be used as the only unique identifier for a model - MongoDB requires an @id field\nArguments​\nName\tRequired\tType\tDescription\nfields\tYes\tFieldReference[]\tA list of field names - for example, [\"firstname\", \"lastname\"]. Fields must be mandatory - see remarks.\nname\tNo\tString\tThe name of the unique combination of fields - defaults to fieldName1_fieldName2_fieldName3\nmap\tNo\tString\t\nlength\tNo\tnumber\tAllows you to specify a maximum length for the subpart of the value to be indexed.\n\nMySQL only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\nsort\tNo\tString\tAllows you to specify in what order the entries of the constraint are stored in the database. The available options are Asc and Desc.\n\nIn preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\nclustered\tNo\tBoolean\tDefines whether the constraint is clustered or non-clustered. Defaults to false.\n\nSQL Server only. In preview in versions 3.13.0 and later, and in general availability in versions 4.0.0 and later.\n\nThe name of the fields argument on the @@unique attribute can be omitted:\n\n@@unique(fields: [title, author])\n\n@@unique([title, author])\n\n@@unique(fields: [title, author], name: \"titleAuthor\")\n\n\nThe length and sort arguments are added to the relevant field names:\n\n@@unique(fields: [title(length:10), author])\n\n@@unique([title(sort: Desc), author(sort: Asc)])\n\nSignature​\n@@unique(_ fields: FieldReference[], name: String?, map: String?)\n\n\nNote: Before version 4.0.0, or before version 3.5.0 with the extendedIndexes Preview feature enabled, the signature was:\n\n@@unique(_ fields: FieldReference[], name: String?, map: String?)\n\n\nNote: Before version 3.0.0, the signature was:\n\n@@unique(_ fields: FieldReference[], name: String?)\n\nExamples​\nSpecify a multi-field unique attribute on two String fields​\nRelational databases\nMongoDB\nmodel User {\n\n  id        Int     @default(autoincrement())\n\n  firstName String\n\n  lastName  String\n\n  isAdmin   Boolean @default(false)\n\n\n\n  @@unique([firstName, lastName])\n\n}\n\n\nTo retrieve a user, use the generated field name (firstname_lastname):\n\nconst user = await prisma.user.findUnique({\n\n  where: {\n\n    firstName_lastName: {\n\n      firstName: \"Alice\",\n\n      lastName: \"Smith\",\n\n      isAdmin: true,\n\n    },\n\n  },\n\n});\n\nSpecify a multi-field unique attribute on two String fields and one Boolean field​\nRelational databases\nMongoDB\nmodel User {\n\n  id        Int     @default(autoincrement())\n\n  firstName String\n\n  lastName  String\n\n  isAdmin   Boolean @default(false)\n\n\n\n  @@unique([firstName, lastName, isAdmin])\n\n}\n\nSpecify a multi-field unique attribute that includes a relation field​\nRelational databases\nMongoDB\nmodel Post {\n\n  id        Int     @default(autoincrement())\n\n  author    User    @relation(fields: [authorId], references: [id])\n\n  authorId  Int\n\n  title     String\n\n  published Boolean @default(false)\n\n\n\n  @@unique([authorId, title])\n\n}\n\n\n\nmodel User {\n\n  id    Int    @id @default(autoincrement())\n\n  email String @unique\n\n  posts Post[]\n\n}\n\nSpecify a custom name for a multi-field unique attribute​\nRelational databases\nMongoDB\nmodel User {\n\n  id        Int     @default(autoincrement())\n\n  firstName String\n\n  lastName  String\n\n  isAdmin   Boolean @default(false)\n\n\n\n  @@unique(fields: [firstName, lastName, isAdmin], name: \"admin_identifier\")\n\n}\n\n\nTo retrieve a user, use the custom field name (admin_identifier):\n\nconst user = await prisma.user.findUnique({\n\n  where: {\n\n    admin_identifier: {\n\n      firstName: \"Alice\",\n\n      lastName: \"Smith\",\n\n      isAdmin: true,\n\n    },\n\n  },\n\n});\n\n@@index​\n\nDefines an index in the database.\n\nRemarks​\nRelational databases​\nCorresponding database construct: INDEX\nThere are some additional index configuration options that cannot be provided via the Prisma schema yet. These include:\nPostgreSQL and CockroachDB:\nDefine index fields as expressions (e.g. CREATE INDEX title ON public.\"Post\"((lower(title)) text_ops);)\nDefine partial indexes with WHERE\nCreate indexes concurrently with CONCURRENTLY\nINFO\n\nWhile you cannot configure these option in your Prisma schema, you can still configure them on the database-level directly.\n\nMongoDB​\nIn version 3.12.0 and later, you can define an index on a field of a composite type using the syntax @@index([compositeType.field]). See Defining composite type indexes for more details.\nArguments​\nName\tRequired\tType\tDescription\nfields\tYes\tFieldReference[]\tA list of field names - for example, [\"firstname\", \"lastname\"]\nname\tNo\tString\tThe name that Prisma Client will expose for the argument covering all fields, e.g. fullName in fullName: { firstName: \"First\", lastName: \"Last\"}\nmap\tNo\tmap\tThe name of the index in the underlying database (Prisma generates an index name that respects identifier length limits if you do not specify a name. Prisma uses the following naming convention: tablename.field1_field2_field3_unique)\nlength\tNo\tnumber\tAllows you to specify a maximum length for the subpart of the value to be indexed.\n\nMySQL only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\nsort\tNo\tString\tAllows you to specify in what order the entries of the index or constraint are stored in the database. The available options are asc and desc.\n\nIn preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\nclustered\tNo\tBoolean\tDefines whether the index is clustered or non-clustered. Defaults to false.\n\nSQL Server only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\ntype\tNo\tidentifier\tAllows you to specify an index access method. Defaults to BTree.\n\nPostgreSQL and CockroachDB only. In preview with the Hash index access method in versions 3.6.0 and later, and with the Gist, Gin, SpGist and Brin methods added in 3.14.0. In general availability in versions 4.0.0 and later.\nops\tNo\tidentifier or a function\tAllows you to define the index operators for certain index types.\n\nPostgreSQL only. In preview in versions 3.14.0 and later, and in general availability in versions 4.0.0 and later.\n\nThe name of the fields argument on the @@index attribute can be omitted:\n\n@@index(fields: [title, author])\n\n@@index([title, author])\n\n\nThe length and sort arguments are added to the relevant field names:\n\n@@index(fields: [title(length:10), author])\n\n@@index([title(sort: Asc), author(sort: Desc)])\n\nSignature​\n@@index(_ fields: FieldReference[], map: String?)\n\n\nNote: Until version 3.0.0, the signature was:\n\n@@index(_ fields: FieldReference[], name: String?)\n\n\nThe old name argument will still be accepted to avoid a breaking change.\n\nExamples​\n\nAssume you want to add an index for the title field of the Post model\n\nDefine a single-column index (Relational databases only)​\nmodel Post {\n\n  id      Int     @id @default(autoincrement())\n\n  title   String\n\n  content String?\n\n\n\n  @@index([title])\n\n}\n\nDefine a multi-column index (Relational databases only)​\nmodel Post {\n\n  id      Int     @id @default(autoincrement())\n\n  title   String\n\n  content String?\n\n\n\n  @@index([title, content])\n\n}\n\nDefine an index with a name (Relational databases only)​\nmodel Post {\n\n  id      Int     @id @default(autoincrement())\n\n  title   String\n\n  content String?\n\n\n\n  @@index(fields: [title, content], name: \"main_index\")\n\n}\n\nDefine an index on a composite type field (Relational databases only)​\ntype Address {\n\n  street String\n\n  number Int\n\n}\n\n\n\nmodel User {\n\n  id      Int     @id\n\n  email   String\n\n  address Address\n\n\n\n  @@index([address.number])\n\n}\n\n@relation​\n\nDefines meta information about the relation. Learn more.\n\nRemarks​\nRelational databases​\nCorresponding database constructs: FOREIGN KEY / REFERENCES\nMongoDB​\nIf your model's primary key is of type ObjectId in the underlying database, both the primary key and the foreign key must have the @db.ObjectId attribute\nArguments​\nName\tType\tRequired\tDescription\tExample\nname\tString\tSometimes (e.g. to disambiguate a relation)\tDefines the name of the relationship. In an m-n-relation, it also determines the name of the underlying relation table.\t\"CategoryOnPost\", \"MyRelation\"\nfields\tFieldReference[]\tOn annotated relation fields\tA list of fields of the current model\t[\"authorId\"], [\"authorFirstName, authorLastName\"]\nreferences\tFieldReference[]\tOn annotated relation fields\tA list of fields of the model on the other side of the relation\t[\"id\"], [\"firstName, lastName\"]\nmap\tString\tNo\tDefines a custom name for the foreign key in the database.\t[\"id\"], [\"firstName, lastName\"]\nonUpdate\tEnum. See Types of referential actions for values.\tNo\tDefines the referential action to perform when a referenced entry in the referenced model is being updated.\tCascade, NoAction\nonDelete\tEnum. See Types of referential actions for values.\tNo\tDefines the referential action to perform when a referenced entry in the referenced model is being deleted.\tCascade, NoAction\n\nThe name of the name argument on the @relation attribute can be omitted (references is required):\n\n@relation(name: \"UserOnPost\", references: [id])\n\n@relation(\"UserOnPost\", references: [id])\n\n\n\n// or\n\n\n\n@relation(name: \"UserOnPost\")\n\n@relation(\"UserOnPost\")\n\nSignature​\n@relation(_ name: String?, fields: FieldReference[]?, references: FieldReference[]?, onDelete: ReferentialAction?, onUpdate: ReferentialAction?, map: String?)\n\n\nWith SQLite, the signature changes to:\n\n@relation(_ name: String?, fields: FieldReference[]?, references: FieldReference[]?, onDelete: ReferentialAction?, onUpdate: ReferentialAction?)\n\n\nNote: Until version 3.0.0, the signature was:\n\n@relation(_ name: String?, fields: FieldReference[]?, references: FieldReference[]?)\n\nExamples​\n\nSee: The @relation attribute.\n\n@map​\n\nMaps a field name or enum value from the Prisma schema to a column or document field with a different name in the database. If you do not use @map, the Prisma field name matches the column name or document field name exactly.\n\nSee Using custom model and field names to see how @map and @@map changes the generated Prisma Client.\n\nRemarks​\nGeneral​\n@map does not rename the columns / fields in the database\n@map does change the field names in the generated client\nMongoDB​\n\nYour @id field must include @map(\"_id\"). For example:\n\nmodel User {\n\n  id String @default(auto()) @map(\"_id\") @db.ObjectId\n\n}\n\nArguments​\nName\tType\tRequired\tDescription\tExample\nname\tString\tYes\tThe database column (relational databases) or document field (MongoDB) name.\t\"comments\", \"someFieldName\"\n\nThe name of the name argument on the @map attribute can be omitted:\n\n@map(name: \"is_admin\")\n\n@map(\"users\")\n\nSignature​\n@map(_ name: String)\n\nExamples​\nMap the firstName field to a column called first_name​\nRelational databases\nMongoDB\nmodel User {\n\n  id        Int    @id @default(autoincrement())\n\n  firstName String @map(\"first_name\")\n\n}\n\n\nThe generated client:\n\nawait prisma.user.create({\n\n  data: {\n\n    firstName: \"Yewande\", // first_name --> firstName\n\n  },\n\n});\n\nMap an enum named ADMIN to a database enum named admin​\nenum Role {\n\n  ADMIN    @map(\"admin\")\n\n  CUSTOMER\n\n}\n\n@@map​\n\nMaps the Prisma schema model name to a table (relational databases) or collection (MongoDB) with a different name, or an enum name to a different underlying enum in the database. If you do not use @@map, the model name matches the table (relational databases) or collection (MongoDB) name exactly.\n\nSee Using custom model and field names to see how @map and @@map changes the generated Prisma Client.\n\nArguments​\nName\tType\tRequired\tDescription\tExample\nname\tString\tYes\tThe database table (relational databases) or collection (MongoDB) name.\t\"comments\", \"someTableOrCollectionName\"\n\nThe name of the name argument on the @@map attribute can be omitted\n\n@@map(name: \"users\")\n\n@@map(\"users\")\n\nSignature​\n@@map(_ name: String)\n\nExamples​\nMap the User model to a database table/collection named users​\nRelational databases\nMongoDB\nmodel User {\n\n  id   Int    @id @default(autoincrement())\n\n  name String\n\n\n\n  @@map(\"users\")\n\n}\n\n\nThe generated client:\n\nawait prisma.user.create({\n\n  // users --> user\n\n  data: {\n\n    name: \"Yewande\",\n\n  },\n\n});\n\nMap the Role enum to a native enum in the database named _Role its values to lowercase values in the database​\nenum Role {\n\n  ADMIN    @map(\"admin\")\n\n  CUSTOMER @map(\"customer\")\n\n\n\n  @@map(\"_Role\")\n\n}\n\n@updatedAt​\n\nAutomatically stores the time when a record was last updated. If you do not supply a time yourself, Prisma Client will automatically set the value for fields with this attribute.\n\nRemarks​\nCompatible with DateTime fields\nImplemented at Prisma ORM level\nWARNING\n\nIn versions before 4.4.0\n, if you're also using now(), the time might differ from the @updatedAt values if your database and app have different time zones. This happens because @updatedAt operates at the Prisma ORM level, while now() operates at the database level.\n\nNOTE\n\nIf you pass an empty update clause, the @updatedAt value will remain unchanged. For example:\n\nawait prisma.user.update({\n\n  where: {\n\n    id: 1,\n\n  },\n\n  data: {}, //<- Empty update clause\n\n});\n\nArguments​\n\nN/A\n\nSignature​\n@updatedAt\n\nExamples​\nRelational databases\nMongoDB\nmodel Post {\n\n  id        String   @id\n\n  updatedAt DateTime @updatedAt\n\n}\n\n@ignore​\n\nAdd @ignore to a field that you want to exclude from Prisma Client (for example, a field that you do not want Prisma Client users to update). Ignored fields are excluded from the generated Prisma Client. The model's create method is disabled when doing this for required fields with no @default (because the database cannot create an entry without that data).\n\nRemarks​\nIn 2.17.0\n and later, Prisma ORM automatically adds @ignore to fields that refer to invalid models when you introspect.\nExamples​\n\nThe following example demonstrates manually adding @ignore to exclude the email field from Prisma Client:\n\nschema.prisma\nmodel User {\n\n  id    Int    @id\n\n  name  String\n\n  email String @ignore // this field will be excluded\n\n}\n\n@@ignore​\n\nAdd @@ignore to a model that you want to exclude from Prisma Client (for example, a model that you do not want Prisma users to update). Ignored models are excluded from the generated Prisma Client.\n\nRemarks​\nIn 2.17.0\n and later, Prisma ORM adds @@ignore to an invalid model. (It also adds @ignore to relations pointing to such a model)\nExamples​\n\nIn the following example, the Post model is invalid because it does not have a unique identifier. Use @@ignore to exclude it from the generated Prisma Client API:\n\nschema.prisma\n/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.\n\nmodel Post {\n\n  id       Int  @default(autoincrement()) // no unique identifier\n\n  author   User @relation(fields: [authorId], references: [id])\n\n  authorId Int\n\n\n\n  @@ignore\n\n}\n\n\nIn the following example, the Post model is invalid because it does not have a unique identifier, and the posts relation field on User is invalid because it refers to the invalid Post model. Use @@ignore on the Post model and @ignore on the posts relation field in User to exclude both the model and the relation field from the generated Prisma Client API:\n\nschema.prisma\n/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.\n\nmodel Post {\n\n  id       Int  @default(autoincrement()) // no unique identifier\n\n  author   User @relation(fields: [authorId], references: [id])\n\n  authorId Int\n\n\n\n  @@ignore\n\n}\n\n\n\nmodel User {\n\n  id    Int     @id @default(autoincrement())\n\n  name  String?\n\n  posts Post[]  @ignore\n\n}\n\n@@schema​\n\nAdd @@schema to a model to specify which schema in your database should contain the table associated with that model. Learn more about adding multiple schema's here.\n\nNOTE\n\nMultiple database schema support is only available with the PostgreSQL, CockroachDB, and SQL Server connectors.\n\nArguments​\nName\tType\tRequired\tDescription\tExample\nname\tString\tYes\tThe name of the database schema.\t\"base\", \"auth\"\n\nThe name of the name argument on the @@schema attribute can be omitted\n\n@@schema(name: \"auth\")\n\n@@schema(\"auth\")\n\nSignature​\n@@schema(_ name: String)\n\nExamples​\nMap the User model to a database schema named auth​\ngenerator client {\n\n  provider        = \"prisma-client-js\"\n\n}\n\n\n\ndatasource db {\n\n  provider = \"postgresql\"\n\n  url      = env(\"DATABASE_URL\")\n\n  schemas  = [\"auth\"]\n\n}\n\n\n\nmodel User {\n\n  id   Int    @id @default(autoincrement())\n\n  name String\n\n\n\n  @@schema(\"auth\")\n\n}\n\nINFO\n\nFor more information about using the multiSchema feature, refer to this guide.\n\n@shardKey​\nNOTE\n\nThis features requires the shardKeys Preview feature flag on your generator:\n\ngenerator client {\n\n  provider = \"prisma-client-js\"\n\n  output = \"../generated/prisma\"\n\n  previewFeatures = [\"shardKeys\"]\n\n}\n\n\nThe @shardKey attribute is only compatible with PlanetScale\n databases. It enables you define a shard key\n on a field of your model:\n\nmodel User {\n\n  id     String @default(uuid())\n\n  region String @shardKey\n\n}\n\n@@shardKey​\nNOTE\n\nThis features requires the shardKeys Preview feature flag on your generator:\n\ngenerator client {\n\n  provider = \"prisma-client-js\"\n\n  output = \"../generated/prisma\"\n\n  previewFeatures = [\"shardKeys\"]\n\n}\n\n\nThe @shardKey attribute is only compatible with PlanetScale\n databases. It enables you define a shard key\n on multiple fields of your model:\n\nmodel User {\n\n  id         String @default(uuid())\n\n  country    String\n\n  customerId String\n\n  @@shardKey([country, customerId])\n\n}\n\nAttribute functions​\nauto()​\nWARNING\nThis function is available on MongoDB only.\n\nRepresents default values that are automatically generated by the database.\n\nRemarks​\nMongoDB​\n\nUsed to generate an ObjectId for @id fields:\n\nid  String  @map(\"_id\") @db.ObjectId @default(auto())\n\nRelational databases​\n\nThe auto() function is not available on relational databases.\n\nExample​\nGenerate ObjectId (MongoDB only)​\nmodel User {\n\n  id   String  @id @default(auto()) @map(\"_id\") @db.ObjectId\n\n  name String?\n\n}\n\nautoincrement()​\nWARNING\n\nNot supported by MongoDB\nThe MongoDB connector does not support the autoincrement() function.\n\nCreate a sequence of integers in the underlying database and assign the incremented values to the ID values of the created records based on the sequence.\n\nRemarks​\n\nCompatible with Int on most databases (BigInt on CockroachDB)\n\nImplemented on the database-level, meaning that it manifests in the database schema and can be recognized through introspection. Database implementations:\n\nDatabase\tImplementation\nPostgreSQL\t\nSERIAL\n type\nMySQL\t\nAUTO_INCREMENT\n attribute\nSQLite\t\nAUTOINCREMENT\n keyword\nCockroachDB\t\nSERIAL\n type\nExamples​\nGenerate autoincrementing integers as IDs (Relational databases only)​\nmodel User {\n\n  id   Int    @id @default(autoincrement())\n\n  name String\n\n}\n\nsequence()​\nINFO\n\nOnly supported by CockroachDB\nThe sequence function is only supported by CockroachDB connector.\n\nCreate a sequence of integers in the underlying database and assign the incremented values to the values of the created records based on the sequence.\n\nOptional arguments​\nArgument\tExample\nvirtual\t@default(sequence(virtual))\nVirtual sequences are sequences that do not generate monotonically increasing values and instead produce values like those generated by the built-in function unique_rowid().\ncache\t@default(sequence(cache: 20))\nThe number of sequence values to cache in memory for reuse in the session. A cache size of 1 means that there is no cache, and cache sizes of less than 1 are not valid.\nincrement\t@default(sequence(increment: 4))\nThe new value by which the sequence is incremented. A negative number creates a descending sequence. A positive number creates an ascending sequence.\nminValue\t@default(sequence(minValue: 10))\nThe new minimum value of the sequence.\nmaxValue\t@default(sequence(maxValue: 3030303))\nThe new maximum value of the sequence.\nstart\t@default(sequence(start: 2))\nThe value the sequence starts at, if it's restarted or if the sequence hits the maxValue.\nExamples​\nGenerate sequencing integers as IDs​\nmodel User {\n\n  id   Int    @id @default(sequence(maxValue: 4294967295))\n\n  name String\n\n}\n\ncuid()​\n\nGenerate a globally unique identifier based on the \ncuid\n spec.\n\nIf you'd like to use \ncuid2\n values, you can pass 2 as an argument to the cuid function: cuid(2).\n\nRemarks​\nCompatible with String.\nImplemented by Prisma ORM and therefore not \"visible\" in the underlying database schema. You can still use cuid() when using introspection by manually changing your Prisma schema and generating Prisma Client, in that case the values will be generated by Prisma's query engine.\nSince the length of cuid() output is undefined per the cuid creator, a safe field size is 30 characters, in order to allow for enough characters for very large values. If you set the field size as less than 30, and then a larger value is generated by cuid(), you might see Prisma Client errors such as Error: The provided value for the column is too long for the column's type.\nFor MongoDB: cuid() does not generate a valid ObjectId. You can use @db.ObjectId syntax if you want to use ObjectId in the underlying database. However, you can still use cuid() if your _id field is not of type ObjectId.\nExamples​\nGenerate cuid() values as IDs​\nRelational databases\nMongoDB\nmodel User {\n\n  id   String @id @default(cuid())\n\n  name String\n\n}\n\nGenerate cuid(2) values as IDs based on the cuid2 spec​\nRelational databases\nMongoDB\nmodel User {\n\n  id   String @id @default(cuid(2))\n\n  name String\n\n}\n\nuuid()​\n\nGenerate a globally unique identifier based on the UUID\n spec. Prisma ORM supports versions 4 (default) and 7.\n\nRemarks​\nCompatible with String.\nImplemented by Prisma ORM and therefore not \"visible\" in the underlying database schema. You can still use uuid() when using introspection by manually changing your Prisma schema and generating Prisma Client, in that case the values will be generated by Prisma ORM's query engine.\nFor relational databases: If you do not want to use Prisma ORM's uuid() function, you can use the native database function with dbgenerated.\nFor MongoDB: uuid() does not generate a valid ObjectId. You can use @db.ObjectId syntax if you want to use ObjectId in the underlying database. However, you can still use uuid() if your _id field is not of type ObjectId.\nExamples​\nGenerate uuid() values as IDs using UUID v4​\nRelational databases\nMongoDB\nmodel User {\n\n  id   String @id @default(uuid())\n\n  name String\n\n}\n\nGenerate uuid(7) values as IDs using UUID v7​\nRelational databases\nMongoDB\nmodel User {\n\n  id   String @id @default(uuid(7))\n\n  name String\n\n}\n\nulid()​\n\nGenerate a universally unique lexicographically sortable identifier based on the ULID\n spec.\n\nRemarks​\nulid() will produce 128-bit random identifier represented as a 26-character long alphanumeric string, e.g.: 01ARZ3NDEKTSV4RRFFQ69G5FAV\nExamples​\nGenerate ulid() values as IDs​\nRelational databases\nMongoDB\nmodel User {\n\n  id   String @id @default(ulid())\n\n  name String\n\n}\n\nnanoid()​\n\nGenerated values based on the Nano ID\n spec. nanoid() accepts an integer value between 2 and 255 that specifies the length of the generate ID value, e.g. nanoid(16) will generated ID with 16 characters. If you don't provide a value to the nanoid() function, the default value is 21.\n\nINFO\n\nNano ID is quite comparable to UUID v4 (random-based). It has a similar number of random bits in the ID (126 in Nano ID and 122 in UUID), so it has a similar collision probability:\n\nFor there to be a one in a billion chance of duplication, 103 trillion version 4 IDs must be generated.\n\nThere are two main differences between Nano ID and UUID v4:\n\nNano ID uses a bigger alphabet, so a similar number of random bits are packed in just 21 symbols instead of 36.\nNano ID code is 4 times smaller than uuid/v4 package: 130 bytes instead of 423.\nRemarks​\nCompatible with String.\nImplemented by Prisma ORM and therefore not \"visible\" in the underlying database schema. You can still use uuid() when using introspection by manually changing your Prisma schema and generating Prisma Client, in that case the values will be generated by Prisma ORM's query engine.\nFor MongoDB: nanoid() does not generate a valid ObjectId. You can use @db.ObjectId syntax if you want to use ObjectId in the underlying database. However, you can still use nanoid() if your _id field is not of type ObjectId.\nExamples​\nGenerate nanoid() values with 21 characters as IDs​\nRelational databases\nMongoDB\nmodel User {\n\n  id   String @id @default(nanoid())\n\n  name String\n\n}\n\nGenerate nanoid() values with 16 characters as IDs​\nRelational databases\nMongoDB\nmodel User {\n\n  id   String @id @default(nanoid(16))\n\n  name String\n\n}\n\nnow()​\n\nSet a timestamp of the time when a record is created.\n\nRemarks​\nGeneral​\nCompatible with DateTime\nWARNING\n\nIn versions before 4.4.0\n, if you're also using @updatedAt, the time might differ from the now() values if your database and app have different time zones. This happens because @updatedAt operates at the Prisma ORM level, while now() operates at the database level.\n\nRelational databases​\n\nImplemented on the database-level, meaning that it manifests in the database schema and can be recognized through introspection. Database implementations:\n\nDatabase\tImplementation\nPostgreSQL\t\nCURRENT_TIMESTAMP\n and aliases like now()\nMySQL\t\nCURRENT_TIMESTAMP\n and aliases like now()\nSQLite\tCURRENT_TIMESTAMP and aliases like date('now')\nCockroachDB\t\nCURRENT_TIMESTAMP\n and aliases like now()\nMongoDB​\nImplemented at Prisma ORM level\nExamples​\nSet current timestamp value when a record is created​\nRelational databases\nMongoDB\nmodel User {\n\n  id        String   @id\n\n  createdAt DateTime @default(now())\n\n}\n\ndbgenerated(...)​\n\nRepresents default values that cannot be expressed in the Prisma schema (such as random()).\n\nRemarks​\nRelational databases​\n\nCompatible with any scalar type\n\nCan not be an empty string dbgenerated(\"\") in 2.21.0\n and later\n\nAccepts a String value in 2.17.0\n and later, which allows you to:\n\nSet default values for Unsupported types\nOverride default value behavior for supported types\n\nString values in dbgenerated(...) might not match what the DB returns as the default value, because values such as strings may be explicitly cast (e.g. 'hello'::STRING). When a mismatch is present, Prisma Migrate indicates a migration is still needed. You can use prisma db pull to infer the correct value to resolve the discrepancy. (Related issue\n)\n\nExamples​\nSet default value for Unsupported type​\ncircle     Unsupported(\"circle\")?   @default(dbgenerated(\"'<(10,4),11>'::circle\"))\n\nOverride default value behavior for supported types​\n\nYou can also use dbgenerated(...) to set the default value for supported types. For example, in PostgreSQL you can generate UUIDs at the database level rather than rely on Prisma ORM's uuid():\n\nmodel User {\n\n  id   String  @id @default(dbgenerated(\"gen_random_uuid()\")) @db.Uuid\n\n  id   String  @id @default(uuid()) @db.Uuid\n\n  test String?\n\n}\n\nINFO\n\nNote: \ngen_random_uuid()\nis a PostgreSQL function\n. To use it in PostgreSQL versions 12.13 and earlier, you must enable the pgcrypto extension.\n\nIn Prisma ORM versions 4.5.0 and later, you can declare the pgcrypto extension in your Prisma schema with the postgresqlExtensions preview feature.\n\nAttribute argument types​\nFieldReference[]​\n\nAn array of field names: [id], [firstName, lastName]\n\nString​\n\nA variable length text in double quotes: \"\", \"Hello World\", \"Alice\"\n\nExpression​\n\nAn expression that can be evaluated by Prisma ORM: 42.0, \"\", Bob, now(), cuid()\n\nenum​\nWARNING\n\nNot supported Microsoft SQL Server\nThe Microsoft SQL Server connector does not support the enum type.\n\nDefines an enum .\n\nRemarks​\nEnums are natively supported by PostgreSQL\n and MySQL\nEnums are implemented and enforced at Prisma ORM level in SQLite and MongoDB\nNaming conventions​\nEnum names must start with a letter (they are typically spelled in PascalCase\n)\nEnums must use the singular form (e.g. Role instead of role, roles or Roles).\nMust adhere to the following regular expression: [A-Za-z][A-Za-z0-9_]*\nExamples​\nSpecify an enum with two possible values​\nRelational databases\nMongoDB\nenum Role {\n\n  USER\n\n  ADMIN\n\n}\n\n\n\nmodel User {\n\n  id   Int  @id @default(autoincrement())\n\n  role Role\n\n}\n\nSpecify an enum with two possible values and set a default value​\nRelational databases\nMongoDB\nenum Role {\n\n  USER\n\n  ADMIN\n\n}\n\n\n\nmodel User {\n\n  id   Int  @id @default(autoincrement())\n\n  role Role @default(USER)\n\n}\n\ntype​\nWARNING\n\nComposite types are available for MongoDB only.\n\nINFO\n\nComposite types are available in versions 3.12.0 and later, and in versions 3.10.0 and later if you enable the mongodb Preview feature flag.\n\nDefines a composite type .\n\nNaming conventions​\n\nType names must:\n\nstart with a letter (they are typically spelled in PascalCase\n)\nadhere to the following regular expression: [A-Za-z][A-Za-z0-9_]*\nExamples​\nDefine a Product model with a list of Photo composite types​\nmodel Product {\n\n  id     String  @id @default(auto()) @map(\"_id\") @db.ObjectId\n\n  name   String\n\n  photos Photo[]\n\n}\n\n\n\ntype Photo {\n\n  height Int\n\n  width  Int\n\n  url    String\n\n}\n"
  },
  {
    "title": "Prisma CLI reference | Prisma Documentation",
    "url": "https://www.prisma.io/docs/orm/reference/prisma-cli-reference",
    "html": "ORMReference\nPrisma CLI reference\n\nThis document describes the Prisma CLI commands, arguments, and options.\n\nCommands​\nversion (-v)​\n\nThe version command outputs information about your current prisma version, platform, and engine binaries.\n\nOptions​\n\nThe version command recognizes the following options to modify its behavior:\n\nOption\tRequired\tDescription\n--json\tNo\tOutputs version information in JSON format.\nExamples​\nOutput version information​\nprisma version\n\nShow CLI results\nEnvironment variables loaded from .env\n\nprisma               : 2.21.0-dev.4\n\n@prisma/client       : 2.21.0-dev.4\n\nCurrent platform     : windows\n\nQuery Engine         : query-engine 2fb8f444d9cdf7c0beee7b041194b42d7a9ce1e6 (at C:\\Users\\veroh\\AppData\\Roaming\\npm\\node_modules\\@prisma\\cli\\query-engine-windows.exe)\n\nMigration Engine     : migration-engine-cli 2fb8f444d9cdf7c0beee7b041194b42d7a9ce1e6 (at C:\\Users\\veroh\\AppData\\Roaming\\npm\\node_modules\\@prisma\\cli\\migration-engine-windows.exe)\n\nFormat Binary        : prisma-fmt 60ba6551f29b17d7d6ce479e5733c70d9c00860e (at node_modules\\@prisma\\engines\\prisma-fmt-windows.exe)\n\nDefault Engines Hash : 60ba6551f29b17d7d6ce479e5733c70d9c00860e\n\nStudio               : 0.365.0\n\nOutput version information (-v)​\nprisma -v\n\nShow CLI results\nEnvironment variables loaded from .env\n\nprisma               : 2.21.0-dev.4\n\n@prisma/client       : 2.21.0-dev.4\n\nCurrent platform     : windows\n\nQuery Engine         : query-engine 2fb8f444d9cdf7c0beee7b041194b42d7a9ce1e6 (at C:\\Users\\veroh\\AppData\\Roaming\\npm\\node_modules\\@prisma\\cli\\query-engine-windows.exe)\n\nMigration Engine     : migration-engine-cli 2fb8f444d9cdf7c0beee7b041194b42d7a9ce1e6 (at C:\\Users\\veroh\\AppData\\Roaming\\npm\\node_modules\\@prisma\\cli\\migration-engine-windows.exe)\n\nFormat Binary        : prisma-fmt 60ba6551f29b17d7d6ce479e5733c70d9c00860e (at node_modules\\@prisma\\engines\\prisma-fmt-windows.exe)\n\nDefault Engines Hash : 60ba6551f29b17d7d6ce479e5733c70d9c00860e\n\nStudio               : 0.365.0\n\nOutput version information as JSON​\nprisma version --json\n\nShow CLI results\nEnvironment variables loaded from .env\n\n{\n\n  \"prisma\": \"2.21.0-dev.4\",\n\n  \"@prisma/client\": \"2.21.0-dev.4\",\n\n  \"current-platform\": \"windows\",\n\n  \"query-engine\": \"query-engine 60ba6551f29b17d7d6ce479e5733c70d9c00860e (at node_modules\\\\@prisma\\\\engines\\\\query-engine-windows.exe)\",\n\n  \"migration-engine\": \"migration-engine-cli 60ba6551f29b17d7d6ce479e5733c70d9c00860e (at node_modules\\\\@prisma\\\\engines\\\\migration-engine-windows.exe)\",\n\n  \"format-binary\": \"prisma-fmt 60ba6551f29b17d7d6ce479e5733c70d9c00860e (at node_modules\\\\@prisma\\\\engines\\\\prisma-fmt-windows.exe)\",\n\n  \"default-engines-hash\": \"60ba6551f29b17d7d6ce479e5733c70d9c00860e\",\n\n  \"studio\": \"0.365.0\"\n\n}\n\ninit​\n\nBootstraps a fresh Prisma ORM project within the current directory.\n\nThe init command does not interpret any existing files. Instead, it creates a prisma directory containing a bare-bones schema.prisma file within your current directory.\n\nBy default, the project sets up a local Prisma Postgres instance but you can choose a different database using the --datasource-provider option.\n\nArguments​\nArgument\tRequired\tDescription\tDefault\n--datasource-provider\tNo\tSpecifies the value for the provider field in the datasource block. Options are prisma+postgres, sqlite, postgresql, mysql, sqlserver, mongodb and cockroachdb.\tpostgresql\n--db\tNo\tShorthand syntax for --datasource-provider prisma+postgres; creates a new Prisma Postgres instance. Requires authentication in the PDP Console.\t\n--prompt (or --vibe)\tNo\tScaffolds a Prisma schema based on the prompt and deploys it to a fresh Prisma Postgres instance. Requires authentication in the PDP Console.\t\n--url\tNo\tDefine a custom datasource url.\t\n--generator-provider\tNo\tDefine the generator provider to use.\tprisma-client-js\n--preview-feature\tNo\tDefine the Preview features to use. To define multiple Preview features, you have to provide the flag multiple times for each Preview feature. See examples.\t\n--output\tNo\tSpecifies the output location for the generated client.\t../generated/prisma\n--with-model\tNo\tAdds a simple User model to the initial Prisma schema. Available since version 5.14.0.\t\nExamples​\n\nRun prisma init\n\nprisma init\n\nShow CLI results\n✔ Your Prisma schema was created at prisma/schema.prisma.\n\nYou can now open it in your favorite editor.\n\n\n\nNext steps:\n\n1. Set the DATABASE_URL in the .env file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started\n\n2. Set the provider of the datasource block in schema.prisma to match your database: postgresql, mysql, sqlite, sqlserver, mongodb or cockroachdb.\n\n3. Run prisma db pull to turn your database schema into a Prisma schema.\n\n4. Run prisma generate to generate Prisma Client. You can then start querying your database.\n\n\n\nMore information in our documentation:\n\nhttps://pris.ly/d/getting-started\n\n\nNext, run the prisma dev command to interact with your local Prisma Postgres instance (e.g. to run migrations or execute queries).\n\nRun prisma init --datasource-provider sqlite\n\nprisma init --datasource-provider sqlite\n\n\nThe command output contains helpful information on how to use the generated files and begin using Prisma ORM with your project.\n\nRun prisma init --db\n\nprisma init --db\n\n\nThe command creates a new Prisma Postgres instance. Note that it requires you to be authenticated with the PDP Console, If you run it for the first time without being authenticated, the command will open the browser for you to log into Console.\n\nRun prisma init --prompt \"Simple habit tracker application\"\n\nprisma init --prompt \"Simple habit tracker application\"\n\n\nThe command scaffolds a Prisma schema and deploys it to a fresh Prisma Postgres instance. Note that it requires you to be authenticated with the PDP Console, If you run it for the first time without being authenticated, the command will open the browser for you to log into Console.\n\nRun prisma init --preview-feature\n\nprisma init --preview-feature metrics\n\nShow Prisma schema results\ndatasource db {\n\n  provider = \"postgresql\"\n\n  url      = env(\"DATABASE_URL\")\n\n}\n\n\n\ngenerator client {\n\n  provider        = \"prisma-client-js\"\n\n  previewFeatures = [\"metrics\"]\n\n}\n\nprisma init --preview-feature view --preview-feature metrics\n\nShow Prisma schema results\ndatasource db {\n\n  provider = \"postgresql\"\n\n  url      = env(\"DATABASE_URL\")\n\n}\n\n\n\ngenerator client {\n\n  provider        = \"prisma-client-js\"\n\n  previewFeatures = [\"views\", \"metrics\"]\n\n}\n\nGenerated Assets​\n\nprisma/schema.prisma\n\nAn initial schema.prisma file to define your schema in:\n\n// This is your Prisma schema file,\n\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n\n\ngenerator client {\n\n  provider = \"prisma-client-js\"\n\n  output   = \"../generated/prisma\"\n\n}\n\n\n\ndatasource db {\n\n  provider = \"postgresql\"\n\n  url      = env(\"DATABASE_URL\")\n\n}\n\n\n.env\n\nA file to define environment variables for your project:\n\n# Environment variables declared in this file are automatically made available to Prisma.\n\n# See the documentation for more detail: https://pris.ly/d/prisma-schema#using-environment-variables\n\n\n\n# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n\n# See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n\n\nDATABASE_URL=\"file:./dev.db\"\n\n\n.gitignore\n\nA file to specify what folders/files git should ignore in your project.\n\nnode_modules\n\n# Keep environment variables out of version control\n\n.env\n\n\n\n/generated/prisma\n\n\nRun prisma init --url mysql://user:password@localhost:3306/mydb\n\nThe init command with the --url argument allows you to specify a custom datasource URL during Prisma initialization, instead of relying on a placeholder database URL:\n\nprisma init --url mysql://user:password@localhost:3306/mydb\n\nGenerated Assets​\n\nprisma/schema.prisma\n\nA minimal schema.prisma file to define your schema in:\n\n// This is your Prisma schema file,\n\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n\n\ndatasource db {\n\n  provider = \"mysql\"\n\n  url      = env(\"DATABASE_URL\")\n\n}\n\n\n\ngenerator client {\n\n  provider = \"prisma-client-js\"\n\n}\n\n\n.env\n\nA file to define environment variables for your project:\n\n# Environment variables declared in this file are automatically made available to Prisma.\n\n# See the documentation for more detail: https://pris.ly/d/prisma-schema#using-environment-variables\n\n\n\n# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n\n# See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n\n\nDATABASE_URL=\"mysql://user:password@localhost:3306/mydb\"\n\ngenerate​\n\nThe generate command generates assets like Prisma Client based on the generator and data model blocks defined in your prisma/schema.prisma file.\n\nThe generate command is most often used to generate Prisma Client with the prisma-client-js generator. This does three things:\n\nSearches the current directory and parent directories to find the applicable npm project. It will create a package.json file in the current directory if it cannot find one.\nInstalls the @prisma/client into the npm project if it is not already present.\nInspects the current directory to find a Prisma Schema to process. It will then generate a customized Prisma Client\n for your project.\nPrerequisites​\n\nTo use the generate command, you must add a generator definition in your schema.prisma file. The prisma-client-js generator, used to generate Prisma Client, can be added by including the following in your schema.prisma file:\n\ngenerator client {\n\n  provider = \"prisma-client-js\"\n\n}\n\nOptions​\nOption\tRequired\tDescription\tDefault\n--data-proxy\tNo\tThe generate command will generate Prisma Client for use with Prisma Accelerate prior to Prisma 5.0.0. Mutually exclusive with --accelerate and --no-engine.\t\n--accelerate\tNo\tThe generate command will generate Prisma Client for use with Prisma Accelerate. Mutually exclusive with --data-proxy and --no-engine. Available in Prisma 5.1.0 and later.\t\n--no-engine\tNo\tThe generate command will generate Prisma Client without an accompanied engine for use with Prisma Accelerate. Mutually exclusive with --data-proxy and --accelerate. Available in Prisma ORM 5.2.0 and later.\t\n--no-hints\tNo\tThe generate command will generate Prisma Client without usage hints, surveys or info banners being printed to the terminal. Available in Prisma ORM 5.16.0 and later.\t\n--allow-no-models\tNo\tThe generate command will generate Prisma Client without generating any models.\t\n--watch\tNo\tThe generate command will continue to watch the schema.prisma file and re-generate Prisma Client on file changes.\t\nWARNING\n\nDeprecation Warning\n\nAs of Prisma 5.2.0, --data-proxy and --accelerate are deprecated in favor of --no-engine as Prisma Client no longer requires an option to work with Prisma Accelerate. All options are available and work similarly, but we recommend --no-engine as it prevents an engine from being downloaded which will greatly impact the size of apps deployed to serverless and edge functions.\n\nArguments​\nArgument\tRequired\tDescription\tDefault\t\n--schema\tNo\tSpecifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported.\t./schema.prisma, ./prisma/schema.prisma\t\n--generator\tNo\tSpecifies which generator to use to generate assets. This option may be provided multiple times to include multiple generators. By default, all generators in the target schema will be run.\t\t\nExamples​\nGenerate Prisma Client using the default schema.prisma path​\nprisma generate\n\nShow CLI results\n✔ Generated Prisma Client to ./node_modules/.prisma/client in 61ms\n\n\n\nYou can now start using Prisma Client in your code:\n\n\n\nimport { PrismaClient } from '@prisma/client'\n\n// or const { PrismaClient } = require('@prisma/client')\n\n\n\nconst prisma = new PrismaClient()\n\n\n\nExplore the full API: https://pris.ly/d/client\n\nGenerate Prisma Client using a non-default schema.prisma path​\nprisma generate --schema=./alternative/schema.prisma\n\nContinue watching the schema.prisma file for changes to automatically re-generate Prisma Client​\nprisma generate --watch\n\nShow CLI results\nWatching... /home/prismauser/prisma/prisma-play/prisma/schema.prisma\n\n\n\n✔ Generated Prisma Client to ./node_modules/.prisma/client in 45ms\n\nRun the generate command with only a specific generator​\nprisma generate --generator client\n\nRun the generate command with multiple specific generators​\nprisma generate --generator client --generator zod_schemas\n\nGenerated Assets​\n\nThe prisma-client-js generator creates a customized client for working with your database within the ./node_modules/.prisma/client directory by default - you can customize the output folder.\n\nvalidate​\n\nValidates the Prisma Schema Language of the Prisma schema file.\n\nArguments​\nArgument\tRequired\tDescription\tDefault\n--schema\tNo\tSpecifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported.\t./schema.prisma, ./prisma/schema.prisma\nExamples​\nValidate a schema without errors​\nprisma validate\n\nShow CLI results\nValidate a schema with validation errors​\nprisma validate\n\nShow CLI results\nformat​\n\nFormats the Prisma schema file, which includes validating, formatting, and persisting the schema.\n\nArguments​\nArgument\tRequired\tDescription\tDefault\n--schema\tNo\tSpecifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported.\t./schema.prisma, ./prisma/schema.prisma\n--check\tNo\tFails if any files are unformatted. This can be used in CI to detect if the schema is formatted correctly\t\nExamples​\nValidate a schema without errors​\nprisma format\n\nShow CLI results\nFormatting a schema with validation errors​\nprisma format\n\nShow CLI results\ndebug​\n\nPrints information for debugging and bug reports.\n\nINFO\n\nThis is available from version 5.6.0 and newer.\n\nArguments​\nArgument\tRequired\tDescription\tDefault\n--schema\tNo\tSpecifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported.\t./schema.prisma, ./prisma/schema.prisma\n--help / --h\tNo\tDisplays the help message\t\nExample​\nprisma debug\n\nShow CLI results\n\nIf you're using an older version of Prisma, you can use this command by running:\n\nnpx prisma@latest debug\n\ndev​\n\nThe dev command starts a local Prisma Postgres database that you can run Prisma ORM commands against. It is useful for development and testing purposes and also allows you to switch to Prisma Postgres in production easily.\n\nArguments​\nArgument\tRequired\tDescription\tDefault\n--name (or -n)\tNo\tEnables targeting a specific database instance. Learn more.\t\n--port (or -p)\tNo\tMain port number the local Prisma Postgres HTTP server will listen on.\t51213\n--db-port (or -P)\tNo\tPort number the local Prisma Postgres database server will listen on.\t51214\n--shadow-db-port\tNo\tPort number the shadow database server will listen on.\t51215\n--debug\tNo\tEnable debug logging.\tfalse\nExamples​\n\nRun prisma dev\n\nprisma dev\n\nShow CLI results\n$ npx prisma dev\n\nFetching latest updates for this subcommand...\n\n✔ Great Success! 😉👍\n\n\n\nYour prisma dev server default is ready and listening on ports 63567-63569.\n\n\n\n╭──────────────────────────────╮\n\n│[q]uit [h]ttp url [t]cp urls│\n\n╰──────────────────────────────╯\n\ndev stop​\n\nStops one or more local Prisma Postgres databases:\n\nnpx prisma dev stop <glob>\n\n\n<glob> is a placeholder for a glob pattern to specify which local Prisma Postgres instances should be stopped, for example:\n\nnpx prisma dev stop mydb # stops a DB called `mydb`\n\n\nTo stop all databases that begin with mydb (e.g. mydb-dev and mydb-prod), you can use a glob:\n\nnpx prisma dev stop mydb* # stops all DBs starting with `mydb`\n\ndev rm​\n\nRemoves the data of one or more local Prisma Postgres databases from your file system:\n\nnpx prisma dev rm <glob>\n\n\n<glob> is a placeholder for a glob pattern to specify which local Prisma Postgres instances should be removed, for example:\n\nnpx prisma dev stop mydb # stops a DB called `mydb`\n\n\nTo stop all databases that begin with mydb (e.g. mydb-dev and mydb-prod), you can use a glob:\n\nnpx prisma dev stop mydb* # stops all DBs starting with `mydb`\n\ndb​\ndb pull​\n\nThe db pull command connects to your database and adds Prisma models to your Prisma schema that reflect the current database schema.\n\nWARNING\n\nWarning: The command will overwrite the current schema.prisma file with the new schema. Some manual changes or customization can be lost. Be sure to back up your current schema.prisma file (or commit your current state to version control to be able to revert any changes) before running db pull if it contains important modifications.\n\nINFO\n\nIntrospection with the db pull command on the MongoDB connector samples the data instead of reading a schema.\n\nPrerequisites​\n\nBefore using the db pull command, you must define a valid datasource within your schema.prisma file.\n\nFor example, the following datasource defines a SQLite database file within the current directory:\n\ndatasource db {\n\n  provider = \"sqlite\"\n\n  url      = \"file:my-database.db\"\n\n}\n\nOptions​\nOption\tRequired\tDescription\tDefault\n--force\tNo\tForce overwrite of manual changes made to schema. The generated schema will be based on the introspected schema only.\t\n--print\tNo\tPrints the created schema.prisma to the screen instead of writing it to the filesystem.\t\nArguments​\nArgument\tRequired\tDescription\tDefault\n--schema\tNo\tSpecifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported.\t./schema.prisma, ./prisma/schema.prisma\nExamples​\nAnalyze the database and write its schema to the schema.prisma file​\nprisma db pull\n\nShow CLI results\nIntrospecting based on datasource defined in schema.prisma …\n\n\n\n✔ Introspected 2 models and wrote them into schema.prisma in 38ms\n\n\n\nRun prisma generate to generate Prisma Client.\n\nSpecify an alternative schema.prisma file to read and write to​\nprisma db pull --schema=./alternative/schema.prisma\n\nShow CLI results\nIntrospecting based on datasource defined in alternative/schema.prisma …\n\n\n\n✔ Introspected 2 models and wrote them into alternative/schema.prisma in 60ms\n\n\n\nRun prisma generate to generate Prisma Client.\n\nDisplay the generated schema.prisma file instead of writing it to the filesystem​\nprisma db pull --print\n\nShow CLI results\ngenerator client {\n\n  provider = \"prisma-client-js\"\n\n}\n\n\n\ndatasource db {\n\n  provider = \"sqlite\"\n\n  url      = \"file:./hello-prisma.db\"\n\n}\n\n\n\nmodel User {\n\n  email   String    @unique\n\n  name    String?\n\n  user_id Int       @id @default(autoincrement())\n\n  post    Post[]\n\n  profile Profile[]\n\n}\n\n\n\nmodel Post {\n\n  content   String?\n\n  post_id   Int     @id @default(autoincrement())\n\n  title     String\n\n  author    User?   @relation(fields: [author_id], references: [user_id])\n\n  author_id Int?\n\n}\n\n\n\nmodel Profile {\n\n  bio        String?\n\n  profile_id Int     @id @default(autoincrement())\n\n  user       User    @relation(fields: [user_id], references: [user_id])\n\n  user_id    Int     @unique\n\n}\n\ndb push​\n\nThe db push command pushes the state of your Prisma schema to the database without using migrations. It creates the database if the database does not exist.\n\nThis command is a good choice when you do not need to version schema changes, such as during prototyping and local development.\n\nSee also:\n\nConceptual overview of db push and when to use it over Prisma Migrate\nSchema prototyping with db push\nPrerequisites​\n\nBefore using the db push command, you must define a valid datasource within your schema.prisma file.\n\nFor example, the following datasource defines a SQLite database file within the current directory:\n\ndatasource db {\n\n  provider = \"sqlite\"\n\n  url      = \"file:my-database.db\"\n\n}\n\nOptions​\nOptions\tRequired\tDescription\n--skip-generate\tNo\tSkip generation of artifacts such as Prisma Client\n--force-reset\tNo\tResets the database and then updates the schema - useful if you need to start from scratch due to unexecutable migrations.\n--accept-data-loss\tNo\tIgnore data loss warnings. This option is required if as a result of making the schema changes, data may be lost.\n--help / --h\tNo\tDisplays the help message\nArguments​\nArgument\tRequired\tDescription\tDefault\n--schema\tNo\tSpecifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported.\t./schema.prisma\n./prisma/schema.prisma\nExamples​\n\nPush the schema:\n\nprisma db push\n\n\nPush the schema, accepting data loss:\n\nprisma db push --accept-data-loss\n\n\nPush the schema with a custom schema location:\n\nprisma db push --schema=/tmp/schema.prisma\n\ndb seed​\n\ndb seed changed from Preview to Generally Available (GA) in 3.0.1.\n\nSee Seeding your database\n\nOptions​\nOptions\tRequired\tDescription\n--help / --h\tNo\tDisplays the help message\n--\tNo\tAllows the use of custom arguments defined in a seed file\n\nThe -- argument/ delimiter\n/ double-dash is available from version 4.15.0 or later.\n\nExamples​\nprisma db seed\n\ndb execute​\nINFO\n\nThe db execute command is Generally Available in versions 3.13.0 and later. If you're using a version between 3.9.0 and 3.13.0, it is available behind a --preview-feature CLI flag.\n\nWARNING\n\nThis command is currently not supported on MongoDB.\n\nThis command applies a SQL script to the database without interacting with the Prisma migrations table. The script takes two inputs:\n\nthe SQL script, which can be provided either on standard input or in a file\nthe data source, which can either be the URL of the data source or the path to your Prisma schema file\n\nThe output of the command is connector-specific, and is not meant for returning data, but only to report success or failure.\n\nSee also:\n\nMigration troubleshooting in production\nPrerequisites​\n\nBefore using the db execute command, if you do not use the --url option you must define a valid datasource within your schema.prisma file.\n\nFor example, the following datasource defines a SQLite database file within the current directory:\n\ndatasource db {\n\n  provider = \"sqlite\"\n\n  url      = \"file:my-database.db\"\n\n}\n\nOptions​\n\nOne of the following data source inputs is required:\n\nOptions\tDescription\n--url\tURL of the data source to run the command on\n--schema\tPath to a Prisma schema file, uses the URL in the datasource block\n\nOne of the following script inputs is required:\n\nOptions\tDescription\n--stdin\tUse the terminal standard input as the script to be executed\n--file\tPath to a file. The content will be sent as the script to be executed\n\nOther options:\n\nOptions\tRequired\tDescription\n--help\tNo\tDisplays the help message.\nExamples​\n\nTake the content of a SQL file located at ./script.sql and execute it on the database specified by the URL in the datasource block of your schema.prisma file:\n\nprisma db execute --file ./script.sql --schema schema.prisma\n\n\nTake the SQL script from standard input and execute it on the database specified by the data source URL given in the DATABASE_URL environment variable:\n\necho 'TRUNCATE TABLE dev;' | prisma db execute --stdin --url=\"$DATABASE_URL\"\n\nPrisma Migrate​\n\nPrisma Migrate changed from Preview to Generally Available (GA) in 2.19.0.\n\nINFO\n\nDoes not apply for MongoDB\nInstead of migrate dev and related commands, db push is used for MongoDB.\n\nmigrate dev​\n\nFor use in development environments only, requires shadow database\n\nThe migrate dev command:\n\nReruns the existing migration history in the shadow database in order to detect schema drift (edited or deleted migration file, or a manual changes to the database schema)\nApplies pending migrations to the shadow database (for example, new migrations created by colleagues)\nGenerates a new migration from any changes you made to the Prisma schema before running migrate dev\nApplies all unapplied migrations to the development database and updates the _prisma_migrations table\nTriggers the generation of artifacts (for example, Prisma Client)\nWARNING\n\nThis command is not supported on MongoDB. Use db push instead.\n\nSee also:\n\nConceptual overview of Prisma Migrate\nDeveloping with Prisma Migrate\nOptions​\nOption\tRequired\tDescription\tDefault\n--create-only\tNo\tCreates a new migration but does not apply it. This also works if you haven't made any changes to your schema (in that case, an empty migration is created). Run migrate dev to apply migration.\t\n--skip-seed\tNo\tSkip triggering seed\t\n--skip-generate\tNo\tSkip triggering generators (for example, Prisma Client)\t\n--name / -n\tNo\tName the migration (e.g. prisma migrate dev --name added_job_title)\t\n--help / -h\tNo\tDisplays the help message\t\nINFO\n\nIf a schema drift is detected while running prisma migrate dev using --create-only, you will be prompted to reset your database.\n\nArguments​\nArgument\tRequired\tDescription\tDefault\n--name\tNo\tThe name of the migration. If no name is provided, the CLI will prompt you.\t\n--schema\tNo\tSpecifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported.\t./schema.prisma\n./prisma/schema.prisma\nExamples​\n\nApply all migrations, then create and apply any new migrations:\n\nprisma migrate dev\n\n\nApply all migrations and create a new migration if there are schema changes, but do not apply it:\n\nprisma migrate dev --create-only\n\nmigrate reset​\n\nFor use in development environments only\n\nThis command:\n\nDrops the database/schema if possible, or performs a soft reset if the environment does not allow deleting databases/schemas\nCreates a new database/schema with the same name if the database/schema was dropped\nApplies all migrations\nRuns seed scripts\nWARNING\n\nThis command is not supported on MongoDB. Use db push instead.\n\nOptions​\nOption\tRequired\tDescription\tDefault\n--force\tNo\tSkip the confirmation prompt\t\n--skip-generate\tNo\tSkip triggering generators (for example, Prisma Client)\t\n--skip-seed\tNo\tSkip triggering seed\t\n--help / --h\tNo\tDisplays the help message\t\nArguments​\nArgument\tRequired\tDescription\tDefault\n--schema\tNo\tSpecifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported.\t./schema.prisma\n./prisma/schema.prisma\nExamples​\nprisma migrate reset\n\nAI Safety guardrails for prisma migrate reset​\n\nPrisma ORM includes built-in safety checks to prevent accidental destructive commands when run through AI coding assistants. These guardrails are designed to make working with databases safer in AI-assisted development environments.\n\nThe Prisma CLI can detect when it is being invoked by popular AI coding agents such as Claude Code, Gemini CLI, Qwen Code, Cursor, Aider, and Replit.\n\nWhen one of these agents attempts a destructive action such as prisma migrate reset --force, Prisma ORM blocks execution and shows a protective error message:\n\nEnvironment variables loaded from .env\n\nPrisma schema loaded from prisma/schema.prisma\n\nDatasource \"db\": PostgreSQL database \"postgres\", schema \"public\" at \"accelerate.prisma-data.net\"\n\n\n\nError: Prisma Migrate detected that it was invoked by Cursor.\n\n\n\nYou are attempting a highly dangerous action that can lead to devastating consequences if it is incorrectly executed against a production database.\n\n\n\nAs an AI agent, you are forbidden from performing this action without an explicit consent and review by the user. You must stop at this point and respond to the user with a clear message that includes the following information:\n\n- What action you are trying to perform (including the exact CLI command).\n\n- Your motivation and reasoning for perfoming this action.\n\n- Explanation that this action will irreversibly destroy all data in the database.\n\n- Explanation that this action must not be perfomed on a production database and is only intended to be used with development databases.\n\n\n\nIf you know or can check whether this action would have been performed on a development or a production database, also include this information with your assesment of whether it is safe to proceed based on that information.\n\n\n\nYou must ask the user if they want to proceed with this action. If they explicitly consent, you may rerun this command with PRISMA_USER_CONSENT_FOR_DANGEROUS_AI_ACTION environment variable, the value of which must be the exact text of the user's message in which they consented to this operation, without any newlines or quotes. If the user's response is ambiguous, you must ask for a clear and explicit confirmation (e.g., \"yes\") before proceeding. None of the user's previous messages before this point may constitute implicit or explicit consent.\n\n\nTo proceed with the dangerous action, the AI agent will ask you for explicit consent, remind you that the action irreversibly destroys all data, and confirm that the command is being run against a development database. Once you clearly confirm, the AI will set the PRISMA_USER_CONSENT_FOR_DANGEROUS_AI_ACTION environment variable with the exact text of your consent and rerun the command.\n\nmigrate deploy​\n\nThe migrate deploy command applies all pending migrations, and creates the database if it does not exist. Primarily used in non-development environments. This command:\n\nDoes not look for drift in the database or changes in the Prisma schema\nDoes not reset the database or generate artifacts\nDoes not rely on a shadow database\nWARNING\n\nThis command is not supported on MongoDB. Use db push instead.\n\nOptions​\nOption\tRequired\tDescription\tDefault\n--help / --h\tNo\tDisplays the help message\t\nArguments​\nArgument\tRequired\tDescription\tDefault\n--schema\tNo\tSpecifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported.\t./schema.prisma\n./prisma/schema.prisma\nExamples​\nprisma migrate deploy\n\nmigrate resolve​\n\nThe migrate resolve command allows you to solve migration history issues in production by marking a failed migration as already applied (supports baselining) or rolled back.\n\nNote that this command can only be used with a failed migration. If you try to use it with a successful migration you will receive an error.\n\nWARNING\n\nThis command is not supported on MongoDB. Use db push instead.\n\nOptions​\nOption\tRequired\tDescription\tDefault\n--help / --h\tNo\tDisplays the help message\t\nArguments​\nArgument\tRequired\tDescription\tDefault\n--applied\tNo*\tRecord a specific migration as applied - for example --applied \"20201231000000_add_users_table\"\t\n--rolled-back\tNo*\tRecord a specific migration as rolled back - for example --rolled-back \"20201231000000_add_users_table\"\t./schema.prisma\n./prisma/schema.prisma\n--schema\tNo\tSpecifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported.\t./schema.prisma\n./prisma/schema.prisma\n\nYou must specify either --rolled-back or --applied.\n\nExamples​\nprisma migrate resolve --applied 20201231000000_add_users_table\n\nprisma migrate resolve --rolled-back 20201231000000_add_users_table\n\nmigrate status​\n\nThe prisma migrate status command looks up the migrations in ./prisma/migrations/* folder and the entries in the _prisma_migrations table and compiles information about the state of the migrations in your database.\n\nWARNING\n\nThis command is not supported on MongoDB. Use db push instead.\n\nFor example:\n\nStatus\n\n3 migrations found in prisma/migrations\n\n\n\nYour local migration history and the migrations table from your database are different:\n\n\n\nThe last common migration is: 20201127134938_new_migration\n\n\n\nThe migration have not yet been applied:\n\n20201208100950_test_migration\n\n\n\nThe migrations from the database are not found locally in prisma/migrations:\n\n20201208100950_new_migration\n\n\nIn versions 4.3.0 and later, prisma migrate status exits with exit code 1 in the following cases:\n\na database connection error occurs\nthere are migration files in the migrations directory that have not been applied to the database\nthe migration history in the migrations directory has diverged from the state of the database\nno migration table is found\nfailed migrations are found\nOptions​\nOption\tRequired\tDescription\tDefault\n--help / --h\tNo\tDisplays the help message\t\nArguments​\nArgument\tRequired\tDescription\tDefault\n--schema\tNo\tSpecifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported.\t./schema.prisma\n./prisma/schema.prisma\nExamples​\nprisma migrate status\n\nmigrate diff​\nINFO\n\nThis command is only partially supported for MongoDB. See the command options below for details.\n\nThis command compares two database schema sources and outputs a description of a migration taking the first to the state of the second.\n\nThe output can be given either as a human-readable summary (the default) or an executable script.\n\nWARNING\n\nThe migrate diff command can only compare database features that are supported by Prisma. If two databases differ only in unsupported features, such as views or triggers, then migrate diff will not show any difference between them.\n\nThe format of the command is:\n\nprisma migrate diff --from-... <source1> --to-... <source2>\n\n\nwhere the --from-... and --to-... options are selected based on the type of database schema source. The supported types of sources are:\n\nlive databases\nmigration histories\nPrisma schema data models\nan empty schema\n\nBoth schema sources must use the same database provider. For example, a diff comparing a PostgreSQL data source with a SQLite data source is not supported.\n\nSee also:\n\nMigration troubleshooting in production\nPrerequisites​\n\nBefore using the migrate diff command, if you are using the --from-schema-datasource or --to-schema-datasource you must define a valid datasource within your schema.prisma file.\n\nFor example, the following datasource defines a SQLite database file within the current directory:\n\ndatasource db {\n\n  provider = \"sqlite\"\n\n  url      = \"file:my-database.db\"\n\n}\n\nOptions​\n\nOne of the following --from-... options is required:\n\nOptions\tDescription\tNotes\n--from-url\tA data source URL\t\n--from-migrations\tPath to the Prisma Migrate migrations directory\tNot supported in MongoDB\n--from-schema-datamodel\tPath to a Prisma schema file, uses the data model for the diff\t\n--from-schema-datasource\tPath to a Prisma schema file, uses the URL in the datasource block for the diff\t\n--from-empty\tAssume that you the data model you are migrating from is empty\t\n--from-local-d1\tPath to a local D1 instance (learn more)\tAvailable since 5.12.0\n\nOne of the following --to-... options is required:\n\nOptions\tDescription\tNotes\n--to-url\tA data source URL\t\n--to-migrations\tPath to the Prisma Migrate migrations directory\tNot supported in MongoDB\n--to-schema-datamodel\tPath to a Prisma schema file, uses the data model for the diff\t\n--to-schema-datasource\tPath to a Prisma schema file, uses the URL in the datasource block for the diff\t\n--to-empty\tAssume that you the data model you are migrating to is empty\t\n--to-local-d1\tPath to a local D1 instance (learn more)\tAvailable since 5.12.0\n\nOther options:\n\nOptions\tRequired\tDescription\tNotes\n--shadow-database-url\tNo\tURL for the shadow database\tOnly required if using --to-migrations or --from-migrations\n--script\tNo\tOutputs a SQL script instead of the default human-readable summary\tNot supported in MongoDB\n-o, --output\tNo\tWrites to a file instead of stdout\tAvailable since 5.12.1\n\n--exit-code\tNo\tChange the exit code behavior to signal if the diff is empty or not (Empty: 0, Error: 1, Not empty: 2). Default behavior is Success: 0, Error: 1.\t\n--help\tNo\tDisplays the help message.\t\nExamples​\n\nCompare two databases specified by their data source URL, and output the default human-readable summary:\n\nprisma migrate diff \\\n\n  --from-url \"$DATABASE_URL\" \\\n\n  --to-url \"postgresql://login:password@localhost:5432/db2\"\n\n\nCompare the state of a database with a URL of $DATABASE_URL to the schema defined by the migrations in the ./prisma/migrations directory, and output the differences to a script script.sql:\n\nprisma migrate diff \\\n\n --from-url \"$DATABASE_URL\" \\\n\n --to-migrations ./prisma/migrations \\\n\n --shadow-database-url $SHADOW_DATABASE_URL \\\n\n --script > script.sql\n\nPrisma Data Platform​\nplatform (Early Access)​\n\nThe platform command provides access to the Prisma Data Platform through the Prisma CLI starting in version 5.10.0 or later.\n\nAuthentication:\nplatform auth login: Opens a browser window for login or account creation.\nplatform auth logout: Logs out of the platform.\nplatform auth show: Displays information about the currently authenticated user.\nWorkspace Management:\nplatform workspace show: Lists all workspaces available to your account.\nProject Management:\nplatform project show: Lists all projects within the specified workspace.\nplatform project create: Creates a new project within the specified workspace.\nplatform project delete: Deletes the specified project.\nEnvironment Management:\nplatform environment show: Lists all environments for the specified project.\nplatform environment create: Creates a new environment within the specified project.\nplatform environment delete: Deletes the specified environment.\nAPI Key Management:\nplatform apikey show: Lists all API keys for the specified environment.\nplatform apikey create: Creates a new API key for the specified environment.\nplatform apikey delete: Deletes the specified API key.\nPrisma Accelerate:\nplatform accelerate enable: Enables Prisma Accelerate for the specified environment.\nplatform accelerate disable: Disables Prisma Accelerate for the specified environment.\n\nYou can find the complete list of available commands with the arguments here.\n\nmcp​\n\nStarts the Prisma MCP server.\n\nStudio​\nstudio​\n\nThe studio command allows you to interact with and manage your data interactively. It does this by starting a local web server with a web app configured with your project's data schema and records.\n\nPrerequisites​\n\nBefore using the studio command, you must define a valid datasource within your schema.prisma file.\n\nFor example, the following datasource defines a SQLite database file within the current directory:\n\ndatasource db {\n\n  provider = \"sqlite\"\n\n  url      = \"file:my-database.db\"\n\n}\n\nOptions​\n\nThe studio command recognizes the following options:\n\nOption\tRequired\tDescription\tDefault\n-b, --browser\tNo\tThe browser to auto-open Studio in.\t<your-default-browser>\n-h, --help\tNo\tShow all available options and exit\t\n-p, --port\tNo\tThe port number to start Studio on.\t5555\nArguments​\nArgument\tRequired\tDescription\tDefault\n--schema\tNo\tSpecifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported.\t./schema.prisma\n./prisma/schema.prisma\nExamples​\nStart Studio on the default port and open a new browser tab to it​\nprisma studio\n\nStart Studio on a different port and open a new browser tab to it​\nprisma studio --port 7777\n\nStart Studio and open a Firefox tab to it​\nprisma studio --browser firefox\n\nStart Studio without opening a new browser tab to it​\nprisma studio --browser none\n\npackage.json entry options​\nschema​\n\nThe path to the desired schema.prisma file can be specified with the prisma.schema entry in the package.json file. The path defines the file the Prisma CLI should use when you run any of the CLI commands. Both absolute and relative paths are supported.\n\n\"package.json\"\n{\n\n  \"name\": \"my-project\",\n\n  \"version\": \"1.0.0\",\n\n  \"prisma\": {\n\n    \"schema\": \"./custom-path-to-schema/schema.prisma\"\n\n  }\n\n}\n\n\nThis is available from version 2.7.0 and later.\n\nseed​\n\nThe command used to populate the datasource is specified in the prisma.seed entry in the package.json file. It is used when prisma db seed is invoked or triggered.\n\nSee Seeding your database\n\n\"package.json\"\n{\n\n  \"name\": \"my-project\",\n\n  \"version\": \"1.0.0\",\n\n  \"prisma\": {\n\n    \"seed\": \"node ./prisma/seed.js\"\n\n  }\n\n}\n\n\nThis is available from version 3.0.1 and later.\n\nUsing a HTTP proxy for the CLI​\n\nPrisma CLI supports custom HTTP proxies\n. This is particularly relevant when being behind a corporate firewall.\n\nTo activate usage of the proxy, provide either of the following environment variables:\n\nHTTP_PROXY or http_proxy: Proxy URL for http traffic, for example http://localhost:8080\nHTTPS_PROXY or https_proxy: Proxy URL for https traffic, for example https://localhost:8080\nnpx create-db​\n\nThe create-db command provisions a temporary Prisma Postgres database with a single command. This is a standalone utility that can be invoked using npx. It's ideal for quickly testing, prototyping, or integrating with Prisma Postgres.\n\nYou can run the following variants:\n\nCommand\tDescription\nnpx create-db@latest\tCreates a temporary Prisma Postgres database.\nnpx create-pg@latest\tAlias for npx create-db.\nnpx create-postgres@latest\tAlias for npx create-db.\n\nEach database created with these commands:\n\nIs available for 24 hours by default.\nCan be claimed for free to make it permanent using the URL displayed in the CLI output.\n\nFor full usage details, options (such as --region and --interactive), and examples, see the documentation."
  },
  {
    "title": "Errors | Prisma Documentation",
    "url": "https://www.prisma.io/docs/orm/reference/error-reference",
    "html": "ORMReference\nError message reference\n\nFor more information about how to work with exceptions and error codes, see Handling exceptions and errors.\n\nPrisma Client error types​\n\nPrisma Client throws different kinds of errors. The following lists the exception types, and their documented data fields:\n\nPrismaClientKnownRequestError​\n\nPrisma Client throws a PrismaClientKnownRequestError exception if the query engine returns a known error related to the request - for example, a unique constraint violation.\n\nProperty\tDescription\ncode\tA Prisma-specific error code.\nmeta\tAdditional information about the error - for example, the field that caused the error: { target: [ 'email' ] }\nmessage\tError message associated with error code.\nclientVersion\tVersion of Prisma Client (for example, 2.19.0)\nPrismaClientUnknownRequestError​\n\nPrisma Client throws a PrismaClientUnknownRequestError exception if the query engine returns an error related to a request that does not have an error code.\n\nProperty\tDescription\nmessage\tError message associated with error code.\nclientVersion\tVersion of Prisma Client (for example, 2.19.0)\nPrismaClientRustPanicError​\n\nPrisma Client throws a PrismaClientRustPanicError exception if the underlying engine crashes and exits with a non-zero exit code. In this case, Prisma Client or the whole Node process must be restarted.\n\nProperty\tDescription\nmessage\tError message associated with error code.\nclientVersion\tVersion of Prisma Client (for example, 2.19.0)\nPrismaClientInitializationError​\n\nPrisma Client throws a PrismaClientInitializationError exception if something goes wrong when the query engine is started and the connection to the database is created. This happens either:\n\nWhen prisma.$connect() is called OR\nWhen the first query is executed\n\nErrors that can occur include:\n\nThe provided credentials for the database are invalid\nThere is no database server running under the provided hostname and port\nThe port that the query engine HTTP server wants to bind to is already taken\nA missing or inaccessible environment variable\nThe query engine binary for the current platform could not be found (generator block)\nProperty\tDescription\nerrorCode\tA Prisma-specific error code.\nmessage\tError message associated with error code.\nclientVersion\tVersion of Prisma Client (for example, 2.19.0)\nPrismaClientValidationError​\n\nPrisma Client throws a PrismaClientValidationError exception if validation fails - for example:\n\nMissing field - for example, an empty data: {} property when creating a new record\nIncorrect field type provided (for example, setting a Boolean field to \"Hello, I like cheese and gold!\")\nProperty\tDescription\nmessage\tError message.\nclientVersion\tVersion of Prisma Client (for example, 2.19.0)\nError codes​\nCommon​\nP1000​\n\n\"Authentication failed against database server at {database_host}, the provided database credentials for {database_user} are not valid. Please make sure to provide valid database credentials for the database server at {database_host}.\"\n\nP1001​\n\n\"Can't reach database server at {database_host}:{database_port} Please make sure your database server is running at {database_host}:{database_port}.\"\n\nP1002​\n\n\"The database server at {database_host}:{database_port} was reached but timed out. Please try again. Please make sure your database server is running at {database_host}:{database_port}. \"\n\nP1003​\n\n\"Database {database_file_name} does not exist at {database_file_path}\"\n\n\"Database {database_name}.{database_schema_name} does not exist on the database server at {database_host}:{database_port}.\"\n\n\"Database {database_name} does not exist on the database server at {database_host}:{database_port}.\"\n\nP1008​\n\n\"Operations timed out after {time}\"\n\nP1009​\n\n\"Database {database_name} already exists on the database server at {database_host}:{database_port}\"\n\nP1010​\n\n\"User {database_user} was denied access on the database {database_name}\"\n\nP1011​\n\n\"Error opening a TLS connection: {message}\"\n\nP1012​\n\nNote: If you get error code P1012 after you upgrade Prisma ORM to version 4.0.0 or later, see the version 4.0.0 upgrade guide. A schema that was valid before version 4.0.0 might be invalid in version 4.0.0 and later. The upgrade guide explains how to update your schema to make it valid.\n\n\"{full_error}\"\n\nPossible P1012 error messages:\n\n\"Argument {} is missing.\"\n\"Function {} takes arguments, but received .\"\n\"Argument {} is missing in attribute @{}.\"\n\"Argument {} is missing in data source block {}.\"\n\"Argument {} is missing in generator block {}.\"\n\"Error parsing attribute @{}: \"\n\"Attribute @{} is defined twice.\"\n\"The model with database name {} could not be defined because another model with this name exists: {}\"\n\"{} is a reserved scalar type name and can not be used.\"\n\"The {} cannot be defined because a with that name already exists.\"\n\"Key {} is already defined in .\"\n\"Argument {} is already specified as unnamed argument.\"\n\"Argument {} is already specified.\"\n\"No such argument.\"\"\n\"Field {} is already defined on model {}.\"\n\"Field {} in model {} can't be a list. The current connector does not support lists of primitive types.\"\n\"The index name {} is declared multiple times. With the current connector index names have to be globally unique.\"\n\"Value {} is already defined on enum {}.\"\n\"Attribute not known: @{}.\"\n\"Function not known: {}.\"\n\"Datasource provider not known: {}.\"\n\"shadowDatabaseUrl is the same as url for datasource {}. Please specify a different database as shadow database.\"\n\"The preview feature {} is not known. Expected one of: \"\n\"{} is not a valid value for .\"\n\"Type {} is neither a built-in type, nor refers to another model, custom type, or enum.\"\n\"Type {} is not a built-in type.\"\n\"Unexpected token. Expected one of: \"\n\"Environment variable not found: .\"\n\"Expected a value, but received value {}.\"\n\"Expected a value, but failed while parsing {}: .\"\n\"Error validating model {}: \"\n\"Error validating field {} in model {}: \"\n\"Error validating datasource {datasource}: {message}\"\n\"Error validating enum {}: \"\n\"Error validating: \"\nP1013​\n\n\"The provided database string is invalid. {details}\"\n\nP1014​\n\n\"The underlying {kind} for model {model} does not exist.\"\n\nP1015​\n\n\"Your Prisma schema is using features that are not supported for the version of the database.\nDatabase version: {database_version}\nErrors:\n{errors}\"\n\nP1016​\n\n\"Your raw query had an incorrect number of parameters. Expected: {expected}, actual: {actual}.\"\n\nP1017​\n\n\"Server has closed the connection.\"\n\nPrisma Client (Query Engine)​\nP2000​\n\n\"The provided value for the column is too long for the column's type. Column: {column_name}\"\n\nP2001​\n\n\"The record searched for in the where condition ({model_name}.{argument_name} = {argument_value}) does not exist\"\n\nP2002​\n\n\"Unique constraint failed on the {constraint}\"\n\nP2003​\n\n\"Foreign key constraint failed on the field: {field_name}\"\n\nP2004​\n\n\"A constraint failed on the database: {database_error}\"\n\nP2005​\n\n\"The value {field_value} stored in the database for the field {field_name} is invalid for the field's type\"\n\nP2006​\n\n\"The provided value {field_value} for {model_name} field {field_name} is not valid\"\n\nP2007​\n\n\"Data validation error {database_error}\"\n\nP2008​\n\n\"Failed to parse the query {query_parsing_error} at {query_position}\"\n\nP2009​\n\n\"Failed to validate the query: {query_validation_error} at {query_position}\"\n\nP2010​\n\n\"Raw query failed. Code: {code}. Message: {message}\"\n\nP2011​\n\n\"Null constraint violation on the {constraint}\"\n\nP2012​\n\n\"Missing a required value at {path}\"\n\nP2013​\n\n\"Missing the required argument {argument_name} for field {field_name} on {object_name}.\"\n\nP2014​\n\n\"The change you are trying to make would violate the required relation '{relation_name}' between the {model_a_name} and {model_b_name} models.\"\n\nP2015​\n\n\"A related record could not be found. {details}\"\n\nP2016​\n\n\"Query interpretation error. {details}\"\n\nP2017​\n\n\"The records for relation {relation_name} between the {parent_name} and {child_name} models are not connected.\"\n\nP2018​\n\n\"The required connected records were not found. {details}\"\n\nP2019​\n\n\"Input error. {details}\"\n\nP2020​\n\n\"Value out of range for the type. {details}\"\n\nP2021​\n\n\"The table {table} does not exist in the current database.\"\n\nP2022​\n\n\"The column {column} does not exist in the current database.\"\n\nP2023​\n\n\"Inconsistent column data: {message}\"\n\nP2024​\n\n\"Timed out fetching a new connection from the connection pool. (More info: http://pris.ly/d/connection-pool\n (Current connection pool timeout: {timeout}, connection limit: {connection_limit})\"\n\nP2025​\n\n\"An operation failed because it depends on one or more records that were required but not found. {cause}\"\n\nP2026​\n\n\"The current database provider doesn't support a feature that the query used: {feature}\"\n\nP2027​\n\n\"Multiple errors occurred on the database during query execution: {errors}\"\n\nP2028​\n\n\"Transaction API error: {error}\"\n\nP2029​\n\n\"Query parameter limit exceeded error: {message}\"\n\nP2030​\n\n\"Cannot find a fulltext index to use for the search, try adding a @@fulltext([Fields...]) to your schema\"\n\nP2031​\n\n\"Prisma needs to perform transactions, which requires your MongoDB server to be run as a replica set. See details: https://pris.ly/d/mongodb-replica-set\n\"\n\nP2033​\n\n\"A number used in the query does not fit into a 64 bit signed integer. Consider using BigInt as field type if you're trying to store large integers\"\n\nP2034​\n\n\"Transaction failed due to a write conflict or a deadlock. Please retry your transaction\"\n\nP2035​\n\n\"Assertion violation on the database: {database_error}\"\n\nP2036​\n\n\"Error in external connector (id {id})\"\n\nP2037​\n\n\"Too many database connections opened: {message}\"\n\nPrisma Migrate (Schema Engine)​\nWARNING\n\nThe Schema Engine was previously called Migration Engine. This change was introduced in version 5.0.0\n.\n\nP3000​\n\n\"Failed to create database: {database_error}\"\n\nP3001​\n\n\"Migration possible with destructive changes and possible data loss: {migration_engine_destructive_details}\"\n\nP3002​\n\n\"The attempted migration was rolled back: {database_error}\"\n\nP3003​\n\n\"The format of migrations changed, the saved migrations are no longer valid. To solve this problem, please follow the steps at: https://pris.ly/d/migrate\n\"\n\nP3004​\n\n\"The {database_name} database is a system database, it should not be altered with prisma migrate. Please connect to another database.\"\n\nP3005​\n\n\"The database schema is not empty. Read more about how to baseline an existing production database: https://pris.ly/d/migrate-baseline\n\"\n\nP3006​\n\n\"Migration {migration_name} failed to apply cleanly to the shadow database.\n{error_code}Error:\n{inner_error}\"\n\nP3007​\n\n\"Some of the requested preview features are not yet allowed in schema engine. Please remove them from your data model before using migrations. (blocked: {list_of_blocked_features})\"\n\nP3008​\n\n\"The migration {migration_name} is already recorded as applied in the database.\"\n\nP3009​\n\n\"migrate found failed migrations in the target database, new migrations will not be applied. Read more about how to resolve migration issues in a production database: https://pris.ly/d/migrate-resolve\n\n{details}\"\n\nP3010​\n\n\"The name of the migration is too long. It must not be longer than 200 characters (bytes).\"\n\nP3011​\n\n\"Migration {migration_name} cannot be rolled back because it was never applied to the database. Hint: did you pass in the whole migration name? (example: \"20201207184859_initial_migration\")\"\n\nP3012​\n\n\"Migration {migration_name} cannot be rolled back because it is not in a failed state.\"\n\nP3013​\n\n\"Datasource provider arrays are no longer supported in migrate. Please change your datasource to use a single provider. Read more at https://pris.ly/multi-provider-deprecation\n\"\n\nP3014​\n\n\"Prisma Migrate could not create the shadow database. Please make sure the database user has permission to create databases. Read more about the shadow database (and workarounds) at https://pris.ly/d/migrate-shadow\n.\n\nOriginal error: {error_code}\n{inner_error}\"\n\nP3015​\n\n\"Could not find the migration file at {migration_file_path}. Please delete the directory or restore the migration file.\"\n\nP3016​\n\n\"The fallback method for database resets failed, meaning Migrate could not clean up the database entirely. Original error: {error_code}\n{inner_error}\"\n\nP3017​\n\n\"The migration {migration_name} could not be found. Please make sure that the migration exists, and that you included the whole name of the directory. (example: \"20201207184859_initial_migration\")\"\n\nP3018​\n\n\"A migration failed to apply. New migrations cannot be applied before the error is recovered from. Read more about how to resolve migration issues in a production database: https://pris.ly/d/migrate-resolve\n\n\nMigration name: {migration_name}\n\nDatabase error code: {database_error_code}\n\nDatabase error:\n{database_error} \"\n\nP3019​\n\n\"The datasource provider {provider} specified in your schema does not match the one specified in the migration_lock.toml, {expected_provider}. Please remove your current migration directory and start a new migration history with prisma migrate dev. Read more: https://pris.ly/d/migrate-provider-switch\n\"\n\nP3020​\n\n\"The automatic creation of shadow databases is disabled on Azure SQL. Please set up a shadow database using the shadowDatabaseUrl datasource attribute.\nRead the docs page for more details: https://pris.ly/d/migrate-shadow\n\"\n\nP3021​\n\n\"Foreign keys cannot be created on this database. Learn more how to handle this: https://pris.ly/d/migrate-no-foreign-keys\n\"\n\nP3022​\n\n\"Direct execution of DDL (Data Definition Language) SQL statements is disabled on this database. Please read more here about how to handle this: https://pris.ly/d/migrate-no-direct-ddl\n\"\n\nP3023​\n\n\"For the current database, externalTables & externalEnums in your prisma config must contain only fully qualified identifiers (e.g. schema_name.table_name).\"\n\nP3024​\n\n\"For the current database, externalTables & externalEnums in your prisma config must contain only simple identifiers without a schema name.\"\n\nprisma db pull​\nP4000​\n\n\"Introspection operation failed to produce a schema file: {introspection_error}\"\n\nP4001​\n\n\"The introspected database was empty.\"\n\nP4002​\n\n\"The schema of the introspected database was inconsistent: {explanation}\"\n\nPrisma Accelerate​\n\nPrisma Accelerate-related errors start with P6xxx except for P5011.\n\nP6000 (ServerError)​\n\nGeneric error to catch all other errors.\n\nP6001 (InvalidDataSource)​\n\nThe URL is malformed; for instance, it does not use the prisma:// protocol.\n\nP6002 (Unauthorized)​\n\nThe API Key in the connection string is invalid.\n\nP6003 (PlanLimitReached)​\n\nThe included usage of the current plan has been exceeded. This can only occur on the free plan.\n\nP6004 (QueryTimeout)​\n\nThe global timeout of Accelerate has been exceeded. You can find the limit here.\n\nAlso see the troubleshooting guide for more information.\n\nP6005 (InvalidParameters)​\n\nThe user supplied invalid parameters. Currently only relevant for transaction methods. For example, setting a timeout that is too high. You can find the limit here.\n\nP6006 (VersionNotSupported)​\n\nThe chosen Prisma version is not compatible with Accelerate. This may occur when a user uses an unstable development version that we occasionally prune.\n\nP6008 (ConnectionError|EngineStartError)​\n\nThe engine failed to start. For example, it couldn't establish a connection to the database.\n\nAlso see the troubleshooting guide for more information.\n\nP6009 (ResponseSizeLimitExceeded)​\n\nThe global response size limit of Accelerate has been exceeded. You can find the limit here.\n\nAlso see the troubleshooting guide for more information.\n\nP6010 (ProjectDisabledError)​\n\nYour accelerate project is disabled. Please enable it again to use it.\n\nP5011 (Too Many Requests)​\n\nThis error indicates that the request volume exceeded. Implement a back-off strategy and try again later. For assistance with expected high workloads, contact support."
  },
  {
    "title": "Prisma environment variables | Prisma Documentation",
    "url": "https://www.prisma.io/docs/orm/reference/environment-variables-reference",
    "html": "ORMReference\nEnvironment variables reference\n\nThis document describes different environment variables and their use cases.\n\nPrisma Client​\nDEBUG​\n\nDEBUG is used to enable debugging output in Prisma Client.\n\nExample setting Prisma Client level debugging output:\n\n# enable only `prisma:client`-level debugging output\n\nexport DEBUG=\"prisma:client\"\n\n\nSee Debugging for more information.\n\nNO_COLOR​\n\nNO_COLOR if truthy\n will activate the colorless setting for error formatting and strip colors from error messages.\n\nSee Formatting via environment variables for more information.\n\nPrisma Studio​\nBROWSER​\n\nBROWSER is for Prisma Studio to force which browser it should be open in, if not set it will open in the default browser.\n\nBROWSER=firefox prisma studio --port 5555\n\n\nAlternatively you can set this when starting Studio from the CLI as well:\n\nprisma studio --browser firefox\n\n\nSee Studio documentation for more information.\n\nPrisma CLI​\nPRISMA_HIDE_PREVIEW_FLAG_WARNINGS​\n\nPRISMA_HIDE_PREVIEW_FLAG_WARNINGS hides the warning message that states that a preview feature flag can be removed. It is a truthy value.\n\nPRISMA_HIDE_UPDATE_MESSAGE​\n\nPRISMA_HIDE_UPDATE_MESSAGE is used to hide the update notification message that is shown when a newer Prisma CLI version is available. It's a truthy value.\n\nPRISMA_GENERATE_SKIP_AUTOINSTALL​\n\nPRISMA_GENERATE_SKIP_AUTOINSTALL can be set to a truthy value to skip the auto-install of prisma CLI and @prisma/client dependencies (if they are missing), if the prisma-client-js generator is defined in the Prisma Schema, when using the prisma generate command.\n\nPRISMA_SKIP_POSTINSTALL_GENERATE​\n\nPRISMA_SKIP_POSTINSTALL_GENERATE can be set to a truthy value to skip the auto-generation of Prisma Client when its postinstall hook is triggered by a package manager. The postinstall hook of the @prisma/client package is triggered when the package is installed, or its version is updated.\n\nPRISMA_DISABLE_WARNINGS​\n\nDisables all CLI warnings generated by logger.warn.\n\nPRISMA_GENERATE_NO_ENGINE​\nINFO\n\nThis environment variable is available since version 5.2.0\n\nPRISMA_GENERATE_NO_ENGINE can be set to a truthy value to generate a Prisma Client without an included query engine in order to reduce deployed application size when paired with Prisma Accelerate.\n\nPRISMA_SCHEMA_DISABLE_ADVISORY_LOCK​\nINFO\n\nThis environment variable is available since version 5.3.0\n\nPRISMA_SCHEMA_DISABLE_ADVISORY_LOCK can be set to a truthy value to disable the advisory locking used by Prisma Migrate. This might be needed, depending on the database configuration, for example, for a Percona-XtraDB-Cluster or MariaDB Galera Cluster.\n\nProxy environment variables​\n\nThe Prisma CLI supports custom HTTP(S) proxies to download the Prisma engines. These can be helpful to use when working behind a corporate firewall. See Using a HTTP proxy for the CLI for more information.\n\nNO_PROXY​\n\nNO_PROXY is a comma-separated list of hostnames or IP addresses that do not require a proxy.\n\nNO_PROXY=myhostname.com,10.11.12.0/16,172.30.0.0/16\n\nHTTP_PROXY​\n\nHTTP_PROXY is set with the hostname or IP address of a proxy server.\n\nHTTP_PROXY=http://proxy.example.com\n\nHTTPS_PROXY​\n\nHTTPS_PROXY is set with the hostname or IP address of a proxy server.\n\nHTTPS_PROXY=https://proxy.example.com\n\nEngine environment variables​\nConfiguring Query Engine Type​\nPRISMA_CLI_QUERY_ENGINE_TYPE​\n\nPRISMA_CLI_QUERY_ENGINE_TYPE is used to define the query engine type Prisma CLI downloads and uses. Defaults to library, but can be set to binary:\n\nPRISMA_CLI_QUERY_ENGINE_TYPE=binary\n\nPRISMA_CLIENT_ENGINE_TYPE​\n\nPRISMA_CLIENT_ENGINE_TYPE is used to define the query engine type Prisma Client downloads and uses. Defaults to library, but can be set to binary:\n\nPRISMA_CLIENT_ENGINE_TYPE=binary\n\n\nNote: You need to generate your Prisma Client after setting this variable for the configuration to take effect and the libraries to be downloaded. Otherwise, Prisma Client will be missing the appropriate query engine library and you will have to define their location using PRISMA_QUERY_ENGINE_LIBRARY.\n\nIt is the environment variable equivalent for the engineType property of the generator block which enables you to define the same setting in your Prisma Schema.\n\nDownloading Engines​\nPRISMA_ENGINES_MIRROR​\n\nPRISMA_ENGINES_MIRROR can be used to specify a custom CDN (or server) endpoint to download the engines files for the CLI/Client. The default value is https://binaries.prisma.sh, where Prisma hosts the engine files.\n\nPRISMA_ENGINES_MIRROR=https://example.org/custom-engines/\n\n\nSee Prisma engines for a conceptual overview of how to use this environment variable.\n\nNote: This environment variable used to be available as PRISMA_BINARIES_MIRROR, which was deprecated in Prisma ORM 3.0.1. It is discouraged to use anymore and will be removed in the future.\n\nPRISMA_ENGINES_CHECKSUM_IGNORE_MISSING​\nINFO\n\nThis environment variable is available since version 4.16.0\n\nPRISMA_ENGINES_CHECKSUM_IGNORE_MISSING can be can be set to a truthy value to ignore problems around downloading & verifying the integrity (via a checksum file) of the Prisma ORM engines. This is particularly useful when deploying to an offline system environment where the checksum file cannot be downloaded.\n\nPRISMA_ENGINES_CHECKSUM_IGNORE_MISSING=1\n\n\nNote: we might change the overall download behavior in a future release in a way that this environment variable will not be needed anymore in a offline environment case.\n\nCustom engine file locations​\n\nBy default, all engine files are downloaded when you install Prisma CLI, copied when generating Prisma Client, and put into known locations. There are however situations where you may want to use a custom engine file from custom locations:\n\nPRISMA_QUERY_ENGINE_BINARY​\n\nPRISMA_QUERY_ENGINE_BINARY is used to set a custom location for your own query engine binary.\n\nPRISMA_QUERY_ENGINE_BINARY=custom/query-engine-<target>\n\n# Example: ./prisma/binaries/query-engine-linux-arm64-openssl-1.0.x\n\n\nFor Prisma CLI it allows you to define the query engine file to be used.\nFor Prisma Client, on build time (during prisma generate), it defines where the query engine file will be copied from into Prisma Client. At run time (when using the generated Client) it can be used to define the specific query engine file to be used instead of the included one.\n\nNote: This can only have an effect if the engine type of CLI or Client are set to binary. If the engine type is library (the default), use PRISMA_QUERY_ENGINE_LIBARY instead.\n\nPRISMA_QUERY_ENGINE_LIBRARY​\n\nPRISMA_QUERY_ENGINE_LIBRARY is used to set a custom location for your own query engine library.\n\nPRISMA_QUERY_ENGINE_LIBRARY=custom/libquery_engine-<target>.so.node\n\n# Example: ./prisma/binaries/libquery_engine-linux-arm64-openssl-1.0.x.so.node\n\n\nFor Prisma CLI it allows you to define the query engine file to be used.\nFor Prisma Client, on build time (during prisma generate), it defines where the query engine file will be copied from into Prisma Client. At run time (when using the generated Client) it can be used to define the specific query engine file to be used instead of the included one.\n\nNote: This can only have an effect if the engine type of CLI or Client are set to library (the default)\n\nPRISMA_SCHEMA_ENGINE_BINARY​\n\nPRISMA_SCHEMA_ENGINE_BINARY is used to set a custom location for your Schema engine binary.\n\nPRISMA_SCHEMA_ENGINE_BINARY=custom/my-schema-engine-unix\n\nPRISMA_MIGRATION_ENGINE_BINARY​\nWARNING\n\nDeprecated: PRISMA_MIGRATION_ENGINE_BINARY variable is deprecated in 5.0.0\n because Migration engine was renamed to Schema Engine.\n\nPRISMA_MIGRATION_ENGINE_BINARY is used to set a custom location for your own migration engine binary.\n\nPRISMA_MIGRATION_ENGINE_BINARY=custom/my-migration-engine-unix\n\nPRISMA_INTROSPECTION_ENGINE_BINARY​\n\nPRISMA_INTROSPECTION_ENGINE_BINARY is used to set a custom location for your own introspection engine binary.\n\nPRISMA_INTROSPECTION_ENGINE_BINARY=custom/my-introspection-engine-unix\n\nWARNING\n\nThe Introspection Engine is served by the Migration Engine from 4.9.0\n. Therefore, the PRISMA_INTROSPECTION_ENGINE environment variable will not be used.\n\nPRISMA_FMT_BINARY​\nDANGER\n\nThis functionality has been removed in Prisma CLI version 4.10.0. It only works in earlier versions.\n\nPRISMA_FMT_BINARY is used to set a custom location for your own format engine binary.\n\nPRISMA_FMT_BINARY=custom/my-custom-format-engine-unix\n\nWARNING\n\nThe PRISMA_FMT_BINARY variable is used in versions 4.2.0\n or lower.\n\nCLI Binary Targets​\nPRISMA_CLI_BINARY_TARGETS​\n\nPRISMA_CLI_BINARY_TARGETS can be used to specify one or more binary targets that Prisma CLI will download during installation (so it must be provided during npm install of Prisma CLI and does not affect runtime of Prisma CLI or Prisma Client).\n\nUse PRISMA_CLI_BINARY_TARGETS if you 1) deploy to a specific platform via an upload of a local project that includes dependencies, and 2) your local environment is different from the target (e.g. AWS Lambda with Node.js 20+ is rhel-openssl-3.0.x, and your local environment might be macOS arm64 darwin-arm64). Using the PRISMA_CLI_BINARY_TARGETS environment variable ensures that the target engine files are also downloaded.\n\nPRISMA_CLI_BINARY_TARGETS=darwin-arm64,rhel-openssl-3.0.x npm install\n\n\nThis is the Prisma CLI equivalent for the binaryTargets property of the generator block, which enables you to define the same setting for Prisma Client.\n\nNote: For Node.js versions earlier than 20, the openssl version was 1.0.x instead of 3.0.x. This is most obvious in AWS Lambda deployments, where the binary target would be rhel-openssl-1.0.x instead of rhel-openssl-3.0.x."
  },
  {
    "title": "Reference documentation for the prisma config file | Prisma Documentation",
    "url": "https://www.prisma.io/docs/orm/reference/prisma-config-reference",
    "html": "ORMReference\nPrisma Config reference\nOverview​\n\nThe Prisma Config file configures the Prisma CLI, including subcommands like migrate and studio, using TypeScript.\n\nYou can define your config in either of two ways:\n\nUsing the defineConfig helper:\n\nimport path from \"node:path\";\n\nimport { defineConfig, env } from \"prisma/config\";\n\n\n\nexport default defineConfig({\n\n  schema: path.join(\"prisma\", \"schema.prisma\"),\n\n  migrations: { \n\n    path: path.join(\"db\", \"migrations\"),\n\n  },\n\n  views: { \n\n    path: path.join(\"db\", \"views\"),\n\n  },\n\n  typedSql: { \n\n  path: path.join(\"db\", \"queries\"),\n\n  },\n\n  engine: \"classic\",\n\n  datasource: { \n\n    url: env(\"DATABASE_URL\") \n\n  }\n\n});\n\n\nUsing TypeScript's satisfies operator with the PrismaConfig type:\n\nimport path from \"node:path\";\n\nimport type { PrismaConfig } from \"prisma\";\n\n\n\nexport default {\n\n  schema: path.join(\"db\", \"schema.prisma\"),\n\n  migrations: {\n\n    path: path.join(\"db\", \"migrations\"),\n\n  },\n\n  views: {\n\n    path: path.join(\"db\", \"views\"),\n\n  },\n\n  typedSql: {\n\n    path: path.join(\"db\", \"queries\"),\n\n  },\n\n  engine: \"classic\",\n\n  datasource: { \n\n    url: env(\"DATABASE_URL\") \n\n  }\n\n} satisfies PrismaConfig;\n\nConfiguration interface​\n\nHere is a simplified version of the PrismaConfig type:\n\nexport declare type PrismaConfig = {\n\n\n\n  // Whether features with an unstable API are enabled.\n\n  experimental: {\n\n    adapter: boolean;\n\n    externalTables: boolean;\n\n    studio: boolean;\n\n  },\n\n\n\n  // The path to the schema file, or path to a folder that shall be recursively searched for *.prisma files.\n\n  schema?: string;\n\n\n\n  // The Driver Adapter used for Prisma CLI.\n\n  adapter?: () => Promise<SqlMigrationAwareDriverAdapterFactory>;\n\n\n\n  // Configuration for Prisma Studio.\n\n  studio?: {\n\n    adapter: () => Promise<SqlMigrationAwareDriverAdapterFactory>;\n\n  };\n\n\n\n  // Configuration for Prisma migrations.\n\n  migrations?: {\n\n    path: string;\n\n    seed: string;\n\n    initShadowDb: string;\n\n  };\n\n\n\n  // Configuration for the database view entities.\n\n  views?: {\n\n    path: string;\n\n  };\n\n\n\n  // Configuration for the `typedSql` preview feature.\n\n  typedSql?: {\n\n    path: string;\n\n  };\n\n  // Depending on the choice, you must provide either a `datasource` object or driver adapter\n\n  engine: 'classic' | 'js'\n\n  \n\n  // If using the classic engine, datasource sets the database url, shadowDatabaseUrl, or directURL\n\n  datasource?: {\n\n    url: string;\n\n    directUrl?: string;\n\n    shadowDatabaseUrl?: string;\n\n  }\n\n  \n\n};\n\nSupported file extensions​\n\nPrisma Config files can be named as prisma.config.* or .config/prisma.* with the extensions js, ts, mjs, cjs, mts, or cts. Other extensions are supported to ensure compatibility with different TypeScript compiler settings.\n\nRECOMMENDATION\nUse prisma.config.ts for small TypeScript projects.\nUse .config/prisma.ts for larger TypeScript projects with multiple configuration files (following the \n.config\ndirectory proposal\n).\nOptions reference​\nschema​\n\nConfigures how Prisma ORM locates and loads your schema file(s). Can be a file or folder path. Relative paths are resolved relative to the prisma.config.ts file location. See here for more info about schema location options.\n\nProperty\tType\tRequired\tDefault\nschema\tstring\tNo\t./prisma/schema.prisma and ./schema.prisma\nadapter​\n\nA function that returns a Prisma driver adapter instance which is used by the Prisma CLI to run migrations. The function should return a Promise that resolves to a valid Prisma driver adapter.\n\nProperty\tType\tRequired\tDefault\nadapter\t() => Promise<SqlMigrationAwareDriverAdapterFactory>\tNo\tnone\n\nExample using the Prisma ORM D1 driver adapter:\n\nimport path from \"node:path\";\n\nimport type { PrismaConfig } from \"prisma\";\n\nimport { PrismaD1 } from \"@prisma/adapter-d1\";\n\n\n\nexport default {\n\n  experimental: {\n\n    adapter: true\n\n  },\n\n  schema: path.join(\"prisma\", \"schema.prisma\"),\n\n  async adapter() {\n\n    return new PrismaD1({\n\n      CLOUDFLARE_D1_TOKEN: process.env.CLOUDFLARE_D1_TOKEN,\n\n      CLOUDFLARE_ACCOUNT_ID: process.env.CLOUDFLARE_ACCOUNT_ID,\n\n      CLOUDFLARE_DATABASE_ID: process.env.CLOUDFLARE_DATABASE_ID,\n\n    });\n\n  },\n\n} satisfies PrismaConfig;\n\nNOTE\n\nAs of Prisma ORM v6.11.0\n, the D1 adapter has been renamed from PrismaD1HTTP to PrismaD1.\n\nstudio​\n\nConfigures how Prisma Studio connects to your database. See sub-options below for details.\n\nProperty\tType\tRequired\tDefault\nstudio\tobject\tNo\tnone\nstudio.adapter​\n\nA function that returns a Prisma driver adapter instance. The function receives an env parameter containing environment variables and should return a Promise that resolves to a valid Prisma driver adapter.\n\nProperty\tType\tRequired\tDefault\nstudio.adapter\t(env: Env) => Promise<SqlMigrationAwareDriverAdapterFactory>\tNo\tnone\n\nExample using the Prisma ORM LibSQL driver adapter:\n\nimport type { PrismaConfig } from \"prisma\";\n\n\n\nexport default {\n\n  experimental: {\n\n    studio: true\n\n  },\n\n  studio: {\n\n    adapter: async (env: Env) => {\n\n      const { PrismaLibSQL } = await import(\"@prisma/adapter-libsql\");\n\n      const { createClient } = await import(\"@libsql/client\");\n\n\n\n      const libsql = createClient({\n\n        url: env.DOTENV_PRISMA_STUDIO_LIBSQL_DATABASE_URL,\n\n      });\n\n      return new PrismaLibSQL(libsql);\n\n    },\n\n  },\n\n} satisfies PrismaConfig;\n\ntables.external and enums.external​\n\nThese options declare tables and enums in your database that are managed externally (not by Prisma Migrate). You can still query them with Prisma Client, but they will be ignored by migrations.\n\nProperty\tType\tRequired\tDefault\ntables.external\tstring[]\tNo\t[]\nenums.external\tstring[]\tNo\t[]\n\nExample:\n\nimport { defineConfig } from \"prisma/config\";\n\n\n\nexport default defineConfig({\n\n  experimental: {\n\n    externalTables: true,\n\n  },\n\n  tables: {\n\n    external: [\"public.users\"],\n\n  },\n\n  enums: {\n\n    external: [\"public.role\"],\n\n  },\n\n});\n\n\nLearn more about the externalTables feature here.\n\nmigrations.path​\n\nThe path to the directory where Prisma should store migration files, and look for them.\n\nProperty\tType\tRequired\tDefault\nmigrations.path\tstring\tNo\tnone\nmigrations.seed​\n\nThis option allows you to define a script that Prisma runs to seed your database after running migrations or using the npx prisma db seed command. The string should be a command that can be executed in your terminal, such as with node, ts-node, or tsx.\n\nProperty\tType\tRequired\tDefault\nmigrations.seed\tstring\tNo\tnone\n\nExample:\n\nimport { defineConfig } from \"prisma/config\";\n\n\n\nexport default defineConfig({\n\n  migrations: {\n\n    seed: `tsx db/seed.ts`,\n\n  },\n\n});\n\nmigrations.initShadowDb​\n\nThis option allows you to define SQL statements that Prisma runs on the shadow database before creating migrations. It is useful when working with external managed tables, as Prisma needs to know about the structure of these tables to correctly generate migrations.\n\nProperty\tType\tRequired\tDefault\nmigrations.initShadowDb\tstring\tNo\tnone\n\nExample:\n\nimport { defineConfig } from \"prisma/config\";\n\n\n\nexport default defineConfig({\n\n  experimental: {\n\n    externalTables: true,\n\n  },\n\n  tables: {\n\n    external: [\"public.users\"],\n\n  },\n\n  migrations: {\n\n    initShadowDb: `\n\n      CREATE TABLE public.users (id SERIAL PRIMARY KEY);\n\n    `,\n\n  },\n\n});\n\n\nLearn more about the externalTables feature here.\n\nviews.path​\n\nThe path to the directory where Prisma should look for the SQL view definitions.\n\nProperty\tType\tRequired\tDefault\nviews.path\tstring\tNo\tnone\ntypedSql.path​\n\nThe path to the directory where Prisma should look for the SQL files used for generating typings via typedSql.\n\nProperty\tType\tRequired\tDefault\ntypedSql.path\tstring\tNo\tnone\nexperimental​\n\nEnables specific experimental features in the Prisma CLI.\n\nProperty\tType\tRequired\tDefault\nadapter\tboolean\tNo\tfalse\nexternalTables\tboolean\tNo\tfalse\nstudio\tboolean\tNo\tfalse\n\nExample:\n\nimport { defineConfig } from \"prisma/config\";\n\n\n\nexport default defineConfig({\n\n  experimental: {\n\n    adapter: true,\n\n    externalTables: true,\n\n    studio: true,\n\n  },\n\n  schema: \"prisma/schema.prisma\",\n\n});\n\nNOTE\n\nIf you use features like adapter, studio or externalTables without enabling the corresponding experimental flag, Prisma will throw an error:\n\nFailed to load config file \"~\" as a TypeScript/JavaScript module. Error: Error: The `studio` configuration requires `experimental.studio` to be set to `true`.\n\nengine​\n\nConfigure the schema engine your project should use.\n\nProperty\tType\tRequired\tDefault\nengine\tclassic or js\tNo\tclassic\n\nBy default it is set to use the classic engine, which requires that datasource be set in your prisma.config.ts.\n\nimport path from \"node:path\";\n\nimport { defineConfig, env } from \"prisma/config\";\n\nexport default defineConfig({\n\n  engine: \"classic\",\n\n  datasource: {\n\n      url: env('DATABASE_URL'),\n\n  },\n\n  schema: path.join(\"prisma\", \"schema.prisma\"),\n\n});\n\ndatasource.url​\n\nConnection URL including authentication info. Most connectors use the syntax provided by the database.\n\nProperty\tType\tRequired\tDefault\ndatasource.url\tstring\tYes\t''\ndatasource.shadowDatabaseUrl​\n\nConnection URL to the shadow database used by Prisma Migrate. Allows you to use a cloud-hosted database as the shadow database\n\nProperty\tType\tRequired\tDefault\ndatasource.shadowDatabaseUrl\tstring\tNo\t''\ndatasource.directUrl​\n\nConnection URL for direct connection to the database.\n\nIf you use a connection pooler URL in the url argument (for example, if you use Prisma Accelerate or pgBouncer), Prisma CLI commands that require a direct connection to the database use the URL in the directUrl argument.\n\nThe directUrl property is supported by Prisma Studio from version 5.1.0 upwards.\n\nThe directUrl property is not needed when using Prisma Postgres database.\n\nProperty\tType\tRequired\tDefault\ndatasource.directUrl\tstring\tNo\t''\nCommon patterns​\nSetting up your project​\n\nTo get started with Prisma Config, create a prisma.config.ts file in your project root. You can use either of these approaches:\n\nUsing defineConfig:\n\nimport { defineConfig } from \"prisma/config\";\n\n\n\nexport default defineConfig({});\n\n\nUsing TypeScript types:\n\nimport type { PrismaConfig } from \"prisma\";\n\n\n\nexport default {} satisfies PrismaConfig;\n\nUsing environment variables​\n\nWhen using prisma.config.ts, environment variables from .env files are not automatically loaded. Using tsx, you can pass a --env-file flag and that will automatically add those values to process.env\n\nIf using Node or Deno:\n\ntsx --env-file=.env src/index.ts\n\ntsx watch --env-file=.env --env-file=.local.env src/index.ts\n\ntsx --env-file=.env ./prisma/seed.ts\n\n\nFor Bun, .env files are automatically loaded.\n\nFor accessing environment variables within prisma.config.ts, use the env() helper function to provide a type-safe way of accessing that variable:\n\nimport path from \"node:path\";\n\nimport { defineConfig, env } from \"prisma/config\";\n\n\n\ntype Env = {\n\n  DATABASE_URL: string\n\n}\n\nexport default defineConfig({\n\n  engine: \"classic\",\n\n  datasource: {\n\n      url: env<Env>('DATABASE_URL'),\n\n  },\n\n  schema: path.join(\"prisma\", \"schema.prisma\"),\n\n});\n\n\nFor releases of Node before v20, you'll need to:\n\nInstall the dotenv package:\nnpm install dotenv\n\nImport dotenv/config in your config file:\nimport \"dotenv/config\";\n\nimport { defineConfig, env } from \"prisma/config\";\n\n\n\ntype Env = {\n\n  DATABASE_URL: string\n\n}\n\nexport default defineConfig({\n\n  engine: \"classic\",\n\n  datasource: {\n\n      url: env<Env>('DATABASE_URL'),\n\n  },\n\n  schema: path.join(\"prisma\", \"schema.prisma\"),\n\n});\n\nUsing multi-file schemas​\n\nIf you want to split your Prisma schema into multiple files, you need to specify the path to your Prisma schema folder via the schema property:\n\nimport path from \"node:path\";\n\nimport type { PrismaConfig } from \"prisma\";\n\n\n\nexport default {\n\n  schema: path.join(\"prisma\", \"schema\"),\n\n} satisfies PrismaConfig;\n\n\nIn that case, your migrations directory must be located next to the .prisma file that defines the datasource block.\n\nFor example, assuming schema.prisma defines the datasource, here's how how need to place the migrations folder:\n\n# `migrations` and `schema.prisma` are on the same level\n\n.\n\n├── migrations\n\n├── models\n\n│   ├── posts.prisma\n\n│   └── users.prisma\n\n└── schema.prisma\n\nPath resolution​\n\nPrisma CLI commands such as prisma validate or prisma migrate use prisma.config.ts (or .config/prisma.ts) to locate your Prisma schema and other resources.\n\nKey rules:\n\nPaths defined in the config file (e.g., schema, migrations) are always resolved relative to the location of the config file, not where you run the CLI command from.\nThe CLI must first find the config file itself, which depends on how Prisma is installed and the package manager used.\nBehavior with pnpm prisma​\n\nWhen Prisma is installed locally and run via pnpm prisma, the config file is detected automatically whether you run the command from the project root or a subdirectory.\n\nExample project tree:\n\n.\n\n├── node_modules\n\n├── package.json\n\n├── prisma-custom\n\n│   └── schema.prisma\n\n├── prisma.config.ts\n\n└── src\n\n\nExample run from the project root:\n\npnpm prisma validate\n\n# → Loaded Prisma config from ./prisma.config.ts\n\n# → Prisma schema loaded from prisma-custom/schema.prisma\n\n\nExample run from a subdirectory:\n\ncd src\n\npnpm prisma validate\n\n# → Still finds prisma.config.ts and resolves schema correctly\n\nBehavior with npm exec prisma or bun prisma​\n\nWhen running via npm exec prisma or bun prisma, the CLI only detects the config file if the command is run from the project root (where package.json declares Prisma).\n\nExample run from the project root:\n\nnpm exec prisma validate\n\n# → Works as expected\n\n\nRun from a subdirectory (fails):\n\ncd src\n\nnpm exec prisma validate\n\n# → Error: Could not find Prisma Schema...\n\n\nTo fix this, you can use the --config flag:\n\nnpm exec prisma -- --config ../prisma.config.ts validate\n\nGlobal Prisma installations​\n\nIf Prisma is installed globally (npm i -g prisma), it may not find your prisma.config.ts or prisma/config module by default. To avoid issues:\n\nPrefer local Prisma installations in your project.\nOr use prisma/config locally and pass --config to point to your config file.\nMonorepos​\nIf Prisma is installed in the workspace root, pnpm prisma will detect the config file from subdirectories.\nIf Prisma is installed in a subpackage (e.g., ./packages/db), run commands from that package directory or deeper.\nCustom config location​\n\nYou can specify a custom location for your config file when running Prisma CLI commands:\n\nprisma validate --config ./path/to/myconfig.ts\n"
  },
  {
    "title": "Database features matrix | Prisma Documentation",
    "url": "https://www.prisma.io/docs/orm/reference/database-features",
    "html": "ORMReference\nDatabase features matrix\n\nThis page gives an overview of the features which are provided by the databases that Prisma ORM supports. Additionally, it explains how each of these features can be used in Prisma ORM with pointers to further documentation.\n\nRelational database features​\n\nThis section describes which database features exist on the relational databases that are currently supported by Prisma ORM. The Prisma schema column indicates how a certain feature can be represented in the Prisma schema and links to its documentation. Note that database features can be used in Prisma Client even though they might not yet be representable in the Prisma schema.\n\nNOTE\n\nThese features are only for relational databases. Supported features for NoSQL databases, like MongoDB, can be found below.\n\nConstraints​\nConstraint\tSupported\tPrisma schema\tPrisma Client\tPrisma Migrate\nPRIMARY KEY\t✔️\t@id and @@id\t✔️\t✔️\nFOREIGN KEY\t✔️\tRelation fields\t✔️\t✔️\nUNIQUE\t✔️*\t@unique and @@unique\t✔️\t✔️\nCHECK\t✔️†\tNot yet\t✔️\tNot yet\nNOT NULL\t✔️\t?\t✔️\t✔️\nDEFAULT\t✔️\t@default\t✔️\t✔️\nEXCLUDE\t✔️‡\tNot yet\t✔️\tNot yet\n\n* Caveats apply when using the UNIQUE constraint with Microsoft SQL Server † Only supported in MySQL in version 8 and higher\n. ‡ Only supported in PostgreSQL.\n\nReferential Actions (Delete and Update behaviors for foreign key references)​\nDeletion behavior\tSupported\tPrisma schema\tPrisma Client\tPrisma Migrate\nCASCADE\t✔️\t✔️\t✔️\t✔️\nRESTRICT\t✔️*\t✔️\t✔️\t✔️\nNO ACTION\t✔️\t✔️\t✔️\t✔️\nSET DEFAULT\t✔️\t✔️\t✔️\t✔️\nSET NULL\t✔️\t✔️\t✔️\t✔️\n\n* RESTRICT is not supported in Microsoft SQL Server.\n\nIndexes​\nIndex\tSupported\tPrisma schema\tPrisma Client\tPrisma Migrate\nUNIQUE\t✔️\t@unique and @@unique\t✔️\t✔️\nUSING\tPostgreSQL only\ttype\t✔️\t✔️\nWHERE\t✔️\tNot yet\t✔️\tNot yet\n(expression)\t✔️\tNot yet\t✔️\tNot yet\nINCLUDE\tPostgreSQL and Microsoft SQL Server only\tNot yet\t✔️\tNot yet\n\nAlgorithm specified via USING:\n\nIndex type (Algorithm)\tSupported\tPrisma schema\tPrisma Client\tPrisma Migrate\nB-tree\t✔️\t✔️†\t✔️\tNot yet\nHash\t✔️\t✔️†\t✔️\tNot yet\nGiST\t✔️*\t✔️†\t✔️*\tNot yet\nGIN\t✔️*\t✔️†\t✔️*\tNot yet\nBRIN\t✔️*\t✔️†\t✔️*\tNot yet\nSP-GiST\t✔️*\t✔️†\t✔️*\tNot yet\n* Not supported for MySQL and SQLite\n† Available with the PostgreSQL connector only in Prisma ORM versions 4.0.0 and later.\nMisc​\nFeature\tSupported\tPrisma schema\tPrisma Client\tPrisma Migrate\nAutoincrementing IDs\t✔️\tautoincrement()\t✔️\t✔️\nArrays\tPostgreSQL only\t[]\t✔️\t✔️\nEnums\t✔️*†\tenum\t✔️\t✔️\nNative database types\t✔️\t✔️\t✔️\tNot yet\nSQL Views\t✔️\tNot yet\tNot yet\tNot yet\nJSON support\t✔️†\t✔️\t✔️\t✔️\nFuzzy/Phrase full text search\t✔️‡\tNot yet\tNot yet\tNot yet\nTable inheritance\tPostgreSQL and Microsoft SQL Server only\tNot yet\t✔️\tNot yet\nAuthorization and user management\t✔️‡\tNot yet\tNot yet\tNot yet\n* Not supported by Microsoft SQL Server\n† JSON and Enum types are supported in SQLite as of Prisma ORM 6.2.0.\n‡ Not supported by SQLite\nNoSQL database features​\n\nThis section describes which database features exist on the NoSQL databases that are currently supported by Prisma ORM.\n\nMongoDB​\n\nThe following table lists common MongoDB features and describes the level of support offered by Prisma ORM:\n\nFeature\tSupported by Prisma ORM\tNotes\nEmbedded documents\t✔️\t\nTransactions\t✔️\t\nIndexes\t✔️ with caveats\tIndexes can only be introspected if the field they refer to includes at least some data.\nAutoincrementing IDs\tNo\t\nCompound IDs\tNo\tMongoDB does not support composite IDs (@@id)\nGenerated ObjectId\t✔️\tSee: Defining IDs for MongoDB\nArrays\t✔️\t\nEnums\t✔️\tImplemented at Prisma ORM level\nNative database types\t✔️\tSee: Field mapping reference\nJSON support\t✔️\tAdvanced Json field filtering is not yet supported.\nDBrefs\tNo\t\nChange streams\tNo\t\nDirect access to the aggregation pipeline\tNo\t"
  },
  {
    "title": "Databases supported by Prisma ORM | Prisma Documentation",
    "url": "https://www.prisma.io/docs/orm/reference/supported-databases",
    "html": "ORMReference\nSupported databases\n\nPrisma ORM currently supports the following databases.\n\nSee also: System requirements.\n\nAn asterisk (*) indicates that the version number is not relevant; either all versions are supported, there is not a public version number, etc.\n\nSelf-hosted databases​\nDatabase\tVersion\nCockroachDB\t21.2.4+\nMariaDB\t10.0+\nMariaDB\t11.0+\nMicrosoft SQL Server\t2017\nMicrosoft SQL Server\t2019\nMicrosoft SQL Server\t2022\nMongoDB\t4.2+\nMySQL\t5.6\nMySQL\t5.7\nMySQL\t8.0\nMySQL\t8.4\nPostgreSQL\t9.6\nPostgreSQL\t10\nPostgreSQL\t11\nPostgreSQL\t12\nPostgreSQL\t13\nPostgreSQL\t14\nPostgreSQL\t15\nPostgreSQL\t16\nPostgreSQL\t17\nSQLite\t*\n\nNote that a fixed version of SQLite is shipped with every Prisma ORM release.\n\nManaged databases​\nDatabase\tVersion\nAWS Aurora\t*\nAWS Aurora Serverless ¹\t*\nAzure SQL\t*\nCockroachDB-as-a-Service\t*\nMongoDB Atlas\t*\nNeon Serverless Postgres\t*\nPlanetScale\t*\nCloudflare D1 (Preview)\t*\nAiven (MySQL & Postgres)\t*\n¹ This does not include support for Data API for Aurora Serverless\n.\t"
  },
  {
    "title": "Connection URLs (Reference) | Prisma Documentation",
    "url": "https://www.prisma.io/docs/orm/reference/connection-urls",
    "html": "ORMReference\nConnection URLs\n\nPrisma ORM needs a connection URL to be able to connect to your database, e.g. when sending queries with Prisma Client or when changing the database schema with Prisma Migrate.\n\nThe connection URL is provided via the url field of a datasource block in your Prisma schema. It usually consists of the following components (except for SQLite and Prisma Postgres):\n\nUser: The name of your database user\nPassword: The password for your database user\nHost: The IP or domain name of the machine where your database server is running\nPort: The port on which your database server is running\nDatabase name: The name of the database you want to use\n\nMake sure you have this information at hand when getting started with Prisma ORM. If you don't have a database server running yet, you can either use a local SQLite database file (see the Quickstart) or setup a free PostgreSQL database with Prisma Postgres.\n\nFormat​\n\nThe format of the connection URL depends on the database connector you're using. Prisma ORM generally supports the standard formats for each database. You can find out more about the connection URL of your database on the dedicated docs page:\n\nPostgreSQL\nMySQL\nSQLite\nMongoDB\nMicrosoft SQL Server\nCockroachDB\nSpecial characters​\n\nFor MySQL, PostgreSQL and CockroachDB you must percentage-encode special characters\n in any part of your connection URL - including passwords. For example, p@$$w0rd becomes p%40%24%24w0rd.\n\nFor Microsoft SQL Server, you must escape special characters in any part of your connection string.\n\nExamples​\n\nHere are examples for the connection URLs of the databases Prisma ORM supports:\n\nPrisma Postgres​\n\nPrisma Postgres is a managed PostgreSQL service running on unikernels. There are several ways to connect to Prisma Postgres:\n\nvia direct TCP connections (lets you connect via any ORM or database tool)\nvia Prisma Accelerate (only supported with Prisma ORM)\nlocally\n\nThe connection string formats of these are covered below.\n\nDirect TCP​\n\nWhen you connect to Prisma Postgres via direct TCP, your connection string looks as follows:\n\nDATABASE_URL=\"postgres://USER:PASSWORD@db.prisma.io:5432/?sslmode=require\"\n\n\nThe USER and PASSWORD values are provided when you generate credentials for your Prisma Postgres instance in the Prisma Console. Here is an example with sample values:\n\nDATABASE_URL=\"postgres://2f9881cc7eef46f094ac913df34c1fb441502fe66cbe28cc48998d4e6b20336b:sk_QZ3u8fMPFfBzOID4ol-mV@db.prisma.io:5432/?sslmode=require\"\n\nVia Prisma Accelerate (HTTP)​\n\nWhen connecting via Prisma Accelerate, the connection string doesn't require a user/password like a conventional connection string does. Instead, authentication works via an API key:\n\nschema.prisma\ndatasource db {\n\n  provider = \"postgresql\"\n\n  url      = \"prisma+postgres://accelerate.prisma-data.net/?api_key=API_KEY\"\n\n} \n\n\nIn this snippet, API_KEY is a placeholder for the API key you are receiving when setting up a new Prismas Postgres instance via the Prisma Console. Here is an example for what a real connection URL to Prisma Postgres may look like:\n\nschema.prisma\ndatasource db {\n\n  provider = \"postgresql\"\n\n  url      = \"prisma+postgres://accelerate.prisma-data.net/?api_key=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhcGlfa2V5IjoiMGNkZTFlMjQtNzhiYi00NTY4LTkyM2EtNWUwOTEzZWUyNjU1IiwidGVuYW50X2lkIjoiNzEyZWRlZTc1Y2U2MDk2ZjI4NDg3YjE4NWMyYzA2OTNhNGMxNzJkMjhhOWFlNGUwZTYxNWE4NWIxZWY1YjBkMCIsImludGVybmFsX3NlY3JldCI6IjA4MzQ2Y2RlLWI5ZjktNDQ4Yy04NThmLTMxNjg4ODEzNmEzZCJ9.N1Za6q6NfInzHvRkud6Ojt_-RFg18a0601vdYWGKOrk\"\n\n}\n\nLocal Prisma Postgres​\n\nThe connection string for connecting to a local Prisma Postgres instance mirrors the structure of a remote instance via Accelerate:\n\nschema.prisma\ndatasource db {\n\n  provider = \"postgresql\"\n\n  url      = \"prisma+postgres://accelerate.prisma-data.net/?api_key=API_KEY\"\n\n} \n\n\nHowever, in this case the API_KEY doesn't provide authentication details. Instead, it encodes information about the local Prisma Postgres instance. You can obtain a local connection string via the prisma dev command.\n\nPostgreSQL​\nschema.prisma\ndatasource db {\n\n  provider = \"postgresql\"\n\n  url      = \"postgresql://janedoe:mypassword@localhost:5432/mydb?schema=sample\"\n\n}\n\nMySQL​\nschema.prisma\ndatasource db {\n\n  provider = \"mysql\"\n\n  url      = \"mysql://janedoe:mypassword@localhost:3306/mydb\"\n\n}\n\nMicrosoft SQL Server​\nschema.prisma\ndatasource db {\n\n  provider = \"sqlserver\"\n\n  url      = \"sqlserver://localhost:1433;initial catalog=sample;user=sa;password=mypassword;\"\n\n}\n\nSQLite​\nschema.prisma\ndatasource db {\n\n  provider = \"sqlite\"\n\n  url      = \"file:./dev.db\"\n\n}\n\nCockroachDB​\nschema.prisma\ndatasource db {\n\n  provider = \"cockroachdb\"\n\n  url      = \"postgresql://janedoe:mypassword@localhost:26257/mydb?schema=public\"\n\n}\n\nMongoDB​\nschema.prisma\ndatasource db {\n\n  provider = \"mongodb\"\n\n  url      = \"mongodb+srv://root:<password>@cluster0.ab1cd.mongodb.net/myDatabase?retryWrites=true&w=majority\"\n\n}\n\n.env​\n\nYou can also provide the connection URL as an environment variable:\n\nschema.prisma\ndatasource db {\n\n  provider = \"postgresql\"\n\n  url      = env(\"DATABASE_URL\")\n\n}\n\n\nYou can then either set the environment variable in your terminal or by providing a dotenv\n file named .env. This will automatically be picked up by the Prisma CLI.\n\nPrisma ORM reads the connection URL from the dotenv file in the following situations:\n\nWhen it updates the schema during build time\nWhen it connects to the database during run time\nDATABASE_URL=postgresql://janedoe:mypassword@localhost:5432/mydb\n"
  },
  {
    "title": "System requirements (Reference) | Prisma Documentation",
    "url": "https://www.prisma.io/docs/orm/reference/system-requirements",
    "html": "ORMReference\nSystem requirements\n\nThis page provides an overview of the system requirements for Prisma ORM.\n\nSystem requirements​\n\nThis section lists the software that Prisma ORM requires and the supported operating systems, along with runtime dependency requirements for specific operating systems.\n\nSoftware requirements​\n\nThe latest version of Prisma ORM requires the following software:\n\nTool\tMinimum required version\nNode.js\t18.8 / 20.9 / 22.11\nTypeScript (optional)\t5.1.X\nYarn (optional)\t1.19.2\nPrisma ORM supports and tests all Active LTS and Maintenance LTS Node.js releases. Releases that are not in these states like\nCurrent\n, and also odd-numbered versions\n probably also work, but are not recommended for production use.\nTypeScript is only required for TypeScript users.\nWhen using Yarn 1, 1.19.2 is the minimum version compatible with Prisma Client.\n\nSee also: Supported database versions\n\nExpand for earlier versions\nOperating systems​\n\nPrisma ORM is supported on macOS, Windows and most Linux distributions.\n\nLinux runtime dependencies​\n\nPrisma ORM requires the following system libraries to be installed to work:\n\nOpenSSL 1.0.x, 1.1.x or 3.x\nzlib (libz.so.1)\nlibgcc (libgcc_s.so.1)\nC standard library (glibc on most Linux distributions or musl libc on Alpine Linux)\n\nThe following two tables show the supported Linux distro families, OpenSSL versions and C standard libraries for each CPU architecture.\n\nOn AMD64 (x86_64) architecture:\n\nDistro family\tOpenSSL version\tlibc version\nAlpine\t1.1.x, 3.x\tmusl 1.2.x\nRHEL\t1.0.x, 1.1.x, 3.x\tglibc 2.17+\nDebian or others\t1.0.x\tglibc 2.19+\nDebian or others\t1.1.x, 3.x\tglibc 2.24+\n\nOn ARM64 (aarch64) architecture:\n\nDistro family\tOpenSSL version\tlibc version\nAlpine\t1.1.x, 3.x\tmusl 1.2.x\nRHEL\t1.0.x, 1.1.x, 3.x\tglibc 2.24+\nDebian or others\t1.0.x, 1.1.x, 3.x\tglibc 2.24+\n\nWhen Prisma ORM can not resolve the OpenSSL version on a system (e.g. because it is not installed), it will default to OpenSSL 1.1.x.\n\nSystems that can run the supported Node.js versions will most likely have zlib and libgcc available. One notable exception is Google's Distroless images, where libz.so.1 needs to be copied from a compatible Debian system.\n\nWindows runtime dependencies​\n\nOn Windows Microsoft Visual C++ Redistributable 2015\n or newer must be installed (which is by default the case on most modern installations).\n\nmacOS runtime dependencies​\n\nPrisma ORM supports macOS 10.15 or newer. There are no additional platform-specific requirements on macOS other than what is listed for all platforms in the Software requirements section.\n\nTroubleshooting​\n\nThere are some common problems caused by using outdated versions of the system requirements:\n\nUnable to build a TypeScript project with @prisma/client​\nProblem​\n\nYou see the following error when you try type-checking a project after you run prisma generate.\n\n./node_modules/.prisma/client/index.d.ts:10:33\n\nType error: Type expected.\n\n8 | export type PrismaPromise<A> = Promise<A> & {[prisma]: true}\n\n9 | type UnwrapTuple<Tuple extends readonly unknown[]> = {\n\n> 10 | [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : never : never\n\n| ^\n\n11 | };\n\n12 |\n\n13 |\n\nSolution​\n\nUpgrade the TypeScript dependency in your project to a version supported by Prisma ORM. npm install -D typescript.\n\nUnable to use groupBy preview feature​\nProblem​\n\nYou see the following console error when you attempt to run an app that uses the groupBy preview feature:\n\nserver.ts:6:25 - error TS2615: Type of property 'OR' circularly references itself in mapped type '{ [K in keyof { AND?: Enumerable<ProductScalarWhereWithAggregatesInput>; OR?: Enumerable<ProductScalarWhereWithAggregatesInput>; ... 4 more ...; category?: string | StringWithAggregatesFilter; }]: Or<...> extends 1 ? { ...; }[K] extends infer TK ? GetHavingFields<...> : never : {} extends FieldPaths<...> ? never : K...'.\n\n6 const grouped = await prisma.product.groupBy({\n\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n7 by: ['category']\n\n~~~~~~~~~~~~~~~~~~~~\n\n8 });\n\n~~~~\n\nserver.ts:6:48 - error TS2554: Expected 0 arguments, but got 1.\n\n6 const grouped = await prisma.product.groupBy({\n\n~\n\n7 by: ['category']\n\n~~~~~~~~~~~~~~~~~~~~\n\n8 });\n\n~~~\n\nSolution​\n\nUpgrade the TypeScript dependency in your project to a version supported by Prisma ORM. npm install -D typescript."
  },
  {
    "title": "Prisma Client & Prisma schema | Prisma Documentation",
    "url": "https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features",
    "html": "ORMReferencePreview features\nPrisma Client & Prisma schema\n\nWhen we release a new Prisma Client or Prisma schema feature, it often starts in Preview so that you can test it and submit your feedback. After we improve the feature with your feedback and are satisfied with the internal test results, we promote the feature to general availability.\n\nFor more information, see ORM releases and maturity levels.\n\nCurrently active Preview features​\n\nThe following Preview feature flags are available for Prisma Client and Prisma schema:\n\nFeature\tReleased into Preview\tFeedback issue\nmetrics\t3.15.0\n\tSubmit feedback\n\nviews\t4.9.0\n\tSubmit feedback\n\nrelationJoins\t5.7.0\n\tSubmit feedback\n\nnativeDistinct\t5.7.0\n\tSubmit feedback\n\ntypedSql\t5.19.0\n\tSubmit feedback\n\nstrictUndefinedChecks\t5.20.0\n\tSubmit feedback\n\nfullTextSearchPostgres\t6.0.0\n\tSubmit feedback\n\nshardKeys\t6.10.0\n\tSubmit feedback\n\nTo enable a Preview feature, add the feature flag to the generator block in your schema.prisma file. Share your feedback on all Preview features on GitHub\n.\n\nEnabling a Prisma Client Preview feature​\n\nTo enable a Prisma Client Preview feature:\n\nAdd the Preview feature flag to the generator block:\n\ngenerator client {\n\n  provider        = \"prisma-client-js\"\n\n  previewFeatures = [\"relationJoins\"]\n\n}\n\n\nRe-generate Prisma Client:\n\nnpx prisma generate\n\n\nIf you are using Visual Studio Code and the Preview feature is not available in your .ts file after generating Prisma Client, run the TypeScript: Restart TS server command.\n\nPreview features promoted to General Availability​\n\nIn the list below, you can find a history of Prisma Client and Prisma schema features that were in Preview and are now in general availability. The features are sorted by the most recent version in which they were promoted to general availability.\n\nFeature\tReleased into Preview\tReleased into General Availability\ndriverAdapters\t5.4.0\n\t6.16.0\n\nqueryCompiler\t6.7.0\n\t6.16.0\n\nmultiSchema\t4.3.0\n\t6.13.0\n\nprismaSchemaFolder\t5.15.0\n\t6.7.0\n\nomitApi\t5.13.0\n\t6.2.0\n\njsonProtocol\t4.11.0\n\t5.0.0\n\nextendedWhereUnique\t4.5.0\n\t5.0.0\n\nfieldReference\t4.3.0\n\t5.0.0\n\nclientExtensions\t4.7.0\n\t4.16.0\n\nfilteredRelationCount\t4.3.0\n\t4.16.0\n\ntracing\t4.2.0\n\t6.1.0\n\norderByNulls\t4.1.0\n\t4.16.0\n\nreferentialIntegrity\t3.1.1\n\t4.7.0\n\ninteractiveTransactions\t2.29.0\n\t4.7.0\n\nwith Prisma Accelerate 5.1.1\n\nextendedIndexes\t3.5.0\n\t4.0.0\n\nfilterJson\t2.23.0\n\t4.0.0\n\nimprovedQueryRaw\t3.14.0\n\t4.0.0\n\ncockroachdb\t3.9.0\n\nmigrations in 3.11.0\n\t3.14.0\n\nmongodb\t2.27.0\n\nintrospection in 3.2.0\n\nembedded docs in 3.4.0\n\nraw queries in 3.9.0\n\nfilters/ordering in embedded docs in 3.11.0\n\t3.12.0\n\nmicrosoftSqlServer\t2.10.0\n\t3.0.1\n\nnamedConstraints\t2.29.0\n\t3.0.1\n\nreferentialActions\t2.26.0\n\t3.0.1\n\norderByAggregateGroup\t2.21.0\n\t3.0.1\n\norderByRelation\t2.16.0\n\naggregates in 2.19.0\n\t3.0.1\n\nselectRelationCount\t2.20.0\n\t3.0.1\n\nnapi\t2.20.0\n\t3.0.1\n\ngroupBy\t2.14.0\n\t2.20.0\n\ncreateMany\t2.16.0\n\t2.20.0\n\nnativeTypes\t2.11.0\n\t2.17.0\n\nuncheckedScalarInputs\t2.11.0\n\t2.15.0\n\ntransactionApi\t2.1.0\n\t2.11.0\n\nconnectOrCreate\t2.1.0\n\t2.11.0\n\natomicNumberOperations\t2.6.0\n\t2.10.0\n\ninsensitiveFilters (PostgreSQL)\t2.5.0\n\t2.8.0\n\nmiddlewares\t2.3.0\n\t2.5.0\n\naggregateApi\t2.2.0\n\t2.5.0\n\ndistinct\t2.3.0\n\t2.5.0"
  },
  {
    "title": "Preview features (Reference) | Prisma Documentation",
    "url": "https://www.prisma.io/docs/orm/reference/preview-features",
    "html": "ORMReference\nPreview features\n\nSome Prisma ORM features are released as Previews. Share your feedback on all Preview features on GitHub\n. For information about available preview features and how to enable them, see:\n\nPrisma Client and Prisma schema preview features\nPrisma CLI preview features\n\nFor information regarding upgrading Prisma ORM and enabling Preview features see Upgrading to use Preview features."
  },
  {
    "title": "Prisma CLI Preview features | Prisma Documentation",
    "url": "https://www.prisma.io/docs/orm/reference/preview-features/cli-preview-features",
    "html": "ORMReferencePreview features\nPrisma CLI Preview features\n\nWhen we release a new Prisma CLI feature, it often starts in Preview so that you can test it and submit your feedback. After we improve the feature with your feedback and are satisfied with the internal test results, we promote the feature to general availability.\n\nFor more information, see ORM releases and maturity levels.\n\nCurrently active Preview features​\n\nThere are currently no Preview features for Prisma CLI.\n\nPreview features promoted to general availability​\n\nIn the list below, you can find a history of Prisma CLI features that were in Preview and are now in general availability. The features are sorted by the most recent version in which they were promoted to general availability.\n\nFeatures\tReleased in Preview\tReleased in general availability\nprisma migrate diff\t3.9.0\n\t3.13.0\n\nprisma db execute\t3.9.0\n\t3.13.0\n\nprisma db push\t2.10.0\n\t2.22.0\n\nprisma migrate\t2.13.0\n\t2.19.0"
  }
]